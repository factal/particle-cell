(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __reExport = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toModule = (module) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };

  // node_modules/@yandeu/events/cjs/version.js
  var require_version = __commonJS({
    "node_modules/@yandeu/events/cjs/version.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.VERSION = void 0;
      exports.VERSION = "0.0.5";
    }
  });

  // node_modules/@yandeu/events/cjs/index.js
  var require_cjs = __commonJS({
    "node_modules/@yandeu/events/cjs/index.js"(exports) {
      "use strict";
      var __spreadArray = exports && exports.__spreadArray || function(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
          to[j] = from[i];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Events = void 0;
      var version_1 = require_version();
      var EE = function() {
        function EE2(fn2, context, once) {
          if (once === void 0) {
            once = false;
          }
          this.fn = fn2;
          this.context = context;
          this.once = once;
        }
        return EE2;
      }();
      var addListener = function(emitter, event, fn2, context, once) {
        if (typeof fn2 !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn2, context || emitter, once);
        if (!emitter._events.has(event))
          emitter._events.set(event, listener), emitter._eventsCount++;
        else if (!emitter._events.get(event).fn)
          emitter._events.get(event).push(listener);
        else
          emitter._events.set(event, [emitter._events.get(event), listener]);
        return emitter;
      };
      var clearEvent = function(emitter, event) {
        if (--emitter._eventsCount === 0)
          emitter._events = new Map();
        else
          emitter._events.delete(event);
      };
      var Events8 = function() {
        function Events9() {
          this._events = new Map();
          this._eventsCount = 0;
        }
        Object.defineProperty(Events9, "VERSION", {
          get: function() {
            return version_1.VERSION;
          },
          enumerable: false,
          configurable: true
        });
        Events9.prototype.eventNames = function() {
          return Array.from(this._events.keys());
        };
        Events9.prototype.listeners = function(event) {
          var handlers = this._events.get(event);
          if (!handlers)
            return [];
          if (handlers.fn)
            return [handlers.fn];
          for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
            ee[i] = handlers[i].fn;
          }
          return ee;
        };
        Events9.prototype.listenerCount = function(event) {
          var listeners = this._events.get(event);
          if (!listeners)
            return 0;
          if (listeners.fn)
            return 1;
          return listeners.length;
        };
        Events9.prototype.emit = function(event) {
          var _a, _b;
          var args = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
          }
          if (!this._events.has(event))
            return false;
          var listeners = this._events.get(event);
          var i;
          if (listeners.fn) {
            if (listeners.once)
              this.removeListener(event, listeners.fn, void 0, true);
            return (_a = listeners.fn).call.apply(_a, __spreadArray([listeners.context], args)), true;
          } else {
            var length_1 = listeners.length;
            for (i = 0; i < length_1; i++) {
              if (listeners[i].once)
                this.removeListener(event, listeners[i].fn, void 0, true);
              (_b = listeners[i].fn).call.apply(_b, __spreadArray([listeners[i].context], args));
            }
          }
          return true;
        };
        Events9.prototype.on = function(event, fn2, context) {
          return addListener(this, event, fn2, context, false);
        };
        Events9.prototype.once = function(event, fn2, context) {
          return addListener(this, event, fn2, context, true);
        };
        Events9.prototype.removeListener = function(event, fn2, context, once) {
          if (!this._events.has(event))
            return this;
          if (!fn2) {
            clearEvent(this, event);
            return this;
          }
          var listeners = this._events.get(event);
          if (listeners.fn) {
            if (listeners.fn === fn2 && (!once || listeners.once) && (!context || listeners.context === context)) {
              clearEvent(this, event);
            }
          } else {
            for (var i = 0, events = [], length = listeners.length; i < length; i++) {
              if (listeners[i].fn !== fn2 || once && !listeners[i].once || context && listeners[i].context !== context) {
                events.push(listeners[i]);
              }
            }
            if (events.length)
              this._events.set(event, events.length === 1 ? events[0] : events);
            else
              clearEvent(this, event);
          }
          return this;
        };
        Events9.prototype.removeAllListeners = function(event) {
          if (event) {
            if (this._events.delete(event))
              clearEvent(this, event);
          } else {
            this._events = new Map();
            this._eventsCount = 0;
          }
          return this;
        };
        Object.defineProperty(Events9.prototype, "off", {
          get: function() {
            return this.removeListener;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Events9.prototype, "addListener", {
          get: function() {
            return this.on;
          },
          enumerable: false,
          configurable: true
        });
        return Events9;
      }();
      exports.Events = Events8;
    }
  });

  // node_modules/poly-decomp/src/index.js
  var require_src = __commonJS({
    "node_modules/poly-decomp/src/index.js"(exports, module) {
      module.exports = {
        decomp: polygonDecomp,
        quickDecomp: polygonQuickDecomp,
        isSimple: polygonIsSimple,
        removeCollinearPoints: polygonRemoveCollinearPoints,
        removeDuplicatePoints: polygonRemoveDuplicatePoints,
        makeCCW: polygonMakeCCW
      };
      function lineInt(l1, l2, precision) {
        precision = precision || 0;
        var i = [0, 0];
        var a1, b1, c1, a2, b2, c2, det;
        a1 = l1[1][1] - l1[0][1];
        b1 = l1[0][0] - l1[1][0];
        c1 = a1 * l1[0][0] + b1 * l1[0][1];
        a2 = l2[1][1] - l2[0][1];
        b2 = l2[0][0] - l2[1][0];
        c2 = a2 * l2[0][0] + b2 * l2[0][1];
        det = a1 * b2 - a2 * b1;
        if (!scalar_eq(det, 0, precision)) {
          i[0] = (b2 * c1 - b1 * c2) / det;
          i[1] = (a1 * c2 - a2 * c1) / det;
        }
        return i;
      }
      function lineSegmentsIntersect(p1, p2, q1, q2) {
        var dx = p2[0] - p1[0];
        var dy = p2[1] - p1[1];
        var da = q2[0] - q1[0];
        var db = q2[1] - q1[1];
        if (da * dy - db * dx === 0) {
          return false;
        }
        var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);
        var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);
        return s >= 0 && s <= 1 && t >= 0 && t <= 1;
      }
      function triangleArea(a, b2, c) {
        return (b2[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b2[1] - a[1]);
      }
      function isLeft(a, b2, c) {
        return triangleArea(a, b2, c) > 0;
      }
      function isLeftOn(a, b2, c) {
        return triangleArea(a, b2, c) >= 0;
      }
      function isRight(a, b2, c) {
        return triangleArea(a, b2, c) < 0;
      }
      function isRightOn(a, b2, c) {
        return triangleArea(a, b2, c) <= 0;
      }
      var tmpPoint1 = [];
      var tmpPoint2 = [];
      function collinear(a, b2, c, thresholdAngle) {
        if (!thresholdAngle) {
          return triangleArea(a, b2, c) === 0;
        } else {
          var ab = tmpPoint1, bc = tmpPoint2;
          ab[0] = b2[0] - a[0];
          ab[1] = b2[1] - a[1];
          bc[0] = c[0] - b2[0];
          bc[1] = c[1] - b2[1];
          var dot = ab[0] * bc[0] + ab[1] * bc[1], magA = Math.sqrt(ab[0] * ab[0] + ab[1] * ab[1]), magB = Math.sqrt(bc[0] * bc[0] + bc[1] * bc[1]), angle = Math.acos(dot / (magA * magB));
          return angle < thresholdAngle;
        }
      }
      function sqdist(a, b2) {
        var dx = b2[0] - a[0];
        var dy = b2[1] - a[1];
        return dx * dx + dy * dy;
      }
      function polygonAt(polygon, i) {
        var s = polygon.length;
        return polygon[i < 0 ? i % s + s : i % s];
      }
      function polygonClear(polygon) {
        polygon.length = 0;
      }
      function polygonAppend(polygon, poly, from, to) {
        for (var i = from; i < to; i++) {
          polygon.push(poly[i]);
        }
      }
      function polygonMakeCCW(polygon) {
        var br2 = 0, v = polygon;
        for (var i = 1; i < polygon.length; ++i) {
          if (v[i][1] < v[br2][1] || v[i][1] === v[br2][1] && v[i][0] > v[br2][0]) {
            br2 = i;
          }
        }
        if (!isLeft(polygonAt(polygon, br2 - 1), polygonAt(polygon, br2), polygonAt(polygon, br2 + 1))) {
          polygonReverse(polygon);
          return true;
        } else {
          return false;
        }
      }
      function polygonReverse(polygon) {
        var tmp2 = [];
        var N = polygon.length;
        for (var i = 0; i !== N; i++) {
          tmp2.push(polygon.pop());
        }
        for (var i = 0; i !== N; i++) {
          polygon[i] = tmp2[i];
        }
      }
      function polygonIsReflex(polygon, i) {
        return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));
      }
      var tmpLine1 = [];
      var tmpLine2 = [];
      function polygonCanSee(polygon, a, b2) {
        var p, dist, l1 = tmpLine1, l2 = tmpLine2;
        if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b2)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b2))) {
          return false;
        }
        dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b2));
        for (var i = 0; i !== polygon.length; ++i) {
          if ((i + 1) % polygon.length === a || i === a) {
            continue;
          }
          if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b2), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b2), polygonAt(polygon, i))) {
            l1[0] = polygonAt(polygon, a);
            l1[1] = polygonAt(polygon, b2);
            l2[0] = polygonAt(polygon, i);
            l2[1] = polygonAt(polygon, i + 1);
            p = lineInt(l1, l2);
            if (sqdist(polygonAt(polygon, a), p) < dist) {
              return false;
            }
          }
        }
        return true;
      }
      function polygonCanSee2(polygon, a, b2) {
        for (var i = 0; i !== polygon.length; ++i) {
          if (i === a || i === b2 || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b2) {
            continue;
          }
          if (lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b2), polygonAt(polygon, i), polygonAt(polygon, i + 1))) {
            return false;
          }
        }
        return true;
      }
      function polygonCopy(polygon, i, j, targetPoly) {
        var p = targetPoly || [];
        polygonClear(p);
        if (i < j) {
          for (var k = i; k <= j; k++) {
            p.push(polygon[k]);
          }
        } else {
          for (var k = 0; k <= j; k++) {
            p.push(polygon[k]);
          }
          for (var k = i; k < polygon.length; k++) {
            p.push(polygon[k]);
          }
        }
        return p;
      }
      function polygonGetCutEdges(polygon) {
        var min = [], tmp1 = [], tmp2 = [], tmpPoly = [];
        var nDiags = Number.MAX_VALUE;
        for (var i = 0; i < polygon.length; ++i) {
          if (polygonIsReflex(polygon, i)) {
            for (var j = 0; j < polygon.length; ++j) {
              if (polygonCanSee(polygon, i, j)) {
                tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));
                tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));
                for (var k = 0; k < tmp2.length; k++) {
                  tmp1.push(tmp2[k]);
                }
                if (tmp1.length < nDiags) {
                  min = tmp1;
                  nDiags = tmp1.length;
                  min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);
                }
              }
            }
          }
        }
        return min;
      }
      function polygonDecomp(polygon) {
        var edges = polygonGetCutEdges(polygon);
        if (edges.length > 0) {
          return polygonSlice(polygon, edges);
        } else {
          return [polygon];
        }
      }
      function polygonSlice(polygon, cutEdges) {
        if (cutEdges.length === 0) {
          return [polygon];
        }
        if (cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length === 2 && cutEdges[0][0] instanceof Array) {
          var polys = [polygon];
          for (var i = 0; i < cutEdges.length; i++) {
            var cutEdge = cutEdges[i];
            for (var j = 0; j < polys.length; j++) {
              var poly = polys[j];
              var result = polygonSlice(poly, cutEdge);
              if (result) {
                polys.splice(j, 1);
                polys.push(result[0], result[1]);
                break;
              }
            }
          }
          return polys;
        } else {
          var cutEdge = cutEdges;
          var i = polygon.indexOf(cutEdge[0]);
          var j = polygon.indexOf(cutEdge[1]);
          if (i !== -1 && j !== -1) {
            return [
              polygonCopy(polygon, i, j),
              polygonCopy(polygon, j, i)
            ];
          } else {
            return false;
          }
        }
      }
      function polygonIsSimple(polygon) {
        var path = polygon, i;
        for (i = 0; i < path.length - 1; i++) {
          for (var j = 0; j < i - 1; j++) {
            if (lineSegmentsIntersect(path[i], path[i + 1], path[j], path[j + 1])) {
              return false;
            }
          }
        }
        for (i = 1; i < path.length - 2; i++) {
          if (lineSegmentsIntersect(path[0], path[path.length - 1], path[i], path[i + 1])) {
            return false;
          }
        }
        return true;
      }
      function getIntersectionPoint(p1, p2, q1, q2, delta) {
        delta = delta || 0;
        var a1 = p2[1] - p1[1];
        var b1 = p1[0] - p2[0];
        var c1 = a1 * p1[0] + b1 * p1[1];
        var a2 = q2[1] - q1[1];
        var b2 = q1[0] - q2[0];
        var c2 = a2 * q1[0] + b2 * q1[1];
        var det = a1 * b2 - a2 * b1;
        if (!scalar_eq(det, 0, delta)) {
          return [(b2 * c1 - b1 * c2) / det, (a1 * c2 - a2 * c1) / det];
        } else {
          return [0, 0];
        }
      }
      function polygonQuickDecomp(polygon, result, reflexVertices, steinerPoints, delta, maxlevel, level) {
        maxlevel = maxlevel || 100;
        level = level || 0;
        delta = delta || 25;
        result = typeof result !== "undefined" ? result : [];
        reflexVertices = reflexVertices || [];
        steinerPoints = steinerPoints || [];
        var upperInt = [0, 0], lowerInt = [0, 0], p = [0, 0];
        var upperDist = 0, lowerDist = 0, d = 0, closestDist = 0;
        var upperIndex = 0, lowerIndex = 0, closestIndex = 0;
        var lowerPoly = [], upperPoly = [];
        var poly = polygon, v = polygon;
        if (v.length < 3) {
          return result;
        }
        level++;
        if (level > maxlevel) {
          console.warn("quickDecomp: max level (" + maxlevel + ") reached.");
          return result;
        }
        for (var i = 0; i < polygon.length; ++i) {
          if (polygonIsReflex(poly, i)) {
            reflexVertices.push(poly[i]);
            upperDist = lowerDist = Number.MAX_VALUE;
            for (var j = 0; j < polygon.length; ++j) {
              if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) {
                p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1));
                if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) {
                  d = sqdist(poly[i], p);
                  if (d < lowerDist) {
                    lowerDist = d;
                    lowerInt = p;
                    lowerIndex = j;
                  }
                }
              }
              if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {
                p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));
                if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {
                  d = sqdist(poly[i], p);
                  if (d < upperDist) {
                    upperDist = d;
                    upperInt = p;
                    upperIndex = j;
                  }
                }
              }
            }
            if (lowerIndex === (upperIndex + 1) % polygon.length) {
              p[0] = (lowerInt[0] + upperInt[0]) / 2;
              p[1] = (lowerInt[1] + upperInt[1]) / 2;
              steinerPoints.push(p);
              if (i < upperIndex) {
                polygonAppend(lowerPoly, poly, i, upperIndex + 1);
                lowerPoly.push(p);
                upperPoly.push(p);
                if (lowerIndex !== 0) {
                  polygonAppend(upperPoly, poly, lowerIndex, poly.length);
                }
                polygonAppend(upperPoly, poly, 0, i + 1);
              } else {
                if (i !== 0) {
                  polygonAppend(lowerPoly, poly, i, poly.length);
                }
                polygonAppend(lowerPoly, poly, 0, upperIndex + 1);
                lowerPoly.push(p);
                upperPoly.push(p);
                polygonAppend(upperPoly, poly, lowerIndex, i + 1);
              }
            } else {
              if (lowerIndex > upperIndex) {
                upperIndex += polygon.length;
              }
              closestDist = Number.MAX_VALUE;
              if (upperIndex < lowerIndex) {
                return result;
              }
              for (var j = lowerIndex; j <= upperIndex; ++j) {
                if (isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {
                  d = sqdist(polygonAt(poly, i), polygonAt(poly, j));
                  if (d < closestDist && polygonCanSee2(poly, i, j)) {
                    closestDist = d;
                    closestIndex = j % polygon.length;
                  }
                }
              }
              if (i < closestIndex) {
                polygonAppend(lowerPoly, poly, i, closestIndex + 1);
                if (closestIndex !== 0) {
                  polygonAppend(upperPoly, poly, closestIndex, v.length);
                }
                polygonAppend(upperPoly, poly, 0, i + 1);
              } else {
                if (i !== 0) {
                  polygonAppend(lowerPoly, poly, i, v.length);
                }
                polygonAppend(lowerPoly, poly, 0, closestIndex + 1);
                polygonAppend(upperPoly, poly, closestIndex, i + 1);
              }
            }
            if (lowerPoly.length < upperPoly.length) {
              polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
              polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
            } else {
              polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
              polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
            }
            return result;
          }
        }
        result.push(polygon);
        return result;
      }
      function polygonRemoveCollinearPoints(polygon, precision) {
        var num = 0;
        for (var i = polygon.length - 1; polygon.length > 3 && i >= 0; --i) {
          if (collinear(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1), precision)) {
            polygon.splice(i % polygon.length, 1);
            num++;
          }
        }
        return num;
      }
      function polygonRemoveDuplicatePoints(polygon, precision) {
        for (var i = polygon.length - 1; i >= 1; --i) {
          var pi = polygon[i];
          for (var j = i - 1; j >= 0; --j) {
            if (points_eq(pi, polygon[j], precision)) {
              polygon.splice(i, 1);
              continue;
            }
          }
        }
      }
      function scalar_eq(a, b2, precision) {
        precision = precision || 0;
        return Math.abs(a - b2) <= precision;
      }
      function points_eq(a, b2, precision) {
        return scalar_eq(a[0], b2[0], precision) && scalar_eq(a[1], b2[1], precision);
      }
    }
  });

  // node_modules/matter-js/build/matter.js
  var require_matter = __commonJS({
    "node_modules/matter-js/build/matter.js"(exports, module) {
      (function webpackUniversalModuleDefinition(root, factory) {
        if (typeof exports === "object" && typeof module === "object")
          module.exports = factory(function webpackLoadOptionalExternalModule() {
            try {
              return require_src();
            } catch (e) {
            }
          }());
        else if (typeof define === "function" && define.amd)
          define("Matter", ["poly-decomp"], factory);
        else if (typeof exports === "object")
          exports["Matter"] = factory(function webpackLoadOptionalExternalModule() {
            try {
              return require_src();
            } catch (e) {
            }
          }());
        else
          root["Matter"] = factory(root["decomp"]);
      })(exports, function(__WEBPACK_EXTERNAL_MODULE__27__) {
        return function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module2 = installedModules[moduleId] = {
              i: moduleId,
              l: false,
              exports: {}
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.l = true;
            return module2.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.d = function(exports2, name, getter) {
            if (!__webpack_require__.o(exports2, name)) {
              Object.defineProperty(exports2, name, { enumerable: true, get: getter });
            }
          };
          __webpack_require__.r = function(exports2) {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
              Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
            }
            Object.defineProperty(exports2, "__esModule", { value: true });
          };
          __webpack_require__.t = function(value, mode) {
            if (mode & 1)
              value = __webpack_require__(value);
            if (mode & 8)
              return value;
            if (mode & 4 && typeof value === "object" && value && value.__esModule)
              return value;
            var ns = Object.create(null);
            __webpack_require__.r(ns);
            Object.defineProperty(ns, "default", { enumerable: true, value });
            if (mode & 2 && typeof value != "string")
              for (var key in value)
                __webpack_require__.d(ns, key, function(key2) {
                  return value[key2];
                }.bind(null, key));
            return ns;
          };
          __webpack_require__.n = function(module2) {
            var getter = module2 && module2.__esModule ? function getDefault() {
              return module2["default"];
            } : function getModuleExports() {
              return module2;
            };
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = 24);
        }([
          function(module2, exports2) {
            var Common = {};
            module2.exports = Common;
            (function() {
              Common._nextId = 0;
              Common._seed = 0;
              Common._nowStartTime = +new Date();
              Common.extend = function(obj, deep) {
                var argsStart, args, deepClone;
                if (typeof deep === "boolean") {
                  argsStart = 2;
                  deepClone = deep;
                } else {
                  argsStart = 1;
                  deepClone = true;
                }
                for (var i = argsStart; i < arguments.length; i++) {
                  var source = arguments[i];
                  if (source) {
                    for (var prop in source) {
                      if (deepClone && source[prop] && source[prop].constructor === Object) {
                        if (!obj[prop] || obj[prop].constructor === Object) {
                          obj[prop] = obj[prop] || {};
                          Common.extend(obj[prop], deepClone, source[prop]);
                        } else {
                          obj[prop] = source[prop];
                        }
                      } else {
                        obj[prop] = source[prop];
                      }
                    }
                  }
                }
                return obj;
              };
              Common.clone = function(obj, deep) {
                return Common.extend({}, deep, obj);
              };
              Common.keys = function(obj) {
                if (Object.keys)
                  return Object.keys(obj);
                var keys = [];
                for (var key in obj)
                  keys.push(key);
                return keys;
              };
              Common.values = function(obj) {
                var values = [];
                if (Object.keys) {
                  var keys = Object.keys(obj);
                  for (var i = 0; i < keys.length; i++) {
                    values.push(obj[keys[i]]);
                  }
                  return values;
                }
                for (var key in obj)
                  values.push(obj[key]);
                return values;
              };
              Common.get = function(obj, path, begin, end) {
                path = path.split(".").slice(begin, end);
                for (var i = 0; i < path.length; i += 1) {
                  obj = obj[path[i]];
                }
                return obj;
              };
              Common.set = function(obj, path, val, begin, end) {
                var parts = path.split(".").slice(begin, end);
                Common.get(obj, path, 0, -1)[parts[parts.length - 1]] = val;
                return val;
              };
              Common.shuffle = function(array) {
                for (var i = array.length - 1; i > 0; i--) {
                  var j = Math.floor(Common.random() * (i + 1));
                  var temp = array[i];
                  array[i] = array[j];
                  array[j] = temp;
                }
                return array;
              };
              Common.choose = function(choices) {
                return choices[Math.floor(Common.random() * choices.length)];
              };
              Common.isElement = function(obj) {
                if (typeof HTMLElement !== "undefined") {
                  return obj instanceof HTMLElement;
                }
                return !!(obj && obj.nodeType && obj.nodeName);
              };
              Common.isArray = function(obj) {
                return Object.prototype.toString.call(obj) === "[object Array]";
              };
              Common.isFunction = function(obj) {
                return typeof obj === "function";
              };
              Common.isPlainObject = function(obj) {
                return typeof obj === "object" && obj.constructor === Object;
              };
              Common.isString = function(obj) {
                return toString.call(obj) === "[object String]";
              };
              Common.clamp = function(value, min, max) {
                if (value < min)
                  return min;
                if (value > max)
                  return max;
                return value;
              };
              Common.sign = function(value) {
                return value < 0 ? -1 : 1;
              };
              Common.now = function() {
                if (typeof window !== "undefined" && window.performance) {
                  if (window.performance.now) {
                    return window.performance.now();
                  } else if (window.performance.webkitNow) {
                    return window.performance.webkitNow();
                  }
                }
                return new Date() - Common._nowStartTime;
              };
              Common.random = function(min, max) {
                min = typeof min !== "undefined" ? min : 0;
                max = typeof max !== "undefined" ? max : 1;
                return min + _seededRandom() * (max - min);
              };
              var _seededRandom = function() {
                Common._seed = (Common._seed * 9301 + 49297) % 233280;
                return Common._seed / 233280;
              };
              Common.colorToNumber = function(colorString) {
                colorString = colorString.replace("#", "");
                if (colorString.length == 3) {
                  colorString = colorString.charAt(0) + colorString.charAt(0) + colorString.charAt(1) + colorString.charAt(1) + colorString.charAt(2) + colorString.charAt(2);
                }
                return parseInt(colorString, 16);
              };
              Common.logLevel = 1;
              Common.log = function() {
                if (console && Common.logLevel > 0 && Common.logLevel <= 3) {
                  console.log.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
                }
              };
              Common.info = function() {
                if (console && Common.logLevel > 0 && Common.logLevel <= 2) {
                  console.info.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
                }
              };
              Common.warn = function() {
                if (console && Common.logLevel > 0 && Common.logLevel <= 3) {
                  console.warn.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
                }
              };
              Common.nextId = function() {
                return Common._nextId++;
              };
              Common.indexOf = function(haystack, needle) {
                if (haystack.indexOf)
                  return haystack.indexOf(needle);
                for (var i = 0; i < haystack.length; i++) {
                  if (haystack[i] === needle)
                    return i;
                }
                return -1;
              };
              Common.map = function(list, func) {
                if (list.map) {
                  return list.map(func);
                }
                var mapped = [];
                for (var i = 0; i < list.length; i += 1) {
                  mapped.push(func(list[i]));
                }
                return mapped;
              };
              Common.topologicalSort = function(graph) {
                var result = [], visited = [], temp = [];
                for (var node in graph) {
                  if (!visited[node] && !temp[node]) {
                    Common._topologicalSort(node, visited, temp, graph, result);
                  }
                }
                return result;
              };
              Common._topologicalSort = function(node, visited, temp, graph, result) {
                var neighbors = graph[node] || [];
                temp[node] = true;
                for (var i = 0; i < neighbors.length; i += 1) {
                  var neighbor = neighbors[i];
                  if (temp[neighbor]) {
                    continue;
                  }
                  if (!visited[neighbor]) {
                    Common._topologicalSort(neighbor, visited, temp, graph, result);
                  }
                }
                temp[node] = false;
                visited[node] = true;
                result.push(node);
              };
              Common.chain = function() {
                var funcs = [];
                for (var i = 0; i < arguments.length; i += 1) {
                  var func = arguments[i];
                  if (func._chained) {
                    funcs.push.apply(funcs, func._chained);
                  } else {
                    funcs.push(func);
                  }
                }
                var chain = function() {
                  var lastResult, args = new Array(arguments.length);
                  for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
                    args[i2] = arguments[i2];
                  }
                  for (i2 = 0; i2 < funcs.length; i2 += 1) {
                    var result = funcs[i2].apply(lastResult, args);
                    if (typeof result !== "undefined") {
                      lastResult = result;
                    }
                  }
                  return lastResult;
                };
                chain._chained = funcs;
                return chain;
              };
              Common.chainPathBefore = function(base, path, func) {
                return Common.set(base, path, Common.chain(func, Common.get(base, path)));
              };
              Common.chainPathAfter = function(base, path, func) {
                return Common.set(base, path, Common.chain(Common.get(base, path), func));
              };
            })();
          },
          function(module2, exports2) {
            var Bounds = {};
            module2.exports = Bounds;
            (function() {
              Bounds.create = function(vertices) {
                var bounds = {
                  min: { x: 0, y: 0 },
                  max: { x: 0, y: 0 }
                };
                if (vertices)
                  Bounds.update(bounds, vertices);
                return bounds;
              };
              Bounds.update = function(bounds, vertices, velocity) {
                bounds.min.x = Infinity;
                bounds.max.x = -Infinity;
                bounds.min.y = Infinity;
                bounds.max.y = -Infinity;
                for (var i = 0; i < vertices.length; i++) {
                  var vertex = vertices[i];
                  if (vertex.x > bounds.max.x)
                    bounds.max.x = vertex.x;
                  if (vertex.x < bounds.min.x)
                    bounds.min.x = vertex.x;
                  if (vertex.y > bounds.max.y)
                    bounds.max.y = vertex.y;
                  if (vertex.y < bounds.min.y)
                    bounds.min.y = vertex.y;
                }
                if (velocity) {
                  if (velocity.x > 0) {
                    bounds.max.x += velocity.x;
                  } else {
                    bounds.min.x += velocity.x;
                  }
                  if (velocity.y > 0) {
                    bounds.max.y += velocity.y;
                  } else {
                    bounds.min.y += velocity.y;
                  }
                }
              };
              Bounds.contains = function(bounds, point) {
                return point.x >= bounds.min.x && point.x <= bounds.max.x && point.y >= bounds.min.y && point.y <= bounds.max.y;
              };
              Bounds.overlaps = function(boundsA, boundsB) {
                return boundsA.min.x <= boundsB.max.x && boundsA.max.x >= boundsB.min.x && boundsA.max.y >= boundsB.min.y && boundsA.min.y <= boundsB.max.y;
              };
              Bounds.translate = function(bounds, vector) {
                bounds.min.x += vector.x;
                bounds.max.x += vector.x;
                bounds.min.y += vector.y;
                bounds.max.y += vector.y;
              };
              Bounds.shift = function(bounds, position) {
                var deltaX = bounds.max.x - bounds.min.x, deltaY = bounds.max.y - bounds.min.y;
                bounds.min.x = position.x;
                bounds.max.x = position.x + deltaX;
                bounds.min.y = position.y;
                bounds.max.y = position.y + deltaY;
              };
            })();
          },
          function(module2, exports2) {
            var Vector6 = {};
            module2.exports = Vector6;
            (function() {
              Vector6.create = function(x, y) {
                return { x: x || 0, y: y || 0 };
              };
              Vector6.clone = function(vector) {
                return { x: vector.x, y: vector.y };
              };
              Vector6.magnitude = function(vector) {
                return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
              };
              Vector6.magnitudeSquared = function(vector) {
                return vector.x * vector.x + vector.y * vector.y;
              };
              Vector6.rotate = function(vector, angle, output) {
                var cos = Math.cos(angle), sin = Math.sin(angle);
                if (!output)
                  output = {};
                var x = vector.x * cos - vector.y * sin;
                output.y = vector.x * sin + vector.y * cos;
                output.x = x;
                return output;
              };
              Vector6.rotateAbout = function(vector, angle, point, output) {
                var cos = Math.cos(angle), sin = Math.sin(angle);
                if (!output)
                  output = {};
                var x = point.x + ((vector.x - point.x) * cos - (vector.y - point.y) * sin);
                output.y = point.y + ((vector.x - point.x) * sin + (vector.y - point.y) * cos);
                output.x = x;
                return output;
              };
              Vector6.normalise = function(vector) {
                var magnitude = Vector6.magnitude(vector);
                if (magnitude === 0)
                  return { x: 0, y: 0 };
                return { x: vector.x / magnitude, y: vector.y / magnitude };
              };
              Vector6.dot = function(vectorA, vectorB) {
                return vectorA.x * vectorB.x + vectorA.y * vectorB.y;
              };
              Vector6.cross = function(vectorA, vectorB) {
                return vectorA.x * vectorB.y - vectorA.y * vectorB.x;
              };
              Vector6.cross3 = function(vectorA, vectorB, vectorC) {
                return (vectorB.x - vectorA.x) * (vectorC.y - vectorA.y) - (vectorB.y - vectorA.y) * (vectorC.x - vectorA.x);
              };
              Vector6.add = function(vectorA, vectorB, output) {
                if (!output)
                  output = {};
                output.x = vectorA.x + vectorB.x;
                output.y = vectorA.y + vectorB.y;
                return output;
              };
              Vector6.sub = function(vectorA, vectorB, output) {
                if (!output)
                  output = {};
                output.x = vectorA.x - vectorB.x;
                output.y = vectorA.y - vectorB.y;
                return output;
              };
              Vector6.mult = function(vector, scalar) {
                return { x: vector.x * scalar, y: vector.y * scalar };
              };
              Vector6.div = function(vector, scalar) {
                return { x: vector.x / scalar, y: vector.y / scalar };
              };
              Vector6.perp = function(vector, negate) {
                negate = negate === true ? -1 : 1;
                return { x: negate * -vector.y, y: negate * vector.x };
              };
              Vector6.neg = function(vector) {
                return { x: -vector.x, y: -vector.y };
              };
              Vector6.angle = function(vectorA, vectorB) {
                return Math.atan2(vectorB.y - vectorA.y, vectorB.x - vectorA.x);
              };
              Vector6._temp = [
                Vector6.create(),
                Vector6.create(),
                Vector6.create(),
                Vector6.create(),
                Vector6.create(),
                Vector6.create()
              ];
            })();
          },
          function(module2, exports2, __webpack_require__) {
            var Vertices2 = {};
            module2.exports = Vertices2;
            var Vector6 = __webpack_require__(2);
            var Common = __webpack_require__(0);
            (function() {
              Vertices2.create = function(points, body) {
                var vertices = [];
                for (var i = 0; i < points.length; i++) {
                  var point = points[i], vertex = {
                    x: point.x,
                    y: point.y,
                    index: i,
                    body,
                    isInternal: false
                  };
                  vertices.push(vertex);
                }
                return vertices;
              };
              Vertices2.fromPath = function(path, body) {
                var pathPattern = /L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/ig, points = [];
                path.replace(pathPattern, function(match, x, y) {
                  points.push({ x: parseFloat(x), y: parseFloat(y) });
                });
                return Vertices2.create(points, body);
              };
              Vertices2.centre = function(vertices) {
                var area2 = Vertices2.area(vertices, true), centre = { x: 0, y: 0 }, cross, temp, j;
                for (var i = 0; i < vertices.length; i++) {
                  j = (i + 1) % vertices.length;
                  cross = Vector6.cross(vertices[i], vertices[j]);
                  temp = Vector6.mult(Vector6.add(vertices[i], vertices[j]), cross);
                  centre = Vector6.add(centre, temp);
                }
                return Vector6.div(centre, 6 * area2);
              };
              Vertices2.mean = function(vertices) {
                var average = { x: 0, y: 0 };
                for (var i = 0; i < vertices.length; i++) {
                  average.x += vertices[i].x;
                  average.y += vertices[i].y;
                }
                return Vector6.div(average, vertices.length);
              };
              Vertices2.area = function(vertices, signed) {
                var area2 = 0, j = vertices.length - 1;
                for (var i = 0; i < vertices.length; i++) {
                  area2 += (vertices[j].x - vertices[i].x) * (vertices[j].y + vertices[i].y);
                  j = i;
                }
                if (signed)
                  return area2 / 2;
                return Math.abs(area2) / 2;
              };
              Vertices2.inertia = function(vertices, mass) {
                var numerator = 0, denominator = 0, v = vertices, cross, j;
                for (var n = 0; n < v.length; n++) {
                  j = (n + 1) % v.length;
                  cross = Math.abs(Vector6.cross(v[j], v[n]));
                  numerator += cross * (Vector6.dot(v[j], v[j]) + Vector6.dot(v[j], v[n]) + Vector6.dot(v[n], v[n]));
                  denominator += cross;
                }
                return mass / 6 * (numerator / denominator);
              };
              Vertices2.translate = function(vertices, vector, scalar) {
                var i;
                if (scalar) {
                  for (i = 0; i < vertices.length; i++) {
                    vertices[i].x += vector.x * scalar;
                    vertices[i].y += vector.y * scalar;
                  }
                } else {
                  for (i = 0; i < vertices.length; i++) {
                    vertices[i].x += vector.x;
                    vertices[i].y += vector.y;
                  }
                }
                return vertices;
              };
              Vertices2.rotate = function(vertices, angle, point) {
                if (angle === 0)
                  return;
                var cos = Math.cos(angle), sin = Math.sin(angle);
                for (var i = 0; i < vertices.length; i++) {
                  var vertice = vertices[i], dx = vertice.x - point.x, dy = vertice.y - point.y;
                  vertice.x = point.x + (dx * cos - dy * sin);
                  vertice.y = point.y + (dx * sin + dy * cos);
                }
                return vertices;
              };
              Vertices2.contains = function(vertices, point) {
                for (var i = 0; i < vertices.length; i++) {
                  var vertice = vertices[i], nextVertice = vertices[(i + 1) % vertices.length];
                  if ((point.x - vertice.x) * (nextVertice.y - vertice.y) + (point.y - vertice.y) * (vertice.x - nextVertice.x) > 0) {
                    return false;
                  }
                }
                return true;
              };
              Vertices2.scale = function(vertices, scaleX, scaleY, point) {
                if (scaleX === 1 && scaleY === 1)
                  return vertices;
                point = point || Vertices2.centre(vertices);
                var vertex, delta;
                for (var i = 0; i < vertices.length; i++) {
                  vertex = vertices[i];
                  delta = Vector6.sub(vertex, point);
                  vertices[i].x = point.x + delta.x * scaleX;
                  vertices[i].y = point.y + delta.y * scaleY;
                }
                return vertices;
              };
              Vertices2.chamfer = function(vertices, radius, quality, qualityMin, qualityMax) {
                if (typeof radius === "number") {
                  radius = [radius];
                } else {
                  radius = radius || [8];
                }
                quality = typeof quality !== "undefined" ? quality : -1;
                qualityMin = qualityMin || 2;
                qualityMax = qualityMax || 14;
                var newVertices = [];
                for (var i = 0; i < vertices.length; i++) {
                  var prevVertex = vertices[i - 1 >= 0 ? i - 1 : vertices.length - 1], vertex = vertices[i], nextVertex = vertices[(i + 1) % vertices.length], currentRadius = radius[i < radius.length ? i : radius.length - 1];
                  if (currentRadius === 0) {
                    newVertices.push(vertex);
                    continue;
                  }
                  var prevNormal = Vector6.normalise({
                    x: vertex.y - prevVertex.y,
                    y: prevVertex.x - vertex.x
                  });
                  var nextNormal = Vector6.normalise({
                    x: nextVertex.y - vertex.y,
                    y: vertex.x - nextVertex.x
                  });
                  var diagonalRadius = Math.sqrt(2 * Math.pow(currentRadius, 2)), radiusVector = Vector6.mult(Common.clone(prevNormal), currentRadius), midNormal = Vector6.normalise(Vector6.mult(Vector6.add(prevNormal, nextNormal), 0.5)), scaledVertex = Vector6.sub(vertex, Vector6.mult(midNormal, diagonalRadius));
                  var precision = quality;
                  if (quality === -1) {
                    precision = Math.pow(currentRadius, 0.32) * 1.75;
                  }
                  precision = Common.clamp(precision, qualityMin, qualityMax);
                  if (precision % 2 === 1)
                    precision += 1;
                  var alpha = Math.acos(Vector6.dot(prevNormal, nextNormal)), theta = alpha / precision;
                  for (var j = 0; j < precision; j++) {
                    newVertices.push(Vector6.add(Vector6.rotate(radiusVector, theta * j), scaledVertex));
                  }
                }
                return newVertices;
              };
              Vertices2.clockwiseSort = function(vertices) {
                var centre = Vertices2.mean(vertices);
                vertices.sort(function(vertexA, vertexB) {
                  return Vector6.angle(centre, vertexA) - Vector6.angle(centre, vertexB);
                });
                return vertices;
              };
              Vertices2.isConvex = function(vertices) {
                var flag = 0, n = vertices.length, i, j, k, z;
                if (n < 3)
                  return null;
                for (i = 0; i < n; i++) {
                  j = (i + 1) % n;
                  k = (i + 2) % n;
                  z = (vertices[j].x - vertices[i].x) * (vertices[k].y - vertices[j].y);
                  z -= (vertices[j].y - vertices[i].y) * (vertices[k].x - vertices[j].x);
                  if (z < 0) {
                    flag |= 1;
                  } else if (z > 0) {
                    flag |= 2;
                  }
                  if (flag === 3) {
                    return false;
                  }
                }
                if (flag !== 0) {
                  return true;
                } else {
                  return null;
                }
              };
              Vertices2.hull = function(vertices) {
                var upper = [], lower = [], vertex, i;
                vertices = vertices.slice(0);
                vertices.sort(function(vertexA, vertexB) {
                  var dx = vertexA.x - vertexB.x;
                  return dx !== 0 ? dx : vertexA.y - vertexB.y;
                });
                for (i = 0; i < vertices.length; i += 1) {
                  vertex = vertices[i];
                  while (lower.length >= 2 && Vector6.cross3(lower[lower.length - 2], lower[lower.length - 1], vertex) <= 0) {
                    lower.pop();
                  }
                  lower.push(vertex);
                }
                for (i = vertices.length - 1; i >= 0; i -= 1) {
                  vertex = vertices[i];
                  while (upper.length >= 2 && Vector6.cross3(upper[upper.length - 2], upper[upper.length - 1], vertex) <= 0) {
                    upper.pop();
                  }
                  upper.push(vertex);
                }
                upper.pop();
                lower.pop();
                return upper.concat(lower);
              };
            })();
          },
          function(module2, exports2, __webpack_require__) {
            var Events8 = {};
            module2.exports = Events8;
            var Common = __webpack_require__(0);
            (function() {
              Events8.on = function(object, eventNames, callback) {
                var names = eventNames.split(" "), name;
                for (var i = 0; i < names.length; i++) {
                  name = names[i];
                  object.events = object.events || {};
                  object.events[name] = object.events[name] || [];
                  object.events[name].push(callback);
                }
                return callback;
              };
              Events8.off = function(object, eventNames, callback) {
                if (!eventNames) {
                  object.events = {};
                  return;
                }
                if (typeof eventNames === "function") {
                  callback = eventNames;
                  eventNames = Common.keys(object.events).join(" ");
                }
                var names = eventNames.split(" ");
                for (var i = 0; i < names.length; i++) {
                  var callbacks = object.events[names[i]], newCallbacks = [];
                  if (callback && callbacks) {
                    for (var j = 0; j < callbacks.length; j++) {
                      if (callbacks[j] !== callback)
                        newCallbacks.push(callbacks[j]);
                    }
                  }
                  object.events[names[i]] = newCallbacks;
                }
              };
              Events8.trigger = function(object, eventNames, event) {
                var names, name, callbacks, eventClone;
                var events = object.events;
                if (events && Common.keys(events).length > 0) {
                  if (!event)
                    event = {};
                  names = eventNames.split(" ");
                  for (var i = 0; i < names.length; i++) {
                    name = names[i];
                    callbacks = events[name];
                    if (callbacks) {
                      eventClone = Common.clone(event, false);
                      eventClone.name = name;
                      eventClone.source = object;
                      for (var j = 0; j < callbacks.length; j++) {
                        callbacks[j].apply(object, [eventClone]);
                      }
                    }
                  }
                }
              };
            })();
          },
          function(module2, exports2, __webpack_require__) {
            var Composite2 = {};
            module2.exports = Composite2;
            var Events8 = __webpack_require__(4);
            var Common = __webpack_require__(0);
            var Bounds = __webpack_require__(1);
            var Body2 = __webpack_require__(6);
            (function() {
              Composite2.create = function(options) {
                return Common.extend({
                  id: Common.nextId(),
                  type: "composite",
                  parent: null,
                  isModified: false,
                  bodies: [],
                  constraints: [],
                  composites: [],
                  label: "Composite",
                  plugin: {}
                }, options);
              };
              Composite2.setModified = function(composite, isModified, updateParents, updateChildren) {
                composite.isModified = isModified;
                if (updateParents && composite.parent) {
                  Composite2.setModified(composite.parent, isModified, updateParents, updateChildren);
                }
                if (updateChildren) {
                  for (var i = 0; i < composite.composites.length; i++) {
                    var childComposite = composite.composites[i];
                    Composite2.setModified(childComposite, isModified, updateParents, updateChildren);
                  }
                }
              };
              Composite2.add = function(composite, object) {
                var objects = [].concat(object);
                Events8.trigger(composite, "beforeAdd", { object });
                for (var i = 0; i < objects.length; i++) {
                  var obj = objects[i];
                  switch (obj.type) {
                    case "body":
                      if (obj.parent !== obj) {
                        Common.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)");
                        break;
                      }
                      Composite2.addBody(composite, obj);
                      break;
                    case "constraint":
                      Composite2.addConstraint(composite, obj);
                      break;
                    case "composite":
                      Composite2.addComposite(composite, obj);
                      break;
                    case "mouseConstraint":
                      Composite2.addConstraint(composite, obj.constraint);
                      break;
                  }
                }
                Events8.trigger(composite, "afterAdd", { object });
                return composite;
              };
              Composite2.remove = function(composite, object, deep) {
                var objects = [].concat(object);
                Events8.trigger(composite, "beforeRemove", { object });
                for (var i = 0; i < objects.length; i++) {
                  var obj = objects[i];
                  switch (obj.type) {
                    case "body":
                      Composite2.removeBody(composite, obj, deep);
                      break;
                    case "constraint":
                      Composite2.removeConstraint(composite, obj, deep);
                      break;
                    case "composite":
                      Composite2.removeComposite(composite, obj, deep);
                      break;
                    case "mouseConstraint":
                      Composite2.removeConstraint(composite, obj.constraint);
                      break;
                  }
                }
                Events8.trigger(composite, "afterRemove", { object });
                return composite;
              };
              Composite2.addComposite = function(compositeA, compositeB) {
                compositeA.composites.push(compositeB);
                compositeB.parent = compositeA;
                Composite2.setModified(compositeA, true, true, false);
                return compositeA;
              };
              Composite2.removeComposite = function(compositeA, compositeB, deep) {
                var position = Common.indexOf(compositeA.composites, compositeB);
                if (position !== -1) {
                  Composite2.removeCompositeAt(compositeA, position);
                  Composite2.setModified(compositeA, true, true, false);
                }
                if (deep) {
                  for (var i = 0; i < compositeA.composites.length; i++) {
                    Composite2.removeComposite(compositeA.composites[i], compositeB, true);
                  }
                }
                return compositeA;
              };
              Composite2.removeCompositeAt = function(composite, position) {
                composite.composites.splice(position, 1);
                Composite2.setModified(composite, true, true, false);
                return composite;
              };
              Composite2.addBody = function(composite, body) {
                composite.bodies.push(body);
                Composite2.setModified(composite, true, true, false);
                return composite;
              };
              Composite2.removeBody = function(composite, body, deep) {
                var position = Common.indexOf(composite.bodies, body);
                if (position !== -1) {
                  Composite2.removeBodyAt(composite, position);
                  Composite2.setModified(composite, true, true, false);
                }
                if (deep) {
                  for (var i = 0; i < composite.composites.length; i++) {
                    Composite2.removeBody(composite.composites[i], body, true);
                  }
                }
                return composite;
              };
              Composite2.removeBodyAt = function(composite, position) {
                composite.bodies.splice(position, 1);
                Composite2.setModified(composite, true, true, false);
                return composite;
              };
              Composite2.addConstraint = function(composite, constraint) {
                composite.constraints.push(constraint);
                Composite2.setModified(composite, true, true, false);
                return composite;
              };
              Composite2.removeConstraint = function(composite, constraint, deep) {
                var position = Common.indexOf(composite.constraints, constraint);
                if (position !== -1) {
                  Composite2.removeConstraintAt(composite, position);
                }
                if (deep) {
                  for (var i = 0; i < composite.composites.length; i++) {
                    Composite2.removeConstraint(composite.composites[i], constraint, true);
                  }
                }
                return composite;
              };
              Composite2.removeConstraintAt = function(composite, position) {
                composite.constraints.splice(position, 1);
                Composite2.setModified(composite, true, true, false);
                return composite;
              };
              Composite2.clear = function(composite, keepStatic, deep) {
                if (deep) {
                  for (var i = 0; i < composite.composites.length; i++) {
                    Composite2.clear(composite.composites[i], keepStatic, true);
                  }
                }
                if (keepStatic) {
                  composite.bodies = composite.bodies.filter(function(body) {
                    return body.isStatic;
                  });
                } else {
                  composite.bodies.length = 0;
                }
                composite.constraints.length = 0;
                composite.composites.length = 0;
                Composite2.setModified(composite, true, true, false);
                return composite;
              };
              Composite2.allBodies = function(composite) {
                var bodies = [].concat(composite.bodies);
                for (var i = 0; i < composite.composites.length; i++)
                  bodies = bodies.concat(Composite2.allBodies(composite.composites[i]));
                return bodies;
              };
              Composite2.allConstraints = function(composite) {
                var constraints = [].concat(composite.constraints);
                for (var i = 0; i < composite.composites.length; i++)
                  constraints = constraints.concat(Composite2.allConstraints(composite.composites[i]));
                return constraints;
              };
              Composite2.allComposites = function(composite) {
                var composites = [].concat(composite.composites);
                for (var i = 0; i < composite.composites.length; i++)
                  composites = composites.concat(Composite2.allComposites(composite.composites[i]));
                return composites;
              };
              Composite2.get = function(composite, id, type) {
                var objects, object;
                switch (type) {
                  case "body":
                    objects = Composite2.allBodies(composite);
                    break;
                  case "constraint":
                    objects = Composite2.allConstraints(composite);
                    break;
                  case "composite":
                    objects = Composite2.allComposites(composite).concat(composite);
                    break;
                }
                if (!objects)
                  return null;
                object = objects.filter(function(object2) {
                  return object2.id.toString() === id.toString();
                });
                return object.length === 0 ? null : object[0];
              };
              Composite2.move = function(compositeA, objects, compositeB) {
                Composite2.remove(compositeA, objects);
                Composite2.add(compositeB, objects);
                return compositeA;
              };
              Composite2.rebase = function(composite) {
                var objects = Composite2.allBodies(composite).concat(Composite2.allConstraints(composite)).concat(Composite2.allComposites(composite));
                for (var i = 0; i < objects.length; i++) {
                  objects[i].id = Common.nextId();
                }
                Composite2.setModified(composite, true, true, false);
                return composite;
              };
              Composite2.translate = function(composite, translation, recursive) {
                var bodies = recursive ? Composite2.allBodies(composite) : composite.bodies;
                for (var i = 0; i < bodies.length; i++) {
                  Body2.translate(bodies[i], translation);
                }
                Composite2.setModified(composite, true, true, false);
                return composite;
              };
              Composite2.rotate = function(composite, rotation, point, recursive) {
                var cos = Math.cos(rotation), sin = Math.sin(rotation), bodies = recursive ? Composite2.allBodies(composite) : composite.bodies;
                for (var i = 0; i < bodies.length; i++) {
                  var body = bodies[i], dx = body.position.x - point.x, dy = body.position.y - point.y;
                  Body2.setPosition(body, {
                    x: point.x + (dx * cos - dy * sin),
                    y: point.y + (dx * sin + dy * cos)
                  });
                  Body2.rotate(body, rotation);
                }
                Composite2.setModified(composite, true, true, false);
                return composite;
              };
              Composite2.scale = function(composite, scaleX, scaleY, point, recursive) {
                var bodies = recursive ? Composite2.allBodies(composite) : composite.bodies;
                for (var i = 0; i < bodies.length; i++) {
                  var body = bodies[i], dx = body.position.x - point.x, dy = body.position.y - point.y;
                  Body2.setPosition(body, {
                    x: point.x + dx * scaleX,
                    y: point.y + dy * scaleY
                  });
                  Body2.scale(body, scaleX, scaleY);
                }
                Composite2.setModified(composite, true, true, false);
                return composite;
              };
              Composite2.bounds = function(composite) {
                var bodies = Composite2.allBodies(composite), vertices = [];
                for (var i = 0; i < bodies.length; i += 1) {
                  var body = bodies[i];
                  vertices.push(body.bounds.min, body.bounds.max);
                }
                return Bounds.create(vertices);
              };
            })();
          },
          function(module2, exports2, __webpack_require__) {
            var Body2 = {};
            module2.exports = Body2;
            var Vertices2 = __webpack_require__(3);
            var Vector6 = __webpack_require__(2);
            var Sleeping = __webpack_require__(7);
            var Render2 = __webpack_require__(10);
            var Common = __webpack_require__(0);
            var Bounds = __webpack_require__(1);
            var Axes = __webpack_require__(15);
            (function() {
              Body2._inertiaScale = 4;
              Body2._nextCollidingGroupId = 1;
              Body2._nextNonCollidingGroupId = -1;
              Body2._nextCategory = 1;
              Body2.create = function(options) {
                var defaults = {
                  id: Common.nextId(),
                  type: "body",
                  label: "Body",
                  parts: [],
                  plugin: {},
                  angle: 0,
                  vertices: Vertices2.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"),
                  position: { x: 0, y: 0 },
                  force: { x: 0, y: 0 },
                  torque: 0,
                  positionImpulse: { x: 0, y: 0 },
                  constraintImpulse: { x: 0, y: 0, angle: 0 },
                  totalContacts: 0,
                  speed: 0,
                  angularSpeed: 0,
                  velocity: { x: 0, y: 0 },
                  angularVelocity: 0,
                  isSensor: false,
                  isStatic: false,
                  isSleeping: false,
                  motion: 0,
                  sleepThreshold: 60,
                  density: 1e-3,
                  restitution: 0,
                  friction: 0.1,
                  frictionStatic: 0.5,
                  frictionAir: 0.01,
                  collisionFilter: {
                    category: 1,
                    mask: 4294967295,
                    group: 0
                  },
                  slop: 0.05,
                  timeScale: 1,
                  render: {
                    visible: true,
                    opacity: 1,
                    strokeStyle: null,
                    fillStyle: null,
                    lineWidth: null,
                    sprite: {
                      xScale: 1,
                      yScale: 1,
                      xOffset: 0,
                      yOffset: 0
                    }
                  },
                  events: null,
                  bounds: null,
                  chamfer: null,
                  circleRadius: 0,
                  positionPrev: null,
                  anglePrev: 0,
                  parent: null,
                  axes: null,
                  area: 0,
                  mass: 0,
                  inertia: 0,
                  _original: null
                };
                var body = Common.extend(defaults, options);
                _initProperties(body, options);
                return body;
              };
              Body2.nextGroup = function(isNonColliding) {
                if (isNonColliding)
                  return Body2._nextNonCollidingGroupId--;
                return Body2._nextCollidingGroupId++;
              };
              Body2.nextCategory = function() {
                Body2._nextCategory = Body2._nextCategory << 1;
                return Body2._nextCategory;
              };
              var _initProperties = function(body, options) {
                options = options || {};
                Body2.set(body, {
                  bounds: body.bounds || Bounds.create(body.vertices),
                  positionPrev: body.positionPrev || Vector6.clone(body.position),
                  anglePrev: body.anglePrev || body.angle,
                  vertices: body.vertices,
                  parts: body.parts || [body],
                  isStatic: body.isStatic,
                  isSleeping: body.isSleeping,
                  parent: body.parent || body
                });
                Vertices2.rotate(body.vertices, body.angle, body.position);
                Axes.rotate(body.axes, body.angle);
                Bounds.update(body.bounds, body.vertices, body.velocity);
                Body2.set(body, {
                  axes: options.axes || body.axes,
                  area: options.area || body.area,
                  mass: options.mass || body.mass,
                  inertia: options.inertia || body.inertia
                });
                var defaultFillStyle = body.isStatic ? "#14151f" : Common.choose(["#f19648", "#f5d259", "#f55a3c", "#063e7b", "#ececd1"]), defaultStrokeStyle = body.isStatic ? "#555" : "#ccc", defaultLineWidth = body.isStatic && body.render.fillStyle === null ? 1 : 0;
                body.render.fillStyle = body.render.fillStyle || defaultFillStyle;
                body.render.strokeStyle = body.render.strokeStyle || defaultStrokeStyle;
                body.render.lineWidth = body.render.lineWidth || defaultLineWidth;
                body.render.sprite.xOffset += -(body.bounds.min.x - body.position.x) / (body.bounds.max.x - body.bounds.min.x);
                body.render.sprite.yOffset += -(body.bounds.min.y - body.position.y) / (body.bounds.max.y - body.bounds.min.y);
              };
              Body2.set = function(body, settings, value) {
                var property;
                if (typeof settings === "string") {
                  property = settings;
                  settings = {};
                  settings[property] = value;
                }
                for (property in settings) {
                  if (!Object.prototype.hasOwnProperty.call(settings, property))
                    continue;
                  value = settings[property];
                  switch (property) {
                    case "isStatic":
                      Body2.setStatic(body, value);
                      break;
                    case "isSleeping":
                      Sleeping.set(body, value);
                      break;
                    case "mass":
                      Body2.setMass(body, value);
                      break;
                    case "density":
                      Body2.setDensity(body, value);
                      break;
                    case "inertia":
                      Body2.setInertia(body, value);
                      break;
                    case "vertices":
                      Body2.setVertices(body, value);
                      break;
                    case "position":
                      Body2.setPosition(body, value);
                      break;
                    case "angle":
                      Body2.setAngle(body, value);
                      break;
                    case "velocity":
                      Body2.setVelocity(body, value);
                      break;
                    case "angularVelocity":
                      Body2.setAngularVelocity(body, value);
                      break;
                    case "parts":
                      Body2.setParts(body, value);
                      break;
                    case "centre":
                      Body2.setCentre(body, value);
                      break;
                    default:
                      body[property] = value;
                  }
                }
              };
              Body2.setStatic = function(body, isStatic) {
                for (var i = 0; i < body.parts.length; i++) {
                  var part = body.parts[i];
                  part.isStatic = isStatic;
                  if (isStatic) {
                    part._original = {
                      restitution: part.restitution,
                      friction: part.friction,
                      mass: part.mass,
                      inertia: part.inertia,
                      density: part.density,
                      inverseMass: part.inverseMass,
                      inverseInertia: part.inverseInertia
                    };
                    part.restitution = 0;
                    part.friction = 1;
                    part.mass = part.inertia = part.density = Infinity;
                    part.inverseMass = part.inverseInertia = 0;
                    part.positionPrev.x = part.position.x;
                    part.positionPrev.y = part.position.y;
                    part.anglePrev = part.angle;
                    part.angularVelocity = 0;
                    part.speed = 0;
                    part.angularSpeed = 0;
                    part.motion = 0;
                  } else if (part._original) {
                    part.restitution = part._original.restitution;
                    part.friction = part._original.friction;
                    part.mass = part._original.mass;
                    part.inertia = part._original.inertia;
                    part.density = part._original.density;
                    part.inverseMass = part._original.inverseMass;
                    part.inverseInertia = part._original.inverseInertia;
                    part._original = null;
                  }
                }
              };
              Body2.setMass = function(body, mass) {
                var moment = body.inertia / (body.mass / 6);
                body.inertia = moment * (mass / 6);
                body.inverseInertia = 1 / body.inertia;
                body.mass = mass;
                body.inverseMass = 1 / body.mass;
                body.density = body.mass / body.area;
              };
              Body2.setDensity = function(body, density) {
                Body2.setMass(body, density * body.area);
                body.density = density;
              };
              Body2.setInertia = function(body, inertia) {
                body.inertia = inertia;
                body.inverseInertia = 1 / body.inertia;
              };
              Body2.setVertices = function(body, vertices) {
                if (vertices[0].body === body) {
                  body.vertices = vertices;
                } else {
                  body.vertices = Vertices2.create(vertices, body);
                }
                body.axes = Axes.fromVertices(body.vertices);
                body.area = Vertices2.area(body.vertices);
                Body2.setMass(body, body.density * body.area);
                var centre = Vertices2.centre(body.vertices);
                Vertices2.translate(body.vertices, centre, -1);
                Body2.setInertia(body, Body2._inertiaScale * Vertices2.inertia(body.vertices, body.mass));
                Vertices2.translate(body.vertices, body.position);
                Bounds.update(body.bounds, body.vertices, body.velocity);
              };
              Body2.setParts = function(body, parts, autoHull) {
                var i;
                parts = parts.slice(0);
                body.parts.length = 0;
                body.parts.push(body);
                body.parent = body;
                for (i = 0; i < parts.length; i++) {
                  var part = parts[i];
                  if (part !== body) {
                    part.parent = body;
                    body.parts.push(part);
                  }
                }
                if (body.parts.length === 1)
                  return;
                autoHull = typeof autoHull !== "undefined" ? autoHull : true;
                if (autoHull) {
                  var vertices = [];
                  for (i = 0; i < parts.length; i++) {
                    vertices = vertices.concat(parts[i].vertices);
                  }
                  Vertices2.clockwiseSort(vertices);
                  var hull = Vertices2.hull(vertices), hullCentre = Vertices2.centre(hull);
                  Body2.setVertices(body, hull);
                  Vertices2.translate(body.vertices, hullCentre);
                }
                var total = Body2._totalProperties(body);
                body.area = total.area;
                body.parent = body;
                body.position.x = total.centre.x;
                body.position.y = total.centre.y;
                body.positionPrev.x = total.centre.x;
                body.positionPrev.y = total.centre.y;
                Body2.setMass(body, total.mass);
                Body2.setInertia(body, total.inertia);
                Body2.setPosition(body, total.centre);
              };
              Body2.setCentre = function(body, centre, relative) {
                if (!relative) {
                  body.positionPrev.x = centre.x - (body.position.x - body.positionPrev.x);
                  body.positionPrev.y = centre.y - (body.position.y - body.positionPrev.y);
                  body.position.x = centre.x;
                  body.position.y = centre.y;
                } else {
                  body.positionPrev.x += centre.x;
                  body.positionPrev.y += centre.y;
                  body.position.x += centre.x;
                  body.position.y += centre.y;
                }
              };
              Body2.setPosition = function(body, position) {
                var delta = Vector6.sub(position, body.position);
                body.positionPrev.x += delta.x;
                body.positionPrev.y += delta.y;
                for (var i = 0; i < body.parts.length; i++) {
                  var part = body.parts[i];
                  part.position.x += delta.x;
                  part.position.y += delta.y;
                  Vertices2.translate(part.vertices, delta);
                  Bounds.update(part.bounds, part.vertices, body.velocity);
                }
              };
              Body2.setAngle = function(body, angle) {
                var delta = angle - body.angle;
                body.anglePrev += delta;
                for (var i = 0; i < body.parts.length; i++) {
                  var part = body.parts[i];
                  part.angle += delta;
                  Vertices2.rotate(part.vertices, delta, body.position);
                  Axes.rotate(part.axes, delta);
                  Bounds.update(part.bounds, part.vertices, body.velocity);
                  if (i > 0) {
                    Vector6.rotateAbout(part.position, delta, body.position, part.position);
                  }
                }
              };
              Body2.setVelocity = function(body, velocity) {
                body.positionPrev.x = body.position.x - velocity.x;
                body.positionPrev.y = body.position.y - velocity.y;
                body.velocity.x = velocity.x;
                body.velocity.y = velocity.y;
                body.speed = Vector6.magnitude(body.velocity);
              };
              Body2.setAngularVelocity = function(body, velocity) {
                body.anglePrev = body.angle - velocity;
                body.angularVelocity = velocity;
                body.angularSpeed = Math.abs(body.angularVelocity);
              };
              Body2.translate = function(body, translation) {
                Body2.setPosition(body, Vector6.add(body.position, translation));
              };
              Body2.rotate = function(body, rotation, point) {
                if (!point) {
                  Body2.setAngle(body, body.angle + rotation);
                } else {
                  var cos = Math.cos(rotation), sin = Math.sin(rotation), dx = body.position.x - point.x, dy = body.position.y - point.y;
                  Body2.setPosition(body, {
                    x: point.x + (dx * cos - dy * sin),
                    y: point.y + (dx * sin + dy * cos)
                  });
                  Body2.setAngle(body, body.angle + rotation);
                }
              };
              Body2.scale = function(body, scaleX, scaleY, point) {
                var totalArea = 0, totalInertia = 0;
                point = point || body.position;
                for (var i = 0; i < body.parts.length; i++) {
                  var part = body.parts[i];
                  Vertices2.scale(part.vertices, scaleX, scaleY, point);
                  part.axes = Axes.fromVertices(part.vertices);
                  part.area = Vertices2.area(part.vertices);
                  Body2.setMass(part, body.density * part.area);
                  Vertices2.translate(part.vertices, { x: -part.position.x, y: -part.position.y });
                  Body2.setInertia(part, Body2._inertiaScale * Vertices2.inertia(part.vertices, part.mass));
                  Vertices2.translate(part.vertices, { x: part.position.x, y: part.position.y });
                  if (i > 0) {
                    totalArea += part.area;
                    totalInertia += part.inertia;
                  }
                  part.position.x = point.x + (part.position.x - point.x) * scaleX;
                  part.position.y = point.y + (part.position.y - point.y) * scaleY;
                  Bounds.update(part.bounds, part.vertices, body.velocity);
                }
                if (body.parts.length > 1) {
                  body.area = totalArea;
                  if (!body.isStatic) {
                    Body2.setMass(body, body.density * totalArea);
                    Body2.setInertia(body, totalInertia);
                  }
                }
                if (body.circleRadius) {
                  if (scaleX === scaleY) {
                    body.circleRadius *= scaleX;
                  } else {
                    body.circleRadius = null;
                  }
                }
              };
              Body2.update = function(body, deltaTime, timeScale, correction) {
                var deltaTimeSquared = Math.pow(deltaTime * timeScale * body.timeScale, 2);
                var frictionAir = 1 - body.frictionAir * timeScale * body.timeScale, velocityPrevX = body.position.x - body.positionPrev.x, velocityPrevY = body.position.y - body.positionPrev.y;
                body.velocity.x = velocityPrevX * frictionAir * correction + body.force.x / body.mass * deltaTimeSquared;
                body.velocity.y = velocityPrevY * frictionAir * correction + body.force.y / body.mass * deltaTimeSquared;
                body.positionPrev.x = body.position.x;
                body.positionPrev.y = body.position.y;
                body.position.x += body.velocity.x;
                body.position.y += body.velocity.y;
                body.angularVelocity = (body.angle - body.anglePrev) * frictionAir * correction + body.torque / body.inertia * deltaTimeSquared;
                body.anglePrev = body.angle;
                body.angle += body.angularVelocity;
                body.speed = Vector6.magnitude(body.velocity);
                body.angularSpeed = Math.abs(body.angularVelocity);
                for (var i = 0; i < body.parts.length; i++) {
                  var part = body.parts[i];
                  Vertices2.translate(part.vertices, body.velocity);
                  if (i > 0) {
                    part.position.x += body.velocity.x;
                    part.position.y += body.velocity.y;
                  }
                  if (body.angularVelocity !== 0) {
                    Vertices2.rotate(part.vertices, body.angularVelocity, body.position);
                    Axes.rotate(part.axes, body.angularVelocity);
                    if (i > 0) {
                      Vector6.rotateAbout(part.position, body.angularVelocity, body.position, part.position);
                    }
                  }
                  Bounds.update(part.bounds, part.vertices, body.velocity);
                }
              };
              Body2.applyForce = function(body, position, force) {
                body.force.x += force.x;
                body.force.y += force.y;
                var offset = { x: position.x - body.position.x, y: position.y - body.position.y };
                body.torque += offset.x * force.y - offset.y * force.x;
              };
              Body2._totalProperties = function(body) {
                var properties = {
                  mass: 0,
                  area: 0,
                  inertia: 0,
                  centre: { x: 0, y: 0 }
                };
                for (var i = body.parts.length === 1 ? 0 : 1; i < body.parts.length; i++) {
                  var part = body.parts[i], mass = part.mass !== Infinity ? part.mass : 1;
                  properties.mass += mass;
                  properties.area += part.area;
                  properties.inertia += part.inertia;
                  properties.centre = Vector6.add(properties.centre, Vector6.mult(part.position, mass));
                }
                properties.centre = Vector6.div(properties.centre, properties.mass);
                return properties;
              };
            })();
          },
          function(module2, exports2, __webpack_require__) {
            var Sleeping = {};
            module2.exports = Sleeping;
            var Events8 = __webpack_require__(4);
            (function() {
              Sleeping._motionWakeThreshold = 0.18;
              Sleeping._motionSleepThreshold = 0.08;
              Sleeping._minBias = 0.9;
              Sleeping.update = function(bodies, timeScale) {
                var timeFactor = timeScale * timeScale * timeScale;
                for (var i = 0; i < bodies.length; i++) {
                  var body = bodies[i], motion = body.speed * body.speed + body.angularSpeed * body.angularSpeed;
                  if (body.force.x !== 0 || body.force.y !== 0) {
                    Sleeping.set(body, false);
                    continue;
                  }
                  var minMotion = Math.min(body.motion, motion), maxMotion = Math.max(body.motion, motion);
                  body.motion = Sleeping._minBias * minMotion + (1 - Sleeping._minBias) * maxMotion;
                  if (body.sleepThreshold > 0 && body.motion < Sleeping._motionSleepThreshold * timeFactor) {
                    body.sleepCounter += 1;
                    if (body.sleepCounter >= body.sleepThreshold)
                      Sleeping.set(body, true);
                  } else if (body.sleepCounter > 0) {
                    body.sleepCounter -= 1;
                  }
                }
              };
              Sleeping.afterCollisions = function(pairs, timeScale) {
                var timeFactor = timeScale * timeScale * timeScale;
                for (var i = 0; i < pairs.length; i++) {
                  var pair = pairs[i];
                  if (!pair.isActive)
                    continue;
                  var collision = pair.collision, bodyA = collision.bodyA.parent, bodyB = collision.bodyB.parent;
                  if (bodyA.isSleeping && bodyB.isSleeping || bodyA.isStatic || bodyB.isStatic)
                    continue;
                  if (bodyA.isSleeping || bodyB.isSleeping) {
                    var sleepingBody = bodyA.isSleeping && !bodyA.isStatic ? bodyA : bodyB, movingBody = sleepingBody === bodyA ? bodyB : bodyA;
                    if (!sleepingBody.isStatic && movingBody.motion > Sleeping._motionWakeThreshold * timeFactor) {
                      Sleeping.set(sleepingBody, false);
                    }
                  }
                }
              };
              Sleeping.set = function(body, isSleeping) {
                var wasSleeping = body.isSleeping;
                if (isSleeping) {
                  body.isSleeping = true;
                  body.sleepCounter = body.sleepThreshold;
                  body.positionImpulse.x = 0;
                  body.positionImpulse.y = 0;
                  body.positionPrev.x = body.position.x;
                  body.positionPrev.y = body.position.y;
                  body.anglePrev = body.angle;
                  body.speed = 0;
                  body.angularSpeed = 0;
                  body.motion = 0;
                  if (!wasSleeping) {
                    Events8.trigger(body, "sleepStart");
                  }
                } else {
                  body.isSleeping = false;
                  body.sleepCounter = 0;
                  if (wasSleeping) {
                    Events8.trigger(body, "sleepEnd");
                  }
                }
              };
            })();
          },
          function(module2, exports2, __webpack_require__) {
            var Constraint = {};
            module2.exports = Constraint;
            var Vertices2 = __webpack_require__(3);
            var Vector6 = __webpack_require__(2);
            var Sleeping = __webpack_require__(7);
            var Bounds = __webpack_require__(1);
            var Axes = __webpack_require__(15);
            var Common = __webpack_require__(0);
            (function() {
              Constraint._warming = 0.4;
              Constraint._torqueDampen = 1;
              Constraint._minLength = 1e-6;
              Constraint.create = function(options) {
                var constraint = options;
                if (constraint.bodyA && !constraint.pointA)
                  constraint.pointA = { x: 0, y: 0 };
                if (constraint.bodyB && !constraint.pointB)
                  constraint.pointB = { x: 0, y: 0 };
                var initialPointA = constraint.bodyA ? Vector6.add(constraint.bodyA.position, constraint.pointA) : constraint.pointA, initialPointB = constraint.bodyB ? Vector6.add(constraint.bodyB.position, constraint.pointB) : constraint.pointB, length = Vector6.magnitude(Vector6.sub(initialPointA, initialPointB));
                constraint.length = typeof constraint.length !== "undefined" ? constraint.length : length;
                constraint.id = constraint.id || Common.nextId();
                constraint.label = constraint.label || "Constraint";
                constraint.type = "constraint";
                constraint.stiffness = constraint.stiffness || (constraint.length > 0 ? 1 : 0.7);
                constraint.damping = constraint.damping || 0;
                constraint.angularStiffness = constraint.angularStiffness || 0;
                constraint.angleA = constraint.bodyA ? constraint.bodyA.angle : constraint.angleA;
                constraint.angleB = constraint.bodyB ? constraint.bodyB.angle : constraint.angleB;
                constraint.plugin = {};
                var render = {
                  visible: true,
                  lineWidth: 2,
                  strokeStyle: "#ffffff",
                  type: "line",
                  anchors: true
                };
                if (constraint.length === 0 && constraint.stiffness > 0.1) {
                  render.type = "pin";
                  render.anchors = false;
                } else if (constraint.stiffness < 0.9) {
                  render.type = "spring";
                }
                constraint.render = Common.extend(render, constraint.render);
                return constraint;
              };
              Constraint.preSolveAll = function(bodies) {
                for (var i = 0; i < bodies.length; i += 1) {
                  var body = bodies[i], impulse = body.constraintImpulse;
                  if (body.isStatic || impulse.x === 0 && impulse.y === 0 && impulse.angle === 0) {
                    continue;
                  }
                  body.position.x += impulse.x;
                  body.position.y += impulse.y;
                  body.angle += impulse.angle;
                }
              };
              Constraint.solveAll = function(constraints, timeScale) {
                for (var i = 0; i < constraints.length; i += 1) {
                  var constraint = constraints[i], fixedA = !constraint.bodyA || constraint.bodyA && constraint.bodyA.isStatic, fixedB = !constraint.bodyB || constraint.bodyB && constraint.bodyB.isStatic;
                  if (fixedA || fixedB) {
                    Constraint.solve(constraints[i], timeScale);
                  }
                }
                for (i = 0; i < constraints.length; i += 1) {
                  constraint = constraints[i];
                  fixedA = !constraint.bodyA || constraint.bodyA && constraint.bodyA.isStatic;
                  fixedB = !constraint.bodyB || constraint.bodyB && constraint.bodyB.isStatic;
                  if (!fixedA && !fixedB) {
                    Constraint.solve(constraints[i], timeScale);
                  }
                }
              };
              Constraint.solve = function(constraint, timeScale) {
                var bodyA = constraint.bodyA, bodyB = constraint.bodyB, pointA = constraint.pointA, pointB = constraint.pointB;
                if (!bodyA && !bodyB)
                  return;
                if (bodyA && !bodyA.isStatic) {
                  Vector6.rotate(pointA, bodyA.angle - constraint.angleA, pointA);
                  constraint.angleA = bodyA.angle;
                }
                if (bodyB && !bodyB.isStatic) {
                  Vector6.rotate(pointB, bodyB.angle - constraint.angleB, pointB);
                  constraint.angleB = bodyB.angle;
                }
                var pointAWorld = pointA, pointBWorld = pointB;
                if (bodyA)
                  pointAWorld = Vector6.add(bodyA.position, pointA);
                if (bodyB)
                  pointBWorld = Vector6.add(bodyB.position, pointB);
                if (!pointAWorld || !pointBWorld)
                  return;
                var delta = Vector6.sub(pointAWorld, pointBWorld), currentLength = Vector6.magnitude(delta);
                if (currentLength < Constraint._minLength) {
                  currentLength = Constraint._minLength;
                }
                var difference = (currentLength - constraint.length) / currentLength, stiffness = constraint.stiffness < 1 ? constraint.stiffness * timeScale : constraint.stiffness, force = Vector6.mult(delta, difference * stiffness), massTotal = (bodyA ? bodyA.inverseMass : 0) + (bodyB ? bodyB.inverseMass : 0), inertiaTotal = (bodyA ? bodyA.inverseInertia : 0) + (bodyB ? bodyB.inverseInertia : 0), resistanceTotal = massTotal + inertiaTotal, torque, share, normal, normalVelocity, relativeVelocity;
                if (constraint.damping) {
                  var zero = Vector6.create();
                  normal = Vector6.div(delta, currentLength);
                  relativeVelocity = Vector6.sub(bodyB && Vector6.sub(bodyB.position, bodyB.positionPrev) || zero, bodyA && Vector6.sub(bodyA.position, bodyA.positionPrev) || zero);
                  normalVelocity = Vector6.dot(normal, relativeVelocity);
                }
                if (bodyA && !bodyA.isStatic) {
                  share = bodyA.inverseMass / massTotal;
                  bodyA.constraintImpulse.x -= force.x * share;
                  bodyA.constraintImpulse.y -= force.y * share;
                  bodyA.position.x -= force.x * share;
                  bodyA.position.y -= force.y * share;
                  if (constraint.damping) {
                    bodyA.positionPrev.x -= constraint.damping * normal.x * normalVelocity * share;
                    bodyA.positionPrev.y -= constraint.damping * normal.y * normalVelocity * share;
                  }
                  torque = Vector6.cross(pointA, force) / resistanceTotal * Constraint._torqueDampen * bodyA.inverseInertia * (1 - constraint.angularStiffness);
                  bodyA.constraintImpulse.angle -= torque;
                  bodyA.angle -= torque;
                }
                if (bodyB && !bodyB.isStatic) {
                  share = bodyB.inverseMass / massTotal;
                  bodyB.constraintImpulse.x += force.x * share;
                  bodyB.constraintImpulse.y += force.y * share;
                  bodyB.position.x += force.x * share;
                  bodyB.position.y += force.y * share;
                  if (constraint.damping) {
                    bodyB.positionPrev.x += constraint.damping * normal.x * normalVelocity * share;
                    bodyB.positionPrev.y += constraint.damping * normal.y * normalVelocity * share;
                  }
                  torque = Vector6.cross(pointB, force) / resistanceTotal * Constraint._torqueDampen * bodyB.inverseInertia * (1 - constraint.angularStiffness);
                  bodyB.constraintImpulse.angle += torque;
                  bodyB.angle += torque;
                }
              };
              Constraint.postSolveAll = function(bodies) {
                for (var i = 0; i < bodies.length; i++) {
                  var body = bodies[i], impulse = body.constraintImpulse;
                  if (body.isStatic || impulse.x === 0 && impulse.y === 0 && impulse.angle === 0) {
                    continue;
                  }
                  Sleeping.set(body, false);
                  for (var j = 0; j < body.parts.length; j++) {
                    var part = body.parts[j];
                    Vertices2.translate(part.vertices, impulse);
                    if (j > 0) {
                      part.position.x += impulse.x;
                      part.position.y += impulse.y;
                    }
                    if (impulse.angle !== 0) {
                      Vertices2.rotate(part.vertices, impulse.angle, body.position);
                      Axes.rotate(part.axes, impulse.angle);
                      if (j > 0) {
                        Vector6.rotateAbout(part.position, impulse.angle, body.position, part.position);
                      }
                    }
                    Bounds.update(part.bounds, part.vertices, body.velocity);
                  }
                  impulse.angle *= Constraint._warming;
                  impulse.x *= Constraint._warming;
                  impulse.y *= Constraint._warming;
                }
              };
              Constraint.pointAWorld = function(constraint) {
                return {
                  x: (constraint.bodyA ? constraint.bodyA.position.x : 0) + constraint.pointA.x,
                  y: (constraint.bodyA ? constraint.bodyA.position.y : 0) + constraint.pointA.y
                };
              };
              Constraint.pointBWorld = function(constraint) {
                return {
                  x: (constraint.bodyB ? constraint.bodyB.position.x : 0) + constraint.pointB.x,
                  y: (constraint.bodyB ? constraint.bodyB.position.y : 0) + constraint.pointB.y
                };
              };
            })();
          },
          function(module2, exports2, __webpack_require__) {
            var Pair = {};
            module2.exports = Pair;
            var Contact = __webpack_require__(18);
            (function() {
              Pair.create = function(collision, timestamp) {
                var bodyA = collision.bodyA, bodyB = collision.bodyB, parentA = collision.parentA, parentB = collision.parentB;
                var pair = {
                  id: Pair.id(bodyA, bodyB),
                  bodyA,
                  bodyB,
                  contacts: {},
                  activeContacts: [],
                  separation: 0,
                  isActive: true,
                  confirmedActive: true,
                  isSensor: bodyA.isSensor || bodyB.isSensor,
                  timeCreated: timestamp,
                  timeUpdated: timestamp,
                  inverseMass: parentA.inverseMass + parentB.inverseMass,
                  friction: Math.min(parentA.friction, parentB.friction),
                  frictionStatic: Math.max(parentA.frictionStatic, parentB.frictionStatic),
                  restitution: Math.max(parentA.restitution, parentB.restitution),
                  slop: Math.max(parentA.slop, parentB.slop)
                };
                Pair.update(pair, collision, timestamp);
                return pair;
              };
              Pair.update = function(pair, collision, timestamp) {
                var contacts = pair.contacts, supports = collision.supports, activeContacts = pair.activeContacts, parentA = collision.parentA, parentB = collision.parentB;
                pair.collision = collision;
                pair.inverseMass = parentA.inverseMass + parentB.inverseMass;
                pair.friction = Math.min(parentA.friction, parentB.friction);
                pair.frictionStatic = Math.max(parentA.frictionStatic, parentB.frictionStatic);
                pair.restitution = Math.max(parentA.restitution, parentB.restitution);
                pair.slop = Math.max(parentA.slop, parentB.slop);
                activeContacts.length = 0;
                if (collision.collided) {
                  for (var i = 0; i < supports.length; i++) {
                    var support = supports[i], contactId = Contact.id(support), contact = contacts[contactId];
                    if (contact) {
                      activeContacts.push(contact);
                    } else {
                      activeContacts.push(contacts[contactId] = Contact.create(support));
                    }
                  }
                  pair.separation = collision.depth;
                  Pair.setActive(pair, true, timestamp);
                } else {
                  if (pair.isActive === true)
                    Pair.setActive(pair, false, timestamp);
                }
              };
              Pair.setActive = function(pair, isActive, timestamp) {
                if (isActive) {
                  pair.isActive = true;
                  pair.timeUpdated = timestamp;
                } else {
                  pair.isActive = false;
                  pair.activeContacts.length = 0;
                }
              };
              Pair.id = function(bodyA, bodyB) {
                if (bodyA.id < bodyB.id) {
                  return "A" + bodyA.id + "B" + bodyB.id;
                } else {
                  return "A" + bodyB.id + "B" + bodyA.id;
                }
              };
            })();
          },
          function(module2, exports2, __webpack_require__) {
            var Render2 = {};
            module2.exports = Render2;
            var Common = __webpack_require__(0);
            var Composite2 = __webpack_require__(5);
            var Bounds = __webpack_require__(1);
            var Events8 = __webpack_require__(4);
            var Grid = __webpack_require__(11);
            var Vector6 = __webpack_require__(2);
            var Mouse = __webpack_require__(14);
            (function() {
              var _requestAnimationFrame, _cancelAnimationFrame;
              if (typeof window !== "undefined") {
                _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
                  window.setTimeout(function() {
                    callback(Common.now());
                  }, 1e3 / 60);
                };
                _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;
              }
              Render2.create = function(options) {
                var defaults = {
                  controller: Render2,
                  engine: null,
                  element: null,
                  canvas: null,
                  mouse: null,
                  frameRequestId: null,
                  options: {
                    width: 800,
                    height: 600,
                    pixelRatio: 1,
                    background: "#14151f",
                    wireframeBackground: "#14151f",
                    hasBounds: !!options.bounds,
                    enabled: true,
                    wireframes: true,
                    showSleeping: true,
                    showDebug: false,
                    showBroadphase: false,
                    showBounds: false,
                    showVelocity: false,
                    showCollisions: false,
                    showSeparations: false,
                    showAxes: false,
                    showPositions: false,
                    showAngleIndicator: false,
                    showIds: false,
                    showShadows: false,
                    showVertexNumbers: false,
                    showConvexHulls: false,
                    showInternalEdges: false,
                    showMousePosition: false
                  }
                };
                var render = Common.extend(defaults, options);
                if (render.canvas) {
                  render.canvas.width = render.options.width || render.canvas.width;
                  render.canvas.height = render.options.height || render.canvas.height;
                }
                render.mouse = options.mouse;
                render.engine = options.engine;
                render.canvas = render.canvas || _createCanvas(render.options.width, render.options.height);
                render.context = render.canvas.getContext("2d");
                render.textures = {};
                render.bounds = render.bounds || {
                  min: {
                    x: 0,
                    y: 0
                  },
                  max: {
                    x: render.canvas.width,
                    y: render.canvas.height
                  }
                };
                if (render.options.pixelRatio !== 1) {
                  Render2.setPixelRatio(render, render.options.pixelRatio);
                }
                if (Common.isElement(render.element)) {
                  render.element.appendChild(render.canvas);
                } else if (!render.canvas.parentNode) {
                  Common.log("Render.create: options.element was undefined, render.canvas was created but not appended", "warn");
                }
                return render;
              };
              Render2.run = function(render) {
                (function loop(time) {
                  render.frameRequestId = _requestAnimationFrame(loop);
                  Render2.world(render);
                })();
              };
              Render2.stop = function(render) {
                _cancelAnimationFrame(render.frameRequestId);
              };
              Render2.setPixelRatio = function(render, pixelRatio) {
                var options = render.options, canvas2 = render.canvas;
                if (pixelRatio === "auto") {
                  pixelRatio = _getPixelRatio(canvas2);
                }
                options.pixelRatio = pixelRatio;
                canvas2.setAttribute("data-pixel-ratio", pixelRatio);
                canvas2.width = options.width * pixelRatio;
                canvas2.height = options.height * pixelRatio;
                canvas2.style.width = options.width + "px";
                canvas2.style.height = options.height + "px";
              };
              Render2.lookAt = function(render, objects, padding, center) {
                center = typeof center !== "undefined" ? center : true;
                objects = Common.isArray(objects) ? objects : [objects];
                padding = padding || {
                  x: 0,
                  y: 0
                };
                var bounds = {
                  min: { x: Infinity, y: Infinity },
                  max: { x: -Infinity, y: -Infinity }
                };
                for (var i = 0; i < objects.length; i += 1) {
                  var object = objects[i], min = object.bounds ? object.bounds.min : object.min || object.position || object, max = object.bounds ? object.bounds.max : object.max || object.position || object;
                  if (min && max) {
                    if (min.x < bounds.min.x)
                      bounds.min.x = min.x;
                    if (max.x > bounds.max.x)
                      bounds.max.x = max.x;
                    if (min.y < bounds.min.y)
                      bounds.min.y = min.y;
                    if (max.y > bounds.max.y)
                      bounds.max.y = max.y;
                  }
                }
                var width = bounds.max.x - bounds.min.x + 2 * padding.x, height = bounds.max.y - bounds.min.y + 2 * padding.y, viewHeight = render.canvas.height, viewWidth = render.canvas.width, outerRatio = viewWidth / viewHeight, innerRatio = width / height, scaleX = 1, scaleY = 1;
                if (innerRatio > outerRatio) {
                  scaleY = innerRatio / outerRatio;
                } else {
                  scaleX = outerRatio / innerRatio;
                }
                render.options.hasBounds = true;
                render.bounds.min.x = bounds.min.x;
                render.bounds.max.x = bounds.min.x + width * scaleX;
                render.bounds.min.y = bounds.min.y;
                render.bounds.max.y = bounds.min.y + height * scaleY;
                if (center) {
                  render.bounds.min.x += width * 0.5 - width * scaleX * 0.5;
                  render.bounds.max.x += width * 0.5 - width * scaleX * 0.5;
                  render.bounds.min.y += height * 0.5 - height * scaleY * 0.5;
                  render.bounds.max.y += height * 0.5 - height * scaleY * 0.5;
                }
                render.bounds.min.x -= padding.x;
                render.bounds.max.x -= padding.x;
                render.bounds.min.y -= padding.y;
                render.bounds.max.y -= padding.y;
                if (render.mouse) {
                  Mouse.setScale(render.mouse, {
                    x: (render.bounds.max.x - render.bounds.min.x) / render.canvas.width,
                    y: (render.bounds.max.y - render.bounds.min.y) / render.canvas.height
                  });
                  Mouse.setOffset(render.mouse, render.bounds.min);
                }
              };
              Render2.startViewTransform = function(render) {
                var boundsWidth = render.bounds.max.x - render.bounds.min.x, boundsHeight = render.bounds.max.y - render.bounds.min.y, boundsScaleX = boundsWidth / render.options.width, boundsScaleY = boundsHeight / render.options.height;
                render.context.setTransform(render.options.pixelRatio / boundsScaleX, 0, 0, render.options.pixelRatio / boundsScaleY, 0, 0);
                render.context.translate(-render.bounds.min.x, -render.bounds.min.y);
              };
              Render2.endViewTransform = function(render) {
                render.context.setTransform(render.options.pixelRatio, 0, 0, render.options.pixelRatio, 0, 0);
              };
              Render2.world = function(render) {
                var engine = render.engine, world = engine.world, canvas2 = render.canvas, context = render.context, options = render.options, allBodies = Composite2.allBodies(world), allConstraints = Composite2.allConstraints(world), background = options.wireframes ? options.wireframeBackground : options.background, bodies = [], constraints = [], i;
                var event = {
                  timestamp: engine.timing.timestamp
                };
                Events8.trigger(render, "beforeRender", event);
                if (render.currentBackground !== background)
                  _applyBackground(render, background);
                context.globalCompositeOperation = "source-in";
                context.fillStyle = "transparent";
                context.fillRect(0, 0, canvas2.width, canvas2.height);
                context.globalCompositeOperation = "source-over";
                if (options.hasBounds) {
                  for (i = 0; i < allBodies.length; i++) {
                    var body = allBodies[i];
                    if (Bounds.overlaps(body.bounds, render.bounds))
                      bodies.push(body);
                  }
                  for (i = 0; i < allConstraints.length; i++) {
                    var constraint = allConstraints[i], bodyA = constraint.bodyA, bodyB = constraint.bodyB, pointAWorld = constraint.pointA, pointBWorld = constraint.pointB;
                    if (bodyA)
                      pointAWorld = Vector6.add(bodyA.position, constraint.pointA);
                    if (bodyB)
                      pointBWorld = Vector6.add(bodyB.position, constraint.pointB);
                    if (!pointAWorld || !pointBWorld)
                      continue;
                    if (Bounds.contains(render.bounds, pointAWorld) || Bounds.contains(render.bounds, pointBWorld))
                      constraints.push(constraint);
                  }
                  Render2.startViewTransform(render);
                  if (render.mouse) {
                    Mouse.setScale(render.mouse, {
                      x: (render.bounds.max.x - render.bounds.min.x) / render.options.width,
                      y: (render.bounds.max.y - render.bounds.min.y) / render.options.height
                    });
                    Mouse.setOffset(render.mouse, render.bounds.min);
                  }
                } else {
                  constraints = allConstraints;
                  bodies = allBodies;
                  if (render.options.pixelRatio !== 1) {
                    render.context.setTransform(render.options.pixelRatio, 0, 0, render.options.pixelRatio, 0, 0);
                  }
                }
                if (!options.wireframes || engine.enableSleeping && options.showSleeping) {
                  Render2.bodies(render, bodies, context);
                } else {
                  if (options.showConvexHulls)
                    Render2.bodyConvexHulls(render, bodies, context);
                  Render2.bodyWireframes(render, bodies, context);
                }
                if (options.showBounds)
                  Render2.bodyBounds(render, bodies, context);
                if (options.showAxes || options.showAngleIndicator)
                  Render2.bodyAxes(render, bodies, context);
                if (options.showPositions)
                  Render2.bodyPositions(render, bodies, context);
                if (options.showVelocity)
                  Render2.bodyVelocity(render, bodies, context);
                if (options.showIds)
                  Render2.bodyIds(render, bodies, context);
                if (options.showSeparations)
                  Render2.separations(render, engine.pairs.list, context);
                if (options.showCollisions)
                  Render2.collisions(render, engine.pairs.list, context);
                if (options.showVertexNumbers)
                  Render2.vertexNumbers(render, bodies, context);
                if (options.showMousePosition)
                  Render2.mousePosition(render, render.mouse, context);
                Render2.constraints(constraints, context);
                if (options.showBroadphase && engine.broadphase.controller === Grid)
                  Render2.grid(render, engine.broadphase, context);
                if (options.showDebug)
                  Render2.debug(render, context);
                if (options.hasBounds) {
                  Render2.endViewTransform(render);
                }
                Events8.trigger(render, "afterRender", event);
              };
              Render2.debug = function(render, context) {
                var c = context, engine = render.engine, world = engine.world, metrics = engine.metrics, options = render.options, bodies = Composite2.allBodies(world), space = "    ";
                if (engine.timing.timestamp - (render.debugTimestamp || 0) >= 500) {
                  var text = "";
                  if (metrics.timing) {
                    text += "fps: " + Math.round(metrics.timing.fps) + space;
                  }
                  if (metrics.extended) {
                    if (metrics.timing) {
                      text += "delta: " + metrics.timing.delta.toFixed(3) + space;
                      text += "correction: " + metrics.timing.correction.toFixed(3) + space;
                    }
                    text += "bodies: " + bodies.length + space;
                    if (engine.broadphase.controller === Grid)
                      text += "buckets: " + metrics.buckets + space;
                    text += "\n";
                    text += "collisions: " + metrics.collisions + space;
                    text += "pairs: " + engine.pairs.list.length + space;
                    text += "broad: " + metrics.broadEff + space;
                    text += "mid: " + metrics.midEff + space;
                    text += "narrow: " + metrics.narrowEff + space;
                  }
                  render.debugString = text;
                  render.debugTimestamp = engine.timing.timestamp;
                }
                if (render.debugString) {
                  c.font = "12px Arial";
                  if (options.wireframes) {
                    c.fillStyle = "rgba(255,255,255,0.5)";
                  } else {
                    c.fillStyle = "rgba(0,0,0,0.5)";
                  }
                  var split = render.debugString.split("\n");
                  for (var i = 0; i < split.length; i++) {
                    c.fillText(split[i], 50, 50 + i * 18);
                  }
                }
              };
              Render2.constraints = function(constraints, context) {
                var c = context;
                for (var i = 0; i < constraints.length; i++) {
                  var constraint = constraints[i];
                  if (!constraint.render.visible || !constraint.pointA || !constraint.pointB)
                    continue;
                  var bodyA = constraint.bodyA, bodyB = constraint.bodyB, start, end;
                  if (bodyA) {
                    start = Vector6.add(bodyA.position, constraint.pointA);
                  } else {
                    start = constraint.pointA;
                  }
                  if (constraint.render.type === "pin") {
                    c.beginPath();
                    c.arc(start.x, start.y, 3, 0, 2 * Math.PI);
                    c.closePath();
                  } else {
                    if (bodyB) {
                      end = Vector6.add(bodyB.position, constraint.pointB);
                    } else {
                      end = constraint.pointB;
                    }
                    c.beginPath();
                    c.moveTo(start.x, start.y);
                    if (constraint.render.type === "spring") {
                      var delta = Vector6.sub(end, start), normal = Vector6.perp(Vector6.normalise(delta)), coils = Math.ceil(Common.clamp(constraint.length / 5, 12, 20)), offset;
                      for (var j = 1; j < coils; j += 1) {
                        offset = j % 2 === 0 ? 1 : -1;
                        c.lineTo(start.x + delta.x * (j / coils) + normal.x * offset * 4, start.y + delta.y * (j / coils) + normal.y * offset * 4);
                      }
                    }
                    c.lineTo(end.x, end.y);
                  }
                  if (constraint.render.lineWidth) {
                    c.lineWidth = constraint.render.lineWidth;
                    c.strokeStyle = constraint.render.strokeStyle;
                    c.stroke();
                  }
                  if (constraint.render.anchors) {
                    c.fillStyle = constraint.render.strokeStyle;
                    c.beginPath();
                    c.arc(start.x, start.y, 3, 0, 2 * Math.PI);
                    c.arc(end.x, end.y, 3, 0, 2 * Math.PI);
                    c.closePath();
                    c.fill();
                  }
                }
              };
              Render2.bodyShadows = function(render, bodies, context) {
                var c = context, engine = render.engine;
                for (var i = 0; i < bodies.length; i++) {
                  var body = bodies[i];
                  if (!body.render.visible)
                    continue;
                  if (body.circleRadius) {
                    c.beginPath();
                    c.arc(body.position.x, body.position.y, body.circleRadius, 0, 2 * Math.PI);
                    c.closePath();
                  } else {
                    c.beginPath();
                    c.moveTo(body.vertices[0].x, body.vertices[0].y);
                    for (var j = 1; j < body.vertices.length; j++) {
                      c.lineTo(body.vertices[j].x, body.vertices[j].y);
                    }
                    c.closePath();
                  }
                  var distanceX = body.position.x - render.options.width * 0.5, distanceY = body.position.y - render.options.height * 0.2, distance = Math.abs(distanceX) + Math.abs(distanceY);
                  c.shadowColor = "rgba(0,0,0,0.15)";
                  c.shadowOffsetX = 0.05 * distanceX;
                  c.shadowOffsetY = 0.05 * distanceY;
                  c.shadowBlur = 1 + 12 * Math.min(1, distance / 1e3);
                  c.fill();
                  c.shadowColor = null;
                  c.shadowOffsetX = null;
                  c.shadowOffsetY = null;
                  c.shadowBlur = null;
                }
              };
              Render2.bodies = function(render, bodies, context) {
                var c = context, engine = render.engine, options = render.options, showInternalEdges = options.showInternalEdges || !options.wireframes, body, part, i, k;
                for (i = 0; i < bodies.length; i++) {
                  body = bodies[i];
                  if (!body.render.visible)
                    continue;
                  for (k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {
                    part = body.parts[k];
                    if (!part.render.visible)
                      continue;
                    if (options.showSleeping && body.isSleeping) {
                      c.globalAlpha = 0.5 * part.render.opacity;
                    } else if (part.render.opacity !== 1) {
                      c.globalAlpha = part.render.opacity;
                    }
                    if (part.render.sprite && part.render.sprite.texture && !options.wireframes) {
                      var sprite = part.render.sprite, texture = _getTexture(render, sprite.texture);
                      c.translate(part.position.x, part.position.y);
                      c.rotate(part.angle);
                      c.drawImage(texture, texture.width * -sprite.xOffset * sprite.xScale, texture.height * -sprite.yOffset * sprite.yScale, texture.width * sprite.xScale, texture.height * sprite.yScale);
                      c.rotate(-part.angle);
                      c.translate(-part.position.x, -part.position.y);
                    } else {
                      if (part.circleRadius) {
                        c.beginPath();
                        c.arc(part.position.x, part.position.y, part.circleRadius, 0, 2 * Math.PI);
                      } else {
                        c.beginPath();
                        c.moveTo(part.vertices[0].x, part.vertices[0].y);
                        for (var j = 1; j < part.vertices.length; j++) {
                          if (!part.vertices[j - 1].isInternal || showInternalEdges) {
                            c.lineTo(part.vertices[j].x, part.vertices[j].y);
                          } else {
                            c.moveTo(part.vertices[j].x, part.vertices[j].y);
                          }
                          if (part.vertices[j].isInternal && !showInternalEdges) {
                            c.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);
                          }
                        }
                        c.lineTo(part.vertices[0].x, part.vertices[0].y);
                        c.closePath();
                      }
                      if (!options.wireframes) {
                        c.fillStyle = part.render.fillStyle;
                        if (part.render.lineWidth) {
                          c.lineWidth = part.render.lineWidth;
                          c.strokeStyle = part.render.strokeStyle;
                          c.stroke();
                        }
                        c.fill();
                      } else {
                        c.lineWidth = 1;
                        c.strokeStyle = "#bbb";
                        c.stroke();
                      }
                    }
                    c.globalAlpha = 1;
                  }
                }
              };
              Render2.bodyWireframes = function(render, bodies, context) {
                var c = context, showInternalEdges = render.options.showInternalEdges, body, part, i, j, k;
                c.beginPath();
                for (i = 0; i < bodies.length; i++) {
                  body = bodies[i];
                  if (!body.render.visible)
                    continue;
                  for (k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {
                    part = body.parts[k];
                    c.moveTo(part.vertices[0].x, part.vertices[0].y);
                    for (j = 1; j < part.vertices.length; j++) {
                      if (!part.vertices[j - 1].isInternal || showInternalEdges) {
                        c.lineTo(part.vertices[j].x, part.vertices[j].y);
                      } else {
                        c.moveTo(part.vertices[j].x, part.vertices[j].y);
                      }
                      if (part.vertices[j].isInternal && !showInternalEdges) {
                        c.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);
                      }
                    }
                    c.lineTo(part.vertices[0].x, part.vertices[0].y);
                  }
                }
                c.lineWidth = 1;
                c.strokeStyle = "#bbb";
                c.stroke();
              };
              Render2.bodyConvexHulls = function(render, bodies, context) {
                var c = context, body, part, i, j, k;
                c.beginPath();
                for (i = 0; i < bodies.length; i++) {
                  body = bodies[i];
                  if (!body.render.visible || body.parts.length === 1)
                    continue;
                  c.moveTo(body.vertices[0].x, body.vertices[0].y);
                  for (j = 1; j < body.vertices.length; j++) {
                    c.lineTo(body.vertices[j].x, body.vertices[j].y);
                  }
                  c.lineTo(body.vertices[0].x, body.vertices[0].y);
                }
                c.lineWidth = 1;
                c.strokeStyle = "rgba(255,255,255,0.2)";
                c.stroke();
              };
              Render2.vertexNumbers = function(render, bodies, context) {
                var c = context, i, j, k;
                for (i = 0; i < bodies.length; i++) {
                  var parts = bodies[i].parts;
                  for (k = parts.length > 1 ? 1 : 0; k < parts.length; k++) {
                    var part = parts[k];
                    for (j = 0; j < part.vertices.length; j++) {
                      c.fillStyle = "rgba(255,255,255,0.2)";
                      c.fillText(i + "_" + j, part.position.x + (part.vertices[j].x - part.position.x) * 0.8, part.position.y + (part.vertices[j].y - part.position.y) * 0.8);
                    }
                  }
                }
              };
              Render2.mousePosition = function(render, mouse2, context) {
                var c = context;
                c.fillStyle = "rgba(255,255,255,0.8)";
                c.fillText(mouse2.position.x + "  " + mouse2.position.y, mouse2.position.x + 5, mouse2.position.y - 5);
              };
              Render2.bodyBounds = function(render, bodies, context) {
                var c = context, engine = render.engine, options = render.options;
                c.beginPath();
                for (var i = 0; i < bodies.length; i++) {
                  var body = bodies[i];
                  if (body.render.visible) {
                    var parts = bodies[i].parts;
                    for (var j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                      var part = parts[j];
                      c.rect(part.bounds.min.x, part.bounds.min.y, part.bounds.max.x - part.bounds.min.x, part.bounds.max.y - part.bounds.min.y);
                    }
                  }
                }
                if (options.wireframes) {
                  c.strokeStyle = "rgba(255,255,255,0.08)";
                } else {
                  c.strokeStyle = "rgba(0,0,0,0.1)";
                }
                c.lineWidth = 1;
                c.stroke();
              };
              Render2.bodyAxes = function(render, bodies, context) {
                var c = context, engine = render.engine, options = render.options, part, i, j, k;
                c.beginPath();
                for (i = 0; i < bodies.length; i++) {
                  var body = bodies[i], parts = body.parts;
                  if (!body.render.visible)
                    continue;
                  if (options.showAxes) {
                    for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                      part = parts[j];
                      for (k = 0; k < part.axes.length; k++) {
                        var axis = part.axes[k];
                        c.moveTo(part.position.x, part.position.y);
                        c.lineTo(part.position.x + axis.x * 20, part.position.y + axis.y * 20);
                      }
                    }
                  } else {
                    for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                      part = parts[j];
                      for (k = 0; k < part.axes.length; k++) {
                        c.moveTo(part.position.x, part.position.y);
                        c.lineTo((part.vertices[0].x + part.vertices[part.vertices.length - 1].x) / 2, (part.vertices[0].y + part.vertices[part.vertices.length - 1].y) / 2);
                      }
                    }
                  }
                }
                if (options.wireframes) {
                  c.strokeStyle = "indianred";
                  c.lineWidth = 1;
                } else {
                  c.strokeStyle = "rgba(255, 255, 255, 0.4)";
                  c.globalCompositeOperation = "overlay";
                  c.lineWidth = 2;
                }
                c.stroke();
                c.globalCompositeOperation = "source-over";
              };
              Render2.bodyPositions = function(render, bodies, context) {
                var c = context, engine = render.engine, options = render.options, body, part, i, k;
                c.beginPath();
                for (i = 0; i < bodies.length; i++) {
                  body = bodies[i];
                  if (!body.render.visible)
                    continue;
                  for (k = 0; k < body.parts.length; k++) {
                    part = body.parts[k];
                    c.arc(part.position.x, part.position.y, 3, 0, 2 * Math.PI, false);
                    c.closePath();
                  }
                }
                if (options.wireframes) {
                  c.fillStyle = "indianred";
                } else {
                  c.fillStyle = "rgba(0,0,0,0.5)";
                }
                c.fill();
                c.beginPath();
                for (i = 0; i < bodies.length; i++) {
                  body = bodies[i];
                  if (body.render.visible) {
                    c.arc(body.positionPrev.x, body.positionPrev.y, 2, 0, 2 * Math.PI, false);
                    c.closePath();
                  }
                }
                c.fillStyle = "rgba(255,165,0,0.8)";
                c.fill();
              };
              Render2.bodyVelocity = function(render, bodies, context) {
                var c = context;
                c.beginPath();
                for (var i = 0; i < bodies.length; i++) {
                  var body = bodies[i];
                  if (!body.render.visible)
                    continue;
                  c.moveTo(body.position.x, body.position.y);
                  c.lineTo(body.position.x + (body.position.x - body.positionPrev.x) * 2, body.position.y + (body.position.y - body.positionPrev.y) * 2);
                }
                c.lineWidth = 3;
                c.strokeStyle = "cornflowerblue";
                c.stroke();
              };
              Render2.bodyIds = function(render, bodies, context) {
                var c = context, i, j;
                for (i = 0; i < bodies.length; i++) {
                  if (!bodies[i].render.visible)
                    continue;
                  var parts = bodies[i].parts;
                  for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {
                    var part = parts[j];
                    c.font = "12px Arial";
                    c.fillStyle = "rgba(255,255,255,0.5)";
                    c.fillText(part.id, part.position.x + 10, part.position.y - 10);
                  }
                }
              };
              Render2.collisions = function(render, pairs, context) {
                var c = context, options = render.options, pair, collision, corrected, bodyA, bodyB, i, j;
                c.beginPath();
                for (i = 0; i < pairs.length; i++) {
                  pair = pairs[i];
                  if (!pair.isActive)
                    continue;
                  collision = pair.collision;
                  for (j = 0; j < pair.activeContacts.length; j++) {
                    var contact = pair.activeContacts[j], vertex = contact.vertex;
                    c.rect(vertex.x - 1.5, vertex.y - 1.5, 3.5, 3.5);
                  }
                }
                if (options.wireframes) {
                  c.fillStyle = "rgba(255,255,255,0.7)";
                } else {
                  c.fillStyle = "orange";
                }
                c.fill();
                c.beginPath();
                for (i = 0; i < pairs.length; i++) {
                  pair = pairs[i];
                  if (!pair.isActive)
                    continue;
                  collision = pair.collision;
                  if (pair.activeContacts.length > 0) {
                    var normalPosX = pair.activeContacts[0].vertex.x, normalPosY = pair.activeContacts[0].vertex.y;
                    if (pair.activeContacts.length === 2) {
                      normalPosX = (pair.activeContacts[0].vertex.x + pair.activeContacts[1].vertex.x) / 2;
                      normalPosY = (pair.activeContacts[0].vertex.y + pair.activeContacts[1].vertex.y) / 2;
                    }
                    if (collision.bodyB === collision.supports[0].body || collision.bodyA.isStatic === true) {
                      c.moveTo(normalPosX - collision.normal.x * 8, normalPosY - collision.normal.y * 8);
                    } else {
                      c.moveTo(normalPosX + collision.normal.x * 8, normalPosY + collision.normal.y * 8);
                    }
                    c.lineTo(normalPosX, normalPosY);
                  }
                }
                if (options.wireframes) {
                  c.strokeStyle = "rgba(255,165,0,0.7)";
                } else {
                  c.strokeStyle = "orange";
                }
                c.lineWidth = 1;
                c.stroke();
              };
              Render2.separations = function(render, pairs, context) {
                var c = context, options = render.options, pair, collision, corrected, bodyA, bodyB, i, j;
                c.beginPath();
                for (i = 0; i < pairs.length; i++) {
                  pair = pairs[i];
                  if (!pair.isActive)
                    continue;
                  collision = pair.collision;
                  bodyA = collision.bodyA;
                  bodyB = collision.bodyB;
                  var k = 1;
                  if (!bodyB.isStatic && !bodyA.isStatic)
                    k = 0.5;
                  if (bodyB.isStatic)
                    k = 0;
                  c.moveTo(bodyB.position.x, bodyB.position.y);
                  c.lineTo(bodyB.position.x - collision.penetration.x * k, bodyB.position.y - collision.penetration.y * k);
                  k = 1;
                  if (!bodyB.isStatic && !bodyA.isStatic)
                    k = 0.5;
                  if (bodyA.isStatic)
                    k = 0;
                  c.moveTo(bodyA.position.x, bodyA.position.y);
                  c.lineTo(bodyA.position.x + collision.penetration.x * k, bodyA.position.y + collision.penetration.y * k);
                }
                if (options.wireframes) {
                  c.strokeStyle = "rgba(255,165,0,0.5)";
                } else {
                  c.strokeStyle = "orange";
                }
                c.stroke();
              };
              Render2.grid = function(render, grid, context) {
                var c = context, options = render.options;
                if (options.wireframes) {
                  c.strokeStyle = "rgba(255,180,0,0.1)";
                } else {
                  c.strokeStyle = "rgba(255,180,0,0.5)";
                }
                c.beginPath();
                var bucketKeys = Common.keys(grid.buckets);
                for (var i = 0; i < bucketKeys.length; i++) {
                  var bucketId = bucketKeys[i];
                  if (grid.buckets[bucketId].length < 2)
                    continue;
                  var region = bucketId.split(/C|R/);
                  c.rect(0.5 + parseInt(region[1], 10) * grid.bucketWidth, 0.5 + parseInt(region[2], 10) * grid.bucketHeight, grid.bucketWidth, grid.bucketHeight);
                }
                c.lineWidth = 1;
                c.stroke();
              };
              Render2.inspector = function(inspector, context) {
                var engine = inspector.engine, selected = inspector.selected, render = inspector.render, options = render.options, bounds;
                if (options.hasBounds) {
                  var boundsWidth = render.bounds.max.x - render.bounds.min.x, boundsHeight = render.bounds.max.y - render.bounds.min.y, boundsScaleX = boundsWidth / render.options.width, boundsScaleY = boundsHeight / render.options.height;
                  context.scale(1 / boundsScaleX, 1 / boundsScaleY);
                  context.translate(-render.bounds.min.x, -render.bounds.min.y);
                }
                for (var i = 0; i < selected.length; i++) {
                  var item = selected[i].data;
                  context.translate(0.5, 0.5);
                  context.lineWidth = 1;
                  context.strokeStyle = "rgba(255,165,0,0.9)";
                  context.setLineDash([1, 2]);
                  switch (item.type) {
                    case "body":
                      bounds = item.bounds;
                      context.beginPath();
                      context.rect(Math.floor(bounds.min.x - 3), Math.floor(bounds.min.y - 3), Math.floor(bounds.max.x - bounds.min.x + 6), Math.floor(bounds.max.y - bounds.min.y + 6));
                      context.closePath();
                      context.stroke();
                      break;
                    case "constraint":
                      var point = item.pointA;
                      if (item.bodyA)
                        point = item.pointB;
                      context.beginPath();
                      context.arc(point.x, point.y, 10, 0, 2 * Math.PI);
                      context.closePath();
                      context.stroke();
                      break;
                  }
                  context.setLineDash([]);
                  context.translate(-0.5, -0.5);
                }
                if (inspector.selectStart !== null) {
                  context.translate(0.5, 0.5);
                  context.lineWidth = 1;
                  context.strokeStyle = "rgba(255,165,0,0.6)";
                  context.fillStyle = "rgba(255,165,0,0.1)";
                  bounds = inspector.selectBounds;
                  context.beginPath();
                  context.rect(Math.floor(bounds.min.x), Math.floor(bounds.min.y), Math.floor(bounds.max.x - bounds.min.x), Math.floor(bounds.max.y - bounds.min.y));
                  context.closePath();
                  context.stroke();
                  context.fill();
                  context.translate(-0.5, -0.5);
                }
                if (options.hasBounds)
                  context.setTransform(1, 0, 0, 1, 0, 0);
              };
              var _createCanvas = function(width, height) {
                var canvas2 = document.createElement("canvas");
                canvas2.width = width;
                canvas2.height = height;
                canvas2.oncontextmenu = function() {
                  return false;
                };
                canvas2.onselectstart = function() {
                  return false;
                };
                return canvas2;
              };
              var _getPixelRatio = function(canvas2) {
                var context = canvas2.getContext("2d"), devicePixelRatio = window.devicePixelRatio || 1, backingStorePixelRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
                return devicePixelRatio / backingStorePixelRatio;
              };
              var _getTexture = function(render, imagePath) {
                var image = render.textures[imagePath];
                if (image)
                  return image;
                image = render.textures[imagePath] = new Image();
                image.src = imagePath;
                return image;
              };
              var _applyBackground = function(render, background) {
                var cssBackground = background;
                if (/(jpg|gif|png)$/.test(background))
                  cssBackground = "url(" + background + ")";
                render.canvas.style.background = cssBackground;
                render.canvas.style.backgroundSize = "contain";
                render.currentBackground = background;
              };
            })();
          },
          function(module2, exports2, __webpack_require__) {
            var Grid = {};
            module2.exports = Grid;
            var Pair = __webpack_require__(9);
            var Detector = __webpack_require__(12);
            var Common = __webpack_require__(0);
            (function() {
              Grid.create = function(options) {
                var defaults = {
                  controller: Grid,
                  detector: Detector.collisions,
                  buckets: {},
                  pairs: {},
                  pairsList: [],
                  bucketWidth: 48,
                  bucketHeight: 48
                };
                return Common.extend(defaults, options);
              };
              Grid.update = function(grid, bodies, engine, forceUpdate) {
                var i, col, row, world = engine.world, buckets = grid.buckets, bucket, bucketId, gridChanged = false;
                var metrics = engine.metrics;
                metrics.broadphaseTests = 0;
                for (i = 0; i < bodies.length; i++) {
                  var body = bodies[i];
                  if (body.isSleeping && !forceUpdate)
                    continue;
                  if (body.bounds.max.x < world.bounds.min.x || body.bounds.min.x > world.bounds.max.x || body.bounds.max.y < world.bounds.min.y || body.bounds.min.y > world.bounds.max.y)
                    continue;
                  var newRegion = Grid._getRegion(grid, body);
                  if (!body.region || newRegion.id !== body.region.id || forceUpdate) {
                    metrics.broadphaseTests += 1;
                    if (!body.region || forceUpdate)
                      body.region = newRegion;
                    var union = Grid._regionUnion(newRegion, body.region);
                    for (col = union.startCol; col <= union.endCol; col++) {
                      for (row = union.startRow; row <= union.endRow; row++) {
                        bucketId = Grid._getBucketId(col, row);
                        bucket = buckets[bucketId];
                        var isInsideNewRegion = col >= newRegion.startCol && col <= newRegion.endCol && row >= newRegion.startRow && row <= newRegion.endRow;
                        var isInsideOldRegion = col >= body.region.startCol && col <= body.region.endCol && row >= body.region.startRow && row <= body.region.endRow;
                        if (!isInsideNewRegion && isInsideOldRegion) {
                          if (isInsideOldRegion) {
                            if (bucket)
                              Grid._bucketRemoveBody(grid, bucket, body);
                          }
                        }
                        if (body.region === newRegion || isInsideNewRegion && !isInsideOldRegion || forceUpdate) {
                          if (!bucket)
                            bucket = Grid._createBucket(buckets, bucketId);
                          Grid._bucketAddBody(grid, bucket, body);
                        }
                      }
                    }
                    body.region = newRegion;
                    gridChanged = true;
                  }
                }
                if (gridChanged)
                  grid.pairsList = Grid._createActivePairsList(grid);
              };
              Grid.clear = function(grid) {
                grid.buckets = {};
                grid.pairs = {};
                grid.pairsList = [];
              };
              Grid._regionUnion = function(regionA, regionB) {
                var startCol = Math.min(regionA.startCol, regionB.startCol), endCol = Math.max(regionA.endCol, regionB.endCol), startRow = Math.min(regionA.startRow, regionB.startRow), endRow = Math.max(regionA.endRow, regionB.endRow);
                return Grid._createRegion(startCol, endCol, startRow, endRow);
              };
              Grid._getRegion = function(grid, body) {
                var bounds = body.bounds, startCol = Math.floor(bounds.min.x / grid.bucketWidth), endCol = Math.floor(bounds.max.x / grid.bucketWidth), startRow = Math.floor(bounds.min.y / grid.bucketHeight), endRow = Math.floor(bounds.max.y / grid.bucketHeight);
                return Grid._createRegion(startCol, endCol, startRow, endRow);
              };
              Grid._createRegion = function(startCol, endCol, startRow, endRow) {
                return {
                  id: startCol + "," + endCol + "," + startRow + "," + endRow,
                  startCol,
                  endCol,
                  startRow,
                  endRow
                };
              };
              Grid._getBucketId = function(column, row) {
                return "C" + column + "R" + row;
              };
              Grid._createBucket = function(buckets, bucketId) {
                var bucket = buckets[bucketId] = [];
                return bucket;
              };
              Grid._bucketAddBody = function(grid, bucket, body) {
                for (var i = 0; i < bucket.length; i++) {
                  var bodyB = bucket[i];
                  if (body.id === bodyB.id || body.isStatic && bodyB.isStatic)
                    continue;
                  var pairId = Pair.id(body, bodyB), pair = grid.pairs[pairId];
                  if (pair) {
                    pair[2] += 1;
                  } else {
                    grid.pairs[pairId] = [body, bodyB, 1];
                  }
                }
                bucket.push(body);
              };
              Grid._bucketRemoveBody = function(grid, bucket, body) {
                bucket.splice(Common.indexOf(bucket, body), 1);
                for (var i = 0; i < bucket.length; i++) {
                  var bodyB = bucket[i], pairId = Pair.id(body, bodyB), pair = grid.pairs[pairId];
                  if (pair)
                    pair[2] -= 1;
                }
              };
              Grid._createActivePairsList = function(grid) {
                var pairKeys, pair, pairs = [];
                pairKeys = Common.keys(grid.pairs);
                for (var k = 0; k < pairKeys.length; k++) {
                  pair = grid.pairs[pairKeys[k]];
                  if (pair[2] > 0) {
                    pairs.push(pair);
                  } else {
                    delete grid.pairs[pairKeys[k]];
                  }
                }
                return pairs;
              };
            })();
          },
          function(module2, exports2, __webpack_require__) {
            var Detector = {};
            module2.exports = Detector;
            var SAT = __webpack_require__(13);
            var Pair = __webpack_require__(9);
            var Bounds = __webpack_require__(1);
            (function() {
              Detector.collisions = function(broadphasePairs, engine) {
                var collisions = [], pairsTable = engine.pairs.table;
                var metrics = engine.metrics;
                for (var i = 0; i < broadphasePairs.length; i++) {
                  var bodyA = broadphasePairs[i][0], bodyB = broadphasePairs[i][1];
                  if ((bodyA.isStatic || bodyA.isSleeping) && (bodyB.isStatic || bodyB.isSleeping))
                    continue;
                  if (!Detector.canCollide(bodyA.collisionFilter, bodyB.collisionFilter))
                    continue;
                  metrics.midphaseTests += 1;
                  if (Bounds.overlaps(bodyA.bounds, bodyB.bounds)) {
                    for (var j = bodyA.parts.length > 1 ? 1 : 0; j < bodyA.parts.length; j++) {
                      var partA = bodyA.parts[j];
                      for (var k = bodyB.parts.length > 1 ? 1 : 0; k < bodyB.parts.length; k++) {
                        var partB = bodyB.parts[k];
                        if (partA === bodyA && partB === bodyB || Bounds.overlaps(partA.bounds, partB.bounds)) {
                          var pairId = Pair.id(partA, partB), pair = pairsTable[pairId], previousCollision;
                          if (pair && pair.isActive) {
                            previousCollision = pair.collision;
                          } else {
                            previousCollision = null;
                          }
                          var collision = SAT.collides(partA, partB, previousCollision);
                          metrics.narrowphaseTests += 1;
                          if (collision.reused)
                            metrics.narrowReuseCount += 1;
                          if (collision.collided) {
                            collisions.push(collision);
                            metrics.narrowDetections += 1;
                          }
                        }
                      }
                    }
                  }
                }
                return collisions;
              };
              Detector.canCollide = function(filterA, filterB) {
                if (filterA.group === filterB.group && filterA.group !== 0)
                  return filterA.group > 0;
                return (filterA.mask & filterB.category) !== 0 && (filterB.mask & filterA.category) !== 0;
              };
            })();
          },
          function(module2, exports2, __webpack_require__) {
            var SAT = {};
            module2.exports = SAT;
            var Vertices2 = __webpack_require__(3);
            var Vector6 = __webpack_require__(2);
            (function() {
              SAT.collides = function(bodyA, bodyB, previousCollision) {
                var overlapAB, overlapBA, minOverlap, collision, canReusePrevCol = false;
                if (previousCollision) {
                  var parentA = bodyA.parent, parentB = bodyB.parent, motion = parentA.speed * parentA.speed + parentA.angularSpeed * parentA.angularSpeed + parentB.speed * parentB.speed + parentB.angularSpeed * parentB.angularSpeed;
                  canReusePrevCol = previousCollision && previousCollision.collided && motion < 0.2;
                  collision = previousCollision;
                } else {
                  collision = { collided: false, bodyA, bodyB };
                }
                if (previousCollision && canReusePrevCol) {
                  var axisBodyA = collision.axisBody, axisBodyB = axisBodyA === bodyA ? bodyB : bodyA, axes = [axisBodyA.axes[previousCollision.axisNumber]];
                  minOverlap = SAT._overlapAxes(axisBodyA.vertices, axisBodyB.vertices, axes);
                  collision.reused = true;
                  if (minOverlap.overlap <= 0) {
                    collision.collided = false;
                    return collision;
                  }
                } else {
                  overlapAB = SAT._overlapAxes(bodyA.vertices, bodyB.vertices, bodyA.axes);
                  if (overlapAB.overlap <= 0) {
                    collision.collided = false;
                    return collision;
                  }
                  overlapBA = SAT._overlapAxes(bodyB.vertices, bodyA.vertices, bodyB.axes);
                  if (overlapBA.overlap <= 0) {
                    collision.collided = false;
                    return collision;
                  }
                  if (overlapAB.overlap < overlapBA.overlap) {
                    minOverlap = overlapAB;
                    collision.axisBody = bodyA;
                  } else {
                    minOverlap = overlapBA;
                    collision.axisBody = bodyB;
                  }
                  collision.axisNumber = minOverlap.axisNumber;
                }
                collision.bodyA = bodyA.id < bodyB.id ? bodyA : bodyB;
                collision.bodyB = bodyA.id < bodyB.id ? bodyB : bodyA;
                collision.collided = true;
                collision.depth = minOverlap.overlap;
                collision.parentA = collision.bodyA.parent;
                collision.parentB = collision.bodyB.parent;
                bodyA = collision.bodyA;
                bodyB = collision.bodyB;
                if (Vector6.dot(minOverlap.axis, Vector6.sub(bodyB.position, bodyA.position)) < 0) {
                  collision.normal = {
                    x: minOverlap.axis.x,
                    y: minOverlap.axis.y
                  };
                } else {
                  collision.normal = {
                    x: -minOverlap.axis.x,
                    y: -minOverlap.axis.y
                  };
                }
                collision.tangent = Vector6.perp(collision.normal);
                collision.penetration = collision.penetration || {};
                collision.penetration.x = collision.normal.x * collision.depth;
                collision.penetration.y = collision.normal.y * collision.depth;
                var verticesB = SAT._findSupports(bodyA, bodyB, collision.normal), supports = [];
                if (Vertices2.contains(bodyA.vertices, verticesB[0]))
                  supports.push(verticesB[0]);
                if (Vertices2.contains(bodyA.vertices, verticesB[1]))
                  supports.push(verticesB[1]);
                if (supports.length < 2) {
                  var verticesA = SAT._findSupports(bodyB, bodyA, Vector6.neg(collision.normal));
                  if (Vertices2.contains(bodyB.vertices, verticesA[0]))
                    supports.push(verticesA[0]);
                  if (supports.length < 2 && Vertices2.contains(bodyB.vertices, verticesA[1]))
                    supports.push(verticesA[1]);
                }
                if (supports.length < 1)
                  supports = [verticesB[0]];
                collision.supports = supports;
                return collision;
              };
              SAT._overlapAxes = function(verticesA, verticesB, axes) {
                var projectionA = Vector6._temp[0], projectionB = Vector6._temp[1], result = { overlap: Number.MAX_VALUE }, overlap, axis;
                for (var i = 0; i < axes.length; i++) {
                  axis = axes[i];
                  SAT._projectToAxis(projectionA, verticesA, axis);
                  SAT._projectToAxis(projectionB, verticesB, axis);
                  overlap = Math.min(projectionA.max - projectionB.min, projectionB.max - projectionA.min);
                  if (overlap <= 0) {
                    result.overlap = overlap;
                    return result;
                  }
                  if (overlap < result.overlap) {
                    result.overlap = overlap;
                    result.axis = axis;
                    result.axisNumber = i;
                  }
                }
                return result;
              };
              SAT._projectToAxis = function(projection, vertices, axis) {
                var min = Vector6.dot(vertices[0], axis), max = min;
                for (var i = 1; i < vertices.length; i += 1) {
                  var dot = Vector6.dot(vertices[i], axis);
                  if (dot > max) {
                    max = dot;
                  } else if (dot < min) {
                    min = dot;
                  }
                }
                projection.min = min;
                projection.max = max;
              };
              SAT._findSupports = function(bodyA, bodyB, normal) {
                var nearestDistance = Number.MAX_VALUE, vertexToBody = Vector6._temp[0], vertices = bodyB.vertices, bodyAPosition = bodyA.position, distance, vertex, vertexA, vertexB;
                for (var i = 0; i < vertices.length; i++) {
                  vertex = vertices[i];
                  vertexToBody.x = vertex.x - bodyAPosition.x;
                  vertexToBody.y = vertex.y - bodyAPosition.y;
                  distance = -Vector6.dot(normal, vertexToBody);
                  if (distance < nearestDistance) {
                    nearestDistance = distance;
                    vertexA = vertex;
                  }
                }
                var prevIndex = vertexA.index - 1 >= 0 ? vertexA.index - 1 : vertices.length - 1;
                vertex = vertices[prevIndex];
                vertexToBody.x = vertex.x - bodyAPosition.x;
                vertexToBody.y = vertex.y - bodyAPosition.y;
                nearestDistance = -Vector6.dot(normal, vertexToBody);
                vertexB = vertex;
                var nextIndex = (vertexA.index + 1) % vertices.length;
                vertex = vertices[nextIndex];
                vertexToBody.x = vertex.x - bodyAPosition.x;
                vertexToBody.y = vertex.y - bodyAPosition.y;
                distance = -Vector6.dot(normal, vertexToBody);
                if (distance < nearestDistance) {
                  vertexB = vertex;
                }
                return [vertexA, vertexB];
              };
            })();
          },
          function(module2, exports2, __webpack_require__) {
            var Mouse = {};
            module2.exports = Mouse;
            var Common = __webpack_require__(0);
            (function() {
              Mouse.create = function(element) {
                var mouse2 = {};
                if (!element) {
                  Common.log("Mouse.create: element was undefined, defaulting to document.body", "warn");
                }
                mouse2.element = element || document.body;
                mouse2.absolute = { x: 0, y: 0 };
                mouse2.position = { x: 0, y: 0 };
                mouse2.mousedownPosition = { x: 0, y: 0 };
                mouse2.mouseupPosition = { x: 0, y: 0 };
                mouse2.offset = { x: 0, y: 0 };
                mouse2.scale = { x: 1, y: 1 };
                mouse2.wheelDelta = 0;
                mouse2.button = -1;
                mouse2.pixelRatio = parseInt(mouse2.element.getAttribute("data-pixel-ratio"), 10) || 1;
                mouse2.sourceEvents = {
                  mousemove: null,
                  mousedown: null,
                  mouseup: null,
                  mousewheel: null
                };
                mouse2.mousemove = function(event) {
                  var position = Mouse._getRelativeMousePosition(event, mouse2.element, mouse2.pixelRatio), touches = event.changedTouches;
                  if (touches) {
                    mouse2.button = 0;
                    event.preventDefault();
                  }
                  mouse2.absolute.x = position.x;
                  mouse2.absolute.y = position.y;
                  mouse2.position.x = mouse2.absolute.x * mouse2.scale.x + mouse2.offset.x;
                  mouse2.position.y = mouse2.absolute.y * mouse2.scale.y + mouse2.offset.y;
                  mouse2.sourceEvents.mousemove = event;
                };
                mouse2.mousedown = function(event) {
                  var position = Mouse._getRelativeMousePosition(event, mouse2.element, mouse2.pixelRatio), touches = event.changedTouches;
                  if (touches) {
                    mouse2.button = 0;
                    event.preventDefault();
                  } else {
                    mouse2.button = event.button;
                  }
                  mouse2.absolute.x = position.x;
                  mouse2.absolute.y = position.y;
                  mouse2.position.x = mouse2.absolute.x * mouse2.scale.x + mouse2.offset.x;
                  mouse2.position.y = mouse2.absolute.y * mouse2.scale.y + mouse2.offset.y;
                  mouse2.mousedownPosition.x = mouse2.position.x;
                  mouse2.mousedownPosition.y = mouse2.position.y;
                  mouse2.sourceEvents.mousedown = event;
                };
                mouse2.mouseup = function(event) {
                  var position = Mouse._getRelativeMousePosition(event, mouse2.element, mouse2.pixelRatio), touches = event.changedTouches;
                  if (touches) {
                    event.preventDefault();
                  }
                  mouse2.button = -1;
                  mouse2.absolute.x = position.x;
                  mouse2.absolute.y = position.y;
                  mouse2.position.x = mouse2.absolute.x * mouse2.scale.x + mouse2.offset.x;
                  mouse2.position.y = mouse2.absolute.y * mouse2.scale.y + mouse2.offset.y;
                  mouse2.mouseupPosition.x = mouse2.position.x;
                  mouse2.mouseupPosition.y = mouse2.position.y;
                  mouse2.sourceEvents.mouseup = event;
                };
                mouse2.mousewheel = function(event) {
                  mouse2.wheelDelta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail));
                  event.preventDefault();
                };
                Mouse.setElement(mouse2, mouse2.element);
                return mouse2;
              };
              Mouse.setElement = function(mouse2, element) {
                mouse2.element = element;
                element.addEventListener("mousemove", mouse2.mousemove);
                element.addEventListener("mousedown", mouse2.mousedown);
                element.addEventListener("mouseup", mouse2.mouseup);
                element.addEventListener("mousewheel", mouse2.mousewheel);
                element.addEventListener("DOMMouseScroll", mouse2.mousewheel);
                element.addEventListener("touchmove", mouse2.mousemove);
                element.addEventListener("touchstart", mouse2.mousedown);
                element.addEventListener("touchend", mouse2.mouseup);
              };
              Mouse.clearSourceEvents = function(mouse2) {
                mouse2.sourceEvents.mousemove = null;
                mouse2.sourceEvents.mousedown = null;
                mouse2.sourceEvents.mouseup = null;
                mouse2.sourceEvents.mousewheel = null;
                mouse2.wheelDelta = 0;
              };
              Mouse.setOffset = function(mouse2, offset) {
                mouse2.offset.x = offset.x;
                mouse2.offset.y = offset.y;
                mouse2.position.x = mouse2.absolute.x * mouse2.scale.x + mouse2.offset.x;
                mouse2.position.y = mouse2.absolute.y * mouse2.scale.y + mouse2.offset.y;
              };
              Mouse.setScale = function(mouse2, scale) {
                mouse2.scale.x = scale.x;
                mouse2.scale.y = scale.y;
                mouse2.position.x = mouse2.absolute.x * mouse2.scale.x + mouse2.offset.x;
                mouse2.position.y = mouse2.absolute.y * mouse2.scale.y + mouse2.offset.y;
              };
              Mouse._getRelativeMousePosition = function(event, element, pixelRatio) {
                var elementBounds = element.getBoundingClientRect(), rootNode = document.documentElement || document.body.parentNode || document.body, scrollX = window.pageXOffset !== void 0 ? window.pageXOffset : rootNode.scrollLeft, scrollY = window.pageYOffset !== void 0 ? window.pageYOffset : rootNode.scrollTop, touches = event.changedTouches, x, y;
                if (touches) {
                  x = touches[0].pageX - elementBounds.left - scrollX;
                  y = touches[0].pageY - elementBounds.top - scrollY;
                } else {
                  x = event.pageX - elementBounds.left - scrollX;
                  y = event.pageY - elementBounds.top - scrollY;
                }
                return {
                  x: x / (element.clientWidth / (element.width || element.clientWidth) * pixelRatio),
                  y: y / (element.clientHeight / (element.height || element.clientHeight) * pixelRatio)
                };
              };
            })();
          },
          function(module2, exports2, __webpack_require__) {
            var Axes = {};
            module2.exports = Axes;
            var Vector6 = __webpack_require__(2);
            var Common = __webpack_require__(0);
            (function() {
              Axes.fromVertices = function(vertices) {
                var axes = {};
                for (var i = 0; i < vertices.length; i++) {
                  var j = (i + 1) % vertices.length, normal = Vector6.normalise({
                    x: vertices[j].y - vertices[i].y,
                    y: vertices[i].x - vertices[j].x
                  }), gradient = normal.y === 0 ? Infinity : normal.x / normal.y;
                  gradient = gradient.toFixed(3).toString();
                  axes[gradient] = normal;
                }
                return Common.values(axes);
              };
              Axes.rotate = function(axes, angle) {
                if (angle === 0)
                  return;
                var cos = Math.cos(angle), sin = Math.sin(angle);
                for (var i = 0; i < axes.length; i++) {
                  var axis = axes[i], xx;
                  xx = axis.x * cos - axis.y * sin;
                  axis.y = axis.x * sin + axis.y * cos;
                  axis.x = xx;
                }
              };
            })();
          },
          function(module2, exports2, __webpack_require__) {
            var Bodies2 = {};
            module2.exports = Bodies2;
            var Vertices2 = __webpack_require__(3);
            var Common = __webpack_require__(0);
            var Body2 = __webpack_require__(6);
            var Bounds = __webpack_require__(1);
            var Vector6 = __webpack_require__(2);
            (function() {
              Bodies2._decompWarned = false;
              Bodies2.rectangle = function(x, y, width, height, options) {
                options = options || {};
                var rectangle = {
                  label: "Rectangle Body",
                  position: { x, y },
                  vertices: Vertices2.fromPath("L 0 0 L " + width + " 0 L " + width + " " + height + " L 0 " + height)
                };
                if (options.chamfer) {
                  var chamfer = options.chamfer;
                  rectangle.vertices = Vertices2.chamfer(rectangle.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
                  delete options.chamfer;
                }
                return Body2.create(Common.extend({}, rectangle, options));
              };
              Bodies2.trapezoid = function(x, y, width, height, slope, options) {
                options = options || {};
                slope *= 0.5;
                var roof = (1 - slope * 2) * width;
                var x1 = width * slope, x2 = x1 + roof, x3 = x2 + x1, verticesPath;
                if (slope < 0.5) {
                  verticesPath = "L 0 0 L " + x1 + " " + -height + " L " + x2 + " " + -height + " L " + x3 + " 0";
                } else {
                  verticesPath = "L 0 0 L " + x2 + " " + -height + " L " + x3 + " 0";
                }
                var trapezoid = {
                  label: "Trapezoid Body",
                  position: { x, y },
                  vertices: Vertices2.fromPath(verticesPath)
                };
                if (options.chamfer) {
                  var chamfer = options.chamfer;
                  trapezoid.vertices = Vertices2.chamfer(trapezoid.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
                  delete options.chamfer;
                }
                return Body2.create(Common.extend({}, trapezoid, options));
              };
              Bodies2.circle = function(x, y, radius, options, maxSides) {
                options = options || {};
                var circle = {
                  label: "Circle Body",
                  circleRadius: radius
                };
                maxSides = maxSides || 25;
                var sides = Math.ceil(Math.max(10, Math.min(maxSides, radius)));
                if (sides % 2 === 1)
                  sides += 1;
                return Bodies2.polygon(x, y, sides, radius, Common.extend({}, circle, options));
              };
              Bodies2.polygon = function(x, y, sides, radius, options) {
                options = options || {};
                if (sides < 3)
                  return Bodies2.circle(x, y, radius, options);
                var theta = 2 * Math.PI / sides, path = "", offset = theta * 0.5;
                for (var i = 0; i < sides; i += 1) {
                  var angle = offset + i * theta, xx = Math.cos(angle) * radius, yy = Math.sin(angle) * radius;
                  path += "L " + xx.toFixed(3) + " " + yy.toFixed(3) + " ";
                }
                var polygon = {
                  label: "Polygon Body",
                  position: { x, y },
                  vertices: Vertices2.fromPath(path)
                };
                if (options.chamfer) {
                  var chamfer = options.chamfer;
                  polygon.vertices = Vertices2.chamfer(polygon.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);
                  delete options.chamfer;
                }
                return Body2.create(Common.extend({}, polygon, options));
              };
              Bodies2.fromVertices = function(x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea, removeDuplicatePoints) {
                var decomp, canDecomp, body, parts, isConvex, isConcave, vertices, i, j, k, v, z;
                try {
                  decomp = __webpack_require__(27);
                } catch (e) {
                  decomp = null;
                }
                canDecomp = Boolean(decomp && decomp.quickDecomp);
                options = options || {};
                parts = [];
                flagInternal = typeof flagInternal !== "undefined" ? flagInternal : false;
                removeCollinear = typeof removeCollinear !== "undefined" ? removeCollinear : 0.01;
                minimumArea = typeof minimumArea !== "undefined" ? minimumArea : 10;
                removeDuplicatePoints = typeof removeDuplicatePoints !== "undefined" ? removeDuplicatePoints : 0.01;
                if (!Common.isArray(vertexSets[0])) {
                  vertexSets = [vertexSets];
                }
                for (v = 0; v < vertexSets.length; v += 1) {
                  vertices = vertexSets[v];
                  isConvex = Vertices2.isConvex(vertices);
                  isConcave = !isConvex;
                  if (isConcave && !canDecomp && !Bodies2._decompWarned) {
                    Common.warn("Could not resolve the expected 'poly-decomp' package for concave vertices in 'Bodies.fromVertices'");
                    Common.warn("Try 'npm install poly-decomp --save' or as a global e.g. 'window.decomp'");
                    Bodies2._decompWarned = true;
                  }
                  if (isConvex || !canDecomp) {
                    if (isConvex) {
                      vertices = Vertices2.clockwiseSort(vertices);
                    } else {
                      vertices = Vertices2.hull(vertices);
                    }
                    parts.push({
                      position: { x, y },
                      vertices
                    });
                  } else {
                    var concave = vertices.map(function(vertex) {
                      return [vertex.x, vertex.y];
                    });
                    decomp.makeCCW(concave);
                    if (removeCollinear !== false)
                      decomp.removeCollinearPoints(concave, removeCollinear);
                    if (removeDuplicatePoints !== false && decomp.removeDuplicatePoints)
                      decomp.removeDuplicatePoints(concave, removeDuplicatePoints);
                    var decomposed = decomp.quickDecomp(concave);
                    for (i = 0; i < decomposed.length; i++) {
                      var chunk = decomposed[i];
                      var chunkVertices = chunk.map(function(vertices2) {
                        return {
                          x: vertices2[0],
                          y: vertices2[1]
                        };
                      });
                      if (minimumArea > 0 && Vertices2.area(chunkVertices) < minimumArea)
                        continue;
                      parts.push({
                        position: Vertices2.centre(chunkVertices),
                        vertices: chunkVertices
                      });
                    }
                  }
                }
                for (i = 0; i < parts.length; i++) {
                  parts[i] = Body2.create(Common.extend(parts[i], options));
                }
                if (flagInternal) {
                  var coincident_max_dist = 5;
                  for (i = 0; i < parts.length; i++) {
                    var partA = parts[i];
                    for (j = i + 1; j < parts.length; j++) {
                      var partB = parts[j];
                      if (Bounds.overlaps(partA.bounds, partB.bounds)) {
                        var pav = partA.vertices, pbv = partB.vertices;
                        for (k = 0; k < partA.vertices.length; k++) {
                          for (z = 0; z < partB.vertices.length; z++) {
                            var da = Vector6.magnitudeSquared(Vector6.sub(pav[(k + 1) % pav.length], pbv[z])), db = Vector6.magnitudeSquared(Vector6.sub(pav[k], pbv[(z + 1) % pbv.length]));
                            if (da < coincident_max_dist && db < coincident_max_dist) {
                              pav[k].isInternal = true;
                              pbv[z].isInternal = true;
                            }
                          }
                        }
                      }
                    }
                  }
                }
                if (parts.length > 1) {
                  body = Body2.create(Common.extend({ parts: parts.slice(0) }, options));
                  Body2.setPosition(body, { x, y });
                  return body;
                } else {
                  return parts[0];
                }
              };
            })();
          },
          function(module2, exports2, __webpack_require__) {
            var Plugin = {};
            module2.exports = Plugin;
            var Common = __webpack_require__(0);
            (function() {
              Plugin._registry = {};
              Plugin.register = function(plugin) {
                if (!Plugin.isPlugin(plugin)) {
                  Common.warn("Plugin.register:", Plugin.toString(plugin), "does not implement all required fields.");
                }
                if (plugin.name in Plugin._registry) {
                  var registered = Plugin._registry[plugin.name], pluginVersion = Plugin.versionParse(plugin.version).number, registeredVersion = Plugin.versionParse(registered.version).number;
                  if (pluginVersion > registeredVersion) {
                    Common.warn("Plugin.register:", Plugin.toString(registered), "was upgraded to", Plugin.toString(plugin));
                    Plugin._registry[plugin.name] = plugin;
                  } else if (pluginVersion < registeredVersion) {
                    Common.warn("Plugin.register:", Plugin.toString(registered), "can not be downgraded to", Plugin.toString(plugin));
                  } else if (plugin !== registered) {
                    Common.warn("Plugin.register:", Plugin.toString(plugin), "is already registered to different plugin object");
                  }
                } else {
                  Plugin._registry[plugin.name] = plugin;
                }
                return plugin;
              };
              Plugin.resolve = function(dependency) {
                return Plugin._registry[Plugin.dependencyParse(dependency).name];
              };
              Plugin.toString = function(plugin) {
                return typeof plugin === "string" ? plugin : (plugin.name || "anonymous") + "@" + (plugin.version || plugin.range || "0.0.0");
              };
              Plugin.isPlugin = function(obj) {
                return obj && obj.name && obj.version && obj.install;
              };
              Plugin.isUsed = function(module3, name) {
                return module3.used.indexOf(name) > -1;
              };
              Plugin.isFor = function(plugin, module3) {
                var parsed = plugin.for && Plugin.dependencyParse(plugin.for);
                return !plugin.for || module3.name === parsed.name && Plugin.versionSatisfies(module3.version, parsed.range);
              };
              Plugin.use = function(module3, plugins) {
                module3.uses = (module3.uses || []).concat(plugins || []);
                if (module3.uses.length === 0) {
                  Common.warn("Plugin.use:", Plugin.toString(module3), "does not specify any dependencies to install.");
                  return;
                }
                var dependencies = Plugin.dependencies(module3), sortedDependencies = Common.topologicalSort(dependencies), status = [];
                for (var i = 0; i < sortedDependencies.length; i += 1) {
                  if (sortedDependencies[i] === module3.name) {
                    continue;
                  }
                  var plugin = Plugin.resolve(sortedDependencies[i]);
                  if (!plugin) {
                    status.push("\u274C " + sortedDependencies[i]);
                    continue;
                  }
                  if (Plugin.isUsed(module3, plugin.name)) {
                    continue;
                  }
                  if (!Plugin.isFor(plugin, module3)) {
                    Common.warn("Plugin.use:", Plugin.toString(plugin), "is for", plugin.for, "but installed on", Plugin.toString(module3) + ".");
                    plugin._warned = true;
                  }
                  if (plugin.install) {
                    plugin.install(module3);
                  } else {
                    Common.warn("Plugin.use:", Plugin.toString(plugin), "does not specify an install function.");
                    plugin._warned = true;
                  }
                  if (plugin._warned) {
                    status.push("\u{1F536} " + Plugin.toString(plugin));
                    delete plugin._warned;
                  } else {
                    status.push("\u2705 " + Plugin.toString(plugin));
                  }
                  module3.used.push(plugin.name);
                }
                if (status.length > 0) {
                  Common.info(status.join("  "));
                }
              };
              Plugin.dependencies = function(module3, tracked) {
                var parsedBase = Plugin.dependencyParse(module3), name = parsedBase.name;
                tracked = tracked || {};
                if (name in tracked) {
                  return;
                }
                module3 = Plugin.resolve(module3) || module3;
                tracked[name] = Common.map(module3.uses || [], function(dependency) {
                  if (Plugin.isPlugin(dependency)) {
                    Plugin.register(dependency);
                  }
                  var parsed = Plugin.dependencyParse(dependency), resolved = Plugin.resolve(dependency);
                  if (resolved && !Plugin.versionSatisfies(resolved.version, parsed.range)) {
                    Common.warn("Plugin.dependencies:", Plugin.toString(resolved), "does not satisfy", Plugin.toString(parsed), "used by", Plugin.toString(parsedBase) + ".");
                    resolved._warned = true;
                    module3._warned = true;
                  } else if (!resolved) {
                    Common.warn("Plugin.dependencies:", Plugin.toString(dependency), "used by", Plugin.toString(parsedBase), "could not be resolved.");
                    module3._warned = true;
                  }
                  return parsed.name;
                });
                for (var i = 0; i < tracked[name].length; i += 1) {
                  Plugin.dependencies(tracked[name][i], tracked);
                }
                return tracked;
              };
              Plugin.dependencyParse = function(dependency) {
                if (Common.isString(dependency)) {
                  var pattern = /^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?))?$/;
                  if (!pattern.test(dependency)) {
                    Common.warn("Plugin.dependencyParse:", dependency, "is not a valid dependency string.");
                  }
                  return {
                    name: dependency.split("@")[0],
                    range: dependency.split("@")[1] || "*"
                  };
                }
                return {
                  name: dependency.name,
                  range: dependency.range || dependency.version
                };
              };
              Plugin.versionParse = function(range) {
                var pattern = /^(\*)|(\^|~|>=|>)?\s*((\d+)\.(\d+)\.(\d+))(-[0-9A-Za-z-]+)?$/;
                if (!pattern.test(range)) {
                  Common.warn("Plugin.versionParse:", range, "is not a valid version or range.");
                }
                var parts = pattern.exec(range);
                var major = Number(parts[4]);
                var minor = Number(parts[5]);
                var patch = Number(parts[6]);
                return {
                  isRange: Boolean(parts[1] || parts[2]),
                  version: parts[3],
                  range,
                  operator: parts[1] || parts[2] || "",
                  major,
                  minor,
                  patch,
                  parts: [major, minor, patch],
                  prerelease: parts[7],
                  number: major * 1e8 + minor * 1e4 + patch
                };
              };
              Plugin.versionSatisfies = function(version, range) {
                range = range || "*";
                var r = Plugin.versionParse(range), v = Plugin.versionParse(version);
                if (r.isRange) {
                  if (r.operator === "*" || version === "*") {
                    return true;
                  }
                  if (r.operator === ">") {
                    return v.number > r.number;
                  }
                  if (r.operator === ">=") {
                    return v.number >= r.number;
                  }
                  if (r.operator === "~") {
                    return v.major === r.major && v.minor === r.minor && v.patch >= r.patch;
                  }
                  if (r.operator === "^") {
                    if (r.major > 0) {
                      return v.major === r.major && v.number >= r.number;
                    }
                    if (r.minor > 0) {
                      return v.minor === r.minor && v.patch >= r.patch;
                    }
                    return v.patch === r.patch;
                  }
                }
                return version === range || version === "*";
              };
            })();
          },
          function(module2, exports2) {
            var Contact = {};
            module2.exports = Contact;
            (function() {
              Contact.create = function(vertex) {
                return {
                  id: Contact.id(vertex),
                  vertex,
                  normalImpulse: 0,
                  tangentImpulse: 0
                };
              };
              Contact.id = function(vertex) {
                return vertex.body.id + "_" + vertex.index;
              };
            })();
          },
          function(module2, exports2, __webpack_require__) {
            var World2 = {};
            module2.exports = World2;
            var Composite2 = __webpack_require__(5);
            var Constraint = __webpack_require__(8);
            var Common = __webpack_require__(0);
            (function() {
              World2.create = function(options) {
                var composite = Composite2.create();
                var defaults = {
                  label: "World",
                  gravity: {
                    x: 0,
                    y: 1,
                    scale: 1e-3
                  },
                  bounds: {
                    min: { x: -Infinity, y: -Infinity },
                    max: { x: Infinity, y: Infinity }
                  }
                };
                return Common.extend(composite, defaults, options);
              };
            })();
          },
          function(module2, exports2, __webpack_require__) {
            var Pairs = {};
            module2.exports = Pairs;
            var Pair = __webpack_require__(9);
            var Common = __webpack_require__(0);
            (function() {
              Pairs._pairMaxIdleLife = 1e3;
              Pairs.create = function(options) {
                return Common.extend({
                  table: {},
                  list: [],
                  collisionStart: [],
                  collisionActive: [],
                  collisionEnd: []
                }, options);
              };
              Pairs.update = function(pairs, collisions, timestamp) {
                var pairsList = pairs.list, pairsTable = pairs.table, collisionStart = pairs.collisionStart, collisionEnd = pairs.collisionEnd, collisionActive = pairs.collisionActive, collision, pairId, pair, i;
                collisionStart.length = 0;
                collisionEnd.length = 0;
                collisionActive.length = 0;
                for (i = 0; i < pairsList.length; i++) {
                  pairsList[i].confirmedActive = false;
                }
                for (i = 0; i < collisions.length; i++) {
                  collision = collisions[i];
                  if (collision.collided) {
                    pairId = Pair.id(collision.bodyA, collision.bodyB);
                    pair = pairsTable[pairId];
                    if (pair) {
                      if (pair.isActive) {
                        collisionActive.push(pair);
                      } else {
                        collisionStart.push(pair);
                      }
                      Pair.update(pair, collision, timestamp);
                      pair.confirmedActive = true;
                    } else {
                      pair = Pair.create(collision, timestamp);
                      pairsTable[pairId] = pair;
                      collisionStart.push(pair);
                      pairsList.push(pair);
                    }
                  }
                }
                for (i = 0; i < pairsList.length; i++) {
                  pair = pairsList[i];
                  if (pair.isActive && !pair.confirmedActive) {
                    Pair.setActive(pair, false, timestamp);
                    collisionEnd.push(pair);
                  }
                }
              };
              Pairs.removeOld = function(pairs, timestamp) {
                var pairsList = pairs.list, pairsTable = pairs.table, indexesToRemove = [], pair, collision, pairIndex, i;
                for (i = 0; i < pairsList.length; i++) {
                  pair = pairsList[i];
                  collision = pair.collision;
                  if (collision.bodyA.isSleeping || collision.bodyB.isSleeping) {
                    pair.timeUpdated = timestamp;
                    continue;
                  }
                  if (timestamp - pair.timeUpdated > Pairs._pairMaxIdleLife) {
                    indexesToRemove.push(i);
                  }
                }
                for (i = 0; i < indexesToRemove.length; i++) {
                  pairIndex = indexesToRemove[i] - i;
                  pair = pairsList[pairIndex];
                  delete pairsTable[pair.id];
                  pairsList.splice(pairIndex, 1);
                }
              };
              Pairs.clear = function(pairs) {
                pairs.table = {};
                pairs.list.length = 0;
                pairs.collisionStart.length = 0;
                pairs.collisionActive.length = 0;
                pairs.collisionEnd.length = 0;
                return pairs;
              };
            })();
          },
          function(module2, exports2, __webpack_require__) {
            var Resolver = {};
            module2.exports = Resolver;
            var Vertices2 = __webpack_require__(3);
            var Vector6 = __webpack_require__(2);
            var Common = __webpack_require__(0);
            var Bounds = __webpack_require__(1);
            (function() {
              Resolver._restingThresh = 4;
              Resolver._restingThreshTangent = 6;
              Resolver._positionDampen = 0.9;
              Resolver._positionWarming = 0.8;
              Resolver._frictionNormalMultiplier = 5;
              Resolver.preSolvePosition = function(pairs) {
                var i, pair, activeCount;
                for (i = 0; i < pairs.length; i++) {
                  pair = pairs[i];
                  if (!pair.isActive)
                    continue;
                  activeCount = pair.activeContacts.length;
                  pair.collision.parentA.totalContacts += activeCount;
                  pair.collision.parentB.totalContacts += activeCount;
                }
              };
              Resolver.solvePosition = function(pairs, timeScale) {
                var i, pair, collision, bodyA, bodyB, normal, bodyBtoA, contactShare, positionImpulse, contactCount = {}, tempA = Vector6._temp[0], tempB = Vector6._temp[1], tempC = Vector6._temp[2], tempD = Vector6._temp[3];
                for (i = 0; i < pairs.length; i++) {
                  pair = pairs[i];
                  if (!pair.isActive || pair.isSensor)
                    continue;
                  collision = pair.collision;
                  bodyA = collision.parentA;
                  bodyB = collision.parentB;
                  normal = collision.normal;
                  bodyBtoA = Vector6.sub(Vector6.add(bodyB.positionImpulse, bodyB.position, tempA), Vector6.add(bodyA.positionImpulse, Vector6.sub(bodyB.position, collision.penetration, tempB), tempC), tempD);
                  pair.separation = Vector6.dot(normal, bodyBtoA);
                }
                for (i = 0; i < pairs.length; i++) {
                  pair = pairs[i];
                  if (!pair.isActive || pair.isSensor)
                    continue;
                  collision = pair.collision;
                  bodyA = collision.parentA;
                  bodyB = collision.parentB;
                  normal = collision.normal;
                  positionImpulse = (pair.separation - pair.slop) * timeScale;
                  if (bodyA.isStatic || bodyB.isStatic)
                    positionImpulse *= 2;
                  if (!(bodyA.isStatic || bodyA.isSleeping)) {
                    contactShare = Resolver._positionDampen / bodyA.totalContacts;
                    bodyA.positionImpulse.x += normal.x * positionImpulse * contactShare;
                    bodyA.positionImpulse.y += normal.y * positionImpulse * contactShare;
                  }
                  if (!(bodyB.isStatic || bodyB.isSleeping)) {
                    contactShare = Resolver._positionDampen / bodyB.totalContacts;
                    bodyB.positionImpulse.x -= normal.x * positionImpulse * contactShare;
                    bodyB.positionImpulse.y -= normal.y * positionImpulse * contactShare;
                  }
                }
              };
              Resolver.postSolvePosition = function(bodies) {
                for (var i = 0; i < bodies.length; i++) {
                  var body = bodies[i];
                  body.totalContacts = 0;
                  if (body.positionImpulse.x !== 0 || body.positionImpulse.y !== 0) {
                    for (var j = 0; j < body.parts.length; j++) {
                      var part = body.parts[j];
                      Vertices2.translate(part.vertices, body.positionImpulse);
                      Bounds.update(part.bounds, part.vertices, body.velocity);
                      part.position.x += body.positionImpulse.x;
                      part.position.y += body.positionImpulse.y;
                    }
                    body.positionPrev.x += body.positionImpulse.x;
                    body.positionPrev.y += body.positionImpulse.y;
                    if (Vector6.dot(body.positionImpulse, body.velocity) < 0) {
                      body.positionImpulse.x = 0;
                      body.positionImpulse.y = 0;
                    } else {
                      body.positionImpulse.x *= Resolver._positionWarming;
                      body.positionImpulse.y *= Resolver._positionWarming;
                    }
                  }
                }
              };
              Resolver.preSolveVelocity = function(pairs) {
                var i, j, pair, contacts, collision, bodyA, bodyB, normal, tangent, contact, contactVertex, normalImpulse, tangentImpulse, offset, impulse = Vector6._temp[0], tempA = Vector6._temp[1];
                for (i = 0; i < pairs.length; i++) {
                  pair = pairs[i];
                  if (!pair.isActive || pair.isSensor)
                    continue;
                  contacts = pair.activeContacts;
                  collision = pair.collision;
                  bodyA = collision.parentA;
                  bodyB = collision.parentB;
                  normal = collision.normal;
                  tangent = collision.tangent;
                  for (j = 0; j < contacts.length; j++) {
                    contact = contacts[j];
                    contactVertex = contact.vertex;
                    normalImpulse = contact.normalImpulse;
                    tangentImpulse = contact.tangentImpulse;
                    if (normalImpulse !== 0 || tangentImpulse !== 0) {
                      impulse.x = normal.x * normalImpulse + tangent.x * tangentImpulse;
                      impulse.y = normal.y * normalImpulse + tangent.y * tangentImpulse;
                      if (!(bodyA.isStatic || bodyA.isSleeping)) {
                        offset = Vector6.sub(contactVertex, bodyA.position, tempA);
                        bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;
                        bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;
                        bodyA.anglePrev += Vector6.cross(offset, impulse) * bodyA.inverseInertia;
                      }
                      if (!(bodyB.isStatic || bodyB.isSleeping)) {
                        offset = Vector6.sub(contactVertex, bodyB.position, tempA);
                        bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;
                        bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;
                        bodyB.anglePrev -= Vector6.cross(offset, impulse) * bodyB.inverseInertia;
                      }
                    }
                  }
                }
              };
              Resolver.solveVelocity = function(pairs, timeScale) {
                var timeScaleSquared = timeScale * timeScale, impulse = Vector6._temp[0], tempA = Vector6._temp[1], tempB = Vector6._temp[2], tempC = Vector6._temp[3], tempD = Vector6._temp[4], tempE = Vector6._temp[5];
                for (var i = 0; i < pairs.length; i++) {
                  var pair = pairs[i];
                  if (!pair.isActive || pair.isSensor)
                    continue;
                  var collision = pair.collision, bodyA = collision.parentA, bodyB = collision.parentB, normal = collision.normal, tangent = collision.tangent, contacts = pair.activeContacts, contactShare = 1 / contacts.length;
                  bodyA.velocity.x = bodyA.position.x - bodyA.positionPrev.x;
                  bodyA.velocity.y = bodyA.position.y - bodyA.positionPrev.y;
                  bodyB.velocity.x = bodyB.position.x - bodyB.positionPrev.x;
                  bodyB.velocity.y = bodyB.position.y - bodyB.positionPrev.y;
                  bodyA.angularVelocity = bodyA.angle - bodyA.anglePrev;
                  bodyB.angularVelocity = bodyB.angle - bodyB.anglePrev;
                  for (var j = 0; j < contacts.length; j++) {
                    var contact = contacts[j], contactVertex = contact.vertex, offsetA = Vector6.sub(contactVertex, bodyA.position, tempA), offsetB = Vector6.sub(contactVertex, bodyB.position, tempB), velocityPointA = Vector6.add(bodyA.velocity, Vector6.mult(Vector6.perp(offsetA), bodyA.angularVelocity), tempC), velocityPointB = Vector6.add(bodyB.velocity, Vector6.mult(Vector6.perp(offsetB), bodyB.angularVelocity), tempD), relativeVelocity = Vector6.sub(velocityPointA, velocityPointB, tempE), normalVelocity = Vector6.dot(normal, relativeVelocity);
                    var tangentVelocity = Vector6.dot(tangent, relativeVelocity), tangentSpeed = Math.abs(tangentVelocity), tangentVelocityDirection = Common.sign(tangentVelocity);
                    var normalImpulse = (1 + pair.restitution) * normalVelocity, normalForce = Common.clamp(pair.separation + normalVelocity, 0, 1) * Resolver._frictionNormalMultiplier;
                    var tangentImpulse = tangentVelocity, maxFriction = Infinity;
                    if (tangentSpeed > pair.friction * pair.frictionStatic * normalForce * timeScaleSquared) {
                      maxFriction = tangentSpeed;
                      tangentImpulse = Common.clamp(pair.friction * tangentVelocityDirection * timeScaleSquared, -maxFriction, maxFriction);
                    }
                    var oAcN = Vector6.cross(offsetA, normal), oBcN = Vector6.cross(offsetB, normal), share = contactShare / (bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * oAcN * oAcN + bodyB.inverseInertia * oBcN * oBcN);
                    normalImpulse *= share;
                    tangentImpulse *= share;
                    if (normalVelocity < 0 && normalVelocity * normalVelocity > Resolver._restingThresh * timeScaleSquared) {
                      contact.normalImpulse = 0;
                    } else {
                      var contactNormalImpulse = contact.normalImpulse;
                      contact.normalImpulse = Math.min(contact.normalImpulse + normalImpulse, 0);
                      normalImpulse = contact.normalImpulse - contactNormalImpulse;
                    }
                    if (tangentVelocity * tangentVelocity > Resolver._restingThreshTangent * timeScaleSquared) {
                      contact.tangentImpulse = 0;
                    } else {
                      var contactTangentImpulse = contact.tangentImpulse;
                      contact.tangentImpulse = Common.clamp(contact.tangentImpulse + tangentImpulse, -maxFriction, maxFriction);
                      tangentImpulse = contact.tangentImpulse - contactTangentImpulse;
                    }
                    impulse.x = normal.x * normalImpulse + tangent.x * tangentImpulse;
                    impulse.y = normal.y * normalImpulse + tangent.y * tangentImpulse;
                    if (!(bodyA.isStatic || bodyA.isSleeping)) {
                      bodyA.positionPrev.x += impulse.x * bodyA.inverseMass;
                      bodyA.positionPrev.y += impulse.y * bodyA.inverseMass;
                      bodyA.anglePrev += Vector6.cross(offsetA, impulse) * bodyA.inverseInertia;
                    }
                    if (!(bodyB.isStatic || bodyB.isSleeping)) {
                      bodyB.positionPrev.x -= impulse.x * bodyB.inverseMass;
                      bodyB.positionPrev.y -= impulse.y * bodyB.inverseMass;
                      bodyB.anglePrev -= Vector6.cross(offsetB, impulse) * bodyB.inverseInertia;
                    }
                  }
                }
              };
            })();
          },
          function(module2, exports2, __webpack_require__) {
            var Engine2 = {};
            module2.exports = Engine2;
            var World2 = __webpack_require__(19);
            var Sleeping = __webpack_require__(7);
            var Resolver = __webpack_require__(21);
            var Render2 = __webpack_require__(10);
            var Pairs = __webpack_require__(20);
            var Metrics = __webpack_require__(23);
            var Grid = __webpack_require__(11);
            var Events8 = __webpack_require__(4);
            var Composite2 = __webpack_require__(5);
            var Constraint = __webpack_require__(8);
            var Common = __webpack_require__(0);
            var Body2 = __webpack_require__(6);
            (function() {
              Engine2.create = function(element, options) {
                options = Common.isElement(element) ? options : element;
                element = Common.isElement(element) ? element : null;
                options = options || {};
                if (element || options.render) {
                  Common.warn("Engine.create: engine.render is deprecated (see docs)");
                }
                var defaults = {
                  positionIterations: 6,
                  velocityIterations: 4,
                  constraintIterations: 2,
                  enableSleeping: false,
                  events: [],
                  plugin: {},
                  timing: {
                    timestamp: 0,
                    timeScale: 1
                  },
                  broadphase: {
                    controller: Grid
                  }
                };
                var engine = Common.extend(defaults, options);
                if (element || engine.render) {
                  var renderDefaults = {
                    element,
                    controller: Render2
                  };
                  engine.render = Common.extend(renderDefaults, engine.render);
                }
                if (engine.render && engine.render.controller) {
                  engine.render = engine.render.controller.create(engine.render);
                }
                if (engine.render) {
                  engine.render.engine = engine;
                }
                engine.world = options.world || World2.create(engine.world);
                engine.pairs = Pairs.create();
                engine.broadphase = engine.broadphase.controller.create(engine.broadphase);
                engine.metrics = engine.metrics || { extended: false };
                engine.metrics = Metrics.create(engine.metrics);
                return engine;
              };
              Engine2.update = function(engine, delta, correction) {
                delta = delta || 1e3 / 60;
                correction = correction || 1;
                var world = engine.world, timing = engine.timing, broadphase = engine.broadphase, broadphasePairs = [], i;
                timing.timestamp += delta * timing.timeScale;
                var event = {
                  timestamp: timing.timestamp
                };
                Events8.trigger(engine, "beforeUpdate", event);
                var allBodies = Composite2.allBodies(world), allConstraints = Composite2.allConstraints(world);
                Metrics.reset(engine.metrics);
                if (engine.enableSleeping)
                  Sleeping.update(allBodies, timing.timeScale);
                Engine2._bodiesApplyGravity(allBodies, world.gravity);
                Engine2._bodiesUpdate(allBodies, delta, timing.timeScale, correction, world.bounds);
                Constraint.preSolveAll(allBodies);
                for (i = 0; i < engine.constraintIterations; i++) {
                  Constraint.solveAll(allConstraints, timing.timeScale);
                }
                Constraint.postSolveAll(allBodies);
                if (broadphase.controller) {
                  if (world.isModified)
                    broadphase.controller.clear(broadphase);
                  broadphase.controller.update(broadphase, allBodies, engine, world.isModified);
                  broadphasePairs = broadphase.pairsList;
                } else {
                  broadphasePairs = allBodies;
                }
                if (world.isModified) {
                  Composite2.setModified(world, false, false, true);
                }
                var collisions = broadphase.detector(broadphasePairs, engine);
                var pairs = engine.pairs, timestamp = timing.timestamp;
                Pairs.update(pairs, collisions, timestamp);
                Pairs.removeOld(pairs, timestamp);
                if (engine.enableSleeping)
                  Sleeping.afterCollisions(pairs.list, timing.timeScale);
                if (pairs.collisionStart.length > 0)
                  Events8.trigger(engine, "collisionStart", { pairs: pairs.collisionStart });
                Resolver.preSolvePosition(pairs.list);
                for (i = 0; i < engine.positionIterations; i++) {
                  Resolver.solvePosition(pairs.list, timing.timeScale);
                }
                Resolver.postSolvePosition(allBodies);
                Constraint.preSolveAll(allBodies);
                for (i = 0; i < engine.constraintIterations; i++) {
                  Constraint.solveAll(allConstraints, timing.timeScale);
                }
                Constraint.postSolveAll(allBodies);
                Resolver.preSolveVelocity(pairs.list);
                for (i = 0; i < engine.velocityIterations; i++) {
                  Resolver.solveVelocity(pairs.list, timing.timeScale);
                }
                if (pairs.collisionActive.length > 0)
                  Events8.trigger(engine, "collisionActive", { pairs: pairs.collisionActive });
                if (pairs.collisionEnd.length > 0)
                  Events8.trigger(engine, "collisionEnd", { pairs: pairs.collisionEnd });
                Metrics.update(engine.metrics, engine);
                Engine2._bodiesClearForces(allBodies);
                Events8.trigger(engine, "afterUpdate", event);
                return engine;
              };
              Engine2.merge = function(engineA, engineB) {
                Common.extend(engineA, engineB);
                if (engineB.world) {
                  engineA.world = engineB.world;
                  Engine2.clear(engineA);
                  var bodies = Composite2.allBodies(engineA.world);
                  for (var i = 0; i < bodies.length; i++) {
                    var body = bodies[i];
                    Sleeping.set(body, false);
                    body.id = Common.nextId();
                  }
                }
              };
              Engine2.clear = function(engine) {
                var world = engine.world;
                Pairs.clear(engine.pairs);
                var broadphase = engine.broadphase;
                if (broadphase.controller) {
                  var bodies = Composite2.allBodies(world);
                  broadphase.controller.clear(broadphase);
                  broadphase.controller.update(broadphase, bodies, engine, true);
                }
              };
              Engine2._bodiesClearForces = function(bodies) {
                for (var i = 0; i < bodies.length; i++) {
                  var body = bodies[i];
                  body.force.x = 0;
                  body.force.y = 0;
                  body.torque = 0;
                }
              };
              Engine2._bodiesApplyGravity = function(bodies, gravity) {
                var gravityScale = typeof gravity.scale !== "undefined" ? gravity.scale : 1e-3;
                if (gravity.x === 0 && gravity.y === 0 || gravityScale === 0) {
                  return;
                }
                for (var i = 0; i < bodies.length; i++) {
                  var body = bodies[i];
                  if (body.isStatic || body.isSleeping)
                    continue;
                  body.force.y += body.mass * gravity.y * gravityScale;
                  body.force.x += body.mass * gravity.x * gravityScale;
                }
              };
              Engine2._bodiesUpdate = function(bodies, deltaTime, timeScale, correction, worldBounds) {
                for (var i = 0; i < bodies.length; i++) {
                  var body = bodies[i];
                  if (body.isStatic || body.isSleeping)
                    continue;
                  Body2.update(body, deltaTime, timeScale, correction);
                }
              };
            })();
          },
          function(module2, exports2, __webpack_require__) {
            var Metrics = {};
            module2.exports = Metrics;
            var Composite2 = __webpack_require__(5);
            var Common = __webpack_require__(0);
            (function() {
              Metrics.create = function(options) {
                var defaults = {
                  extended: false,
                  narrowDetections: 0,
                  narrowphaseTests: 0,
                  narrowReuse: 0,
                  narrowReuseCount: 0,
                  midphaseTests: 0,
                  broadphaseTests: 0,
                  narrowEff: 1e-4,
                  midEff: 1e-4,
                  broadEff: 1e-4,
                  collisions: 0,
                  buckets: 0,
                  bodies: 0,
                  pairs: 0
                };
                return Common.extend(defaults, false, options);
              };
              Metrics.reset = function(metrics) {
                if (metrics.extended) {
                  metrics.narrowDetections = 0;
                  metrics.narrowphaseTests = 0;
                  metrics.narrowReuse = 0;
                  metrics.narrowReuseCount = 0;
                  metrics.midphaseTests = 0;
                  metrics.broadphaseTests = 0;
                  metrics.narrowEff = 0;
                  metrics.midEff = 0;
                  metrics.broadEff = 0;
                  metrics.collisions = 0;
                  metrics.buckets = 0;
                  metrics.pairs = 0;
                  metrics.bodies = 0;
                }
              };
              Metrics.update = function(metrics, engine) {
                if (metrics.extended) {
                  var world = engine.world, bodies = Composite2.allBodies(world);
                  metrics.collisions = metrics.narrowDetections;
                  metrics.pairs = engine.pairs.list.length;
                  metrics.bodies = bodies.length;
                  metrics.midEff = (metrics.narrowDetections / (metrics.midphaseTests || 1)).toFixed(2);
                  metrics.narrowEff = (metrics.narrowDetections / (metrics.narrowphaseTests || 1)).toFixed(2);
                  metrics.broadEff = (1 - metrics.broadphaseTests / (bodies.length || 1)).toFixed(2);
                  metrics.narrowReuse = (metrics.narrowReuseCount / (metrics.narrowphaseTests || 1)).toFixed(2);
                }
              };
            })();
          },
          function(module2, exports2, __webpack_require__) {
            var Matter = module2.exports = __webpack_require__(25);
            Matter.Body = __webpack_require__(6);
            Matter.Composite = __webpack_require__(5);
            Matter.World = __webpack_require__(19);
            Matter.Contact = __webpack_require__(18);
            Matter.Detector = __webpack_require__(12);
            Matter.Grid = __webpack_require__(11);
            Matter.Pairs = __webpack_require__(20);
            Matter.Pair = __webpack_require__(9);
            Matter.Query = __webpack_require__(26);
            Matter.Resolver = __webpack_require__(21);
            Matter.SAT = __webpack_require__(13);
            Matter.Constraint = __webpack_require__(8);
            Matter.MouseConstraint = __webpack_require__(28);
            Matter.Common = __webpack_require__(0);
            Matter.Engine = __webpack_require__(22);
            Matter.Events = __webpack_require__(4);
            Matter.Mouse = __webpack_require__(14);
            Matter.Runner = __webpack_require__(29);
            Matter.Sleeping = __webpack_require__(7);
            Matter.Plugin = __webpack_require__(17);
            Matter.Metrics = __webpack_require__(23);
            Matter.Bodies = __webpack_require__(16);
            Matter.Composites = __webpack_require__(30);
            Matter.Axes = __webpack_require__(15);
            Matter.Bounds = __webpack_require__(1);
            Matter.Svg = __webpack_require__(31);
            Matter.Vector = __webpack_require__(2);
            Matter.Vertices = __webpack_require__(3);
            Matter.Render = __webpack_require__(10);
            Matter.RenderPixi = __webpack_require__(32);
            Matter.World.add = Matter.Composite.add;
            Matter.World.remove = Matter.Composite.remove;
            Matter.World.addComposite = Matter.Composite.addComposite;
            Matter.World.addBody = Matter.Composite.addBody;
            Matter.World.addConstraint = Matter.Composite.addConstraint;
            Matter.World.clear = Matter.Composite.clear;
            Matter.Engine.run = Matter.Runner.run;
          },
          function(module2, exports2, __webpack_require__) {
            var Matter = {};
            module2.exports = Matter;
            var Plugin = __webpack_require__(17);
            var Common = __webpack_require__(0);
            (function() {
              Matter.name = "matter-js";
              Matter.version = true ? "0.16.1" : void 0;
              Matter.uses = [];
              Matter.used = [];
              Matter.use = function() {
                Plugin.use(Matter, Array.prototype.slice.call(arguments));
              };
              Matter.before = function(path, func) {
                path = path.replace(/^Matter./, "");
                return Common.chainPathBefore(Matter, path, func);
              };
              Matter.after = function(path, func) {
                path = path.replace(/^Matter./, "");
                return Common.chainPathAfter(Matter, path, func);
              };
            })();
          },
          function(module2, exports2, __webpack_require__) {
            var Query = {};
            module2.exports = Query;
            var Vector6 = __webpack_require__(2);
            var SAT = __webpack_require__(13);
            var Bounds = __webpack_require__(1);
            var Bodies2 = __webpack_require__(16);
            var Vertices2 = __webpack_require__(3);
            (function() {
              Query.collides = function(body, bodies) {
                var collisions = [];
                for (var i = 0; i < bodies.length; i++) {
                  var bodyA = bodies[i];
                  if (Bounds.overlaps(bodyA.bounds, body.bounds)) {
                    for (var j = bodyA.parts.length === 1 ? 0 : 1; j < bodyA.parts.length; j++) {
                      var part = bodyA.parts[j];
                      if (Bounds.overlaps(part.bounds, body.bounds)) {
                        var collision = SAT.collides(part, body);
                        if (collision.collided) {
                          collisions.push(collision);
                          break;
                        }
                      }
                    }
                  }
                }
                return collisions;
              };
              Query.ray = function(bodies, startPoint, endPoint, rayWidth) {
                rayWidth = rayWidth || 1e-100;
                var rayAngle = Vector6.angle(startPoint, endPoint), rayLength = Vector6.magnitude(Vector6.sub(startPoint, endPoint)), rayX = (endPoint.x + startPoint.x) * 0.5, rayY = (endPoint.y + startPoint.y) * 0.5, ray = Bodies2.rectangle(rayX, rayY, rayLength, rayWidth, { angle: rayAngle }), collisions = Query.collides(ray, bodies);
                for (var i = 0; i < collisions.length; i += 1) {
                  var collision = collisions[i];
                  collision.body = collision.bodyB = collision.bodyA;
                }
                return collisions;
              };
              Query.region = function(bodies, bounds, outside) {
                var result = [];
                for (var i = 0; i < bodies.length; i++) {
                  var body = bodies[i], overlaps = Bounds.overlaps(body.bounds, bounds);
                  if (overlaps && !outside || !overlaps && outside)
                    result.push(body);
                }
                return result;
              };
              Query.point = function(bodies, point) {
                var result = [];
                for (var i = 0; i < bodies.length; i++) {
                  var body = bodies[i];
                  if (Bounds.contains(body.bounds, point)) {
                    for (var j = body.parts.length === 1 ? 0 : 1; j < body.parts.length; j++) {
                      var part = body.parts[j];
                      if (Bounds.contains(part.bounds, point) && Vertices2.contains(part.vertices, point)) {
                        result.push(body);
                        break;
                      }
                    }
                  }
                }
                return result;
              };
            })();
          },
          function(module2, exports2) {
            if (typeof __WEBPACK_EXTERNAL_MODULE__27__ === "undefined") {
              var e = new Error("Cannot find module 'undefined'");
              e.code = "MODULE_NOT_FOUND";
              throw e;
            }
            module2.exports = __WEBPACK_EXTERNAL_MODULE__27__;
          },
          function(module2, exports2, __webpack_require__) {
            var MouseConstraint = {};
            module2.exports = MouseConstraint;
            var Vertices2 = __webpack_require__(3);
            var Sleeping = __webpack_require__(7);
            var Mouse = __webpack_require__(14);
            var Events8 = __webpack_require__(4);
            var Detector = __webpack_require__(12);
            var Constraint = __webpack_require__(8);
            var Composite2 = __webpack_require__(5);
            var Common = __webpack_require__(0);
            var Bounds = __webpack_require__(1);
            (function() {
              MouseConstraint.create = function(engine, options) {
                var mouse2 = (engine ? engine.mouse : null) || (options ? options.mouse : null);
                if (!mouse2) {
                  if (engine && engine.render && engine.render.canvas) {
                    mouse2 = Mouse.create(engine.render.canvas);
                  } else if (options && options.element) {
                    mouse2 = Mouse.create(options.element);
                  } else {
                    mouse2 = Mouse.create();
                    Common.warn("MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected");
                  }
                }
                var constraint = Constraint.create({
                  label: "Mouse Constraint",
                  pointA: mouse2.position,
                  pointB: { x: 0, y: 0 },
                  length: 0.01,
                  stiffness: 0.1,
                  angularStiffness: 1,
                  render: {
                    strokeStyle: "#90EE90",
                    lineWidth: 3
                  }
                });
                var defaults = {
                  type: "mouseConstraint",
                  mouse: mouse2,
                  element: null,
                  body: null,
                  constraint,
                  collisionFilter: {
                    category: 1,
                    mask: 4294967295,
                    group: 0
                  }
                };
                var mouseConstraint = Common.extend(defaults, options);
                Events8.on(engine, "beforeUpdate", function() {
                  var allBodies = Composite2.allBodies(engine.world);
                  MouseConstraint.update(mouseConstraint, allBodies);
                  MouseConstraint._triggerEvents(mouseConstraint);
                });
                return mouseConstraint;
              };
              MouseConstraint.update = function(mouseConstraint, bodies) {
                var mouse2 = mouseConstraint.mouse, constraint = mouseConstraint.constraint, body = mouseConstraint.body;
                if (mouse2.button === 0) {
                  if (!constraint.bodyB) {
                    for (var i = 0; i < bodies.length; i++) {
                      body = bodies[i];
                      if (Bounds.contains(body.bounds, mouse2.position) && Detector.canCollide(body.collisionFilter, mouseConstraint.collisionFilter)) {
                        for (var j = body.parts.length > 1 ? 1 : 0; j < body.parts.length; j++) {
                          var part = body.parts[j];
                          if (Vertices2.contains(part.vertices, mouse2.position)) {
                            constraint.pointA = mouse2.position;
                            constraint.bodyB = mouseConstraint.body = body;
                            constraint.pointB = { x: mouse2.position.x - body.position.x, y: mouse2.position.y - body.position.y };
                            constraint.angleB = body.angle;
                            Sleeping.set(body, false);
                            Events8.trigger(mouseConstraint, "startdrag", { mouse: mouse2, body });
                            break;
                          }
                        }
                      }
                    }
                  } else {
                    Sleeping.set(constraint.bodyB, false);
                    constraint.pointA = mouse2.position;
                  }
                } else {
                  constraint.bodyB = mouseConstraint.body = null;
                  constraint.pointB = null;
                  if (body)
                    Events8.trigger(mouseConstraint, "enddrag", { mouse: mouse2, body });
                }
              };
              MouseConstraint._triggerEvents = function(mouseConstraint) {
                var mouse2 = mouseConstraint.mouse, mouseEvents = mouse2.sourceEvents;
                if (mouseEvents.mousemove)
                  Events8.trigger(mouseConstraint, "mousemove", { mouse: mouse2 });
                if (mouseEvents.mousedown)
                  Events8.trigger(mouseConstraint, "mousedown", { mouse: mouse2 });
                if (mouseEvents.mouseup)
                  Events8.trigger(mouseConstraint, "mouseup", { mouse: mouse2 });
                Mouse.clearSourceEvents(mouse2);
              };
            })();
          },
          function(module2, exports2, __webpack_require__) {
            var Runner2 = {};
            module2.exports = Runner2;
            var Events8 = __webpack_require__(4);
            var Engine2 = __webpack_require__(22);
            var Common = __webpack_require__(0);
            (function() {
              var _requestAnimationFrame, _cancelAnimationFrame;
              if (typeof window !== "undefined") {
                _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame;
                _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;
              }
              if (!_requestAnimationFrame) {
                var _frameTimeout;
                _requestAnimationFrame = function(callback) {
                  _frameTimeout = setTimeout(function() {
                    callback(Common.now());
                  }, 1e3 / 60);
                };
                _cancelAnimationFrame = function() {
                  clearTimeout(_frameTimeout);
                };
              }
              Runner2.create = function(options) {
                var defaults = {
                  fps: 60,
                  correction: 1,
                  deltaSampleSize: 60,
                  counterTimestamp: 0,
                  frameCounter: 0,
                  deltaHistory: [],
                  timePrev: null,
                  timeScalePrev: 1,
                  frameRequestId: null,
                  isFixed: false,
                  enabled: true
                };
                var runner = Common.extend(defaults, options);
                runner.delta = runner.delta || 1e3 / runner.fps;
                runner.deltaMin = runner.deltaMin || 1e3 / runner.fps;
                runner.deltaMax = runner.deltaMax || 1e3 / (runner.fps * 0.5);
                runner.fps = 1e3 / runner.delta;
                return runner;
              };
              Runner2.run = function(runner, engine) {
                if (typeof runner.positionIterations !== "undefined") {
                  engine = runner;
                  runner = Runner2.create();
                }
                (function render(time) {
                  runner.frameRequestId = _requestAnimationFrame(render);
                  if (time && runner.enabled) {
                    Runner2.tick(runner, engine, time);
                  }
                })();
                return runner;
              };
              Runner2.tick = function(runner, engine, time) {
                var timing = engine.timing, correction = 1, delta;
                var event = {
                  timestamp: timing.timestamp
                };
                Events8.trigger(runner, "beforeTick", event);
                Events8.trigger(engine, "beforeTick", event);
                if (runner.isFixed) {
                  delta = runner.delta;
                } else {
                  delta = time - runner.timePrev || runner.delta;
                  runner.timePrev = time;
                  runner.deltaHistory.push(delta);
                  runner.deltaHistory = runner.deltaHistory.slice(-runner.deltaSampleSize);
                  delta = Math.min.apply(null, runner.deltaHistory);
                  delta = delta < runner.deltaMin ? runner.deltaMin : delta;
                  delta = delta > runner.deltaMax ? runner.deltaMax : delta;
                  correction = delta / runner.delta;
                  runner.delta = delta;
                }
                if (runner.timeScalePrev !== 0)
                  correction *= timing.timeScale / runner.timeScalePrev;
                if (timing.timeScale === 0)
                  correction = 0;
                runner.timeScalePrev = timing.timeScale;
                runner.correction = correction;
                runner.frameCounter += 1;
                if (time - runner.counterTimestamp >= 1e3) {
                  runner.fps = runner.frameCounter * ((time - runner.counterTimestamp) / 1e3);
                  runner.counterTimestamp = time;
                  runner.frameCounter = 0;
                }
                Events8.trigger(runner, "tick", event);
                Events8.trigger(engine, "tick", event);
                if (engine.world.isModified && engine.render && engine.render.controller && engine.render.controller.clear) {
                  engine.render.controller.clear(engine.render);
                }
                Events8.trigger(runner, "beforeUpdate", event);
                Engine2.update(engine, delta, correction);
                Events8.trigger(runner, "afterUpdate", event);
                if (engine.render && engine.render.controller) {
                  Events8.trigger(runner, "beforeRender", event);
                  Events8.trigger(engine, "beforeRender", event);
                  engine.render.controller.world(engine.render);
                  Events8.trigger(runner, "afterRender", event);
                  Events8.trigger(engine, "afterRender", event);
                }
                Events8.trigger(runner, "afterTick", event);
                Events8.trigger(engine, "afterTick", event);
              };
              Runner2.stop = function(runner) {
                _cancelAnimationFrame(runner.frameRequestId);
              };
              Runner2.start = function(runner, engine) {
                Runner2.run(runner, engine);
              };
            })();
          },
          function(module2, exports2, __webpack_require__) {
            var Composites = {};
            module2.exports = Composites;
            var Composite2 = __webpack_require__(5);
            var Constraint = __webpack_require__(8);
            var Common = __webpack_require__(0);
            var Body2 = __webpack_require__(6);
            var Bodies2 = __webpack_require__(16);
            (function() {
              Composites.stack = function(xx, yy, columns, rows, columnGap, rowGap, callback) {
                var stack = Composite2.create({ label: "Stack" }), x = xx, y = yy, lastBody, i = 0;
                for (var row = 0; row < rows; row++) {
                  var maxHeight = 0;
                  for (var column = 0; column < columns; column++) {
                    var body = callback(x, y, column, row, lastBody, i);
                    if (body) {
                      var bodyHeight = body.bounds.max.y - body.bounds.min.y, bodyWidth = body.bounds.max.x - body.bounds.min.x;
                      if (bodyHeight > maxHeight)
                        maxHeight = bodyHeight;
                      Body2.translate(body, { x: bodyWidth * 0.5, y: bodyHeight * 0.5 });
                      x = body.bounds.max.x + columnGap;
                      Composite2.addBody(stack, body);
                      lastBody = body;
                      i += 1;
                    } else {
                      x += columnGap;
                    }
                  }
                  y += maxHeight + rowGap;
                  x = xx;
                }
                return stack;
              };
              Composites.chain = function(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {
                var bodies = composite.bodies;
                for (var i = 1; i < bodies.length; i++) {
                  var bodyA = bodies[i - 1], bodyB = bodies[i], bodyAHeight = bodyA.bounds.max.y - bodyA.bounds.min.y, bodyAWidth = bodyA.bounds.max.x - bodyA.bounds.min.x, bodyBHeight = bodyB.bounds.max.y - bodyB.bounds.min.y, bodyBWidth = bodyB.bounds.max.x - bodyB.bounds.min.x;
                  var defaults = {
                    bodyA,
                    pointA: { x: bodyAWidth * xOffsetA, y: bodyAHeight * yOffsetA },
                    bodyB,
                    pointB: { x: bodyBWidth * xOffsetB, y: bodyBHeight * yOffsetB }
                  };
                  var constraint = Common.extend(defaults, options);
                  Composite2.addConstraint(composite, Constraint.create(constraint));
                }
                composite.label += " Chain";
                return composite;
              };
              Composites.mesh = function(composite, columns, rows, crossBrace, options) {
                var bodies = composite.bodies, row, col, bodyA, bodyB, bodyC;
                for (row = 0; row < rows; row++) {
                  for (col = 1; col < columns; col++) {
                    bodyA = bodies[col - 1 + row * columns];
                    bodyB = bodies[col + row * columns];
                    Composite2.addConstraint(composite, Constraint.create(Common.extend({ bodyA, bodyB }, options)));
                  }
                  if (row > 0) {
                    for (col = 0; col < columns; col++) {
                      bodyA = bodies[col + (row - 1) * columns];
                      bodyB = bodies[col + row * columns];
                      Composite2.addConstraint(composite, Constraint.create(Common.extend({ bodyA, bodyB }, options)));
                      if (crossBrace && col > 0) {
                        bodyC = bodies[col - 1 + (row - 1) * columns];
                        Composite2.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyC, bodyB }, options)));
                      }
                      if (crossBrace && col < columns - 1) {
                        bodyC = bodies[col + 1 + (row - 1) * columns];
                        Composite2.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyC, bodyB }, options)));
                      }
                    }
                  }
                }
                composite.label += " Mesh";
                return composite;
              };
              Composites.pyramid = function(xx, yy, columns, rows, columnGap, rowGap, callback) {
                return Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y, column, row, lastBody, i) {
                  var actualRows = Math.min(rows, Math.ceil(columns / 2)), lastBodyWidth = lastBody ? lastBody.bounds.max.x - lastBody.bounds.min.x : 0;
                  if (row > actualRows)
                    return;
                  row = actualRows - row;
                  var start = row, end = columns - 1 - row;
                  if (column < start || column > end)
                    return;
                  if (i === 1) {
                    Body2.translate(lastBody, { x: (column + (columns % 2 === 1 ? 1 : -1)) * lastBodyWidth, y: 0 });
                  }
                  var xOffset = lastBody ? column * lastBodyWidth : 0;
                  return callback(xx + xOffset + column * columnGap, y, column, row, lastBody, i);
                });
              };
              Composites.newtonsCradle = function(xx, yy, number, size2, length) {
                var newtonsCradle = Composite2.create({ label: "Newtons Cradle" });
                for (var i = 0; i < number; i++) {
                  var separation = 1.9, circle = Bodies2.circle(xx + i * (size2 * separation), yy + length, size2, { inertia: Infinity, restitution: 1, friction: 0, frictionAir: 1e-4, slop: 1 }), constraint = Constraint.create({ pointA: { x: xx + i * (size2 * separation), y: yy }, bodyB: circle });
                  Composite2.addBody(newtonsCradle, circle);
                  Composite2.addConstraint(newtonsCradle, constraint);
                }
                return newtonsCradle;
              };
              Composites.car = function(xx, yy, width, height, wheelSize) {
                var group = Body2.nextGroup(true), wheelBase = 20, wheelAOffset = -width * 0.5 + wheelBase, wheelBOffset = width * 0.5 - wheelBase, wheelYOffset = 0;
                var car = Composite2.create({ label: "Car" }), body = Bodies2.rectangle(xx, yy, width, height, {
                  collisionFilter: {
                    group
                  },
                  chamfer: {
                    radius: height * 0.5
                  },
                  density: 2e-4
                });
                var wheelA = Bodies2.circle(xx + wheelAOffset, yy + wheelYOffset, wheelSize, {
                  collisionFilter: {
                    group
                  },
                  friction: 0.8
                });
                var wheelB = Bodies2.circle(xx + wheelBOffset, yy + wheelYOffset, wheelSize, {
                  collisionFilter: {
                    group
                  },
                  friction: 0.8
                });
                var axelA = Constraint.create({
                  bodyB: body,
                  pointB: { x: wheelAOffset, y: wheelYOffset },
                  bodyA: wheelA,
                  stiffness: 1,
                  length: 0
                });
                var axelB = Constraint.create({
                  bodyB: body,
                  pointB: { x: wheelBOffset, y: wheelYOffset },
                  bodyA: wheelB,
                  stiffness: 1,
                  length: 0
                });
                Composite2.addBody(car, body);
                Composite2.addBody(car, wheelA);
                Composite2.addBody(car, wheelB);
                Composite2.addConstraint(car, axelA);
                Composite2.addConstraint(car, axelB);
                return car;
              };
              Composites.softBody = function(xx, yy, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {
                particleOptions = Common.extend({ inertia: Infinity }, particleOptions);
                constraintOptions = Common.extend({ stiffness: 0.2, render: { type: "line", anchors: false } }, constraintOptions);
                var softBody = Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y) {
                  return Bodies2.circle(x, y, particleRadius, particleOptions);
                });
                Composites.mesh(softBody, columns, rows, crossBrace, constraintOptions);
                softBody.label = "Soft Body";
                return softBody;
              };
            })();
          },
          function(module2, exports2, __webpack_require__) {
            var Svg = {};
            module2.exports = Svg;
            var Bounds = __webpack_require__(1);
            var Common = __webpack_require__(0);
            (function() {
              Svg.pathToVertices = function(path, sampleLength) {
                if (typeof window !== "undefined" && !("SVGPathSeg" in window)) {
                  Common.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.");
                }
                var i, il, total, point, segment, segments, segmentsQueue, lastSegment, lastPoint, segmentIndex, points = [], lx, ly, length = 0, x = 0, y = 0;
                sampleLength = sampleLength || 15;
                var addPoint = function(px2, py2, pathSegType) {
                  var isRelative = pathSegType % 2 === 1 && pathSegType > 1;
                  if (!lastPoint || px2 != lastPoint.x || py2 != lastPoint.y) {
                    if (lastPoint && isRelative) {
                      lx = lastPoint.x;
                      ly = lastPoint.y;
                    } else {
                      lx = 0;
                      ly = 0;
                    }
                    var point2 = {
                      x: lx + px2,
                      y: ly + py2
                    };
                    if (isRelative || !lastPoint) {
                      lastPoint = point2;
                    }
                    points.push(point2);
                    x = lx + px2;
                    y = ly + py2;
                  }
                };
                var addSegmentPoint = function(segment2) {
                  var segType = segment2.pathSegTypeAsLetter.toUpperCase();
                  if (segType === "Z")
                    return;
                  switch (segType) {
                    case "M":
                    case "L":
                    case "T":
                    case "C":
                    case "S":
                    case "Q":
                      x = segment2.x;
                      y = segment2.y;
                      break;
                    case "H":
                      x = segment2.x;
                      break;
                    case "V":
                      y = segment2.y;
                      break;
                  }
                  addPoint(x, y, segment2.pathSegType);
                };
                Svg._svgPathToAbsolute(path);
                total = path.getTotalLength();
                segments = [];
                for (i = 0; i < path.pathSegList.numberOfItems; i += 1)
                  segments.push(path.pathSegList.getItem(i));
                segmentsQueue = segments.concat();
                while (length < total) {
                  segmentIndex = path.getPathSegAtLength(length);
                  segment = segments[segmentIndex];
                  if (segment != lastSegment) {
                    while (segmentsQueue.length && segmentsQueue[0] != segment)
                      addSegmentPoint(segmentsQueue.shift());
                    lastSegment = segment;
                  }
                  switch (segment.pathSegTypeAsLetter.toUpperCase()) {
                    case "C":
                    case "T":
                    case "S":
                    case "Q":
                    case "A":
                      point = path.getPointAtLength(length);
                      addPoint(point.x, point.y, 0);
                      break;
                  }
                  length += sampleLength;
                }
                for (i = 0, il = segmentsQueue.length; i < il; ++i)
                  addSegmentPoint(segmentsQueue[i]);
                return points;
              };
              Svg._svgPathToAbsolute = function(path) {
                var x0, y0, x1, y1, x2, y2, segs = path.pathSegList, x = 0, y = 0, len = segs.numberOfItems;
                for (var i = 0; i < len; ++i) {
                  var seg = segs.getItem(i), segType = seg.pathSegTypeAsLetter;
                  if (/[MLHVCSQTA]/.test(segType)) {
                    if ("x" in seg)
                      x = seg.x;
                    if ("y" in seg)
                      y = seg.y;
                  } else {
                    if ("x1" in seg)
                      x1 = x + seg.x1;
                    if ("x2" in seg)
                      x2 = x + seg.x2;
                    if ("y1" in seg)
                      y1 = y + seg.y1;
                    if ("y2" in seg)
                      y2 = y + seg.y2;
                    if ("x" in seg)
                      x += seg.x;
                    if ("y" in seg)
                      y += seg.y;
                    switch (segType) {
                      case "m":
                        segs.replaceItem(path.createSVGPathSegMovetoAbs(x, y), i);
                        break;
                      case "l":
                        segs.replaceItem(path.createSVGPathSegLinetoAbs(x, y), i);
                        break;
                      case "h":
                        segs.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x), i);
                        break;
                      case "v":
                        segs.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y), i);
                        break;
                      case "c":
                        segs.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i);
                        break;
                      case "s":
                        segs.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i);
                        break;
                      case "q":
                        segs.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i);
                        break;
                      case "t":
                        segs.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i);
                        break;
                      case "a":
                        segs.replaceItem(path.createSVGPathSegArcAbs(x, y, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i);
                        break;
                      case "z":
                      case "Z":
                        x = x0;
                        y = y0;
                        break;
                    }
                  }
                  if (segType == "M" || segType == "m") {
                    x0 = x;
                    y0 = y;
                  }
                }
              };
            })();
          },
          function(module2, exports2, __webpack_require__) {
            var RenderPixi = {};
            module2.exports = RenderPixi;
            var Bounds = __webpack_require__(1);
            var Composite2 = __webpack_require__(5);
            var Common = __webpack_require__(0);
            var Events8 = __webpack_require__(4);
            var Vector6 = __webpack_require__(2);
            (function() {
              var _requestAnimationFrame, _cancelAnimationFrame;
              if (typeof window !== "undefined") {
                _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
                  window.setTimeout(function() {
                    callback(Common.now());
                  }, 1e3 / 60);
                };
                _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;
              }
              RenderPixi.create = function(options) {
                Common.warn("RenderPixi.create: Matter.RenderPixi is deprecated (see docs)");
                var defaults = {
                  controller: RenderPixi,
                  engine: null,
                  element: null,
                  frameRequestId: null,
                  canvas: null,
                  renderer: null,
                  container: null,
                  spriteContainer: null,
                  pixiOptions: null,
                  options: {
                    width: 800,
                    height: 600,
                    background: "#fafafa",
                    wireframeBackground: "#222",
                    hasBounds: false,
                    enabled: true,
                    wireframes: true,
                    showSleeping: true,
                    showDebug: false,
                    showBroadphase: false,
                    showBounds: false,
                    showVelocity: false,
                    showCollisions: false,
                    showAxes: false,
                    showPositions: false,
                    showAngleIndicator: false,
                    showIds: false,
                    showShadows: false
                  }
                };
                var render = Common.extend(defaults, options), transparent = !render.options.wireframes && render.options.background === "transparent";
                render.pixiOptions = render.pixiOptions || {
                  view: render.canvas,
                  transparent,
                  antialias: true,
                  backgroundColor: options.background
                };
                render.mouse = options.mouse;
                render.engine = options.engine;
                render.renderer = render.renderer || new PIXI.WebGLRenderer(render.options.width, render.options.height, render.pixiOptions);
                render.container = render.container || new PIXI.Container();
                render.spriteContainer = render.spriteContainer || new PIXI.Container();
                render.canvas = render.canvas || render.renderer.view;
                render.bounds = render.bounds || {
                  min: {
                    x: 0,
                    y: 0
                  },
                  max: {
                    x: render.options.width,
                    y: render.options.height
                  }
                };
                Events8.on(render.engine, "beforeUpdate", function() {
                  RenderPixi.clear(render);
                });
                render.textures = {};
                render.sprites = {};
                render.primitives = {};
                render.container.addChild(render.spriteContainer);
                if (Common.isElement(render.element)) {
                  render.element.appendChild(render.canvas);
                } else {
                  Common.warn('No "render.element" passed, "render.canvas" was not inserted into document.');
                }
                render.canvas.oncontextmenu = function() {
                  return false;
                };
                render.canvas.onselectstart = function() {
                  return false;
                };
                return render;
              };
              RenderPixi.run = function(render) {
                (function loop(time) {
                  render.frameRequestId = _requestAnimationFrame(loop);
                  RenderPixi.world(render);
                })();
              };
              RenderPixi.stop = function(render) {
                _cancelAnimationFrame(render.frameRequestId);
              };
              RenderPixi.clear = function(render) {
                var container = render.container, spriteContainer = render.spriteContainer;
                while (container.children[0]) {
                  container.removeChild(container.children[0]);
                }
                while (spriteContainer.children[0]) {
                  spriteContainer.removeChild(spriteContainer.children[0]);
                }
                var bgSprite = render.sprites["bg-0"];
                render.textures = {};
                render.sprites = {};
                render.primitives = {};
                render.sprites["bg-0"] = bgSprite;
                if (bgSprite)
                  container.addChildAt(bgSprite, 0);
                render.container.addChild(render.spriteContainer);
                render.currentBackground = null;
                container.scale.set(1, 1);
                container.position.set(0, 0);
              };
              RenderPixi.setBackground = function(render, background) {
                if (render.currentBackground !== background) {
                  var isColor = background.indexOf && background.indexOf("#") !== -1, bgSprite = render.sprites["bg-0"];
                  if (isColor) {
                    var color = Common.colorToNumber(background);
                    render.renderer.backgroundColor = color;
                    if (bgSprite)
                      render.container.removeChild(bgSprite);
                  } else {
                    if (!bgSprite) {
                      var texture = _getTexture(render, background);
                      bgSprite = render.sprites["bg-0"] = new PIXI.Sprite(texture);
                      bgSprite.position.x = 0;
                      bgSprite.position.y = 0;
                      render.container.addChildAt(bgSprite, 0);
                    }
                  }
                  render.currentBackground = background;
                }
              };
              RenderPixi.world = function(render) {
                var engine = render.engine, world = engine.world, renderer = render.renderer, container = render.container, options = render.options, bodies = Composite2.allBodies(world), allConstraints = Composite2.allConstraints(world), constraints = [], i;
                if (options.wireframes) {
                  RenderPixi.setBackground(render, options.wireframeBackground);
                } else {
                  RenderPixi.setBackground(render, options.background);
                }
                var boundsWidth = render.bounds.max.x - render.bounds.min.x, boundsHeight = render.bounds.max.y - render.bounds.min.y, boundsScaleX = boundsWidth / render.options.width, boundsScaleY = boundsHeight / render.options.height;
                if (options.hasBounds) {
                  for (i = 0; i < bodies.length; i++) {
                    var body = bodies[i];
                    body.render.sprite.visible = Bounds.overlaps(body.bounds, render.bounds);
                  }
                  for (i = 0; i < allConstraints.length; i++) {
                    var constraint = allConstraints[i], bodyA = constraint.bodyA, bodyB = constraint.bodyB, pointAWorld = constraint.pointA, pointBWorld = constraint.pointB;
                    if (bodyA)
                      pointAWorld = Vector6.add(bodyA.position, constraint.pointA);
                    if (bodyB)
                      pointBWorld = Vector6.add(bodyB.position, constraint.pointB);
                    if (!pointAWorld || !pointBWorld)
                      continue;
                    if (Bounds.contains(render.bounds, pointAWorld) || Bounds.contains(render.bounds, pointBWorld))
                      constraints.push(constraint);
                  }
                  container.scale.set(1 / boundsScaleX, 1 / boundsScaleY);
                  container.position.set(-render.bounds.min.x * (1 / boundsScaleX), -render.bounds.min.y * (1 / boundsScaleY));
                } else {
                  constraints = allConstraints;
                }
                for (i = 0; i < bodies.length; i++)
                  RenderPixi.body(render, bodies[i]);
                for (i = 0; i < constraints.length; i++)
                  RenderPixi.constraint(render, constraints[i]);
                renderer.render(container);
              };
              RenderPixi.constraint = function(render, constraint) {
                var engine = render.engine, bodyA = constraint.bodyA, bodyB = constraint.bodyB, pointA = constraint.pointA, pointB = constraint.pointB, container = render.container, constraintRender = constraint.render, primitiveId = "c-" + constraint.id, primitive = render.primitives[primitiveId];
                if (!primitive)
                  primitive = render.primitives[primitiveId] = new PIXI.Graphics();
                if (!constraintRender.visible || !constraint.pointA || !constraint.pointB) {
                  primitive.clear();
                  return;
                }
                if (Common.indexOf(container.children, primitive) === -1)
                  container.addChild(primitive);
                primitive.clear();
                primitive.beginFill(0, 0);
                primitive.lineStyle(constraintRender.lineWidth, Common.colorToNumber(constraintRender.strokeStyle), 1);
                if (bodyA) {
                  primitive.moveTo(bodyA.position.x + pointA.x, bodyA.position.y + pointA.y);
                } else {
                  primitive.moveTo(pointA.x, pointA.y);
                }
                if (bodyB) {
                  primitive.lineTo(bodyB.position.x + pointB.x, bodyB.position.y + pointB.y);
                } else {
                  primitive.lineTo(pointB.x, pointB.y);
                }
                primitive.endFill();
              };
              RenderPixi.body = function(render, body) {
                var engine = render.engine, bodyRender = body.render;
                if (!bodyRender.visible)
                  return;
                if (bodyRender.sprite && bodyRender.sprite.texture) {
                  var spriteId = "b-" + body.id, sprite = render.sprites[spriteId], spriteContainer = render.spriteContainer;
                  if (!sprite)
                    sprite = render.sprites[spriteId] = _createBodySprite(render, body);
                  if (Common.indexOf(spriteContainer.children, sprite) === -1)
                    spriteContainer.addChild(sprite);
                  sprite.position.x = body.position.x;
                  sprite.position.y = body.position.y;
                  sprite.rotation = body.angle;
                  sprite.scale.x = bodyRender.sprite.xScale || 1;
                  sprite.scale.y = bodyRender.sprite.yScale || 1;
                } else {
                  var primitiveId = "b-" + body.id, primitive = render.primitives[primitiveId], container = render.container;
                  if (!primitive) {
                    primitive = render.primitives[primitiveId] = _createBodyPrimitive(render, body);
                    primitive.initialAngle = body.angle;
                  }
                  if (Common.indexOf(container.children, primitive) === -1)
                    container.addChild(primitive);
                  primitive.position.x = body.position.x;
                  primitive.position.y = body.position.y;
                  primitive.rotation = body.angle - primitive.initialAngle;
                }
              };
              var _createBodySprite = function(render, body) {
                var bodyRender = body.render, texturePath = bodyRender.sprite.texture, texture = _getTexture(render, texturePath), sprite = new PIXI.Sprite(texture);
                sprite.anchor.x = body.render.sprite.xOffset;
                sprite.anchor.y = body.render.sprite.yOffset;
                return sprite;
              };
              var _createBodyPrimitive = function(render, body) {
                var bodyRender = body.render, options = render.options, primitive = new PIXI.Graphics(), fillStyle = Common.colorToNumber(bodyRender.fillStyle), strokeStyle = Common.colorToNumber(bodyRender.strokeStyle), strokeStyleIndicator = Common.colorToNumber(bodyRender.strokeStyle), strokeStyleWireframe = Common.colorToNumber("#bbb"), strokeStyleWireframeIndicator = Common.colorToNumber("#CD5C5C"), part;
                primitive.clear();
                for (var k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {
                  part = body.parts[k];
                  if (!options.wireframes) {
                    primitive.beginFill(fillStyle, 1);
                    primitive.lineStyle(bodyRender.lineWidth, strokeStyle, 1);
                  } else {
                    primitive.beginFill(0, 0);
                    primitive.lineStyle(1, strokeStyleWireframe, 1);
                  }
                  primitive.moveTo(part.vertices[0].x - body.position.x, part.vertices[0].y - body.position.y);
                  for (var j = 1; j < part.vertices.length; j++) {
                    primitive.lineTo(part.vertices[j].x - body.position.x, part.vertices[j].y - body.position.y);
                  }
                  primitive.lineTo(part.vertices[0].x - body.position.x, part.vertices[0].y - body.position.y);
                  primitive.endFill();
                  if (options.showAngleIndicator || options.showAxes) {
                    primitive.beginFill(0, 0);
                    if (options.wireframes) {
                      primitive.lineStyle(1, strokeStyleWireframeIndicator, 1);
                    } else {
                      primitive.lineStyle(1, strokeStyleIndicator);
                    }
                    primitive.moveTo(part.position.x - body.position.x, part.position.y - body.position.y);
                    primitive.lineTo((part.vertices[0].x + part.vertices[part.vertices.length - 1].x) / 2 - body.position.x, (part.vertices[0].y + part.vertices[part.vertices.length - 1].y) / 2 - body.position.y);
                    primitive.endFill();
                  }
                }
                return primitive;
              };
              var _getTexture = function(render, imagePath) {
                var texture = render.textures[imagePath];
                if (!texture)
                  texture = render.textures[imagePath] = PIXI.Texture.fromImage(imagePath);
                return texture;
              };
            })();
          }
        ]);
      });
    }
  });

  // node_modules/three/build/three.module.js
  var REVISION = "127";
  var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
  var TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
  var CullFaceNone = 0;
  var CullFaceBack = 1;
  var CullFaceFront = 2;
  var PCFShadowMap = 1;
  var PCFSoftShadowMap = 2;
  var VSMShadowMap = 3;
  var FrontSide = 0;
  var BackSide = 1;
  var DoubleSide = 2;
  var FlatShading = 1;
  var NoBlending = 0;
  var NormalBlending = 1;
  var AdditiveBlending = 2;
  var SubtractiveBlending = 3;
  var MultiplyBlending = 4;
  var CustomBlending = 5;
  var AddEquation = 100;
  var SubtractEquation = 101;
  var ReverseSubtractEquation = 102;
  var MinEquation = 103;
  var MaxEquation = 104;
  var ZeroFactor = 200;
  var OneFactor = 201;
  var SrcColorFactor = 202;
  var OneMinusSrcColorFactor = 203;
  var SrcAlphaFactor = 204;
  var OneMinusSrcAlphaFactor = 205;
  var DstAlphaFactor = 206;
  var OneMinusDstAlphaFactor = 207;
  var DstColorFactor = 208;
  var OneMinusDstColorFactor = 209;
  var SrcAlphaSaturateFactor = 210;
  var NeverDepth = 0;
  var AlwaysDepth = 1;
  var LessDepth = 2;
  var LessEqualDepth = 3;
  var EqualDepth = 4;
  var GreaterEqualDepth = 5;
  var GreaterDepth = 6;
  var NotEqualDepth = 7;
  var MultiplyOperation = 0;
  var MixOperation = 1;
  var AddOperation = 2;
  var NoToneMapping = 0;
  var LinearToneMapping = 1;
  var ReinhardToneMapping = 2;
  var CineonToneMapping = 3;
  var ACESFilmicToneMapping = 4;
  var CustomToneMapping = 5;
  var UVMapping = 300;
  var CubeReflectionMapping = 301;
  var CubeRefractionMapping = 302;
  var EquirectangularReflectionMapping = 303;
  var EquirectangularRefractionMapping = 304;
  var CubeUVReflectionMapping = 306;
  var CubeUVRefractionMapping = 307;
  var RepeatWrapping = 1e3;
  var ClampToEdgeWrapping = 1001;
  var MirroredRepeatWrapping = 1002;
  var NearestFilter = 1003;
  var NearestMipmapNearestFilter = 1004;
  var NearestMipmapLinearFilter = 1005;
  var LinearFilter = 1006;
  var LinearMipmapNearestFilter = 1007;
  var LinearMipmapLinearFilter = 1008;
  var UnsignedByteType = 1009;
  var ByteType = 1010;
  var ShortType = 1011;
  var UnsignedShortType = 1012;
  var IntType = 1013;
  var UnsignedIntType = 1014;
  var FloatType = 1015;
  var HalfFloatType = 1016;
  var UnsignedShort4444Type = 1017;
  var UnsignedShort5551Type = 1018;
  var UnsignedShort565Type = 1019;
  var UnsignedInt248Type = 1020;
  var AlphaFormat = 1021;
  var RGBFormat = 1022;
  var RGBAFormat = 1023;
  var LuminanceFormat = 1024;
  var LuminanceAlphaFormat = 1025;
  var DepthFormat = 1026;
  var DepthStencilFormat = 1027;
  var RedFormat = 1028;
  var RedIntegerFormat = 1029;
  var RGFormat = 1030;
  var RGIntegerFormat = 1031;
  var RGBIntegerFormat = 1032;
  var RGBAIntegerFormat = 1033;
  var RGB_S3TC_DXT1_Format = 33776;
  var RGBA_S3TC_DXT1_Format = 33777;
  var RGBA_S3TC_DXT3_Format = 33778;
  var RGBA_S3TC_DXT5_Format = 33779;
  var RGB_PVRTC_4BPPV1_Format = 35840;
  var RGB_PVRTC_2BPPV1_Format = 35841;
  var RGBA_PVRTC_4BPPV1_Format = 35842;
  var RGBA_PVRTC_2BPPV1_Format = 35843;
  var RGB_ETC1_Format = 36196;
  var RGB_ETC2_Format = 37492;
  var RGBA_ETC2_EAC_Format = 37496;
  var RGBA_ASTC_4x4_Format = 37808;
  var RGBA_ASTC_5x4_Format = 37809;
  var RGBA_ASTC_5x5_Format = 37810;
  var RGBA_ASTC_6x5_Format = 37811;
  var RGBA_ASTC_6x6_Format = 37812;
  var RGBA_ASTC_8x5_Format = 37813;
  var RGBA_ASTC_8x6_Format = 37814;
  var RGBA_ASTC_8x8_Format = 37815;
  var RGBA_ASTC_10x5_Format = 37816;
  var RGBA_ASTC_10x6_Format = 37817;
  var RGBA_ASTC_10x8_Format = 37818;
  var RGBA_ASTC_10x10_Format = 37819;
  var RGBA_ASTC_12x10_Format = 37820;
  var RGBA_ASTC_12x12_Format = 37821;
  var RGBA_BPTC_Format = 36492;
  var SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
  var SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
  var SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
  var SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
  var SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
  var SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
  var SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
  var SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
  var SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
  var SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
  var SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
  var SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
  var SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
  var SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
  var LoopOnce = 2200;
  var LoopRepeat = 2201;
  var LoopPingPong = 2202;
  var InterpolateDiscrete = 2300;
  var InterpolateLinear = 2301;
  var InterpolateSmooth = 2302;
  var ZeroCurvatureEnding = 2400;
  var ZeroSlopeEnding = 2401;
  var WrapAroundEnding = 2402;
  var NormalAnimationBlendMode = 2500;
  var AdditiveAnimationBlendMode = 2501;
  var TrianglesDrawMode = 0;
  var TriangleStripDrawMode = 1;
  var TriangleFanDrawMode = 2;
  var LinearEncoding = 3e3;
  var sRGBEncoding = 3001;
  var GammaEncoding = 3007;
  var RGBEEncoding = 3002;
  var LogLuvEncoding = 3003;
  var RGBM7Encoding = 3004;
  var RGBM16Encoding = 3005;
  var RGBDEncoding = 3006;
  var BasicDepthPacking = 3200;
  var RGBADepthPacking = 3201;
  var TangentSpaceNormalMap = 0;
  var ObjectSpaceNormalMap = 1;
  var KeepStencilOp = 7680;
  var AlwaysStencilFunc = 519;
  var StaticDrawUsage = 35044;
  var DynamicDrawUsage = 35048;
  var GLSL3 = "300 es";
  function EventDispatcher() {
  }
  Object.assign(EventDispatcher.prototype, {
    addEventListener: function(type, listener) {
      if (this._listeners === void 0)
        this._listeners = {};
      const listeners = this._listeners;
      if (listeners[type] === void 0) {
        listeners[type] = [];
      }
      if (listeners[type].indexOf(listener) === -1) {
        listeners[type].push(listener);
      }
    },
    hasEventListener: function(type, listener) {
      if (this._listeners === void 0)
        return false;
      const listeners = this._listeners;
      return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
    },
    removeEventListener: function(type, listener) {
      if (this._listeners === void 0)
        return;
      const listeners = this._listeners;
      const listenerArray = listeners[type];
      if (listenerArray !== void 0) {
        const index = listenerArray.indexOf(listener);
        if (index !== -1) {
          listenerArray.splice(index, 1);
        }
      }
    },
    dispatchEvent: function(event) {
      if (this._listeners === void 0)
        return;
      const listeners = this._listeners;
      const listenerArray = listeners[event.type];
      if (listenerArray !== void 0) {
        event.target = this;
        const array = listenerArray.slice(0);
        for (let i = 0, l = array.length; i < l; i++) {
          array[i].call(this, event);
        }
        event.target = null;
      }
    }
  });
  var _lut = [];
  for (let i = 0; i < 256; i++) {
    _lut[i] = (i < 16 ? "0" : "") + i.toString(16);
  }
  var _seed = 1234567;
  var MathUtils = {
    DEG2RAD: Math.PI / 180,
    RAD2DEG: 180 / Math.PI,
    generateUUID: function() {
      const d0 = Math.random() * 4294967295 | 0;
      const d1 = Math.random() * 4294967295 | 0;
      const d2 = Math.random() * 4294967295 | 0;
      const d3 = Math.random() * 4294967295 | 0;
      const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
      return uuid.toUpperCase();
    },
    clamp: function(value, min, max) {
      return Math.max(min, Math.min(max, value));
    },
    euclideanModulo: function(n, m) {
      return (n % m + m) % m;
    },
    mapLinear: function(x, a1, a2, b1, b2) {
      return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
    },
    inverseLerp: function(x, y, value) {
      if (x !== y) {
        return (value - x) / (y - x);
      } else {
        return 0;
      }
    },
    lerp: function(x, y, t) {
      return (1 - t) * x + t * y;
    },
    damp: function(x, y, lambda, dt) {
      return MathUtils.lerp(x, y, 1 - Math.exp(-lambda * dt));
    },
    pingpong: function(x, length = 1) {
      return length - Math.abs(MathUtils.euclideanModulo(x, length * 2) - length);
    },
    smoothstep: function(x, min, max) {
      if (x <= min)
        return 0;
      if (x >= max)
        return 1;
      x = (x - min) / (max - min);
      return x * x * (3 - 2 * x);
    },
    smootherstep: function(x, min, max) {
      if (x <= min)
        return 0;
      if (x >= max)
        return 1;
      x = (x - min) / (max - min);
      return x * x * x * (x * (x * 6 - 15) + 10);
    },
    randInt: function(low, high) {
      return low + Math.floor(Math.random() * (high - low + 1));
    },
    randFloat: function(low, high) {
      return low + Math.random() * (high - low);
    },
    randFloatSpread: function(range) {
      return range * (0.5 - Math.random());
    },
    seededRandom: function(s) {
      if (s !== void 0)
        _seed = s % 2147483647;
      _seed = _seed * 16807 % 2147483647;
      return (_seed - 1) / 2147483646;
    },
    degToRad: function(degrees) {
      return degrees * MathUtils.DEG2RAD;
    },
    radToDeg: function(radians) {
      return radians * MathUtils.RAD2DEG;
    },
    isPowerOfTwo: function(value) {
      return (value & value - 1) === 0 && value !== 0;
    },
    ceilPowerOfTwo: function(value) {
      return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
    },
    floorPowerOfTwo: function(value) {
      return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
    },
    setQuaternionFromProperEuler: function(q, a, b2, c, order) {
      const cos = Math.cos;
      const sin = Math.sin;
      const c2 = cos(b2 / 2);
      const s2 = sin(b2 / 2);
      const c13 = cos((a + c) / 2);
      const s13 = sin((a + c) / 2);
      const c1_3 = cos((a - c) / 2);
      const s1_3 = sin((a - c) / 2);
      const c3_1 = cos((c - a) / 2);
      const s3_1 = sin((c - a) / 2);
      switch (order) {
        case "XYX":
          q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
          break;
        case "YZY":
          q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
          break;
        case "ZXZ":
          q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
          break;
        case "XZX":
          q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
          break;
        case "YXY":
          q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
          break;
        case "ZYZ":
          q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
          break;
        default:
          console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
      }
    }
  };
  var Vector2 = class {
    constructor(x = 0, y = 0) {
      this.x = x;
      this.y = y;
    }
    get width() {
      return this.x;
    }
    set width(value) {
      this.x = value;
    }
    get height() {
      return this.y;
    }
    set height(value) {
      this.y = value;
    }
    set(x, y) {
      this.x = x;
      this.y = y;
      return this;
    }
    setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      return this;
    }
    setX(x) {
      this.x = x;
      return this;
    }
    setY(y) {
      this.y = y;
      return this;
    }
    setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        default:
          throw new Error("index is out of range: " + index);
      }
      return this;
    }
    getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + index);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(v) {
      this.x = v.x;
      this.y = v.y;
      return this;
    }
    add(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
        return this.addVectors(v, w);
      }
      this.x += v.x;
      this.y += v.y;
      return this;
    }
    addScalar(s) {
      this.x += s;
      this.y += s;
      return this;
    }
    addVectors(a, b2) {
      this.x = a.x + b2.x;
      this.y = a.y + b2.y;
      return this;
    }
    addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      return this;
    }
    sub(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
        return this.subVectors(v, w);
      }
      this.x -= v.x;
      this.y -= v.y;
      return this;
    }
    subScalar(s) {
      this.x -= s;
      this.y -= s;
      return this;
    }
    subVectors(a, b2) {
      this.x = a.x - b2.x;
      this.y = a.y - b2.y;
      return this;
    }
    multiply(v) {
      this.x *= v.x;
      this.y *= v.y;
      return this;
    }
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      return this;
    }
    divide(v) {
      this.x /= v.x;
      this.y /= v.y;
      return this;
    }
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    applyMatrix3(m) {
      const x = this.x, y = this.y;
      const e = m.elements;
      this.x = e[0] * x + e[3] * y + e[6];
      this.y = e[1] * x + e[4] * y + e[7];
      return this;
    }
    min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      return this;
    }
    max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      return this;
    }
    clamp(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      return this;
    }
    clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      return this;
    }
    clampLength(min, max) {
      const length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      return this;
    }
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      return this;
    }
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    }
    roundToZero() {
      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
      return this;
    }
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    }
    dot(v) {
      return this.x * v.x + this.y * v.y;
    }
    cross(v) {
      return this.x * v.y - this.y * v.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      const angle = Math.atan2(-this.y, -this.x) + Math.PI;
      return angle;
    }
    distanceTo(v) {
      return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
      const dx = this.x - v.x, dy = this.y - v.y;
      return dx * dx + dy * dy;
    }
    manhattanDistanceTo(v) {
      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
    }
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      return this;
    }
    lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      return this;
    }
    equals(v) {
      return v.x === this.x && v.y === this.y;
    }
    fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      return array;
    }
    fromBufferAttribute(attribute, index, offset) {
      if (offset !== void 0) {
        console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
      }
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      return this;
    }
    rotateAround(center, angle) {
      const c = Math.cos(angle), s = Math.sin(angle);
      const x = this.x - center.x;
      const y = this.y - center.y;
      this.x = x * c - y * s + center.x;
      this.y = x * s + y * c + center.y;
      return this;
    }
    random() {
      this.x = Math.random();
      this.y = Math.random();
      return this;
    }
  };
  Vector2.prototype.isVector2 = true;
  var Matrix3 = class {
    constructor() {
      this.elements = [
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ];
      if (arguments.length > 0) {
        console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
      }
    }
    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
      const te = this.elements;
      te[0] = n11;
      te[1] = n21;
      te[2] = n31;
      te[3] = n12;
      te[4] = n22;
      te[5] = n32;
      te[6] = n13;
      te[7] = n23;
      te[8] = n33;
      return this;
    }
    identity() {
      this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
      return this;
    }
    copy(m) {
      const te = this.elements;
      const me = m.elements;
      te[0] = me[0];
      te[1] = me[1];
      te[2] = me[2];
      te[3] = me[3];
      te[4] = me[4];
      te[5] = me[5];
      te[6] = me[6];
      te[7] = me[7];
      te[8] = me[8];
      return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
      xAxis.setFromMatrix3Column(this, 0);
      yAxis.setFromMatrix3Column(this, 1);
      zAxis.setFromMatrix3Column(this, 2);
      return this;
    }
    setFromMatrix4(m) {
      const me = m.elements;
      this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
      return this;
    }
    multiply(m) {
      return this.multiplyMatrices(this, m);
    }
    premultiply(m) {
      return this.multiplyMatrices(m, this);
    }
    multiplyMatrices(a, b2) {
      const ae = a.elements;
      const be = b2.elements;
      const te = this.elements;
      const a11 = ae[0], a12 = ae[3], a13 = ae[6];
      const a21 = ae[1], a22 = ae[4], a23 = ae[7];
      const a31 = ae[2], a32 = ae[5], a33 = ae[8];
      const b11 = be[0], b12 = be[3], b13 = be[6];
      const b21 = be[1], b22 = be[4], b23 = be[7];
      const b31 = be[2], b32 = be[5], b33 = be[8];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31;
      te[3] = a11 * b12 + a12 * b22 + a13 * b32;
      te[6] = a11 * b13 + a12 * b23 + a13 * b33;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31;
      te[4] = a21 * b12 + a22 * b22 + a23 * b32;
      te[7] = a21 * b13 + a22 * b23 + a23 * b33;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31;
      te[5] = a31 * b12 + a32 * b22 + a33 * b32;
      te[8] = a31 * b13 + a32 * b23 + a33 * b33;
      return this;
    }
    multiplyScalar(s) {
      const te = this.elements;
      te[0] *= s;
      te[3] *= s;
      te[6] *= s;
      te[1] *= s;
      te[4] *= s;
      te[7] *= s;
      te[2] *= s;
      te[5] *= s;
      te[8] *= s;
      return this;
    }
    determinant() {
      const te = this.elements;
      const a = te[0], b2 = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
      return a * e * i - a * f * h - b2 * d * i + b2 * f * g + c * d * h - c * e * g;
    }
    invert() {
      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
      if (det === 0)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const detInv = 1 / det;
      te[0] = t11 * detInv;
      te[1] = (n31 * n23 - n33 * n21) * detInv;
      te[2] = (n32 * n21 - n31 * n22) * detInv;
      te[3] = t12 * detInv;
      te[4] = (n33 * n11 - n31 * n13) * detInv;
      te[5] = (n31 * n12 - n32 * n11) * detInv;
      te[6] = t13 * detInv;
      te[7] = (n21 * n13 - n23 * n11) * detInv;
      te[8] = (n22 * n11 - n21 * n12) * detInv;
      return this;
    }
    transpose() {
      let tmp2;
      const m = this.elements;
      tmp2 = m[1];
      m[1] = m[3];
      m[3] = tmp2;
      tmp2 = m[2];
      m[2] = m[6];
      m[6] = tmp2;
      tmp2 = m[5];
      m[5] = m[7];
      m[7] = tmp2;
      return this;
    }
    getNormalMatrix(matrix4) {
      return this.setFromMatrix4(matrix4).invert().transpose();
    }
    transposeIntoArray(r) {
      const m = this.elements;
      r[0] = m[0];
      r[1] = m[3];
      r[2] = m[6];
      r[3] = m[1];
      r[4] = m[4];
      r[5] = m[7];
      r[6] = m[2];
      r[7] = m[5];
      r[8] = m[8];
      return this;
    }
    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
      const c = Math.cos(rotation);
      const s = Math.sin(rotation);
      this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
      return this;
    }
    scale(sx, sy) {
      const te = this.elements;
      te[0] *= sx;
      te[3] *= sx;
      te[6] *= sx;
      te[1] *= sy;
      te[4] *= sy;
      te[7] *= sy;
      return this;
    }
    rotate(theta) {
      const c = Math.cos(theta);
      const s = Math.sin(theta);
      const te = this.elements;
      const a11 = te[0], a12 = te[3], a13 = te[6];
      const a21 = te[1], a22 = te[4], a23 = te[7];
      te[0] = c * a11 + s * a21;
      te[3] = c * a12 + s * a22;
      te[6] = c * a13 + s * a23;
      te[1] = -s * a11 + c * a21;
      te[4] = -s * a12 + c * a22;
      te[7] = -s * a13 + c * a23;
      return this;
    }
    translate(tx, ty) {
      const te = this.elements;
      te[0] += tx * te[2];
      te[3] += tx * te[5];
      te[6] += tx * te[8];
      te[1] += ty * te[2];
      te[4] += ty * te[5];
      te[7] += ty * te[8];
      return this;
    }
    equals(matrix) {
      const te = this.elements;
      const me = matrix.elements;
      for (let i = 0; i < 9; i++) {
        if (te[i] !== me[i])
          return false;
      }
      return true;
    }
    fromArray(array, offset = 0) {
      for (let i = 0; i < 9; i++) {
        this.elements[i] = array[i + offset];
      }
      return this;
    }
    toArray(array = [], offset = 0) {
      const te = this.elements;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      return array;
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  };
  Matrix3.prototype.isMatrix3 = true;
  var _canvas;
  var ImageUtils = {
    getDataURL: function(image) {
      if (/^data:/i.test(image.src)) {
        return image.src;
      }
      if (typeof HTMLCanvasElement == "undefined") {
        return image.src;
      }
      let canvas2;
      if (image instanceof HTMLCanvasElement) {
        canvas2 = image;
      } else {
        if (_canvas === void 0)
          _canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
        _canvas.width = image.width;
        _canvas.height = image.height;
        const context = _canvas.getContext("2d");
        if (image instanceof ImageData) {
          context.putImageData(image, 0, 0);
        } else {
          context.drawImage(image, 0, 0, image.width, image.height);
        }
        canvas2 = _canvas;
      }
      if (canvas2.width > 2048 || canvas2.height > 2048) {
        console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
        return canvas2.toDataURL("image/jpeg", 0.6);
      } else {
        return canvas2.toDataURL("image/png");
      }
    }
  };
  var textureId = 0;
  var Texture = class extends EventDispatcher {
    constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
      super();
      Object.defineProperty(this, "id", { value: textureId++ });
      this.uuid = MathUtils.generateUUID();
      this.name = "";
      this.image = image;
      this.mipmaps = [];
      this.mapping = mapping;
      this.wrapS = wrapS;
      this.wrapT = wrapT;
      this.magFilter = magFilter;
      this.minFilter = minFilter;
      this.anisotropy = anisotropy;
      this.format = format;
      this.internalFormat = null;
      this.type = type;
      this.offset = new Vector2(0, 0);
      this.repeat = new Vector2(1, 1);
      this.center = new Vector2(0, 0);
      this.rotation = 0;
      this.matrixAutoUpdate = true;
      this.matrix = new Matrix3();
      this.generateMipmaps = true;
      this.premultiplyAlpha = false;
      this.flipY = true;
      this.unpackAlignment = 4;
      this.encoding = encoding;
      this.version = 0;
      this.onUpdate = null;
    }
    updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.name = source.name;
      this.image = source.image;
      this.mipmaps = source.mipmaps.slice(0);
      this.mapping = source.mapping;
      this.wrapS = source.wrapS;
      this.wrapT = source.wrapT;
      this.magFilter = source.magFilter;
      this.minFilter = source.minFilter;
      this.anisotropy = source.anisotropy;
      this.format = source.format;
      this.internalFormat = source.internalFormat;
      this.type = source.type;
      this.offset.copy(source.offset);
      this.repeat.copy(source.repeat);
      this.center.copy(source.center);
      this.rotation = source.rotation;
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrix.copy(source.matrix);
      this.generateMipmaps = source.generateMipmaps;
      this.premultiplyAlpha = source.premultiplyAlpha;
      this.flipY = source.flipY;
      this.unpackAlignment = source.unpackAlignment;
      this.encoding = source.encoding;
      return this;
    }
    toJSON(meta) {
      const isRootObject = meta === void 0 || typeof meta === "string";
      if (!isRootObject && meta.textures[this.uuid] !== void 0) {
        return meta.textures[this.uuid];
      }
      const output = {
        metadata: {
          version: 4.5,
          type: "Texture",
          generator: "Texture.toJSON"
        },
        uuid: this.uuid,
        name: this.name,
        mapping: this.mapping,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        type: this.type,
        encoding: this.encoding,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment
      };
      if (this.image !== void 0) {
        const image = this.image;
        if (image.uuid === void 0) {
          image.uuid = MathUtils.generateUUID();
        }
        if (!isRootObject && meta.images[image.uuid] === void 0) {
          let url;
          if (Array.isArray(image)) {
            url = [];
            for (let i = 0, l = image.length; i < l; i++) {
              if (image[i].isDataTexture) {
                url.push(serializeImage(image[i].image));
              } else {
                url.push(serializeImage(image[i]));
              }
            }
          } else {
            url = serializeImage(image);
          }
          meta.images[image.uuid] = {
            uuid: image.uuid,
            url
          };
        }
        output.image = image.uuid;
      }
      if (!isRootObject) {
        meta.textures[this.uuid] = output;
      }
      return output;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    transformUv(uv) {
      if (this.mapping !== UVMapping)
        return uv;
      uv.applyMatrix3(this.matrix);
      if (uv.x < 0 || uv.x > 1) {
        switch (this.wrapS) {
          case RepeatWrapping:
            uv.x = uv.x - Math.floor(uv.x);
            break;
          case ClampToEdgeWrapping:
            uv.x = uv.x < 0 ? 0 : 1;
            break;
          case MirroredRepeatWrapping:
            if (Math.abs(Math.floor(uv.x) % 2) === 1) {
              uv.x = Math.ceil(uv.x) - uv.x;
            } else {
              uv.x = uv.x - Math.floor(uv.x);
            }
            break;
        }
      }
      if (uv.y < 0 || uv.y > 1) {
        switch (this.wrapT) {
          case RepeatWrapping:
            uv.y = uv.y - Math.floor(uv.y);
            break;
          case ClampToEdgeWrapping:
            uv.y = uv.y < 0 ? 0 : 1;
            break;
          case MirroredRepeatWrapping:
            if (Math.abs(Math.floor(uv.y) % 2) === 1) {
              uv.y = Math.ceil(uv.y) - uv.y;
            } else {
              uv.y = uv.y - Math.floor(uv.y);
            }
            break;
        }
      }
      if (this.flipY) {
        uv.y = 1 - uv.y;
      }
      return uv;
    }
    set needsUpdate(value) {
      if (value === true)
        this.version++;
    }
  };
  Texture.DEFAULT_IMAGE = void 0;
  Texture.DEFAULT_MAPPING = UVMapping;
  Texture.prototype.isTexture = true;
  function serializeImage(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      return ImageUtils.getDataURL(image);
    } else {
      if (image.data) {
        return {
          data: Array.prototype.slice.call(image.data),
          width: image.width,
          height: image.height,
          type: image.data.constructor.name
        };
      } else {
        console.warn("THREE.Texture: Unable to serialize Texture.");
        return {};
      }
    }
  }
  var Vector4 = class {
    constructor(x = 0, y = 0, z = 0, w = 1) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
    }
    get width() {
      return this.z;
    }
    set width(value) {
      this.z = value;
    }
    get height() {
      return this.w;
    }
    set height(value) {
      this.w = value;
    }
    set(x, y, z, w) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
      return this;
    }
    setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      this.w = scalar;
      return this;
    }
    setX(x) {
      this.x = x;
      return this;
    }
    setY(y) {
      this.y = y;
      return this;
    }
    setZ(z) {
      this.z = z;
      return this;
    }
    setW(w) {
      this.w = w;
      return this;
    }
    setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        case 2:
          this.z = value;
          break;
        case 3:
          this.w = value;
          break;
        default:
          throw new Error("index is out of range: " + index);
      }
      return this;
    }
    getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + index);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      this.w = v.w !== void 0 ? v.w : 1;
      return this;
    }
    add(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
        return this.addVectors(v, w);
      }
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      this.w += v.w;
      return this;
    }
    addScalar(s) {
      this.x += s;
      this.y += s;
      this.z += s;
      this.w += s;
      return this;
    }
    addVectors(a, b2) {
      this.x = a.x + b2.x;
      this.y = a.y + b2.y;
      this.z = a.z + b2.z;
      this.w = a.w + b2.w;
      return this;
    }
    addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      this.z += v.z * s;
      this.w += v.w * s;
      return this;
    }
    sub(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
        return this.subVectors(v, w);
      }
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      this.w -= v.w;
      return this;
    }
    subScalar(s) {
      this.x -= s;
      this.y -= s;
      this.z -= s;
      this.w -= s;
      return this;
    }
    subVectors(a, b2) {
      this.x = a.x - b2.x;
      this.y = a.y - b2.y;
      this.z = a.z - b2.z;
      this.w = a.w - b2.w;
      return this;
    }
    multiply(v) {
      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;
      this.w *= v.w;
      return this;
    }
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      this.w *= scalar;
      return this;
    }
    applyMatrix4(m) {
      const x = this.x, y = this.y, z = this.z, w = this.w;
      const e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
      this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
      this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
      this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
      return this;
    }
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    setAxisAngleFromQuaternion(q) {
      this.w = 2 * Math.acos(q.w);
      const s = Math.sqrt(1 - q.w * q.w);
      if (s < 1e-4) {
        this.x = 1;
        this.y = 0;
        this.z = 0;
      } else {
        this.x = q.x / s;
        this.y = q.y / s;
        this.z = q.z / s;
      }
      return this;
    }
    setAxisAngleFromRotationMatrix(m) {
      let angle, x, y, z;
      const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
      if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
        if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
          this.set(1, 0, 0, 0);
          return this;
        }
        angle = Math.PI;
        const xx = (m11 + 1) / 2;
        const yy = (m22 + 1) / 2;
        const zz = (m33 + 1) / 2;
        const xy = (m12 + m21) / 4;
        const xz = (m13 + m31) / 4;
        const yz = (m23 + m32) / 4;
        if (xx > yy && xx > zz) {
          if (xx < epsilon) {
            x = 0;
            y = 0.707106781;
            z = 0.707106781;
          } else {
            x = Math.sqrt(xx);
            y = xy / x;
            z = xz / x;
          }
        } else if (yy > zz) {
          if (yy < epsilon) {
            x = 0.707106781;
            y = 0;
            z = 0.707106781;
          } else {
            y = Math.sqrt(yy);
            x = xy / y;
            z = yz / y;
          }
        } else {
          if (zz < epsilon) {
            x = 0.707106781;
            y = 0.707106781;
            z = 0;
          } else {
            z = Math.sqrt(zz);
            x = xz / z;
            y = yz / z;
          }
        }
        this.set(x, y, z, angle);
        return this;
      }
      let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
      if (Math.abs(s) < 1e-3)
        s = 1;
      this.x = (m32 - m23) / s;
      this.y = (m13 - m31) / s;
      this.z = (m21 - m12) / s;
      this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
      return this;
    }
    min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      this.w = Math.min(this.w, v.w);
      return this;
    }
    max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      this.w = Math.max(this.w, v.w);
      return this;
    }
    clamp(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      this.z = Math.max(min.z, Math.min(max.z, this.z));
      this.w = Math.max(min.w, Math.min(max.w, this.w));
      return this;
    }
    clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      this.z = Math.max(minVal, Math.min(maxVal, this.z));
      this.w = Math.max(minVal, Math.min(maxVal, this.w));
      return this;
    }
    clampLength(min, max) {
      const length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      this.w = Math.floor(this.w);
      return this;
    }
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      this.w = Math.ceil(this.w);
      return this;
    }
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      this.w = Math.round(this.w);
      return this;
    }
    roundToZero() {
      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
      this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
      this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
      return this;
    }
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      this.w = -this.w;
      return this;
    }
    dot(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      this.z += (v.z - this.z) * alpha;
      this.w += (v.w - this.w) * alpha;
      return this;
    }
    lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      this.z = v1.z + (v2.z - v1.z) * alpha;
      this.w = v1.w + (v2.w - v1.w) * alpha;
      return this;
    }
    equals(v) {
      return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
    }
    fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      this.w = array[offset + 3];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      array[offset + 3] = this.w;
      return array;
    }
    fromBufferAttribute(attribute, index, offset) {
      if (offset !== void 0) {
        console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
      }
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      this.z = attribute.getZ(index);
      this.w = attribute.getW(index);
      return this;
    }
    random() {
      this.x = Math.random();
      this.y = Math.random();
      this.z = Math.random();
      this.w = Math.random();
      return this;
    }
  };
  Vector4.prototype.isVector4 = true;
  var WebGLRenderTarget = class extends EventDispatcher {
    constructor(width, height, options) {
      super();
      this.width = width;
      this.height = height;
      this.depth = 1;
      this.scissor = new Vector4(0, 0, width, height);
      this.scissorTest = false;
      this.viewport = new Vector4(0, 0, width, height);
      options = options || {};
      this.texture = new Texture(void 0, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
      this.texture.image = {};
      this.texture.image.width = width;
      this.texture.image.height = height;
      this.texture.image.depth = 1;
      this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
      this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
      this.depthBuffer = options.depthBuffer !== void 0 ? options.depthBuffer : true;
      this.stencilBuffer = options.stencilBuffer !== void 0 ? options.stencilBuffer : false;
      this.depthTexture = options.depthTexture !== void 0 ? options.depthTexture : null;
    }
    setTexture(texture) {
      texture.image = {
        width: this.width,
        height: this.height,
        depth: this.depth
      };
      this.texture = texture;
    }
    setSize(width, height, depth = 1) {
      if (this.width !== width || this.height !== height || this.depth !== depth) {
        this.width = width;
        this.height = height;
        this.depth = depth;
        this.texture.image.width = width;
        this.texture.image.height = height;
        this.texture.image.depth = depth;
        this.dispose();
      }
      this.viewport.set(0, 0, width, height);
      this.scissor.set(0, 0, width, height);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.width = source.width;
      this.height = source.height;
      this.depth = source.depth;
      this.viewport.copy(source.viewport);
      this.texture = source.texture.clone();
      this.depthBuffer = source.depthBuffer;
      this.stencilBuffer = source.stencilBuffer;
      this.depthTexture = source.depthTexture;
      return this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  };
  WebGLRenderTarget.prototype.isWebGLRenderTarget = true;
  var WebGLMultisampleRenderTarget = class extends WebGLRenderTarget {
    constructor(width, height, options) {
      super(width, height, options);
      this.samples = 4;
    }
    copy(source) {
      super.copy.call(this, source);
      this.samples = source.samples;
      return this;
    }
  };
  WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;
  var Quaternion = class {
    constructor(x = 0, y = 0, z = 0, w = 1) {
      this._x = x;
      this._y = y;
      this._z = z;
      this._w = w;
    }
    static slerp(qa, qb, qm, t) {
      console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.");
      return qm.slerpQuaternions(qa, qb, t);
    }
    static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
      let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
      const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
      if (t === 0) {
        dst[dstOffset + 0] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
        return;
      }
      if (t === 1) {
        dst[dstOffset + 0] = x1;
        dst[dstOffset + 1] = y1;
        dst[dstOffset + 2] = z1;
        dst[dstOffset + 3] = w1;
        return;
      }
      if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
        let s = 1 - t;
        const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
        if (sqrSin > Number.EPSILON) {
          const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
          s = Math.sin(s * len) / sin;
          t = Math.sin(t * len) / sin;
        }
        const tDir = t * dir;
        x0 = x0 * s + x1 * tDir;
        y0 = y0 * s + y1 * tDir;
        z0 = z0 * s + z1 * tDir;
        w0 = w0 * s + w1 * tDir;
        if (s === 1 - t) {
          const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
          x0 *= f;
          y0 *= f;
          z0 *= f;
          w0 *= f;
        }
      }
      dst[dstOffset] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
    }
    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
      const x0 = src0[srcOffset0];
      const y0 = src0[srcOffset0 + 1];
      const z0 = src0[srcOffset0 + 2];
      const w0 = src0[srcOffset0 + 3];
      const x1 = src1[srcOffset1];
      const y1 = src1[srcOffset1 + 1];
      const z1 = src1[srcOffset1 + 2];
      const w1 = src1[srcOffset1 + 3];
      dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
      dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
      dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
      dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
      return dst;
    }
    get x() {
      return this._x;
    }
    set x(value) {
      this._x = value;
      this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(value) {
      this._y = value;
      this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(value) {
      this._z = value;
      this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(value) {
      this._w = value;
      this._onChangeCallback();
    }
    set(x, y, z, w) {
      this._x = x;
      this._y = y;
      this._z = z;
      this._w = w;
      this._onChangeCallback();
      return this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(quaternion) {
      this._x = quaternion.x;
      this._y = quaternion.y;
      this._z = quaternion.z;
      this._w = quaternion.w;
      this._onChangeCallback();
      return this;
    }
    setFromEuler(euler, update) {
      if (!(euler && euler.isEuler)) {
        throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
      }
      const x = euler._x, y = euler._y, z = euler._z, order = euler._order;
      const cos = Math.cos;
      const sin = Math.sin;
      const c1 = cos(x / 2);
      const c2 = cos(y / 2);
      const c3 = cos(z / 2);
      const s1 = sin(x / 2);
      const s2 = sin(y / 2);
      const s3 = sin(z / 2);
      switch (order) {
        case "XYZ":
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case "YXZ":
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        case "ZXY":
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case "ZYX":
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        case "YZX":
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case "XZY":
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        default:
          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
      }
      if (update !== false)
        this._onChangeCallback();
      return this;
    }
    setFromAxisAngle(axis, angle) {
      const halfAngle = angle / 2, s = Math.sin(halfAngle);
      this._x = axis.x * s;
      this._y = axis.y * s;
      this._z = axis.z * s;
      this._w = Math.cos(halfAngle);
      this._onChangeCallback();
      return this;
    }
    setFromRotationMatrix(m) {
      const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
      if (trace > 0) {
        const s = 0.5 / Math.sqrt(trace + 1);
        this._w = 0.25 / s;
        this._x = (m32 - m23) * s;
        this._y = (m13 - m31) * s;
        this._z = (m21 - m12) * s;
      } else if (m11 > m22 && m11 > m33) {
        const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
        this._w = (m32 - m23) / s;
        this._x = 0.25 * s;
        this._y = (m12 + m21) / s;
        this._z = (m13 + m31) / s;
      } else if (m22 > m33) {
        const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
        this._w = (m13 - m31) / s;
        this._x = (m12 + m21) / s;
        this._y = 0.25 * s;
        this._z = (m23 + m32) / s;
      } else {
        const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
        this._w = (m21 - m12) / s;
        this._x = (m13 + m31) / s;
        this._y = (m23 + m32) / s;
        this._z = 0.25 * s;
      }
      this._onChangeCallback();
      return this;
    }
    setFromUnitVectors(vFrom, vTo) {
      let r = vFrom.dot(vTo) + 1;
      if (r < Number.EPSILON) {
        r = 0;
        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
          this._x = -vFrom.y;
          this._y = vFrom.x;
          this._z = 0;
          this._w = r;
        } else {
          this._x = 0;
          this._y = -vFrom.z;
          this._z = vFrom.y;
          this._w = r;
        }
      } else {
        this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
        this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
        this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
        this._w = r;
      }
      return this.normalize();
    }
    angleTo(q) {
      return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q), -1, 1)));
    }
    rotateTowards(q, step) {
      const angle = this.angleTo(q);
      if (angle === 0)
        return this;
      const t = Math.min(1, step / angle);
      this.slerp(q, t);
      return this;
    }
    identity() {
      return this.set(0, 0, 0, 1);
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      this._x *= -1;
      this._y *= -1;
      this._z *= -1;
      this._onChangeCallback();
      return this;
    }
    dot(v) {
      return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
    }
    lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
      let l = this.length();
      if (l === 0) {
        this._x = 0;
        this._y = 0;
        this._z = 0;
        this._w = 1;
      } else {
        l = 1 / l;
        this._x = this._x * l;
        this._y = this._y * l;
        this._z = this._z * l;
        this._w = this._w * l;
      }
      this._onChangeCallback();
      return this;
    }
    multiply(q, p) {
      if (p !== void 0) {
        console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
        return this.multiplyQuaternions(q, p);
      }
      return this.multiplyQuaternions(this, q);
    }
    premultiply(q) {
      return this.multiplyQuaternions(q, this);
    }
    multiplyQuaternions(a, b2) {
      const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
      const qbx = b2._x, qby = b2._y, qbz = b2._z, qbw = b2._w;
      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
      this._onChangeCallback();
      return this;
    }
    slerp(qb, t) {
      if (t === 0)
        return this;
      if (t === 1)
        return this.copy(qb);
      const x = this._x, y = this._y, z = this._z, w = this._w;
      let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
      if (cosHalfTheta < 0) {
        this._w = -qb._w;
        this._x = -qb._x;
        this._y = -qb._y;
        this._z = -qb._z;
        cosHalfTheta = -cosHalfTheta;
      } else {
        this.copy(qb);
      }
      if (cosHalfTheta >= 1) {
        this._w = w;
        this._x = x;
        this._y = y;
        this._z = z;
        return this;
      }
      const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
      if (sqrSinHalfTheta <= Number.EPSILON) {
        const s = 1 - t;
        this._w = s * w + t * this._w;
        this._x = s * x + t * this._x;
        this._y = s * y + t * this._y;
        this._z = s * z + t * this._z;
        this.normalize();
        this._onChangeCallback();
        return this;
      }
      const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
      const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
      const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
      this._w = w * ratioA + this._w * ratioB;
      this._x = x * ratioA + this._x * ratioB;
      this._y = y * ratioA + this._y * ratioB;
      this._z = z * ratioA + this._z * ratioB;
      this._onChangeCallback();
      return this;
    }
    slerpQuaternions(qa, qb, t) {
      this.copy(qa).slerp(qb, t);
    }
    equals(quaternion) {
      return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
    }
    fromArray(array, offset = 0) {
      this._x = array[offset];
      this._y = array[offset + 1];
      this._z = array[offset + 2];
      this._w = array[offset + 3];
      this._onChangeCallback();
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._w;
      return array;
    }
    fromBufferAttribute(attribute, index) {
      this._x = attribute.getX(index);
      this._y = attribute.getY(index);
      this._z = attribute.getZ(index);
      this._w = attribute.getW(index);
      return this;
    }
    _onChange(callback) {
      this._onChangeCallback = callback;
      return this;
    }
    _onChangeCallback() {
    }
  };
  Quaternion.prototype.isQuaternion = true;
  var Vector3 = class {
    constructor(x = 0, y = 0, z = 0) {
      this.x = x;
      this.y = y;
      this.z = z;
    }
    set(x, y, z) {
      if (z === void 0)
        z = this.z;
      this.x = x;
      this.y = y;
      this.z = z;
      return this;
    }
    setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      return this;
    }
    setX(x) {
      this.x = x;
      return this;
    }
    setY(y) {
      this.y = y;
      return this;
    }
    setZ(z) {
      this.z = z;
      return this;
    }
    setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        case 2:
          this.z = value;
          break;
        default:
          throw new Error("index is out of range: " + index);
      }
      return this;
    }
    getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + index);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    copy(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      return this;
    }
    add(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
        return this.addVectors(v, w);
      }
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      return this;
    }
    addScalar(s) {
      this.x += s;
      this.y += s;
      this.z += s;
      return this;
    }
    addVectors(a, b2) {
      this.x = a.x + b2.x;
      this.y = a.y + b2.y;
      this.z = a.z + b2.z;
      return this;
    }
    addScaledVector(v, s) {
      this.x += v.x * s;
      this.y += v.y * s;
      this.z += v.z * s;
      return this;
    }
    sub(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
        return this.subVectors(v, w);
      }
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      return this;
    }
    subScalar(s) {
      this.x -= s;
      this.y -= s;
      this.z -= s;
      return this;
    }
    subVectors(a, b2) {
      this.x = a.x - b2.x;
      this.y = a.y - b2.y;
      this.z = a.z - b2.z;
      return this;
    }
    multiply(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
        return this.multiplyVectors(v, w);
      }
      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;
      return this;
    }
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      return this;
    }
    multiplyVectors(a, b2) {
      this.x = a.x * b2.x;
      this.y = a.y * b2.y;
      this.z = a.z * b2.z;
      return this;
    }
    applyEuler(euler) {
      if (!(euler && euler.isEuler)) {
        console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
      }
      return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
    }
    applyAxisAngle(axis, angle) {
      return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
    }
    applyMatrix3(m) {
      const x = this.x, y = this.y, z = this.z;
      const e = m.elements;
      this.x = e[0] * x + e[3] * y + e[6] * z;
      this.y = e[1] * x + e[4] * y + e[7] * z;
      this.z = e[2] * x + e[5] * y + e[8] * z;
      return this;
    }
    applyNormalMatrix(m) {
      return this.applyMatrix3(m).normalize();
    }
    applyMatrix4(m) {
      const x = this.x, y = this.y, z = this.z;
      const e = m.elements;
      const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
      this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
      this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
      this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
      return this;
    }
    applyQuaternion(q) {
      const x = this.x, y = this.y, z = this.z;
      const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
      const ix = qw * x + qy * z - qz * y;
      const iy = qw * y + qz * x - qx * z;
      const iz = qw * z + qx * y - qy * x;
      const iw = -qx * x - qy * y - qz * z;
      this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
      return this;
    }
    project(camera) {
      return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
    }
    unproject(camera) {
      return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
    }
    transformDirection(m) {
      const x = this.x, y = this.y, z = this.z;
      const e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z;
      this.y = e[1] * x + e[5] * y + e[9] * z;
      this.z = e[2] * x + e[6] * y + e[10] * z;
      return this.normalize();
    }
    divide(v) {
      this.x /= v.x;
      this.y /= v.y;
      this.z /= v.z;
      return this;
    }
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    min(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      return this;
    }
    max(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      return this;
    }
    clamp(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      this.z = Math.max(min.z, Math.min(max.z, this.z));
      return this;
    }
    clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      this.z = Math.max(minVal, Math.min(maxVal, this.z));
      return this;
    }
    clampLength(min, max) {
      const length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      return this;
    }
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      return this;
    }
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      return this;
    }
    roundToZero() {
      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
      this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
      return this;
    }
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      return this;
    }
    dot(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      this.z += (v.z - this.z) * alpha;
      return this;
    }
    lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      this.z = v1.z + (v2.z - v1.z) * alpha;
      return this;
    }
    cross(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
        return this.crossVectors(v, w);
      }
      return this.crossVectors(this, v);
    }
    crossVectors(a, b2) {
      const ax = a.x, ay = a.y, az = a.z;
      const bx = b2.x, by = b2.y, bz = b2.z;
      this.x = ay * bz - az * by;
      this.y = az * bx - ax * bz;
      this.z = ax * by - ay * bx;
      return this;
    }
    projectOnVector(v) {
      const denominator = v.lengthSq();
      if (denominator === 0)
        return this.set(0, 0, 0);
      const scalar = v.dot(this) / denominator;
      return this.copy(v).multiplyScalar(scalar);
    }
    projectOnPlane(planeNormal) {
      _vector$c.copy(this).projectOnVector(planeNormal);
      return this.sub(_vector$c);
    }
    reflect(normal) {
      return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
    }
    angleTo(v) {
      const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
      if (denominator === 0)
        return Math.PI / 2;
      const theta = this.dot(v) / denominator;
      return Math.acos(MathUtils.clamp(theta, -1, 1));
    }
    distanceTo(v) {
      return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
      const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
      return dx * dx + dy * dy + dz * dz;
    }
    manhattanDistanceTo(v) {
      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
    }
    setFromSpherical(s) {
      return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
    }
    setFromSphericalCoords(radius, phi, theta) {
      const sinPhiRadius = Math.sin(phi) * radius;
      this.x = sinPhiRadius * Math.sin(theta);
      this.y = Math.cos(phi) * radius;
      this.z = sinPhiRadius * Math.cos(theta);
      return this;
    }
    setFromCylindrical(c) {
      return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
    }
    setFromCylindricalCoords(radius, theta, y) {
      this.x = radius * Math.sin(theta);
      this.y = y;
      this.z = radius * Math.cos(theta);
      return this;
    }
    setFromMatrixPosition(m) {
      const e = m.elements;
      this.x = e[12];
      this.y = e[13];
      this.z = e[14];
      return this;
    }
    setFromMatrixScale(m) {
      const sx = this.setFromMatrixColumn(m, 0).length();
      const sy = this.setFromMatrixColumn(m, 1).length();
      const sz = this.setFromMatrixColumn(m, 2).length();
      this.x = sx;
      this.y = sy;
      this.z = sz;
      return this;
    }
    setFromMatrixColumn(m, index) {
      return this.fromArray(m.elements, index * 4);
    }
    setFromMatrix3Column(m, index) {
      return this.fromArray(m.elements, index * 3);
    }
    equals(v) {
      return v.x === this.x && v.y === this.y && v.z === this.z;
    }
    fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      return array;
    }
    fromBufferAttribute(attribute, index, offset) {
      if (offset !== void 0) {
        console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
      }
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      this.z = attribute.getZ(index);
      return this;
    }
    random() {
      this.x = Math.random();
      this.y = Math.random();
      this.z = Math.random();
      return this;
    }
  };
  Vector3.prototype.isVector3 = true;
  var _vector$c = /* @__PURE__ */ new Vector3();
  var _quaternion$4 = /* @__PURE__ */ new Quaternion();
  var Box3 = class {
    constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
      this.min = min;
      this.max = max;
    }
    set(min, max) {
      this.min.copy(min);
      this.max.copy(max);
      return this;
    }
    setFromArray(array) {
      let minX = Infinity;
      let minY = Infinity;
      let minZ = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      let maxZ = -Infinity;
      for (let i = 0, l = array.length; i < l; i += 3) {
        const x = array[i];
        const y = array[i + 1];
        const z = array[i + 2];
        if (x < minX)
          minX = x;
        if (y < minY)
          minY = y;
        if (z < minZ)
          minZ = z;
        if (x > maxX)
          maxX = x;
        if (y > maxY)
          maxY = y;
        if (z > maxZ)
          maxZ = z;
      }
      this.min.set(minX, minY, minZ);
      this.max.set(maxX, maxY, maxZ);
      return this;
    }
    setFromBufferAttribute(attribute) {
      let minX = Infinity;
      let minY = Infinity;
      let minZ = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      let maxZ = -Infinity;
      for (let i = 0, l = attribute.count; i < l; i++) {
        const x = attribute.getX(i);
        const y = attribute.getY(i);
        const z = attribute.getZ(i);
        if (x < minX)
          minX = x;
        if (y < minY)
          minY = y;
        if (z < minZ)
          minZ = z;
        if (x > maxX)
          maxX = x;
        if (y > maxY)
          maxY = y;
        if (z > maxZ)
          maxZ = z;
      }
      this.min.set(minX, minY, minZ);
      this.max.set(maxX, maxY, maxZ);
      return this;
    }
    setFromPoints(points) {
      this.makeEmpty();
      for (let i = 0, il = points.length; i < il; i++) {
        this.expandByPoint(points[i]);
      }
      return this;
    }
    setFromCenterAndSize(center, size2) {
      const halfSize = _vector$b.copy(size2).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    }
    setFromObject(object) {
      this.makeEmpty();
      return this.expandByObject(object);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(box) {
      this.min.copy(box.min);
      this.max.copy(box.max);
      return this;
    }
    makeEmpty() {
      this.min.x = this.min.y = this.min.z = Infinity;
      this.max.x = this.max.y = this.max.z = -Infinity;
      return this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    getCenter(target) {
      if (target === void 0) {
        console.warn("THREE.Box3: .getCenter() target is now required");
        target = new Vector3();
      }
      return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(target) {
      if (target === void 0) {
        console.warn("THREE.Box3: .getSize() target is now required");
        target = new Vector3();
      }
      return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
    }
    expandByPoint(point) {
      this.min.min(point);
      this.max.max(point);
      return this;
    }
    expandByVector(vector) {
      this.min.sub(vector);
      this.max.add(vector);
      return this;
    }
    expandByScalar(scalar) {
      this.min.addScalar(-scalar);
      this.max.addScalar(scalar);
      return this;
    }
    expandByObject(object) {
      object.updateWorldMatrix(false, false);
      const geometry = object.geometry;
      if (geometry !== void 0) {
        if (geometry.boundingBox === null) {
          geometry.computeBoundingBox();
        }
        _box$3.copy(geometry.boundingBox);
        _box$3.applyMatrix4(object.matrixWorld);
        this.union(_box$3);
      }
      const children = object.children;
      for (let i = 0, l = children.length; i < l; i++) {
        this.expandByObject(children[i]);
      }
      return this;
    }
    containsPoint(point) {
      return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
    }
    containsBox(box) {
      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
    }
    getParameter(point, target) {
      if (target === void 0) {
        console.warn("THREE.Box3: .getParameter() target is now required");
        target = new Vector3();
      }
      return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
    }
    intersectsBox(box) {
      return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
    }
    intersectsSphere(sphere) {
      this.clampPoint(sphere.center, _vector$b);
      return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    }
    intersectsPlane(plane) {
      let min, max;
      if (plane.normal.x > 0) {
        min = plane.normal.x * this.min.x;
        max = plane.normal.x * this.max.x;
      } else {
        min = plane.normal.x * this.max.x;
        max = plane.normal.x * this.min.x;
      }
      if (plane.normal.y > 0) {
        min += plane.normal.y * this.min.y;
        max += plane.normal.y * this.max.y;
      } else {
        min += plane.normal.y * this.max.y;
        max += plane.normal.y * this.min.y;
      }
      if (plane.normal.z > 0) {
        min += plane.normal.z * this.min.z;
        max += plane.normal.z * this.max.z;
      } else {
        min += plane.normal.z * this.max.z;
        max += plane.normal.z * this.min.z;
      }
      return min <= -plane.constant && max >= -plane.constant;
    }
    intersectsTriangle(triangle) {
      if (this.isEmpty()) {
        return false;
      }
      this.getCenter(_center);
      _extents.subVectors(this.max, _center);
      _v0$2.subVectors(triangle.a, _center);
      _v1$7.subVectors(triangle.b, _center);
      _v2$3.subVectors(triangle.c, _center);
      _f0.subVectors(_v1$7, _v0$2);
      _f1.subVectors(_v2$3, _v1$7);
      _f2.subVectors(_v0$2, _v2$3);
      let axes = [
        0,
        -_f0.z,
        _f0.y,
        0,
        -_f1.z,
        _f1.y,
        0,
        -_f2.z,
        _f2.y,
        _f0.z,
        0,
        -_f0.x,
        _f1.z,
        0,
        -_f1.x,
        _f2.z,
        0,
        -_f2.x,
        -_f0.y,
        _f0.x,
        0,
        -_f1.y,
        _f1.x,
        0,
        -_f2.y,
        _f2.x,
        0
      ];
      if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
        return false;
      }
      axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
        return false;
      }
      _triangleNormal.crossVectors(_f0, _f1);
      axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
      return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
    }
    clampPoint(point, target) {
      if (target === void 0) {
        console.warn("THREE.Box3: .clampPoint() target is now required");
        target = new Vector3();
      }
      return target.copy(point).clamp(this.min, this.max);
    }
    distanceToPoint(point) {
      const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);
      return clampedPoint.sub(point).length();
    }
    getBoundingSphere(target) {
      if (target === void 0) {
        console.error("THREE.Box3: .getBoundingSphere() target is now required");
      }
      this.getCenter(target.center);
      target.radius = this.getSize(_vector$b).length() * 0.5;
      return target;
    }
    intersect(box) {
      this.min.max(box.min);
      this.max.min(box.max);
      if (this.isEmpty())
        this.makeEmpty();
      return this;
    }
    union(box) {
      this.min.min(box.min);
      this.max.max(box.max);
      return this;
    }
    applyMatrix4(matrix) {
      if (this.isEmpty())
        return this;
      _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
      _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
      _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
      _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
      _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
      _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
      _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
      _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
      this.setFromPoints(_points);
      return this;
    }
    translate(offset) {
      this.min.add(offset);
      this.max.add(offset);
      return this;
    }
    equals(box) {
      return box.min.equals(this.min) && box.max.equals(this.max);
    }
  };
  Box3.prototype.isBox3 = true;
  var _points = [
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3()
  ];
  var _vector$b = /* @__PURE__ */ new Vector3();
  var _box$3 = /* @__PURE__ */ new Box3();
  var _v0$2 = /* @__PURE__ */ new Vector3();
  var _v1$7 = /* @__PURE__ */ new Vector3();
  var _v2$3 = /* @__PURE__ */ new Vector3();
  var _f0 = /* @__PURE__ */ new Vector3();
  var _f1 = /* @__PURE__ */ new Vector3();
  var _f2 = /* @__PURE__ */ new Vector3();
  var _center = /* @__PURE__ */ new Vector3();
  var _extents = /* @__PURE__ */ new Vector3();
  var _triangleNormal = /* @__PURE__ */ new Vector3();
  var _testAxis = /* @__PURE__ */ new Vector3();
  function satForAxes(axes, v0, v1, v2, extents) {
    for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
      _testAxis.fromArray(axes, i);
      const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
      const p0 = v0.dot(_testAxis);
      const p1 = v1.dot(_testAxis);
      const p2 = v2.dot(_testAxis);
      if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
        return false;
      }
    }
    return true;
  }
  var _box$2 = /* @__PURE__ */ new Box3();
  var _v1$6 = /* @__PURE__ */ new Vector3();
  var _toFarthestPoint = /* @__PURE__ */ new Vector3();
  var _toPoint = /* @__PURE__ */ new Vector3();
  var Sphere = class {
    constructor(center = new Vector3(), radius = -1) {
      this.center = center;
      this.radius = radius;
    }
    set(center, radius) {
      this.center.copy(center);
      this.radius = radius;
      return this;
    }
    setFromPoints(points, optionalCenter) {
      const center = this.center;
      if (optionalCenter !== void 0) {
        center.copy(optionalCenter);
      } else {
        _box$2.setFromPoints(points).getCenter(center);
      }
      let maxRadiusSq = 0;
      for (let i = 0, il = points.length; i < il; i++) {
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
      }
      this.radius = Math.sqrt(maxRadiusSq);
      return this;
    }
    copy(sphere) {
      this.center.copy(sphere.center);
      this.radius = sphere.radius;
      return this;
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      this.center.set(0, 0, 0);
      this.radius = -1;
      return this;
    }
    containsPoint(point) {
      return point.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(point) {
      return point.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(sphere) {
      const radiusSum = this.radius + sphere.radius;
      return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
    }
    intersectsBox(box) {
      return box.intersectsSphere(this);
    }
    intersectsPlane(plane) {
      return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(point, target) {
      const deltaLengthSq = this.center.distanceToSquared(point);
      if (target === void 0) {
        console.warn("THREE.Sphere: .clampPoint() target is now required");
        target = new Vector3();
      }
      target.copy(point);
      if (deltaLengthSq > this.radius * this.radius) {
        target.sub(this.center).normalize();
        target.multiplyScalar(this.radius).add(this.center);
      }
      return target;
    }
    getBoundingBox(target) {
      if (target === void 0) {
        console.warn("THREE.Sphere: .getBoundingBox() target is now required");
        target = new Box3();
      }
      if (this.isEmpty()) {
        target.makeEmpty();
        return target;
      }
      target.set(this.center, this.center);
      target.expandByScalar(this.radius);
      return target;
    }
    applyMatrix4(matrix) {
      this.center.applyMatrix4(matrix);
      this.radius = this.radius * matrix.getMaxScaleOnAxis();
      return this;
    }
    translate(offset) {
      this.center.add(offset);
      return this;
    }
    expandByPoint(point) {
      _toPoint.subVectors(point, this.center);
      const lengthSq = _toPoint.lengthSq();
      if (lengthSq > this.radius * this.radius) {
        const length = Math.sqrt(lengthSq);
        const missingRadiusHalf = (length - this.radius) * 0.5;
        this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
        this.radius += missingRadiusHalf;
      }
      return this;
    }
    union(sphere) {
      _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);
      this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));
      this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));
      return this;
    }
    equals(sphere) {
      return sphere.center.equals(this.center) && sphere.radius === this.radius;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var _vector$a = /* @__PURE__ */ new Vector3();
  var _segCenter = /* @__PURE__ */ new Vector3();
  var _segDir = /* @__PURE__ */ new Vector3();
  var _diff = /* @__PURE__ */ new Vector3();
  var _edge1 = /* @__PURE__ */ new Vector3();
  var _edge2 = /* @__PURE__ */ new Vector3();
  var _normal$1 = /* @__PURE__ */ new Vector3();
  var Ray = class {
    constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
      this.origin = origin;
      this.direction = direction;
    }
    set(origin, direction) {
      this.origin.copy(origin);
      this.direction.copy(direction);
      return this;
    }
    copy(ray) {
      this.origin.copy(ray.origin);
      this.direction.copy(ray.direction);
      return this;
    }
    at(t, target) {
      if (target === void 0) {
        console.warn("THREE.Ray: .at() target is now required");
        target = new Vector3();
      }
      return target.copy(this.direction).multiplyScalar(t).add(this.origin);
    }
    lookAt(v) {
      this.direction.copy(v).sub(this.origin).normalize();
      return this;
    }
    recast(t) {
      this.origin.copy(this.at(t, _vector$a));
      return this;
    }
    closestPointToPoint(point, target) {
      if (target === void 0) {
        console.warn("THREE.Ray: .closestPointToPoint() target is now required");
        target = new Vector3();
      }
      target.subVectors(point, this.origin);
      const directionDistance = target.dot(this.direction);
      if (directionDistance < 0) {
        return target.copy(this.origin);
      }
      return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    }
    distanceToPoint(point) {
      return Math.sqrt(this.distanceSqToPoint(point));
    }
    distanceSqToPoint(point) {
      const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
      if (directionDistance < 0) {
        return this.origin.distanceToSquared(point);
      }
      _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
      return _vector$a.distanceToSquared(point);
    }
    distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
      _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
      _segDir.copy(v1).sub(v0).normalize();
      _diff.copy(this.origin).sub(_segCenter);
      const segExtent = v0.distanceTo(v1) * 0.5;
      const a01 = -this.direction.dot(_segDir);
      const b0 = _diff.dot(this.direction);
      const b1 = -_diff.dot(_segDir);
      const c = _diff.lengthSq();
      const det = Math.abs(1 - a01 * a01);
      let s0, s1, sqrDist, extDet;
      if (det > 0) {
        s0 = a01 * b1 - b0;
        s1 = a01 * b0 - b1;
        extDet = segExtent * det;
        if (s0 >= 0) {
          if (s1 >= -extDet) {
            if (s1 <= extDet) {
              const invDet = 1 / det;
              s0 *= invDet;
              s1 *= invDet;
              sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
            } else {
              s1 = segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          } else {
            s1 = -segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          if (s1 <= -extDet) {
            s0 = Math.max(0, -(-a01 * segExtent + b0));
            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          } else if (s1 <= extDet) {
            s0 = 0;
            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = s1 * (s1 + 2 * b1) + c;
          } else {
            s0 = Math.max(0, -(a01 * segExtent + b0));
            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        }
      } else {
        s1 = a01 > 0 ? -segExtent : segExtent;
        s0 = Math.max(0, -(a01 * s1 + b0));
        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
      }
      if (optionalPointOnRay) {
        optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
      }
      if (optionalPointOnSegment) {
        optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
      }
      return sqrDist;
    }
    intersectSphere(sphere, target) {
      _vector$a.subVectors(sphere.center, this.origin);
      const tca = _vector$a.dot(this.direction);
      const d2 = _vector$a.dot(_vector$a) - tca * tca;
      const radius2 = sphere.radius * sphere.radius;
      if (d2 > radius2)
        return null;
      const thc = Math.sqrt(radius2 - d2);
      const t0 = tca - thc;
      const t1 = tca + thc;
      if (t0 < 0 && t1 < 0)
        return null;
      if (t0 < 0)
        return this.at(t1, target);
      return this.at(t0, target);
    }
    intersectsSphere(sphere) {
      return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
    }
    distanceToPlane(plane) {
      const denominator = plane.normal.dot(this.direction);
      if (denominator === 0) {
        if (plane.distanceToPoint(this.origin) === 0) {
          return 0;
        }
        return null;
      }
      const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
      return t >= 0 ? t : null;
    }
    intersectPlane(plane, target) {
      const t = this.distanceToPlane(plane);
      if (t === null) {
        return null;
      }
      return this.at(t, target);
    }
    intersectsPlane(plane) {
      const distToPoint = plane.distanceToPoint(this.origin);
      if (distToPoint === 0) {
        return true;
      }
      const denominator = plane.normal.dot(this.direction);
      if (denominator * distToPoint < 0) {
        return true;
      }
      return false;
    }
    intersectBox(box, target) {
      let tmin, tmax, tymin, tymax, tzmin, tzmax;
      const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
      const origin = this.origin;
      if (invdirx >= 0) {
        tmin = (box.min.x - origin.x) * invdirx;
        tmax = (box.max.x - origin.x) * invdirx;
      } else {
        tmin = (box.max.x - origin.x) * invdirx;
        tmax = (box.min.x - origin.x) * invdirx;
      }
      if (invdiry >= 0) {
        tymin = (box.min.y - origin.y) * invdiry;
        tymax = (box.max.y - origin.y) * invdiry;
      } else {
        tymin = (box.max.y - origin.y) * invdiry;
        tymax = (box.min.y - origin.y) * invdiry;
      }
      if (tmin > tymax || tymin > tmax)
        return null;
      if (tymin > tmin || tmin !== tmin)
        tmin = tymin;
      if (tymax < tmax || tmax !== tmax)
        tmax = tymax;
      if (invdirz >= 0) {
        tzmin = (box.min.z - origin.z) * invdirz;
        tzmax = (box.max.z - origin.z) * invdirz;
      } else {
        tzmin = (box.max.z - origin.z) * invdirz;
        tzmax = (box.min.z - origin.z) * invdirz;
      }
      if (tmin > tzmax || tzmin > tmax)
        return null;
      if (tzmin > tmin || tmin !== tmin)
        tmin = tzmin;
      if (tzmax < tmax || tmax !== tmax)
        tmax = tzmax;
      if (tmax < 0)
        return null;
      return this.at(tmin >= 0 ? tmin : tmax, target);
    }
    intersectsBox(box) {
      return this.intersectBox(box, _vector$a) !== null;
    }
    intersectTriangle(a, b2, c, backfaceCulling, target) {
      _edge1.subVectors(b2, a);
      _edge2.subVectors(c, a);
      _normal$1.crossVectors(_edge1, _edge2);
      let DdN = this.direction.dot(_normal$1);
      let sign2;
      if (DdN > 0) {
        if (backfaceCulling)
          return null;
        sign2 = 1;
      } else if (DdN < 0) {
        sign2 = -1;
        DdN = -DdN;
      } else {
        return null;
      }
      _diff.subVectors(this.origin, a);
      const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
      if (DdQxE2 < 0) {
        return null;
      }
      const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
      if (DdE1xQ < 0) {
        return null;
      }
      if (DdQxE2 + DdE1xQ > DdN) {
        return null;
      }
      const QdN = -sign2 * _diff.dot(_normal$1);
      if (QdN < 0) {
        return null;
      }
      return this.at(QdN / DdN, target);
    }
    applyMatrix4(matrix4) {
      this.origin.applyMatrix4(matrix4);
      this.direction.transformDirection(matrix4);
      return this;
    }
    equals(ray) {
      return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var Matrix4 = class {
    constructor() {
      this.elements = [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ];
      if (arguments.length > 0) {
        console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
      }
    }
    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
      const te = this.elements;
      te[0] = n11;
      te[4] = n12;
      te[8] = n13;
      te[12] = n14;
      te[1] = n21;
      te[5] = n22;
      te[9] = n23;
      te[13] = n24;
      te[2] = n31;
      te[6] = n32;
      te[10] = n33;
      te[14] = n34;
      te[3] = n41;
      te[7] = n42;
      te[11] = n43;
      te[15] = n44;
      return this;
    }
    identity() {
      this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      return this;
    }
    clone() {
      return new Matrix4().fromArray(this.elements);
    }
    copy(m) {
      const te = this.elements;
      const me = m.elements;
      te[0] = me[0];
      te[1] = me[1];
      te[2] = me[2];
      te[3] = me[3];
      te[4] = me[4];
      te[5] = me[5];
      te[6] = me[6];
      te[7] = me[7];
      te[8] = me[8];
      te[9] = me[9];
      te[10] = me[10];
      te[11] = me[11];
      te[12] = me[12];
      te[13] = me[13];
      te[14] = me[14];
      te[15] = me[15];
      return this;
    }
    copyPosition(m) {
      const te = this.elements, me = m.elements;
      te[12] = me[12];
      te[13] = me[13];
      te[14] = me[14];
      return this;
    }
    setFromMatrix3(m) {
      const me = m.elements;
      this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
      return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
      xAxis.setFromMatrixColumn(this, 0);
      yAxis.setFromMatrixColumn(this, 1);
      zAxis.setFromMatrixColumn(this, 2);
      return this;
    }
    makeBasis(xAxis, yAxis, zAxis) {
      this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
      return this;
    }
    extractRotation(m) {
      const te = this.elements;
      const me = m.elements;
      const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
      const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
      const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
      te[0] = me[0] * scaleX;
      te[1] = me[1] * scaleX;
      te[2] = me[2] * scaleX;
      te[3] = 0;
      te[4] = me[4] * scaleY;
      te[5] = me[5] * scaleY;
      te[6] = me[6] * scaleY;
      te[7] = 0;
      te[8] = me[8] * scaleZ;
      te[9] = me[9] * scaleZ;
      te[10] = me[10] * scaleZ;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    }
    makeRotationFromEuler(euler) {
      if (!(euler && euler.isEuler)) {
        console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
      }
      const te = this.elements;
      const x = euler.x, y = euler.y, z = euler.z;
      const a = Math.cos(x), b2 = Math.sin(x);
      const c = Math.cos(y), d = Math.sin(y);
      const e = Math.cos(z), f = Math.sin(z);
      if (euler.order === "XYZ") {
        const ae = a * e, af = a * f, be = b2 * e, bf = b2 * f;
        te[0] = c * e;
        te[4] = -c * f;
        te[8] = d;
        te[1] = af + be * d;
        te[5] = ae - bf * d;
        te[9] = -b2 * c;
        te[2] = bf - ae * d;
        te[6] = be + af * d;
        te[10] = a * c;
      } else if (euler.order === "YXZ") {
        const ce = c * e, cf = c * f, de = d * e, df = d * f;
        te[0] = ce + df * b2;
        te[4] = de * b2 - cf;
        te[8] = a * d;
        te[1] = a * f;
        te[5] = a * e;
        te[9] = -b2;
        te[2] = cf * b2 - de;
        te[6] = df + ce * b2;
        te[10] = a * c;
      } else if (euler.order === "ZXY") {
        const ce = c * e, cf = c * f, de = d * e, df = d * f;
        te[0] = ce - df * b2;
        te[4] = -a * f;
        te[8] = de + cf * b2;
        te[1] = cf + de * b2;
        te[5] = a * e;
        te[9] = df - ce * b2;
        te[2] = -a * d;
        te[6] = b2;
        te[10] = a * c;
      } else if (euler.order === "ZYX") {
        const ae = a * e, af = a * f, be = b2 * e, bf = b2 * f;
        te[0] = c * e;
        te[4] = be * d - af;
        te[8] = ae * d + bf;
        te[1] = c * f;
        te[5] = bf * d + ae;
        te[9] = af * d - be;
        te[2] = -d;
        te[6] = b2 * c;
        te[10] = a * c;
      } else if (euler.order === "YZX") {
        const ac = a * c, ad = a * d, bc = b2 * c, bd = b2 * d;
        te[0] = c * e;
        te[4] = bd - ac * f;
        te[8] = bc * f + ad;
        te[1] = f;
        te[5] = a * e;
        te[9] = -b2 * e;
        te[2] = -d * e;
        te[6] = ad * f + bc;
        te[10] = ac - bd * f;
      } else if (euler.order === "XZY") {
        const ac = a * c, ad = a * d, bc = b2 * c, bd = b2 * d;
        te[0] = c * e;
        te[4] = -f;
        te[8] = d * e;
        te[1] = ac * f + bd;
        te[5] = a * e;
        te[9] = ad * f - bc;
        te[2] = bc * f - ad;
        te[6] = b2 * e;
        te[10] = bd * f + ac;
      }
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    }
    makeRotationFromQuaternion(q) {
      return this.compose(_zero, q, _one);
    }
    lookAt(eye, target, up) {
      const te = this.elements;
      _z.subVectors(eye, target);
      if (_z.lengthSq() === 0) {
        _z.z = 1;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
      if (_x.lengthSq() === 0) {
        if (Math.abs(up.z) === 1) {
          _z.x += 1e-4;
        } else {
          _z.z += 1e-4;
        }
        _z.normalize();
        _x.crossVectors(up, _z);
      }
      _x.normalize();
      _y.crossVectors(_z, _x);
      te[0] = _x.x;
      te[4] = _y.x;
      te[8] = _z.x;
      te[1] = _x.y;
      te[5] = _y.y;
      te[9] = _z.y;
      te[2] = _x.z;
      te[6] = _y.z;
      te[10] = _z.z;
      return this;
    }
    multiply(m, n) {
      if (n !== void 0) {
        console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
        return this.multiplyMatrices(m, n);
      }
      return this.multiplyMatrices(this, m);
    }
    premultiply(m) {
      return this.multiplyMatrices(m, this);
    }
    multiplyMatrices(a, b2) {
      const ae = a.elements;
      const be = b2.elements;
      const te = this.elements;
      const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
      const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
      const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
      const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
      const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
      const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
      const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
      const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
      te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
      te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
      te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
      te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
      te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
      te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
      te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
      te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
      te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
      te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
      te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
      te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
      te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
      return this;
    }
    multiplyScalar(s) {
      const te = this.elements;
      te[0] *= s;
      te[4] *= s;
      te[8] *= s;
      te[12] *= s;
      te[1] *= s;
      te[5] *= s;
      te[9] *= s;
      te[13] *= s;
      te[2] *= s;
      te[6] *= s;
      te[10] *= s;
      te[14] *= s;
      te[3] *= s;
      te[7] *= s;
      te[11] *= s;
      te[15] *= s;
      return this;
    }
    determinant() {
      const te = this.elements;
      const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
      const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
      const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
      const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
      return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
    }
    transpose() {
      const te = this.elements;
      let tmp2;
      tmp2 = te[1];
      te[1] = te[4];
      te[4] = tmp2;
      tmp2 = te[2];
      te[2] = te[8];
      te[8] = tmp2;
      tmp2 = te[6];
      te[6] = te[9];
      te[9] = tmp2;
      tmp2 = te[3];
      te[3] = te[12];
      te[12] = tmp2;
      tmp2 = te[7];
      te[7] = te[13];
      te[13] = tmp2;
      tmp2 = te[11];
      te[11] = te[14];
      te[14] = tmp2;
      return this;
    }
    setPosition(x, y, z) {
      const te = this.elements;
      if (x.isVector3) {
        te[12] = x.x;
        te[13] = x.y;
        te[14] = x.z;
      } else {
        te[12] = x;
        te[13] = y;
        te[14] = z;
      }
      return this;
    }
    invert() {
      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
      const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
      if (det === 0)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const detInv = 1 / det;
      te[0] = t11 * detInv;
      te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
      te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
      te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
      te[4] = t12 * detInv;
      te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
      te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
      te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
      te[8] = t13 * detInv;
      te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
      te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
      te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
      te[12] = t14 * detInv;
      te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
      te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
      te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
      return this;
    }
    scale(v) {
      const te = this.elements;
      const x = v.x, y = v.y, z = v.z;
      te[0] *= x;
      te[4] *= y;
      te[8] *= z;
      te[1] *= x;
      te[5] *= y;
      te[9] *= z;
      te[2] *= x;
      te[6] *= y;
      te[10] *= z;
      te[3] *= x;
      te[7] *= y;
      te[11] *= z;
      return this;
    }
    getMaxScaleOnAxis() {
      const te = this.elements;
      const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
      const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
      const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
      return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
    }
    makeTranslation(x, y, z) {
      this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
      return this;
    }
    makeRotationX(theta) {
      const c = Math.cos(theta), s = Math.sin(theta);
      this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
      return this;
    }
    makeRotationY(theta) {
      const c = Math.cos(theta), s = Math.sin(theta);
      this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
      return this;
    }
    makeRotationZ(theta) {
      const c = Math.cos(theta), s = Math.sin(theta);
      this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      return this;
    }
    makeRotationAxis(axis, angle) {
      const c = Math.cos(angle);
      const s = Math.sin(angle);
      const t = 1 - c;
      const x = axis.x, y = axis.y, z = axis.z;
      const tx = t * x, ty = t * y;
      this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
      return this;
    }
    makeScale(x, y, z) {
      this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
      return this;
    }
    makeShear(x, y, z) {
      this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
      return this;
    }
    compose(position, quaternion, scale) {
      const te = this.elements;
      const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
      const x2 = x + x, y2 = y + y, z2 = z + z;
      const xx = x * x2, xy = x * y2, xz = x * z2;
      const yy = y * y2, yz = y * z2, zz = z * z2;
      const wx = w * x2, wy = w * y2, wz = w * z2;
      const sx = scale.x, sy = scale.y, sz = scale.z;
      te[0] = (1 - (yy + zz)) * sx;
      te[1] = (xy + wz) * sx;
      te[2] = (xz - wy) * sx;
      te[3] = 0;
      te[4] = (xy - wz) * sy;
      te[5] = (1 - (xx + zz)) * sy;
      te[6] = (yz + wx) * sy;
      te[7] = 0;
      te[8] = (xz + wy) * sz;
      te[9] = (yz - wx) * sz;
      te[10] = (1 - (xx + yy)) * sz;
      te[11] = 0;
      te[12] = position.x;
      te[13] = position.y;
      te[14] = position.z;
      te[15] = 1;
      return this;
    }
    decompose(position, quaternion, scale) {
      const te = this.elements;
      let sx = _v1$5.set(te[0], te[1], te[2]).length();
      const sy = _v1$5.set(te[4], te[5], te[6]).length();
      const sz = _v1$5.set(te[8], te[9], te[10]).length();
      const det = this.determinant();
      if (det < 0)
        sx = -sx;
      position.x = te[12];
      position.y = te[13];
      position.z = te[14];
      _m1$2.copy(this);
      const invSX = 1 / sx;
      const invSY = 1 / sy;
      const invSZ = 1 / sz;
      _m1$2.elements[0] *= invSX;
      _m1$2.elements[1] *= invSX;
      _m1$2.elements[2] *= invSX;
      _m1$2.elements[4] *= invSY;
      _m1$2.elements[5] *= invSY;
      _m1$2.elements[6] *= invSY;
      _m1$2.elements[8] *= invSZ;
      _m1$2.elements[9] *= invSZ;
      _m1$2.elements[10] *= invSZ;
      quaternion.setFromRotationMatrix(_m1$2);
      scale.x = sx;
      scale.y = sy;
      scale.z = sz;
      return this;
    }
    makePerspective(left, right, top, bottom, near, far) {
      if (far === void 0) {
        console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
      }
      const te = this.elements;
      const x = 2 * near / (right - left);
      const y = 2 * near / (top - bottom);
      const a = (right + left) / (right - left);
      const b2 = (top + bottom) / (top - bottom);
      const c = -(far + near) / (far - near);
      const d = -2 * far * near / (far - near);
      te[0] = x;
      te[4] = 0;
      te[8] = a;
      te[12] = 0;
      te[1] = 0;
      te[5] = y;
      te[9] = b2;
      te[13] = 0;
      te[2] = 0;
      te[6] = 0;
      te[10] = c;
      te[14] = d;
      te[3] = 0;
      te[7] = 0;
      te[11] = -1;
      te[15] = 0;
      return this;
    }
    makeOrthographic(left, right, top, bottom, near, far) {
      const te = this.elements;
      const w = 1 / (right - left);
      const h = 1 / (top - bottom);
      const p = 1 / (far - near);
      const x = (right + left) * w;
      const y = (top + bottom) * h;
      const z = (far + near) * p;
      te[0] = 2 * w;
      te[4] = 0;
      te[8] = 0;
      te[12] = -x;
      te[1] = 0;
      te[5] = 2 * h;
      te[9] = 0;
      te[13] = -y;
      te[2] = 0;
      te[6] = 0;
      te[10] = -2 * p;
      te[14] = -z;
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[15] = 1;
      return this;
    }
    equals(matrix) {
      const te = this.elements;
      const me = matrix.elements;
      for (let i = 0; i < 16; i++) {
        if (te[i] !== me[i])
          return false;
      }
      return true;
    }
    fromArray(array, offset = 0) {
      for (let i = 0; i < 16; i++) {
        this.elements[i] = array[i + offset];
      }
      return this;
    }
    toArray(array = [], offset = 0) {
      const te = this.elements;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      array[offset + 9] = te[9];
      array[offset + 10] = te[10];
      array[offset + 11] = te[11];
      array[offset + 12] = te[12];
      array[offset + 13] = te[13];
      array[offset + 14] = te[14];
      array[offset + 15] = te[15];
      return array;
    }
  };
  Matrix4.prototype.isMatrix4 = true;
  var _v1$5 = /* @__PURE__ */ new Vector3();
  var _m1$2 = /* @__PURE__ */ new Matrix4();
  var _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
  var _one = /* @__PURE__ */ new Vector3(1, 1, 1);
  var _x = /* @__PURE__ */ new Vector3();
  var _y = /* @__PURE__ */ new Vector3();
  var _z = /* @__PURE__ */ new Vector3();
  var _matrix$1 = /* @__PURE__ */ new Matrix4();
  var _quaternion$3 = /* @__PURE__ */ new Quaternion();
  var Euler = class {
    constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
      this._x = x;
      this._y = y;
      this._z = z;
      this._order = order;
    }
    get x() {
      return this._x;
    }
    set x(value) {
      this._x = value;
      this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(value) {
      this._y = value;
      this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(value) {
      this._z = value;
      this._onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set order(value) {
      this._order = value;
      this._onChangeCallback();
    }
    set(x, y, z, order) {
      this._x = x;
      this._y = y;
      this._z = z;
      this._order = order || this._order;
      this._onChangeCallback();
      return this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(euler) {
      this._x = euler._x;
      this._y = euler._y;
      this._z = euler._z;
      this._order = euler._order;
      this._onChangeCallback();
      return this;
    }
    setFromRotationMatrix(m, order, update) {
      const clamp = MathUtils.clamp;
      const te = m.elements;
      const m11 = te[0], m12 = te[4], m13 = te[8];
      const m21 = te[1], m22 = te[5], m23 = te[9];
      const m31 = te[2], m32 = te[6], m33 = te[10];
      order = order || this._order;
      switch (order) {
        case "XYZ":
          this._y = Math.asin(clamp(m13, -1, 1));
          if (Math.abs(m13) < 0.9999999) {
            this._x = Math.atan2(-m23, m33);
            this._z = Math.atan2(-m12, m11);
          } else {
            this._x = Math.atan2(m32, m22);
            this._z = 0;
          }
          break;
        case "YXZ":
          this._x = Math.asin(-clamp(m23, -1, 1));
          if (Math.abs(m23) < 0.9999999) {
            this._y = Math.atan2(m13, m33);
            this._z = Math.atan2(m21, m22);
          } else {
            this._y = Math.atan2(-m31, m11);
            this._z = 0;
          }
          break;
        case "ZXY":
          this._x = Math.asin(clamp(m32, -1, 1));
          if (Math.abs(m32) < 0.9999999) {
            this._y = Math.atan2(-m31, m33);
            this._z = Math.atan2(-m12, m22);
          } else {
            this._y = 0;
            this._z = Math.atan2(m21, m11);
          }
          break;
        case "ZYX":
          this._y = Math.asin(-clamp(m31, -1, 1));
          if (Math.abs(m31) < 0.9999999) {
            this._x = Math.atan2(m32, m33);
            this._z = Math.atan2(m21, m11);
          } else {
            this._x = 0;
            this._z = Math.atan2(-m12, m22);
          }
          break;
        case "YZX":
          this._z = Math.asin(clamp(m21, -1, 1));
          if (Math.abs(m21) < 0.9999999) {
            this._x = Math.atan2(-m23, m22);
            this._y = Math.atan2(-m31, m11);
          } else {
            this._x = 0;
            this._y = Math.atan2(m13, m33);
          }
          break;
        case "XZY":
          this._z = Math.asin(-clamp(m12, -1, 1));
          if (Math.abs(m12) < 0.9999999) {
            this._x = Math.atan2(m32, m22);
            this._y = Math.atan2(m13, m11);
          } else {
            this._x = Math.atan2(-m23, m33);
            this._y = 0;
          }
          break;
        default:
          console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
      }
      this._order = order;
      if (update !== false)
        this._onChangeCallback();
      return this;
    }
    setFromQuaternion(q, order, update) {
      _matrix$1.makeRotationFromQuaternion(q);
      return this.setFromRotationMatrix(_matrix$1, order, update);
    }
    setFromVector3(v, order) {
      return this.set(v.x, v.y, v.z, order || this._order);
    }
    reorder(newOrder) {
      _quaternion$3.setFromEuler(this);
      return this.setFromQuaternion(_quaternion$3, newOrder);
    }
    equals(euler) {
      return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
    }
    fromArray(array) {
      this._x = array[0];
      this._y = array[1];
      this._z = array[2];
      if (array[3] !== void 0)
        this._order = array[3];
      this._onChangeCallback();
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._order;
      return array;
    }
    toVector3(optionalResult) {
      if (optionalResult) {
        return optionalResult.set(this._x, this._y, this._z);
      } else {
        return new Vector3(this._x, this._y, this._z);
      }
    }
    _onChange(callback) {
      this._onChangeCallback = callback;
      return this;
    }
    _onChangeCallback() {
    }
  };
  Euler.prototype.isEuler = true;
  Euler.DefaultOrder = "XYZ";
  Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
  var Layers = class {
    constructor() {
      this.mask = 1 | 0;
    }
    set(channel) {
      this.mask = 1 << channel | 0;
    }
    enable(channel) {
      this.mask |= 1 << channel | 0;
    }
    enableAll() {
      this.mask = 4294967295 | 0;
    }
    toggle(channel) {
      this.mask ^= 1 << channel | 0;
    }
    disable(channel) {
      this.mask &= ~(1 << channel | 0);
    }
    disableAll() {
      this.mask = 0;
    }
    test(layers) {
      return (this.mask & layers.mask) !== 0;
    }
  };
  var _object3DId = 0;
  var _v1$4 = new Vector3();
  var _q1 = new Quaternion();
  var _m1$1 = new Matrix4();
  var _target = new Vector3();
  var _position$3 = new Vector3();
  var _scale$2 = new Vector3();
  var _quaternion$2 = new Quaternion();
  var _xAxis = new Vector3(1, 0, 0);
  var _yAxis = new Vector3(0, 1, 0);
  var _zAxis = new Vector3(0, 0, 1);
  var _addedEvent = { type: "added" };
  var _removedEvent = { type: "removed" };
  function Object3D() {
    Object.defineProperty(this, "id", { value: _object3DId++ });
    this.uuid = MathUtils.generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = Object3D.DefaultUp.clone();
    const position = new Vector3();
    const rotation = new Euler();
    const quaternion = new Quaternion();
    const scale = new Vector3(1, 1, 1);
    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, void 0, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale
      },
      modelViewMatrix: {
        value: new Matrix4()
      },
      normalMatrix: {
        value: new Matrix3()
      }
    });
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.userData = {};
  }
  Object3D.DefaultUp = new Vector3(0, 1, 0);
  Object3D.DefaultMatrixAutoUpdate = true;
  Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Object3D,
    isObject3D: true,
    onBeforeRender: function() {
    },
    onAfterRender: function() {
    },
    applyMatrix4: function(matrix) {
      if (this.matrixAutoUpdate)
        this.updateMatrix();
      this.matrix.premultiply(matrix);
      this.matrix.decompose(this.position, this.quaternion, this.scale);
    },
    applyQuaternion: function(q) {
      this.quaternion.premultiply(q);
      return this;
    },
    setRotationFromAxisAngle: function(axis, angle) {
      this.quaternion.setFromAxisAngle(axis, angle);
    },
    setRotationFromEuler: function(euler) {
      this.quaternion.setFromEuler(euler, true);
    },
    setRotationFromMatrix: function(m) {
      this.quaternion.setFromRotationMatrix(m);
    },
    setRotationFromQuaternion: function(q) {
      this.quaternion.copy(q);
    },
    rotateOnAxis: function(axis, angle) {
      _q1.setFromAxisAngle(axis, angle);
      this.quaternion.multiply(_q1);
      return this;
    },
    rotateOnWorldAxis: function(axis, angle) {
      _q1.setFromAxisAngle(axis, angle);
      this.quaternion.premultiply(_q1);
      return this;
    },
    rotateX: function(angle) {
      return this.rotateOnAxis(_xAxis, angle);
    },
    rotateY: function(angle) {
      return this.rotateOnAxis(_yAxis, angle);
    },
    rotateZ: function(angle) {
      return this.rotateOnAxis(_zAxis, angle);
    },
    translateOnAxis: function(axis, distance) {
      _v1$4.copy(axis).applyQuaternion(this.quaternion);
      this.position.add(_v1$4.multiplyScalar(distance));
      return this;
    },
    translateX: function(distance) {
      return this.translateOnAxis(_xAxis, distance);
    },
    translateY: function(distance) {
      return this.translateOnAxis(_yAxis, distance);
    },
    translateZ: function(distance) {
      return this.translateOnAxis(_zAxis, distance);
    },
    localToWorld: function(vector) {
      return vector.applyMatrix4(this.matrixWorld);
    },
    worldToLocal: function(vector) {
      return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
    },
    lookAt: function(x, y, z) {
      if (x.isVector3) {
        _target.copy(x);
      } else {
        _target.set(x, y, z);
      }
      const parent = this.parent;
      this.updateWorldMatrix(true, false);
      _position$3.setFromMatrixPosition(this.matrixWorld);
      if (this.isCamera || this.isLight) {
        _m1$1.lookAt(_position$3, _target, this.up);
      } else {
        _m1$1.lookAt(_target, _position$3, this.up);
      }
      this.quaternion.setFromRotationMatrix(_m1$1);
      if (parent) {
        _m1$1.extractRotation(parent.matrixWorld);
        _q1.setFromRotationMatrix(_m1$1);
        this.quaternion.premultiply(_q1.invert());
      }
    },
    add: function(object) {
      if (arguments.length > 1) {
        for (let i = 0; i < arguments.length; i++) {
          this.add(arguments[i]);
        }
        return this;
      }
      if (object === this) {
        console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
        return this;
      }
      if (object && object.isObject3D) {
        if (object.parent !== null) {
          object.parent.remove(object);
        }
        object.parent = this;
        this.children.push(object);
        object.dispatchEvent(_addedEvent);
      } else {
        console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
      }
      return this;
    },
    remove: function(object) {
      if (arguments.length > 1) {
        for (let i = 0; i < arguments.length; i++) {
          this.remove(arguments[i]);
        }
        return this;
      }
      const index = this.children.indexOf(object);
      if (index !== -1) {
        object.parent = null;
        this.children.splice(index, 1);
        object.dispatchEvent(_removedEvent);
      }
      return this;
    },
    clear: function() {
      for (let i = 0; i < this.children.length; i++) {
        const object = this.children[i];
        object.parent = null;
        object.dispatchEvent(_removedEvent);
      }
      this.children.length = 0;
      return this;
    },
    attach: function(object) {
      this.updateWorldMatrix(true, false);
      _m1$1.copy(this.matrixWorld).invert();
      if (object.parent !== null) {
        object.parent.updateWorldMatrix(true, false);
        _m1$1.multiply(object.parent.matrixWorld);
      }
      object.applyMatrix4(_m1$1);
      this.add(object);
      object.updateWorldMatrix(false, true);
      return this;
    },
    getObjectById: function(id) {
      return this.getObjectByProperty("id", id);
    },
    getObjectByName: function(name) {
      return this.getObjectByProperty("name", name);
    },
    getObjectByProperty: function(name, value) {
      if (this[name] === value)
        return this;
      for (let i = 0, l = this.children.length; i < l; i++) {
        const child = this.children[i];
        const object = child.getObjectByProperty(name, value);
        if (object !== void 0) {
          return object;
        }
      }
      return void 0;
    },
    getWorldPosition: function(target) {
      if (target === void 0) {
        console.warn("THREE.Object3D: .getWorldPosition() target is now required");
        target = new Vector3();
      }
      this.updateWorldMatrix(true, false);
      return target.setFromMatrixPosition(this.matrixWorld);
    },
    getWorldQuaternion: function(target) {
      if (target === void 0) {
        console.warn("THREE.Object3D: .getWorldQuaternion() target is now required");
        target = new Quaternion();
      }
      this.updateWorldMatrix(true, false);
      this.matrixWorld.decompose(_position$3, target, _scale$2);
      return target;
    },
    getWorldScale: function(target) {
      if (target === void 0) {
        console.warn("THREE.Object3D: .getWorldScale() target is now required");
        target = new Vector3();
      }
      this.updateWorldMatrix(true, false);
      this.matrixWorld.decompose(_position$3, _quaternion$2, target);
      return target;
    },
    getWorldDirection: function(target) {
      if (target === void 0) {
        console.warn("THREE.Object3D: .getWorldDirection() target is now required");
        target = new Vector3();
      }
      this.updateWorldMatrix(true, false);
      const e = this.matrixWorld.elements;
      return target.set(e[8], e[9], e[10]).normalize();
    },
    raycast: function() {
    },
    traverse: function(callback) {
      callback(this);
      const children = this.children;
      for (let i = 0, l = children.length; i < l; i++) {
        children[i].traverse(callback);
      }
    },
    traverseVisible: function(callback) {
      if (this.visible === false)
        return;
      callback(this);
      const children = this.children;
      for (let i = 0, l = children.length; i < l; i++) {
        children[i].traverseVisible(callback);
      }
    },
    traverseAncestors: function(callback) {
      const parent = this.parent;
      if (parent !== null) {
        callback(parent);
        parent.traverseAncestors(callback);
      }
    },
    updateMatrix: function() {
      this.matrix.compose(this.position, this.quaternion, this.scale);
      this.matrixWorldNeedsUpdate = true;
    },
    updateMatrixWorld: function(force) {
      if (this.matrixAutoUpdate)
        this.updateMatrix();
      if (this.matrixWorldNeedsUpdate || force) {
        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        }
        this.matrixWorldNeedsUpdate = false;
        force = true;
      }
      const children = this.children;
      for (let i = 0, l = children.length; i < l; i++) {
        children[i].updateMatrixWorld(force);
      }
    },
    updateWorldMatrix: function(updateParents, updateChildren) {
      const parent = this.parent;
      if (updateParents === true && parent !== null) {
        parent.updateWorldMatrix(true, false);
      }
      if (this.matrixAutoUpdate)
        this.updateMatrix();
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      if (updateChildren === true) {
        const children = this.children;
        for (let i = 0, l = children.length; i < l; i++) {
          children[i].updateWorldMatrix(false, true);
        }
      }
    },
    toJSON: function(meta) {
      const isRootObject = meta === void 0 || typeof meta === "string";
      const output = {};
      if (isRootObject) {
        meta = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {},
          skeletons: {},
          animations: {}
        };
        output.metadata = {
          version: 4.5,
          type: "Object",
          generator: "Object3D.toJSON"
        };
      }
      const object = {};
      object.uuid = this.uuid;
      object.type = this.type;
      if (this.name !== "")
        object.name = this.name;
      if (this.castShadow === true)
        object.castShadow = true;
      if (this.receiveShadow === true)
        object.receiveShadow = true;
      if (this.visible === false)
        object.visible = false;
      if (this.frustumCulled === false)
        object.frustumCulled = false;
      if (this.renderOrder !== 0)
        object.renderOrder = this.renderOrder;
      if (JSON.stringify(this.userData) !== "{}")
        object.userData = this.userData;
      object.layers = this.layers.mask;
      object.matrix = this.matrix.toArray();
      if (this.matrixAutoUpdate === false)
        object.matrixAutoUpdate = false;
      if (this.isInstancedMesh) {
        object.type = "InstancedMesh";
        object.count = this.count;
        object.instanceMatrix = this.instanceMatrix.toJSON();
        if (this.instanceColor !== null)
          object.instanceColor = this.instanceColor.toJSON();
      }
      function serialize(library, element) {
        if (library[element.uuid] === void 0) {
          library[element.uuid] = element.toJSON(meta);
        }
        return element.uuid;
      }
      if (this.isMesh || this.isLine || this.isPoints) {
        object.geometry = serialize(meta.geometries, this.geometry);
        const parameters = this.geometry.parameters;
        if (parameters !== void 0 && parameters.shapes !== void 0) {
          const shapes = parameters.shapes;
          if (Array.isArray(shapes)) {
            for (let i = 0, l = shapes.length; i < l; i++) {
              const shape = shapes[i];
              serialize(meta.shapes, shape);
            }
          } else {
            serialize(meta.shapes, shapes);
          }
        }
      }
      if (this.isSkinnedMesh) {
        object.bindMode = this.bindMode;
        object.bindMatrix = this.bindMatrix.toArray();
        if (this.skeleton !== void 0) {
          serialize(meta.skeletons, this.skeleton);
          object.skeleton = this.skeleton.uuid;
        }
      }
      if (this.material !== void 0) {
        if (Array.isArray(this.material)) {
          const uuids = [];
          for (let i = 0, l = this.material.length; i < l; i++) {
            uuids.push(serialize(meta.materials, this.material[i]));
          }
          object.material = uuids;
        } else {
          object.material = serialize(meta.materials, this.material);
        }
      }
      if (this.children.length > 0) {
        object.children = [];
        for (let i = 0; i < this.children.length; i++) {
          object.children.push(this.children[i].toJSON(meta).object);
        }
      }
      if (this.animations.length > 0) {
        object.animations = [];
        for (let i = 0; i < this.animations.length; i++) {
          const animation = this.animations[i];
          object.animations.push(serialize(meta.animations, animation));
        }
      }
      if (isRootObject) {
        const geometries = extractFromCache(meta.geometries);
        const materials = extractFromCache(meta.materials);
        const textures = extractFromCache(meta.textures);
        const images = extractFromCache(meta.images);
        const shapes = extractFromCache(meta.shapes);
        const skeletons = extractFromCache(meta.skeletons);
        const animations = extractFromCache(meta.animations);
        if (geometries.length > 0)
          output.geometries = geometries;
        if (materials.length > 0)
          output.materials = materials;
        if (textures.length > 0)
          output.textures = textures;
        if (images.length > 0)
          output.images = images;
        if (shapes.length > 0)
          output.shapes = shapes;
        if (skeletons.length > 0)
          output.skeletons = skeletons;
        if (animations.length > 0)
          output.animations = animations;
      }
      output.object = object;
      return output;
      function extractFromCache(cache) {
        const values = [];
        for (const key in cache) {
          const data = cache[key];
          delete data.metadata;
          values.push(data);
        }
        return values;
      }
    },
    clone: function(recursive) {
      return new this.constructor().copy(this, recursive);
    },
    copy: function(source, recursive = true) {
      this.name = source.name;
      this.up.copy(source.up);
      this.position.copy(source.position);
      this.rotation.order = source.rotation.order;
      this.quaternion.copy(source.quaternion);
      this.scale.copy(source.scale);
      this.matrix.copy(source.matrix);
      this.matrixWorld.copy(source.matrixWorld);
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
      this.layers.mask = source.layers.mask;
      this.visible = source.visible;
      this.castShadow = source.castShadow;
      this.receiveShadow = source.receiveShadow;
      this.frustumCulled = source.frustumCulled;
      this.renderOrder = source.renderOrder;
      this.userData = JSON.parse(JSON.stringify(source.userData));
      if (recursive === true) {
        for (let i = 0; i < source.children.length; i++) {
          const child = source.children[i];
          this.add(child.clone());
        }
      }
      return this;
    }
  });
  var _vector1 = /* @__PURE__ */ new Vector3();
  var _vector2$1 = /* @__PURE__ */ new Vector3();
  var _normalMatrix = /* @__PURE__ */ new Matrix3();
  var Plane = class {
    constructor(normal = new Vector3(1, 0, 0), constant = 0) {
      this.normal = normal;
      this.constant = constant;
    }
    set(normal, constant) {
      this.normal.copy(normal);
      this.constant = constant;
      return this;
    }
    setComponents(x, y, z, w) {
      this.normal.set(x, y, z);
      this.constant = w;
      return this;
    }
    setFromNormalAndCoplanarPoint(normal, point) {
      this.normal.copy(normal);
      this.constant = -point.dot(this.normal);
      return this;
    }
    setFromCoplanarPoints(a, b2, c) {
      const normal = _vector1.subVectors(c, b2).cross(_vector2$1.subVectors(a, b2)).normalize();
      this.setFromNormalAndCoplanarPoint(normal, a);
      return this;
    }
    copy(plane) {
      this.normal.copy(plane.normal);
      this.constant = plane.constant;
      return this;
    }
    normalize() {
      const inverseNormalLength = 1 / this.normal.length();
      this.normal.multiplyScalar(inverseNormalLength);
      this.constant *= inverseNormalLength;
      return this;
    }
    negate() {
      this.constant *= -1;
      this.normal.negate();
      return this;
    }
    distanceToPoint(point) {
      return this.normal.dot(point) + this.constant;
    }
    distanceToSphere(sphere) {
      return this.distanceToPoint(sphere.center) - sphere.radius;
    }
    projectPoint(point, target) {
      if (target === void 0) {
        console.warn("THREE.Plane: .projectPoint() target is now required");
        target = new Vector3();
      }
      return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
    }
    intersectLine(line, target) {
      if (target === void 0) {
        console.warn("THREE.Plane: .intersectLine() target is now required");
        target = new Vector3();
      }
      const direction = line.delta(_vector1);
      const denominator = this.normal.dot(direction);
      if (denominator === 0) {
        if (this.distanceToPoint(line.start) === 0) {
          return target.copy(line.start);
        }
        return null;
      }
      const t = -(line.start.dot(this.normal) + this.constant) / denominator;
      if (t < 0 || t > 1) {
        return null;
      }
      return target.copy(direction).multiplyScalar(t).add(line.start);
    }
    intersectsLine(line) {
      const startSign = this.distanceToPoint(line.start);
      const endSign = this.distanceToPoint(line.end);
      return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
    }
    intersectsBox(box) {
      return box.intersectsPlane(this);
    }
    intersectsSphere(sphere) {
      return sphere.intersectsPlane(this);
    }
    coplanarPoint(target) {
      if (target === void 0) {
        console.warn("THREE.Plane: .coplanarPoint() target is now required");
        target = new Vector3();
      }
      return target.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(matrix, optionalNormalMatrix) {
      const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
      const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
      const normal = this.normal.applyMatrix3(normalMatrix).normalize();
      this.constant = -referencePoint.dot(normal);
      return this;
    }
    translate(offset) {
      this.constant -= offset.dot(this.normal);
      return this;
    }
    equals(plane) {
      return plane.normal.equals(this.normal) && plane.constant === this.constant;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  Plane.prototype.isPlane = true;
  var _v0$1 = /* @__PURE__ */ new Vector3();
  var _v1$3 = /* @__PURE__ */ new Vector3();
  var _v2$2 = /* @__PURE__ */ new Vector3();
  var _v3$1 = /* @__PURE__ */ new Vector3();
  var _vab = /* @__PURE__ */ new Vector3();
  var _vac = /* @__PURE__ */ new Vector3();
  var _vbc = /* @__PURE__ */ new Vector3();
  var _vap = /* @__PURE__ */ new Vector3();
  var _vbp = /* @__PURE__ */ new Vector3();
  var _vcp = /* @__PURE__ */ new Vector3();
  var Triangle = class {
    constructor(a = new Vector3(), b2 = new Vector3(), c = new Vector3()) {
      this.a = a;
      this.b = b2;
      this.c = c;
    }
    static getNormal(a, b2, c, target) {
      if (target === void 0) {
        console.warn("THREE.Triangle: .getNormal() target is now required");
        target = new Vector3();
      }
      target.subVectors(c, b2);
      _v0$1.subVectors(a, b2);
      target.cross(_v0$1);
      const targetLengthSq = target.lengthSq();
      if (targetLengthSq > 0) {
        return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
      }
      return target.set(0, 0, 0);
    }
    static getBarycoord(point, a, b2, c, target) {
      _v0$1.subVectors(c, a);
      _v1$3.subVectors(b2, a);
      _v2$2.subVectors(point, a);
      const dot00 = _v0$1.dot(_v0$1);
      const dot01 = _v0$1.dot(_v1$3);
      const dot02 = _v0$1.dot(_v2$2);
      const dot11 = _v1$3.dot(_v1$3);
      const dot12 = _v1$3.dot(_v2$2);
      const denom = dot00 * dot11 - dot01 * dot01;
      if (target === void 0) {
        console.warn("THREE.Triangle: .getBarycoord() target is now required");
        target = new Vector3();
      }
      if (denom === 0) {
        return target.set(-2, -1, -1);
      }
      const invDenom = 1 / denom;
      const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
      const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
      return target.set(1 - u - v, v, u);
    }
    static containsPoint(point, a, b2, c) {
      this.getBarycoord(point, a, b2, c, _v3$1);
      return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
    }
    static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
      this.getBarycoord(point, p1, p2, p3, _v3$1);
      target.set(0, 0);
      target.addScaledVector(uv1, _v3$1.x);
      target.addScaledVector(uv2, _v3$1.y);
      target.addScaledVector(uv3, _v3$1.z);
      return target;
    }
    static isFrontFacing(a, b2, c, direction) {
      _v0$1.subVectors(c, b2);
      _v1$3.subVectors(a, b2);
      return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
    }
    set(a, b2, c) {
      this.a.copy(a);
      this.b.copy(b2);
      this.c.copy(c);
      return this;
    }
    setFromPointsAndIndices(points, i0, i1, i2) {
      this.a.copy(points[i0]);
      this.b.copy(points[i1]);
      this.c.copy(points[i2]);
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(triangle) {
      this.a.copy(triangle.a);
      this.b.copy(triangle.b);
      this.c.copy(triangle.c);
      return this;
    }
    getArea() {
      _v0$1.subVectors(this.c, this.b);
      _v1$3.subVectors(this.a, this.b);
      return _v0$1.cross(_v1$3).length() * 0.5;
    }
    getMidpoint(target) {
      if (target === void 0) {
        console.warn("THREE.Triangle: .getMidpoint() target is now required");
        target = new Vector3();
      }
      return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
    getNormal(target) {
      return Triangle.getNormal(this.a, this.b, this.c, target);
    }
    getPlane(target) {
      if (target === void 0) {
        console.warn("THREE.Triangle: .getPlane() target is now required");
        target = new Plane();
      }
      return target.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(point, target) {
      return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
    }
    getUV(point, uv1, uv2, uv3, target) {
      return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
    }
    containsPoint(point) {
      return Triangle.containsPoint(point, this.a, this.b, this.c);
    }
    isFrontFacing(direction) {
      return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
    }
    intersectsBox(box) {
      return box.intersectsTriangle(this);
    }
    closestPointToPoint(p, target) {
      if (target === void 0) {
        console.warn("THREE.Triangle: .closestPointToPoint() target is now required");
        target = new Vector3();
      }
      const a = this.a, b2 = this.b, c = this.c;
      let v, w;
      _vab.subVectors(b2, a);
      _vac.subVectors(c, a);
      _vap.subVectors(p, a);
      const d1 = _vab.dot(_vap);
      const d2 = _vac.dot(_vap);
      if (d1 <= 0 && d2 <= 0) {
        return target.copy(a);
      }
      _vbp.subVectors(p, b2);
      const d3 = _vab.dot(_vbp);
      const d4 = _vac.dot(_vbp);
      if (d3 >= 0 && d4 <= d3) {
        return target.copy(b2);
      }
      const vc = d1 * d4 - d3 * d2;
      if (vc <= 0 && d1 >= 0 && d3 <= 0) {
        v = d1 / (d1 - d3);
        return target.copy(a).addScaledVector(_vab, v);
      }
      _vcp.subVectors(p, c);
      const d5 = _vab.dot(_vcp);
      const d6 = _vac.dot(_vcp);
      if (d6 >= 0 && d5 <= d6) {
        return target.copy(c);
      }
      const vb = d5 * d2 - d1 * d6;
      if (vb <= 0 && d2 >= 0 && d6 <= 0) {
        w = d2 / (d2 - d6);
        return target.copy(a).addScaledVector(_vac, w);
      }
      const va = d3 * d6 - d5 * d4;
      if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
        _vbc.subVectors(c, b2);
        w = (d4 - d3) / (d4 - d3 + (d5 - d6));
        return target.copy(b2).addScaledVector(_vbc, w);
      }
      const denom = 1 / (va + vb + vc);
      v = vb * denom;
      w = vc * denom;
      return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
    }
    equals(triangle) {
      return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
    }
  };
  var materialId = 0;
  function Material() {
    Object.defineProperty(this, "id", { value: materialId++ });
    this.uuid = MathUtils.generateUUID();
    this.name = "";
    this.type = "Material";
    this.fog = true;
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.vertexColors = false;
    this.opacity = 1;
    this.transparent = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 255;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaTest = 0;
    this.alphaToCoverage = false;
    this.premultipliedAlpha = false;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {};
    this.version = 0;
  }
  Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Material,
    isMaterial: true,
    onBeforeCompile: function() {
    },
    customProgramCacheKey: function() {
      return this.onBeforeCompile.toString();
    },
    setValues: function(values) {
      if (values === void 0)
        return;
      for (const key in values) {
        const newValue = values[key];
        if (newValue === void 0) {
          console.warn("THREE.Material: '" + key + "' parameter is undefined.");
          continue;
        }
        if (key === "shading") {
          console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
          this.flatShading = newValue === FlatShading ? true : false;
          continue;
        }
        const currentValue = this[key];
        if (currentValue === void 0) {
          console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
          continue;
        }
        if (currentValue && currentValue.isColor) {
          currentValue.set(newValue);
        } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
          currentValue.copy(newValue);
        } else {
          this[key] = newValue;
        }
      }
    },
    toJSON: function(meta) {
      const isRoot = meta === void 0 || typeof meta === "string";
      if (isRoot) {
        meta = {
          textures: {},
          images: {}
        };
      }
      const data = {
        metadata: {
          version: 4.5,
          type: "Material",
          generator: "Material.toJSON"
        }
      };
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== "")
        data.name = this.name;
      if (this.color && this.color.isColor)
        data.color = this.color.getHex();
      if (this.roughness !== void 0)
        data.roughness = this.roughness;
      if (this.metalness !== void 0)
        data.metalness = this.metalness;
      if (this.sheen && this.sheen.isColor)
        data.sheen = this.sheen.getHex();
      if (this.emissive && this.emissive.isColor)
        data.emissive = this.emissive.getHex();
      if (this.emissiveIntensity && this.emissiveIntensity !== 1)
        data.emissiveIntensity = this.emissiveIntensity;
      if (this.specular && this.specular.isColor)
        data.specular = this.specular.getHex();
      if (this.shininess !== void 0)
        data.shininess = this.shininess;
      if (this.clearcoat !== void 0)
        data.clearcoat = this.clearcoat;
      if (this.clearcoatRoughness !== void 0)
        data.clearcoatRoughness = this.clearcoatRoughness;
      if (this.clearcoatMap && this.clearcoatMap.isTexture) {
        data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
      }
      if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
        data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
      }
      if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
        data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
        data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
      }
      if (this.map && this.map.isTexture)
        data.map = this.map.toJSON(meta).uuid;
      if (this.matcap && this.matcap.isTexture)
        data.matcap = this.matcap.toJSON(meta).uuid;
      if (this.alphaMap && this.alphaMap.isTexture)
        data.alphaMap = this.alphaMap.toJSON(meta).uuid;
      if (this.lightMap && this.lightMap.isTexture) {
        data.lightMap = this.lightMap.toJSON(meta).uuid;
        data.lightMapIntensity = this.lightMapIntensity;
      }
      if (this.aoMap && this.aoMap.isTexture) {
        data.aoMap = this.aoMap.toJSON(meta).uuid;
        data.aoMapIntensity = this.aoMapIntensity;
      }
      if (this.bumpMap && this.bumpMap.isTexture) {
        data.bumpMap = this.bumpMap.toJSON(meta).uuid;
        data.bumpScale = this.bumpScale;
      }
      if (this.normalMap && this.normalMap.isTexture) {
        data.normalMap = this.normalMap.toJSON(meta).uuid;
        data.normalMapType = this.normalMapType;
        data.normalScale = this.normalScale.toArray();
      }
      if (this.displacementMap && this.displacementMap.isTexture) {
        data.displacementMap = this.displacementMap.toJSON(meta).uuid;
        data.displacementScale = this.displacementScale;
        data.displacementBias = this.displacementBias;
      }
      if (this.roughnessMap && this.roughnessMap.isTexture)
        data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
      if (this.metalnessMap && this.metalnessMap.isTexture)
        data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
      if (this.emissiveMap && this.emissiveMap.isTexture)
        data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
      if (this.specularMap && this.specularMap.isTexture)
        data.specularMap = this.specularMap.toJSON(meta).uuid;
      if (this.envMap && this.envMap.isTexture) {
        data.envMap = this.envMap.toJSON(meta).uuid;
        data.reflectivity = this.reflectivity;
        data.refractionRatio = this.refractionRatio;
        if (this.combine !== void 0)
          data.combine = this.combine;
        if (this.envMapIntensity !== void 0)
          data.envMapIntensity = this.envMapIntensity;
      }
      if (this.gradientMap && this.gradientMap.isTexture) {
        data.gradientMap = this.gradientMap.toJSON(meta).uuid;
      }
      if (this.size !== void 0)
        data.size = this.size;
      if (this.shadowSide !== null)
        data.shadowSide = this.shadowSide;
      if (this.sizeAttenuation !== void 0)
        data.sizeAttenuation = this.sizeAttenuation;
      if (this.blending !== NormalBlending)
        data.blending = this.blending;
      if (this.side !== FrontSide)
        data.side = this.side;
      if (this.vertexColors)
        data.vertexColors = true;
      if (this.opacity < 1)
        data.opacity = this.opacity;
      if (this.transparent === true)
        data.transparent = this.transparent;
      data.depthFunc = this.depthFunc;
      data.depthTest = this.depthTest;
      data.depthWrite = this.depthWrite;
      data.colorWrite = this.colorWrite;
      data.stencilWrite = this.stencilWrite;
      data.stencilWriteMask = this.stencilWriteMask;
      data.stencilFunc = this.stencilFunc;
      data.stencilRef = this.stencilRef;
      data.stencilFuncMask = this.stencilFuncMask;
      data.stencilFail = this.stencilFail;
      data.stencilZFail = this.stencilZFail;
      data.stencilZPass = this.stencilZPass;
      if (this.rotation && this.rotation !== 0)
        data.rotation = this.rotation;
      if (this.polygonOffset === true)
        data.polygonOffset = true;
      if (this.polygonOffsetFactor !== 0)
        data.polygonOffsetFactor = this.polygonOffsetFactor;
      if (this.polygonOffsetUnits !== 0)
        data.polygonOffsetUnits = this.polygonOffsetUnits;
      if (this.linewidth && this.linewidth !== 1)
        data.linewidth = this.linewidth;
      if (this.dashSize !== void 0)
        data.dashSize = this.dashSize;
      if (this.gapSize !== void 0)
        data.gapSize = this.gapSize;
      if (this.scale !== void 0)
        data.scale = this.scale;
      if (this.dithering === true)
        data.dithering = true;
      if (this.alphaTest > 0)
        data.alphaTest = this.alphaTest;
      if (this.alphaToCoverage === true)
        data.alphaToCoverage = this.alphaToCoverage;
      if (this.premultipliedAlpha === true)
        data.premultipliedAlpha = this.premultipliedAlpha;
      if (this.wireframe === true)
        data.wireframe = this.wireframe;
      if (this.wireframeLinewidth > 1)
        data.wireframeLinewidth = this.wireframeLinewidth;
      if (this.wireframeLinecap !== "round")
        data.wireframeLinecap = this.wireframeLinecap;
      if (this.wireframeLinejoin !== "round")
        data.wireframeLinejoin = this.wireframeLinejoin;
      if (this.morphTargets === true)
        data.morphTargets = true;
      if (this.morphNormals === true)
        data.morphNormals = true;
      if (this.skinning === true)
        data.skinning = true;
      if (this.flatShading === true)
        data.flatShading = this.flatShading;
      if (this.visible === false)
        data.visible = false;
      if (this.toneMapped === false)
        data.toneMapped = false;
      if (JSON.stringify(this.userData) !== "{}")
        data.userData = this.userData;
      function extractFromCache(cache) {
        const values = [];
        for (const key in cache) {
          const data2 = cache[key];
          delete data2.metadata;
          values.push(data2);
        }
        return values;
      }
      if (isRoot) {
        const textures = extractFromCache(meta.textures);
        const images = extractFromCache(meta.images);
        if (textures.length > 0)
          data.textures = textures;
        if (images.length > 0)
          data.images = images;
      }
      return data;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(source) {
      this.name = source.name;
      this.fog = source.fog;
      this.blending = source.blending;
      this.side = source.side;
      this.vertexColors = source.vertexColors;
      this.opacity = source.opacity;
      this.transparent = source.transparent;
      this.blendSrc = source.blendSrc;
      this.blendDst = source.blendDst;
      this.blendEquation = source.blendEquation;
      this.blendSrcAlpha = source.blendSrcAlpha;
      this.blendDstAlpha = source.blendDstAlpha;
      this.blendEquationAlpha = source.blendEquationAlpha;
      this.depthFunc = source.depthFunc;
      this.depthTest = source.depthTest;
      this.depthWrite = source.depthWrite;
      this.stencilWriteMask = source.stencilWriteMask;
      this.stencilFunc = source.stencilFunc;
      this.stencilRef = source.stencilRef;
      this.stencilFuncMask = source.stencilFuncMask;
      this.stencilFail = source.stencilFail;
      this.stencilZFail = source.stencilZFail;
      this.stencilZPass = source.stencilZPass;
      this.stencilWrite = source.stencilWrite;
      const srcPlanes = source.clippingPlanes;
      let dstPlanes = null;
      if (srcPlanes !== null) {
        const n = srcPlanes.length;
        dstPlanes = new Array(n);
        for (let i = 0; i !== n; ++i) {
          dstPlanes[i] = srcPlanes[i].clone();
        }
      }
      this.clippingPlanes = dstPlanes;
      this.clipIntersection = source.clipIntersection;
      this.clipShadows = source.clipShadows;
      this.shadowSide = source.shadowSide;
      this.colorWrite = source.colorWrite;
      this.precision = source.precision;
      this.polygonOffset = source.polygonOffset;
      this.polygonOffsetFactor = source.polygonOffsetFactor;
      this.polygonOffsetUnits = source.polygonOffsetUnits;
      this.dithering = source.dithering;
      this.alphaTest = source.alphaTest;
      this.alphaToCoverage = source.alphaToCoverage;
      this.premultipliedAlpha = source.premultipliedAlpha;
      this.visible = source.visible;
      this.toneMapped = source.toneMapped;
      this.userData = JSON.parse(JSON.stringify(source.userData));
      return this;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  });
  Object.defineProperty(Material.prototype, "needsUpdate", {
    set: function(value) {
      if (value === true)
        this.version++;
    }
  });
  var _colorKeywords = {
    "aliceblue": 15792383,
    "antiquewhite": 16444375,
    "aqua": 65535,
    "aquamarine": 8388564,
    "azure": 15794175,
    "beige": 16119260,
    "bisque": 16770244,
    "black": 0,
    "blanchedalmond": 16772045,
    "blue": 255,
    "blueviolet": 9055202,
    "brown": 10824234,
    "burlywood": 14596231,
    "cadetblue": 6266528,
    "chartreuse": 8388352,
    "chocolate": 13789470,
    "coral": 16744272,
    "cornflowerblue": 6591981,
    "cornsilk": 16775388,
    "crimson": 14423100,
    "cyan": 65535,
    "darkblue": 139,
    "darkcyan": 35723,
    "darkgoldenrod": 12092939,
    "darkgray": 11119017,
    "darkgreen": 25600,
    "darkgrey": 11119017,
    "darkkhaki": 12433259,
    "darkmagenta": 9109643,
    "darkolivegreen": 5597999,
    "darkorange": 16747520,
    "darkorchid": 10040012,
    "darkred": 9109504,
    "darksalmon": 15308410,
    "darkseagreen": 9419919,
    "darkslateblue": 4734347,
    "darkslategray": 3100495,
    "darkslategrey": 3100495,
    "darkturquoise": 52945,
    "darkviolet": 9699539,
    "deeppink": 16716947,
    "deepskyblue": 49151,
    "dimgray": 6908265,
    "dimgrey": 6908265,
    "dodgerblue": 2003199,
    "firebrick": 11674146,
    "floralwhite": 16775920,
    "forestgreen": 2263842,
    "fuchsia": 16711935,
    "gainsboro": 14474460,
    "ghostwhite": 16316671,
    "gold": 16766720,
    "goldenrod": 14329120,
    "gray": 8421504,
    "green": 32768,
    "greenyellow": 11403055,
    "grey": 8421504,
    "honeydew": 15794160,
    "hotpink": 16738740,
    "indianred": 13458524,
    "indigo": 4915330,
    "ivory": 16777200,
    "khaki": 15787660,
    "lavender": 15132410,
    "lavenderblush": 16773365,
    "lawngreen": 8190976,
    "lemonchiffon": 16775885,
    "lightblue": 11393254,
    "lightcoral": 15761536,
    "lightcyan": 14745599,
    "lightgoldenrodyellow": 16448210,
    "lightgray": 13882323,
    "lightgreen": 9498256,
    "lightgrey": 13882323,
    "lightpink": 16758465,
    "lightsalmon": 16752762,
    "lightseagreen": 2142890,
    "lightskyblue": 8900346,
    "lightslategray": 7833753,
    "lightslategrey": 7833753,
    "lightsteelblue": 11584734,
    "lightyellow": 16777184,
    "lime": 65280,
    "limegreen": 3329330,
    "linen": 16445670,
    "magenta": 16711935,
    "maroon": 8388608,
    "mediumaquamarine": 6737322,
    "mediumblue": 205,
    "mediumorchid": 12211667,
    "mediumpurple": 9662683,
    "mediumseagreen": 3978097,
    "mediumslateblue": 8087790,
    "mediumspringgreen": 64154,
    "mediumturquoise": 4772300,
    "mediumvioletred": 13047173,
    "midnightblue": 1644912,
    "mintcream": 16121850,
    "mistyrose": 16770273,
    "moccasin": 16770229,
    "navajowhite": 16768685,
    "navy": 128,
    "oldlace": 16643558,
    "olive": 8421376,
    "olivedrab": 7048739,
    "orange": 16753920,
    "orangered": 16729344,
    "orchid": 14315734,
    "palegoldenrod": 15657130,
    "palegreen": 10025880,
    "paleturquoise": 11529966,
    "palevioletred": 14381203,
    "papayawhip": 16773077,
    "peachpuff": 16767673,
    "peru": 13468991,
    "pink": 16761035,
    "plum": 14524637,
    "powderblue": 11591910,
    "purple": 8388736,
    "rebeccapurple": 6697881,
    "red": 16711680,
    "rosybrown": 12357519,
    "royalblue": 4286945,
    "saddlebrown": 9127187,
    "salmon": 16416882,
    "sandybrown": 16032864,
    "seagreen": 3050327,
    "seashell": 16774638,
    "sienna": 10506797,
    "silver": 12632256,
    "skyblue": 8900331,
    "slateblue": 6970061,
    "slategray": 7372944,
    "slategrey": 7372944,
    "snow": 16775930,
    "springgreen": 65407,
    "steelblue": 4620980,
    "tan": 13808780,
    "teal": 32896,
    "thistle": 14204888,
    "tomato": 16737095,
    "turquoise": 4251856,
    "violet": 15631086,
    "wheat": 16113331,
    "white": 16777215,
    "whitesmoke": 16119285,
    "yellow": 16776960,
    "yellowgreen": 10145074
  };
  var _hslA = { h: 0, s: 0, l: 0 };
  var _hslB = { h: 0, s: 0, l: 0 };
  function hue2rgb(p, q, t) {
    if (t < 0)
      t += 1;
    if (t > 1)
      t -= 1;
    if (t < 1 / 6)
      return p + (q - p) * 6 * t;
    if (t < 1 / 2)
      return q;
    if (t < 2 / 3)
      return p + (q - p) * 6 * (2 / 3 - t);
    return p;
  }
  function SRGBToLinear(c) {
    return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
  }
  function LinearToSRGB(c) {
    return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
  }
  var Color = class {
    constructor(r, g, b2) {
      if (g === void 0 && b2 === void 0) {
        return this.set(r);
      }
      return this.setRGB(r, g, b2);
    }
    set(value) {
      if (value && value.isColor) {
        this.copy(value);
      } else if (typeof value === "number") {
        this.setHex(value);
      } else if (typeof value === "string") {
        this.setStyle(value);
      }
      return this;
    }
    setScalar(scalar) {
      this.r = scalar;
      this.g = scalar;
      this.b = scalar;
      return this;
    }
    setHex(hex) {
      hex = Math.floor(hex);
      this.r = (hex >> 16 & 255) / 255;
      this.g = (hex >> 8 & 255) / 255;
      this.b = (hex & 255) / 255;
      return this;
    }
    setRGB(r, g, b2) {
      this.r = r;
      this.g = g;
      this.b = b2;
      return this;
    }
    setHSL(h, s, l) {
      h = MathUtils.euclideanModulo(h, 1);
      s = MathUtils.clamp(s, 0, 1);
      l = MathUtils.clamp(l, 0, 1);
      if (s === 0) {
        this.r = this.g = this.b = l;
      } else {
        const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
        const q = 2 * l - p;
        this.r = hue2rgb(q, p, h + 1 / 3);
        this.g = hue2rgb(q, p, h);
        this.b = hue2rgb(q, p, h - 1 / 3);
      }
      return this;
    }
    setStyle(style) {
      function handleAlpha(string) {
        if (string === void 0)
          return;
        if (parseFloat(string) < 1) {
          console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
        }
      }
      let m;
      if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
        let color;
        const name = m[1];
        const components = m[2];
        switch (name) {
          case "rgb":
          case "rgba":
            if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
              this.r = Math.min(255, parseInt(color[1], 10)) / 255;
              this.g = Math.min(255, parseInt(color[2], 10)) / 255;
              this.b = Math.min(255, parseInt(color[3], 10)) / 255;
              handleAlpha(color[4]);
              return this;
            }
            if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
              this.r = Math.min(100, parseInt(color[1], 10)) / 100;
              this.g = Math.min(100, parseInt(color[2], 10)) / 100;
              this.b = Math.min(100, parseInt(color[3], 10)) / 100;
              handleAlpha(color[4]);
              return this;
            }
            break;
          case "hsl":
          case "hsla":
            if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
              const h = parseFloat(color[1]) / 360;
              const s = parseInt(color[2], 10) / 100;
              const l = parseInt(color[3], 10) / 100;
              handleAlpha(color[4]);
              return this.setHSL(h, s, l);
            }
            break;
        }
      } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
        const hex = m[1];
        const size2 = hex.length;
        if (size2 === 3) {
          this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
          this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
          this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
          return this;
        } else if (size2 === 6) {
          this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
          this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
          this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
          return this;
        }
      }
      if (style && style.length > 0) {
        return this.setColorName(style);
      }
      return this;
    }
    setColorName(style) {
      const hex = _colorKeywords[style];
      if (hex !== void 0) {
        this.setHex(hex);
      } else {
        console.warn("THREE.Color: Unknown color " + style);
      }
      return this;
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    copy(color) {
      this.r = color.r;
      this.g = color.g;
      this.b = color.b;
      return this;
    }
    copyGammaToLinear(color, gammaFactor = 2) {
      this.r = Math.pow(color.r, gammaFactor);
      this.g = Math.pow(color.g, gammaFactor);
      this.b = Math.pow(color.b, gammaFactor);
      return this;
    }
    copyLinearToGamma(color, gammaFactor = 2) {
      const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
      this.r = Math.pow(color.r, safeInverse);
      this.g = Math.pow(color.g, safeInverse);
      this.b = Math.pow(color.b, safeInverse);
      return this;
    }
    convertGammaToLinear(gammaFactor) {
      this.copyGammaToLinear(this, gammaFactor);
      return this;
    }
    convertLinearToGamma(gammaFactor) {
      this.copyLinearToGamma(this, gammaFactor);
      return this;
    }
    copySRGBToLinear(color) {
      this.r = SRGBToLinear(color.r);
      this.g = SRGBToLinear(color.g);
      this.b = SRGBToLinear(color.b);
      return this;
    }
    copyLinearToSRGB(color) {
      this.r = LinearToSRGB(color.r);
      this.g = LinearToSRGB(color.g);
      this.b = LinearToSRGB(color.b);
      return this;
    }
    convertSRGBToLinear() {
      this.copySRGBToLinear(this);
      return this;
    }
    convertLinearToSRGB() {
      this.copyLinearToSRGB(this);
      return this;
    }
    getHex() {
      return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
    }
    getHexString() {
      return ("000000" + this.getHex().toString(16)).slice(-6);
    }
    getHSL(target) {
      if (target === void 0) {
        console.warn("THREE.Color: .getHSL() target is now required");
        target = { h: 0, s: 0, l: 0 };
      }
      const r = this.r, g = this.g, b2 = this.b;
      const max = Math.max(r, g, b2);
      const min = Math.min(r, g, b2);
      let hue, saturation;
      const lightness = (min + max) / 2;
      if (min === max) {
        hue = 0;
        saturation = 0;
      } else {
        const delta = max - min;
        saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
        switch (max) {
          case r:
            hue = (g - b2) / delta + (g < b2 ? 6 : 0);
            break;
          case g:
            hue = (b2 - r) / delta + 2;
            break;
          case b2:
            hue = (r - g) / delta + 4;
            break;
        }
        hue /= 6;
      }
      target.h = hue;
      target.s = saturation;
      target.l = lightness;
      return target;
    }
    getStyle() {
      return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
    }
    offsetHSL(h, s, l) {
      this.getHSL(_hslA);
      _hslA.h += h;
      _hslA.s += s;
      _hslA.l += l;
      this.setHSL(_hslA.h, _hslA.s, _hslA.l);
      return this;
    }
    add(color) {
      this.r += color.r;
      this.g += color.g;
      this.b += color.b;
      return this;
    }
    addColors(color1, color2) {
      this.r = color1.r + color2.r;
      this.g = color1.g + color2.g;
      this.b = color1.b + color2.b;
      return this;
    }
    addScalar(s) {
      this.r += s;
      this.g += s;
      this.b += s;
      return this;
    }
    sub(color) {
      this.r = Math.max(0, this.r - color.r);
      this.g = Math.max(0, this.g - color.g);
      this.b = Math.max(0, this.b - color.b);
      return this;
    }
    multiply(color) {
      this.r *= color.r;
      this.g *= color.g;
      this.b *= color.b;
      return this;
    }
    multiplyScalar(s) {
      this.r *= s;
      this.g *= s;
      this.b *= s;
      return this;
    }
    lerp(color, alpha) {
      this.r += (color.r - this.r) * alpha;
      this.g += (color.g - this.g) * alpha;
      this.b += (color.b - this.b) * alpha;
      return this;
    }
    lerpColors(color1, color2, alpha) {
      this.r = color1.r + (color2.r - color1.r) * alpha;
      this.g = color1.g + (color2.g - color1.g) * alpha;
      this.b = color1.b + (color2.b - color1.b) * alpha;
      return this;
    }
    lerpHSL(color, alpha) {
      this.getHSL(_hslA);
      color.getHSL(_hslB);
      const h = MathUtils.lerp(_hslA.h, _hslB.h, alpha);
      const s = MathUtils.lerp(_hslA.s, _hslB.s, alpha);
      const l = MathUtils.lerp(_hslA.l, _hslB.l, alpha);
      this.setHSL(h, s, l);
      return this;
    }
    equals(c) {
      return c.r === this.r && c.g === this.g && c.b === this.b;
    }
    fromArray(array, offset = 0) {
      this.r = array[offset];
      this.g = array[offset + 1];
      this.b = array[offset + 2];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.r;
      array[offset + 1] = this.g;
      array[offset + 2] = this.b;
      return array;
    }
    fromBufferAttribute(attribute, index) {
      this.r = attribute.getX(index);
      this.g = attribute.getY(index);
      this.b = attribute.getZ(index);
      if (attribute.normalized === true) {
        this.r /= 255;
        this.g /= 255;
        this.b /= 255;
      }
      return this;
    }
    toJSON() {
      return this.getHex();
    }
  };
  Color.NAMES = _colorKeywords;
  Color.prototype.isColor = true;
  Color.prototype.r = 1;
  Color.prototype.g = 1;
  Color.prototype.b = 1;
  var MeshBasicMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "MeshBasicMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.combine = MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.skinning = false;
      this.morphTargets = false;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      return this;
    }
  };
  MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
  var _vector$9 = new Vector3();
  var _vector2 = new Vector2();
  function BufferAttribute(array, itemSize, normalized) {
    if (Array.isArray(array)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.name = "";
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== void 0 ? array.length / itemSize : 0;
    this.normalized = normalized === true;
    this.usage = StaticDrawUsage;
    this.updateRange = { offset: 0, count: -1 };
    this.version = 0;
  }
  Object.defineProperty(BufferAttribute.prototype, "needsUpdate", {
    set: function(value) {
      if (value === true)
        this.version++;
    }
  });
  Object.assign(BufferAttribute.prototype, {
    isBufferAttribute: true,
    onUploadCallback: function() {
    },
    setUsage: function(value) {
      this.usage = value;
      return this;
    },
    copy: function(source) {
      this.name = source.name;
      this.array = new source.array.constructor(source.array);
      this.itemSize = source.itemSize;
      this.count = source.count;
      this.normalized = source.normalized;
      this.usage = source.usage;
      return this;
    },
    copyAt: function(index1, attribute, index2) {
      index1 *= this.itemSize;
      index2 *= attribute.itemSize;
      for (let i = 0, l = this.itemSize; i < l; i++) {
        this.array[index1 + i] = attribute.array[index2 + i];
      }
      return this;
    },
    copyArray: function(array) {
      this.array.set(array);
      return this;
    },
    copyColorsArray: function(colors) {
      const array = this.array;
      let offset = 0;
      for (let i = 0, l = colors.length; i < l; i++) {
        let color = colors[i];
        if (color === void 0) {
          console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i);
          color = new Color();
        }
        array[offset++] = color.r;
        array[offset++] = color.g;
        array[offset++] = color.b;
      }
      return this;
    },
    copyVector2sArray: function(vectors) {
      const array = this.array;
      let offset = 0;
      for (let i = 0, l = vectors.length; i < l; i++) {
        let vector = vectors[i];
        if (vector === void 0) {
          console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i);
          vector = new Vector2();
        }
        array[offset++] = vector.x;
        array[offset++] = vector.y;
      }
      return this;
    },
    copyVector3sArray: function(vectors) {
      const array = this.array;
      let offset = 0;
      for (let i = 0, l = vectors.length; i < l; i++) {
        let vector = vectors[i];
        if (vector === void 0) {
          console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i);
          vector = new Vector3();
        }
        array[offset++] = vector.x;
        array[offset++] = vector.y;
        array[offset++] = vector.z;
      }
      return this;
    },
    copyVector4sArray: function(vectors) {
      const array = this.array;
      let offset = 0;
      for (let i = 0, l = vectors.length; i < l; i++) {
        let vector = vectors[i];
        if (vector === void 0) {
          console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i);
          vector = new Vector4();
        }
        array[offset++] = vector.x;
        array[offset++] = vector.y;
        array[offset++] = vector.z;
        array[offset++] = vector.w;
      }
      return this;
    },
    applyMatrix3: function(m) {
      if (this.itemSize === 2) {
        for (let i = 0, l = this.count; i < l; i++) {
          _vector2.fromBufferAttribute(this, i);
          _vector2.applyMatrix3(m);
          this.setXY(i, _vector2.x, _vector2.y);
        }
      } else if (this.itemSize === 3) {
        for (let i = 0, l = this.count; i < l; i++) {
          _vector$9.fromBufferAttribute(this, i);
          _vector$9.applyMatrix3(m);
          this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
        }
      }
      return this;
    },
    applyMatrix4: function(m) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$9.x = this.getX(i);
        _vector$9.y = this.getY(i);
        _vector$9.z = this.getZ(i);
        _vector$9.applyMatrix4(m);
        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
      }
      return this;
    },
    applyNormalMatrix: function(m) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$9.x = this.getX(i);
        _vector$9.y = this.getY(i);
        _vector$9.z = this.getZ(i);
        _vector$9.applyNormalMatrix(m);
        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
      }
      return this;
    },
    transformDirection: function(m) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$9.x = this.getX(i);
        _vector$9.y = this.getY(i);
        _vector$9.z = this.getZ(i);
        _vector$9.transformDirection(m);
        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
      }
      return this;
    },
    set: function(value, offset = 0) {
      this.array.set(value, offset);
      return this;
    },
    getX: function(index) {
      return this.array[index * this.itemSize];
    },
    setX: function(index, x) {
      this.array[index * this.itemSize] = x;
      return this;
    },
    getY: function(index) {
      return this.array[index * this.itemSize + 1];
    },
    setY: function(index, y) {
      this.array[index * this.itemSize + 1] = y;
      return this;
    },
    getZ: function(index) {
      return this.array[index * this.itemSize + 2];
    },
    setZ: function(index, z) {
      this.array[index * this.itemSize + 2] = z;
      return this;
    },
    getW: function(index) {
      return this.array[index * this.itemSize + 3];
    },
    setW: function(index, w) {
      this.array[index * this.itemSize + 3] = w;
      return this;
    },
    setXY: function(index, x, y) {
      index *= this.itemSize;
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      return this;
    },
    setXYZ: function(index, x, y, z) {
      index *= this.itemSize;
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      this.array[index + 2] = z;
      return this;
    },
    setXYZW: function(index, x, y, z, w) {
      index *= this.itemSize;
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      this.array[index + 2] = z;
      this.array[index + 3] = w;
      return this;
    },
    onUpload: function(callback) {
      this.onUploadCallback = callback;
      return this;
    },
    clone: function() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    },
    toJSON: function() {
      const data = {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.prototype.slice.call(this.array),
        normalized: this.normalized
      };
      if (this.name !== "")
        data.name = this.name;
      if (this.usage !== StaticDrawUsage)
        data.usage = this.usage;
      if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
        data.updateRange = this.updateRange;
      return data;
    }
  });
  function Int8BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
  }
  Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
  function Uint8BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
  }
  Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
  function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
  }
  Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
  function Int16BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
  }
  Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
  function Uint16BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
  }
  Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
  function Int32BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
  }
  Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
  function Uint32BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
  }
  Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
  function Float16BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
  }
  Float16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Float16BufferAttribute.prototype.constructor = Float16BufferAttribute;
  Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
  function Float32BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
  }
  Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
  function Float64BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
  }
  Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
  function arrayMax(array) {
    if (array.length === 0)
      return -Infinity;
    let max = array[0];
    for (let i = 1, l = array.length; i < l; ++i) {
      if (array[i] > max)
        max = array[i];
    }
    return max;
  }
  var TYPED_ARRAYS = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
  };
  function getTypedArray(type, buffer) {
    return new TYPED_ARRAYS[type](buffer);
  }
  var _id = 0;
  var _m1 = new Matrix4();
  var _obj = new Object3D();
  var _offset = new Vector3();
  var _box$1 = new Box3();
  var _boxMorphTargets = new Box3();
  var _vector$8 = new Vector3();
  function BufferGeometry() {
    Object.defineProperty(this, "id", { value: _id++ });
    this.uuid = MathUtils.generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = { start: 0, count: Infinity };
    this.userData = {};
  }
  BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: BufferGeometry,
    isBufferGeometry: true,
    getIndex: function() {
      return this.index;
    },
    setIndex: function(index) {
      if (Array.isArray(index)) {
        this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
      } else {
        this.index = index;
      }
      return this;
    },
    getAttribute: function(name) {
      return this.attributes[name];
    },
    setAttribute: function(name, attribute) {
      this.attributes[name] = attribute;
      return this;
    },
    deleteAttribute: function(name) {
      delete this.attributes[name];
      return this;
    },
    hasAttribute: function(name) {
      return this.attributes[name] !== void 0;
    },
    addGroup: function(start, count, materialIndex = 0) {
      this.groups.push({
        start,
        count,
        materialIndex
      });
    },
    clearGroups: function() {
      this.groups = [];
    },
    setDrawRange: function(start, count) {
      this.drawRange.start = start;
      this.drawRange.count = count;
    },
    applyMatrix4: function(matrix) {
      const position = this.attributes.position;
      if (position !== void 0) {
        position.applyMatrix4(matrix);
        position.needsUpdate = true;
      }
      const normal = this.attributes.normal;
      if (normal !== void 0) {
        const normalMatrix = new Matrix3().getNormalMatrix(matrix);
        normal.applyNormalMatrix(normalMatrix);
        normal.needsUpdate = true;
      }
      const tangent = this.attributes.tangent;
      if (tangent !== void 0) {
        tangent.transformDirection(matrix);
        tangent.needsUpdate = true;
      }
      if (this.boundingBox !== null) {
        this.computeBoundingBox();
      }
      if (this.boundingSphere !== null) {
        this.computeBoundingSphere();
      }
      return this;
    },
    rotateX: function(angle) {
      _m1.makeRotationX(angle);
      this.applyMatrix4(_m1);
      return this;
    },
    rotateY: function(angle) {
      _m1.makeRotationY(angle);
      this.applyMatrix4(_m1);
      return this;
    },
    rotateZ: function(angle) {
      _m1.makeRotationZ(angle);
      this.applyMatrix4(_m1);
      return this;
    },
    translate: function(x, y, z) {
      _m1.makeTranslation(x, y, z);
      this.applyMatrix4(_m1);
      return this;
    },
    scale: function(x, y, z) {
      _m1.makeScale(x, y, z);
      this.applyMatrix4(_m1);
      return this;
    },
    lookAt: function(vector) {
      _obj.lookAt(vector);
      _obj.updateMatrix();
      this.applyMatrix4(_obj.matrix);
      return this;
    },
    center: function() {
      this.computeBoundingBox();
      this.boundingBox.getCenter(_offset).negate();
      this.translate(_offset.x, _offset.y, _offset.z);
      return this;
    },
    setFromPoints: function(points) {
      const position = [];
      for (let i = 0, l = points.length; i < l; i++) {
        const point = points[i];
        position.push(point.x, point.y, point.z || 0);
      }
      this.setAttribute("position", new Float32BufferAttribute(position, 3));
      return this;
    },
    computeBoundingBox: function() {
      if (this.boundingBox === null) {
        this.boundingBox = new Box3();
      }
      const position = this.attributes.position;
      const morphAttributesPosition = this.morphAttributes.position;
      if (position && position.isGLBufferAttribute) {
        console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
        this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(Infinity, Infinity, Infinity));
        return;
      }
      if (position !== void 0) {
        this.boundingBox.setFromBufferAttribute(position);
        if (morphAttributesPosition) {
          for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
            const morphAttribute = morphAttributesPosition[i];
            _box$1.setFromBufferAttribute(morphAttribute);
            if (this.morphTargetsRelative) {
              _vector$8.addVectors(this.boundingBox.min, _box$1.min);
              this.boundingBox.expandByPoint(_vector$8);
              _vector$8.addVectors(this.boundingBox.max, _box$1.max);
              this.boundingBox.expandByPoint(_vector$8);
            } else {
              this.boundingBox.expandByPoint(_box$1.min);
              this.boundingBox.expandByPoint(_box$1.max);
            }
          }
        }
      } else {
        this.boundingBox.makeEmpty();
      }
      if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
        console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
      }
    },
    computeBoundingSphere: function() {
      if (this.boundingSphere === null) {
        this.boundingSphere = new Sphere();
      }
      const position = this.attributes.position;
      const morphAttributesPosition = this.morphAttributes.position;
      if (position && position.isGLBufferAttribute) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
        this.boundingSphere.set(new Vector3(), Infinity);
        return;
      }
      if (position) {
        const center = this.boundingSphere.center;
        _box$1.setFromBufferAttribute(position);
        if (morphAttributesPosition) {
          for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
            const morphAttribute = morphAttributesPosition[i];
            _boxMorphTargets.setFromBufferAttribute(morphAttribute);
            if (this.morphTargetsRelative) {
              _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);
              _box$1.expandByPoint(_vector$8);
              _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);
              _box$1.expandByPoint(_vector$8);
            } else {
              _box$1.expandByPoint(_boxMorphTargets.min);
              _box$1.expandByPoint(_boxMorphTargets.max);
            }
          }
        }
        _box$1.getCenter(center);
        let maxRadiusSq = 0;
        for (let i = 0, il = position.count; i < il; i++) {
          _vector$8.fromBufferAttribute(position, i);
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
        }
        if (morphAttributesPosition) {
          for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
            const morphAttribute = morphAttributesPosition[i];
            const morphTargetsRelative = this.morphTargetsRelative;
            for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
              _vector$8.fromBufferAttribute(morphAttribute, j);
              if (morphTargetsRelative) {
                _offset.fromBufferAttribute(position, j);
                _vector$8.add(_offset);
              }
              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
            }
          }
        }
        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
        if (isNaN(this.boundingSphere.radius)) {
          console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
      }
    },
    computeFaceNormals: function() {
    },
    computeTangents: function() {
      const index = this.index;
      const attributes = this.attributes;
      if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
        console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
        return;
      }
      const indices = index.array;
      const positions = attributes.position.array;
      const normals = attributes.normal.array;
      const uvs = attributes.uv.array;
      const nVertices = positions.length / 3;
      if (attributes.tangent === void 0) {
        this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
      }
      const tangents = attributes.tangent.array;
      const tan1 = [], tan2 = [];
      for (let i = 0; i < nVertices; i++) {
        tan1[i] = new Vector3();
        tan2[i] = new Vector3();
      }
      const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
      function handleTriangle(a, b2, c) {
        vA.fromArray(positions, a * 3);
        vB.fromArray(positions, b2 * 3);
        vC.fromArray(positions, c * 3);
        uvA.fromArray(uvs, a * 2);
        uvB.fromArray(uvs, b2 * 2);
        uvC.fromArray(uvs, c * 2);
        vB.sub(vA);
        vC.sub(vA);
        uvB.sub(uvA);
        uvC.sub(uvA);
        const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
        if (!isFinite(r))
          return;
        sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
        tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
        tan1[a].add(sdir);
        tan1[b2].add(sdir);
        tan1[c].add(sdir);
        tan2[a].add(tdir);
        tan2[b2].add(tdir);
        tan2[c].add(tdir);
      }
      let groups = this.groups;
      if (groups.length === 0) {
        groups = [{
          start: 0,
          count: indices.length
        }];
      }
      for (let i = 0, il = groups.length; i < il; ++i) {
        const group = groups[i];
        const start = group.start;
        const count = group.count;
        for (let j = start, jl = start + count; j < jl; j += 3) {
          handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
        }
      }
      const tmp2 = new Vector3(), tmp22 = new Vector3();
      const n = new Vector3(), n2 = new Vector3();
      function handleVertex(v) {
        n.fromArray(normals, v * 3);
        n2.copy(n);
        const t = tan1[v];
        tmp2.copy(t);
        tmp2.sub(n.multiplyScalar(n.dot(t))).normalize();
        tmp22.crossVectors(n2, t);
        const test = tmp22.dot(tan2[v]);
        const w = test < 0 ? -1 : 1;
        tangents[v * 4] = tmp2.x;
        tangents[v * 4 + 1] = tmp2.y;
        tangents[v * 4 + 2] = tmp2.z;
        tangents[v * 4 + 3] = w;
      }
      for (let i = 0, il = groups.length; i < il; ++i) {
        const group = groups[i];
        const start = group.start;
        const count = group.count;
        for (let j = start, jl = start + count; j < jl; j += 3) {
          handleVertex(indices[j + 0]);
          handleVertex(indices[j + 1]);
          handleVertex(indices[j + 2]);
        }
      }
    },
    computeVertexNormals: function() {
      const index = this.index;
      const positionAttribute = this.getAttribute("position");
      if (positionAttribute !== void 0) {
        let normalAttribute = this.getAttribute("normal");
        if (normalAttribute === void 0) {
          normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
          this.setAttribute("normal", normalAttribute);
        } else {
          for (let i = 0, il = normalAttribute.count; i < il; i++) {
            normalAttribute.setXYZ(i, 0, 0, 0);
          }
        }
        const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
        const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
        const cb = new Vector3(), ab = new Vector3();
        if (index) {
          for (let i = 0, il = index.count; i < il; i += 3) {
            const vA = index.getX(i + 0);
            const vB = index.getX(i + 1);
            const vC = index.getX(i + 2);
            pA.fromBufferAttribute(positionAttribute, vA);
            pB.fromBufferAttribute(positionAttribute, vB);
            pC.fromBufferAttribute(positionAttribute, vC);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            nA.fromBufferAttribute(normalAttribute, vA);
            nB.fromBufferAttribute(normalAttribute, vB);
            nC.fromBufferAttribute(normalAttribute, vC);
            nA.add(cb);
            nB.add(cb);
            nC.add(cb);
            normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
            normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
            normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
          }
        } else {
          for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
            pA.fromBufferAttribute(positionAttribute, i + 0);
            pB.fromBufferAttribute(positionAttribute, i + 1);
            pC.fromBufferAttribute(positionAttribute, i + 2);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
            normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
            normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
          }
        }
        this.normalizeNormals();
        normalAttribute.needsUpdate = true;
      }
    },
    merge: function(geometry, offset) {
      if (!(geometry && geometry.isBufferGeometry)) {
        console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
        return;
      }
      if (offset === void 0) {
        offset = 0;
        console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
      }
      const attributes = this.attributes;
      for (const key in attributes) {
        if (geometry.attributes[key] === void 0)
          continue;
        const attribute1 = attributes[key];
        const attributeArray1 = attribute1.array;
        const attribute2 = geometry.attributes[key];
        const attributeArray2 = attribute2.array;
        const attributeOffset = attribute2.itemSize * offset;
        const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
        for (let i = 0, j = attributeOffset; i < length; i++, j++) {
          attributeArray1[j] = attributeArray2[i];
        }
      }
      return this;
    },
    normalizeNormals: function() {
      const normals = this.attributes.normal;
      for (let i = 0, il = normals.count; i < il; i++) {
        _vector$8.fromBufferAttribute(normals, i);
        _vector$8.normalize();
        normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
      }
    },
    toNonIndexed: function() {
      function convertBufferAttribute(attribute, indices2) {
        const array = attribute.array;
        const itemSize = attribute.itemSize;
        const normalized = attribute.normalized;
        const array2 = new array.constructor(indices2.length * itemSize);
        let index = 0, index2 = 0;
        for (let i = 0, l = indices2.length; i < l; i++) {
          index = indices2[i] * itemSize;
          for (let j = 0; j < itemSize; j++) {
            array2[index2++] = array[index++];
          }
        }
        return new BufferAttribute(array2, itemSize, normalized);
      }
      if (this.index === null) {
        console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
        return this;
      }
      const geometry2 = new BufferGeometry();
      const indices = this.index.array;
      const attributes = this.attributes;
      for (const name in attributes) {
        const attribute = attributes[name];
        const newAttribute = convertBufferAttribute(attribute, indices);
        geometry2.setAttribute(name, newAttribute);
      }
      const morphAttributes = this.morphAttributes;
      for (const name in morphAttributes) {
        const morphArray = [];
        const morphAttribute = morphAttributes[name];
        for (let i = 0, il = morphAttribute.length; i < il; i++) {
          const attribute = morphAttribute[i];
          const newAttribute = convertBufferAttribute(attribute, indices);
          morphArray.push(newAttribute);
        }
        geometry2.morphAttributes[name] = morphArray;
      }
      geometry2.morphTargetsRelative = this.morphTargetsRelative;
      const groups = this.groups;
      for (let i = 0, l = groups.length; i < l; i++) {
        const group = groups[i];
        geometry2.addGroup(group.start, group.count, group.materialIndex);
      }
      return geometry2;
    },
    toJSON: function() {
      const data = {
        metadata: {
          version: 4.5,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON"
        }
      };
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== "")
        data.name = this.name;
      if (Object.keys(this.userData).length > 0)
        data.userData = this.userData;
      if (this.parameters !== void 0) {
        const parameters = this.parameters;
        for (const key in parameters) {
          if (parameters[key] !== void 0)
            data[key] = parameters[key];
        }
        return data;
      }
      data.data = { attributes: {} };
      const index = this.index;
      if (index !== null) {
        data.data.index = {
          type: index.array.constructor.name,
          array: Array.prototype.slice.call(index.array)
        };
      }
      const attributes = this.attributes;
      for (const key in attributes) {
        const attribute = attributes[key];
        data.data.attributes[key] = attribute.toJSON(data.data);
      }
      const morphAttributes = {};
      let hasMorphAttributes = false;
      for (const key in this.morphAttributes) {
        const attributeArray = this.morphAttributes[key];
        const array = [];
        for (let i = 0, il = attributeArray.length; i < il; i++) {
          const attribute = attributeArray[i];
          array.push(attribute.toJSON(data.data));
        }
        if (array.length > 0) {
          morphAttributes[key] = array;
          hasMorphAttributes = true;
        }
      }
      if (hasMorphAttributes) {
        data.data.morphAttributes = morphAttributes;
        data.data.morphTargetsRelative = this.morphTargetsRelative;
      }
      const groups = this.groups;
      if (groups.length > 0) {
        data.data.groups = JSON.parse(JSON.stringify(groups));
      }
      const boundingSphere = this.boundingSphere;
      if (boundingSphere !== null) {
        data.data.boundingSphere = {
          center: boundingSphere.center.toArray(),
          radius: boundingSphere.radius
        };
      }
      return data;
    },
    clone: function() {
      return new BufferGeometry().copy(this);
    },
    copy: function(source) {
      this.index = null;
      this.attributes = {};
      this.morphAttributes = {};
      this.groups = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      const data = {};
      this.name = source.name;
      const index = source.index;
      if (index !== null) {
        this.setIndex(index.clone(data));
      }
      const attributes = source.attributes;
      for (const name in attributes) {
        const attribute = attributes[name];
        this.setAttribute(name, attribute.clone(data));
      }
      const morphAttributes = source.morphAttributes;
      for (const name in morphAttributes) {
        const array = [];
        const morphAttribute = morphAttributes[name];
        for (let i = 0, l = morphAttribute.length; i < l; i++) {
          array.push(morphAttribute[i].clone(data));
        }
        this.morphAttributes[name] = array;
      }
      this.morphTargetsRelative = source.morphTargetsRelative;
      const groups = source.groups;
      for (let i = 0, l = groups.length; i < l; i++) {
        const group = groups[i];
        this.addGroup(group.start, group.count, group.materialIndex);
      }
      const boundingBox = source.boundingBox;
      if (boundingBox !== null) {
        this.boundingBox = boundingBox.clone();
      }
      const boundingSphere = source.boundingSphere;
      if (boundingSphere !== null) {
        this.boundingSphere = boundingSphere.clone();
      }
      this.drawRange.start = source.drawRange.start;
      this.drawRange.count = source.drawRange.count;
      this.userData = source.userData;
      return this;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  });
  var _inverseMatrix$2 = new Matrix4();
  var _ray$2 = new Ray();
  var _sphere$3 = new Sphere();
  var _vA$1 = new Vector3();
  var _vB$1 = new Vector3();
  var _vC$1 = new Vector3();
  var _tempA = new Vector3();
  var _tempB = new Vector3();
  var _tempC = new Vector3();
  var _morphA = new Vector3();
  var _morphB = new Vector3();
  var _morphC = new Vector3();
  var _uvA$1 = new Vector2();
  var _uvB$1 = new Vector2();
  var _uvC$1 = new Vector2();
  var _intersectionPoint = new Vector3();
  var _intersectionPointWorld = new Vector3();
  function Mesh(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
    Object3D.call(this);
    this.type = "Mesh";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Mesh,
    isMesh: true,
    copy: function(source) {
      Object3D.prototype.copy.call(this, source);
      if (source.morphTargetInfluences !== void 0) {
        this.morphTargetInfluences = source.morphTargetInfluences.slice();
      }
      if (source.morphTargetDictionary !== void 0) {
        this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
      }
      this.material = source.material;
      this.geometry = source.geometry;
      return this;
    },
    updateMorphTargets: function() {
      const geometry = this.geometry;
      if (geometry.isBufferGeometry) {
        const morphAttributes = geometry.morphAttributes;
        const keys = Object.keys(morphAttributes);
        if (keys.length > 0) {
          const morphAttribute = morphAttributes[keys[0]];
          if (morphAttribute !== void 0) {
            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};
            for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
              const name = morphAttribute[m].name || String(m);
              this.morphTargetInfluences.push(0);
              this.morphTargetDictionary[name] = m;
            }
          }
        }
      } else {
        const morphTargets = geometry.morphTargets;
        if (morphTargets !== void 0 && morphTargets.length > 0) {
          console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }
    },
    raycast: function(raycaster2, intersects2) {
      const geometry = this.geometry;
      const material = this.material;
      const matrixWorld = this.matrixWorld;
      if (material === void 0)
        return;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      _sphere$3.copy(geometry.boundingSphere);
      _sphere$3.applyMatrix4(matrixWorld);
      if (raycaster2.ray.intersectsSphere(_sphere$3) === false)
        return;
      _inverseMatrix$2.copy(matrixWorld).invert();
      _ray$2.copy(raycaster2.ray).applyMatrix4(_inverseMatrix$2);
      if (geometry.boundingBox !== null) {
        if (_ray$2.intersectsBox(geometry.boundingBox) === false)
          return;
      }
      let intersection;
      if (geometry.isBufferGeometry) {
        const index = geometry.index;
        const position = geometry.attributes.position;
        const morphPosition = geometry.morphAttributes.position;
        const morphTargetsRelative = geometry.morphTargetsRelative;
        const uv = geometry.attributes.uv;
        const uv2 = geometry.attributes.uv2;
        const groups = geometry.groups;
        const drawRange = geometry.drawRange;
        if (index !== null) {
          if (Array.isArray(material)) {
            for (let i = 0, il = groups.length; i < il; i++) {
              const group = groups[i];
              const groupMaterial = material[group.materialIndex];
              const start = Math.max(group.start, drawRange.start);
              const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
              for (let j = start, jl = end; j < jl; j += 3) {
                const a = index.getX(j);
                const b2 = index.getX(j + 1);
                const c = index.getX(j + 2);
                intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster2, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b2, c);
                if (intersection) {
                  intersection.faceIndex = Math.floor(j / 3);
                  intersection.face.materialIndex = group.materialIndex;
                  intersects2.push(intersection);
                }
              }
            }
          } else {
            const start = Math.max(0, drawRange.start);
            const end = Math.min(index.count, drawRange.start + drawRange.count);
            for (let i = start, il = end; i < il; i += 3) {
              const a = index.getX(i);
              const b2 = index.getX(i + 1);
              const c = index.getX(i + 2);
              intersection = checkBufferGeometryIntersection(this, material, raycaster2, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b2, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(i / 3);
                intersects2.push(intersection);
              }
            }
          }
        } else if (position !== void 0) {
          if (Array.isArray(material)) {
            for (let i = 0, il = groups.length; i < il; i++) {
              const group = groups[i];
              const groupMaterial = material[group.materialIndex];
              const start = Math.max(group.start, drawRange.start);
              const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
              for (let j = start, jl = end; j < jl; j += 3) {
                const a = j;
                const b2 = j + 1;
                const c = j + 2;
                intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster2, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b2, c);
                if (intersection) {
                  intersection.faceIndex = Math.floor(j / 3);
                  intersection.face.materialIndex = group.materialIndex;
                  intersects2.push(intersection);
                }
              }
            }
          } else {
            const start = Math.max(0, drawRange.start);
            const end = Math.min(position.count, drawRange.start + drawRange.count);
            for (let i = start, il = end; i < il; i += 3) {
              const a = i;
              const b2 = i + 1;
              const c = i + 2;
              intersection = checkBufferGeometryIntersection(this, material, raycaster2, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b2, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(i / 3);
                intersects2.push(intersection);
              }
            }
          }
        }
      } else if (geometry.isGeometry) {
        console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  });
  function checkIntersection(object, material, raycaster2, ray, pA, pB, pC, point) {
    let intersect;
    if (material.side === BackSide) {
      intersect = ray.intersectTriangle(pC, pB, pA, true, point);
    } else {
      intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
    }
    if (intersect === null)
      return null;
    _intersectionPointWorld.copy(point);
    _intersectionPointWorld.applyMatrix4(object.matrixWorld);
    const distance = raycaster2.ray.origin.distanceTo(_intersectionPointWorld);
    if (distance < raycaster2.near || distance > raycaster2.far)
      return null;
    return {
      distance,
      point: _intersectionPointWorld.clone(),
      object
    };
  }
  function checkBufferGeometryIntersection(object, material, raycaster2, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b2, c) {
    _vA$1.fromBufferAttribute(position, a);
    _vB$1.fromBufferAttribute(position, b2);
    _vC$1.fromBufferAttribute(position, c);
    const morphInfluences = object.morphTargetInfluences;
    if (material.morphTargets && morphPosition && morphInfluences) {
      _morphA.set(0, 0, 0);
      _morphB.set(0, 0, 0);
      _morphC.set(0, 0, 0);
      for (let i = 0, il = morphPosition.length; i < il; i++) {
        const influence = morphInfluences[i];
        const morphAttribute = morphPosition[i];
        if (influence === 0)
          continue;
        _tempA.fromBufferAttribute(morphAttribute, a);
        _tempB.fromBufferAttribute(morphAttribute, b2);
        _tempC.fromBufferAttribute(morphAttribute, c);
        if (morphTargetsRelative) {
          _morphA.addScaledVector(_tempA, influence);
          _morphB.addScaledVector(_tempB, influence);
          _morphC.addScaledVector(_tempC, influence);
        } else {
          _morphA.addScaledVector(_tempA.sub(_vA$1), influence);
          _morphB.addScaledVector(_tempB.sub(_vB$1), influence);
          _morphC.addScaledVector(_tempC.sub(_vC$1), influence);
        }
      }
      _vA$1.add(_morphA);
      _vB$1.add(_morphB);
      _vC$1.add(_morphC);
    }
    if (object.isSkinnedMesh && material.skinning) {
      object.boneTransform(a, _vA$1);
      object.boneTransform(b2, _vB$1);
      object.boneTransform(c, _vC$1);
    }
    const intersection = checkIntersection(object, material, raycaster2, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
    if (intersection) {
      if (uv) {
        _uvA$1.fromBufferAttribute(uv, a);
        _uvB$1.fromBufferAttribute(uv, b2);
        _uvC$1.fromBufferAttribute(uv, c);
        intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
      }
      if (uv2) {
        _uvA$1.fromBufferAttribute(uv2, a);
        _uvB$1.fromBufferAttribute(uv2, b2);
        _uvC$1.fromBufferAttribute(uv2, c);
        intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
      }
      const face = {
        a,
        b: b2,
        c,
        normal: new Vector3(),
        materialIndex: 0
      };
      Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
      intersection.face = face;
    }
    return intersection;
  }
  var BoxGeometry = class extends BufferGeometry {
    constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
      super();
      this.type = "BoxGeometry";
      this.parameters = {
        width,
        height,
        depth,
        widthSegments,
        heightSegments,
        depthSegments
      };
      const scope = this;
      widthSegments = Math.floor(widthSegments);
      heightSegments = Math.floor(heightSegments);
      depthSegments = Math.floor(depthSegments);
      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];
      let numberOfVertices = 0;
      let groupStart = 0;
      buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
      buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
      buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
      buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
      buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
      buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      function buildPlane(u, v, w, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
        const segmentWidth = width2 / gridX;
        const segmentHeight = height2 / gridY;
        const widthHalf = width2 / 2;
        const heightHalf = height2 / 2;
        const depthHalf = depth2 / 2;
        const gridX1 = gridX + 1;
        const gridY1 = gridY + 1;
        let vertexCounter = 0;
        let groupCount = 0;
        const vector = new Vector3();
        for (let iy = 0; iy < gridY1; iy++) {
          const y = iy * segmentHeight - heightHalf;
          for (let ix = 0; ix < gridX1; ix++) {
            const x = ix * segmentWidth - widthHalf;
            vector[u] = x * udir;
            vector[v] = y * vdir;
            vector[w] = depthHalf;
            vertices.push(vector.x, vector.y, vector.z);
            vector[u] = 0;
            vector[v] = 0;
            vector[w] = depth2 > 0 ? 1 : -1;
            normals.push(vector.x, vector.y, vector.z);
            uvs.push(ix / gridX);
            uvs.push(1 - iy / gridY);
            vertexCounter += 1;
          }
        }
        for (let iy = 0; iy < gridY; iy++) {
          for (let ix = 0; ix < gridX; ix++) {
            const a = numberOfVertices + ix + gridX1 * iy;
            const b2 = numberOfVertices + ix + gridX1 * (iy + 1);
            const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
            const d = numberOfVertices + (ix + 1) + gridX1 * iy;
            indices.push(a, b2, d);
            indices.push(b2, c, d);
            groupCount += 6;
          }
        }
        scope.addGroup(groupStart, groupCount, materialIndex);
        groupStart += groupCount;
        numberOfVertices += vertexCounter;
      }
    }
  };
  function cloneUniforms(src) {
    const dst = {};
    for (const u in src) {
      dst[u] = {};
      for (const p in src[u]) {
        const property = src[u][p];
        if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
          dst[u][p] = property.clone();
        } else if (Array.isArray(property)) {
          dst[u][p] = property.slice();
        } else {
          dst[u][p] = property;
        }
      }
    }
    return dst;
  }
  function mergeUniforms(uniforms) {
    const merged = {};
    for (let u = 0; u < uniforms.length; u++) {
      const tmp2 = cloneUniforms(uniforms[u]);
      for (const p in tmp2) {
        merged[p] = tmp2[p];
      }
    }
    return merged;
  }
  var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
  var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
  var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
  function ShaderMaterial(parameters) {
    Material.call(this);
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.vertexShader = default_vertex;
    this.fragmentShader = default_fragment;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.clipping = false;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.extensions = {
      derivatives: false,
      fragDepth: false,
      drawBuffers: false,
      shaderTextureLOD: false
    };
    this.defaultAttributeValues = {
      "color": [1, 1, 1],
      "uv": [0, 0],
      "uv2": [0, 0]
    };
    this.index0AttributeName = void 0;
    this.uniformsNeedUpdate = false;
    this.glslVersion = null;
    if (parameters !== void 0) {
      if (parameters.attributes !== void 0) {
        console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
      }
      this.setValues(parameters);
    }
  }
  ShaderMaterial.prototype = Object.create(Material.prototype);
  ShaderMaterial.prototype.constructor = ShaderMaterial;
  ShaderMaterial.prototype.isShaderMaterial = true;
  ShaderMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = cloneUniforms(source.uniforms);
    this.defines = Object.assign({}, source.defines);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.extensions = Object.assign({}, source.extensions);
    this.glslVersion = source.glslVersion;
    return this;
  };
  ShaderMaterial.prototype.toJSON = function(meta) {
    const data = Material.prototype.toJSON.call(this, meta);
    data.glslVersion = this.glslVersion;
    data.uniforms = {};
    for (const name in this.uniforms) {
      const uniform = this.uniforms[name];
      const value = uniform.value;
      if (value && value.isTexture) {
        data.uniforms[name] = {
          type: "t",
          value: value.toJSON(meta).uuid
        };
      } else if (value && value.isColor) {
        data.uniforms[name] = {
          type: "c",
          value: value.getHex()
        };
      } else if (value && value.isVector2) {
        data.uniforms[name] = {
          type: "v2",
          value: value.toArray()
        };
      } else if (value && value.isVector3) {
        data.uniforms[name] = {
          type: "v3",
          value: value.toArray()
        };
      } else if (value && value.isVector4) {
        data.uniforms[name] = {
          type: "v4",
          value: value.toArray()
        };
      } else if (value && value.isMatrix3) {
        data.uniforms[name] = {
          type: "m3",
          value: value.toArray()
        };
      } else if (value && value.isMatrix4) {
        data.uniforms[name] = {
          type: "m4",
          value: value.toArray()
        };
      } else {
        data.uniforms[name] = {
          value
        };
      }
    }
    if (Object.keys(this.defines).length > 0)
      data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    const extensions = {};
    for (const key in this.extensions) {
      if (this.extensions[key] === true)
        extensions[key] = true;
    }
    if (Object.keys(extensions).length > 0)
      data.extensions = extensions;
    return data;
  };
  function Camera() {
    Object3D.call(this);
    this.type = "Camera";
    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();
    this.projectionMatrixInverse = new Matrix4();
  }
  Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Camera,
    isCamera: true,
    copy: function(source, recursive) {
      Object3D.prototype.copy.call(this, source, recursive);
      this.matrixWorldInverse.copy(source.matrixWorldInverse);
      this.projectionMatrix.copy(source.projectionMatrix);
      this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
      return this;
    },
    getWorldDirection: function(target) {
      if (target === void 0) {
        console.warn("THREE.Camera: .getWorldDirection() target is now required");
        target = new Vector3();
      }
      this.updateWorldMatrix(true, false);
      const e = this.matrixWorld.elements;
      return target.set(-e[8], -e[9], -e[10]).normalize();
    },
    updateMatrixWorld: function(force) {
      Object3D.prototype.updateMatrixWorld.call(this, force);
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
    },
    updateWorldMatrix: function(updateParents, updateChildren) {
      Object3D.prototype.updateWorldMatrix.call(this, updateParents, updateChildren);
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
    },
    clone: function() {
      return new this.constructor().copy(this);
    }
  });
  function PerspectiveCamera(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
    Camera.call(this);
    this.type = "PerspectiveCamera";
    this.fov = fov2;
    this.zoom = 1;
    this.near = near;
    this.far = far;
    this.focus = 10;
    this.aspect = aspect2;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
    constructor: PerspectiveCamera,
    isPerspectiveCamera: true,
    copy: function(source, recursive) {
      Camera.prototype.copy.call(this, source, recursive);
      this.fov = source.fov;
      this.zoom = source.zoom;
      this.near = source.near;
      this.far = source.far;
      this.focus = source.focus;
      this.aspect = source.aspect;
      this.view = source.view === null ? null : Object.assign({}, source.view);
      this.filmGauge = source.filmGauge;
      this.filmOffset = source.filmOffset;
      return this;
    },
    setFocalLength: function(focalLength) {
      const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
      this.fov = MathUtils.RAD2DEG * 2 * Math.atan(vExtentSlope);
      this.updateProjectionMatrix();
    },
    getFocalLength: function() {
      const vExtentSlope = Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov);
      return 0.5 * this.getFilmHeight() / vExtentSlope;
    },
    getEffectiveFOV: function() {
      return MathUtils.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom);
    },
    getFilmWidth: function() {
      return this.filmGauge * Math.min(this.aspect, 1);
    },
    getFilmHeight: function() {
      return this.filmGauge / Math.max(this.aspect, 1);
    },
    setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
      this.aspect = fullWidth / fullHeight;
      if (this.view === null) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }
      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x;
      this.view.offsetY = y;
      this.view.width = width;
      this.view.height = height;
      this.updateProjectionMatrix();
    },
    clearViewOffset: function() {
      if (this.view !== null) {
        this.view.enabled = false;
      }
      this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function() {
      const near = this.near;
      let top = near * Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom;
      let height = 2 * top;
      let width = this.aspect * height;
      let left = -0.5 * width;
      const view = this.view;
      if (this.view !== null && this.view.enabled) {
        const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
        left += view.offsetX * width / fullWidth;
        top -= view.offsetY * height / fullHeight;
        width *= view.width / fullWidth;
        height *= view.height / fullHeight;
      }
      const skew = this.filmOffset;
      if (skew !== 0)
        left += near * skew / this.getFilmWidth();
      this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    },
    toJSON: function(meta) {
      const data = Object3D.prototype.toJSON.call(this, meta);
      data.object.fov = this.fov;
      data.object.zoom = this.zoom;
      data.object.near = this.near;
      data.object.far = this.far;
      data.object.focus = this.focus;
      data.object.aspect = this.aspect;
      if (this.view !== null)
        data.object.view = Object.assign({}, this.view);
      data.object.filmGauge = this.filmGauge;
      data.object.filmOffset = this.filmOffset;
      return data;
    }
  });
  var fov = 90;
  var aspect = 1;
  var CubeCamera = class extends Object3D {
    constructor(near, far, renderTarget) {
      super();
      this.type = "CubeCamera";
      if (renderTarget.isWebGLCubeRenderTarget !== true) {
        console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
        return;
      }
      this.renderTarget = renderTarget;
      const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
      cameraPX.layers = this.layers;
      cameraPX.up.set(0, -1, 0);
      cameraPX.lookAt(new Vector3(1, 0, 0));
      this.add(cameraPX);
      const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
      cameraNX.layers = this.layers;
      cameraNX.up.set(0, -1, 0);
      cameraNX.lookAt(new Vector3(-1, 0, 0));
      this.add(cameraNX);
      const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
      cameraPY.layers = this.layers;
      cameraPY.up.set(0, 0, 1);
      cameraPY.lookAt(new Vector3(0, 1, 0));
      this.add(cameraPY);
      const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
      cameraNY.layers = this.layers;
      cameraNY.up.set(0, 0, -1);
      cameraNY.lookAt(new Vector3(0, -1, 0));
      this.add(cameraNY);
      const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
      cameraPZ.layers = this.layers;
      cameraPZ.up.set(0, -1, 0);
      cameraPZ.lookAt(new Vector3(0, 0, 1));
      this.add(cameraPZ);
      const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
      cameraNZ.layers = this.layers;
      cameraNZ.up.set(0, -1, 0);
      cameraNZ.lookAt(new Vector3(0, 0, -1));
      this.add(cameraNZ);
    }
    update(renderer, scene) {
      if (this.parent === null)
        this.updateMatrixWorld();
      const renderTarget = this.renderTarget;
      const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
      const currentXrEnabled = renderer.xr.enabled;
      const currentRenderTarget = renderer.getRenderTarget();
      renderer.xr.enabled = false;
      const generateMipmaps = renderTarget.texture.generateMipmaps;
      renderTarget.texture.generateMipmaps = false;
      renderer.setRenderTarget(renderTarget, 0);
      renderer.render(scene, cameraPX);
      renderer.setRenderTarget(renderTarget, 1);
      renderer.render(scene, cameraNX);
      renderer.setRenderTarget(renderTarget, 2);
      renderer.render(scene, cameraPY);
      renderer.setRenderTarget(renderTarget, 3);
      renderer.render(scene, cameraNY);
      renderer.setRenderTarget(renderTarget, 4);
      renderer.render(scene, cameraPZ);
      renderTarget.texture.generateMipmaps = generateMipmaps;
      renderer.setRenderTarget(renderTarget, 5);
      renderer.render(scene, cameraNZ);
      renderer.setRenderTarget(currentRenderTarget);
      renderer.xr.enabled = currentXrEnabled;
    }
  };
  var CubeTexture = class extends Texture {
    constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
      images = images !== void 0 ? images : [];
      mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
      format = format !== void 0 ? format : RGBFormat;
      super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
      this._needsFlipEnvMap = true;
      this.flipY = false;
    }
    get images() {
      return this.image;
    }
    set images(value) {
      this.image = value;
    }
  };
  CubeTexture.prototype.isCubeTexture = true;
  var WebGLCubeRenderTarget = class extends WebGLRenderTarget {
    constructor(size2, options, dummy) {
      if (Number.isInteger(options)) {
        console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )");
        options = dummy;
      }
      super(size2, size2, options);
      options = options || {};
      this.texture = new CubeTexture(void 0, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
      this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
      this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
      this.texture._needsFlipEnvMap = false;
    }
    fromEquirectangularTexture(renderer, texture) {
      this.texture.type = texture.type;
      this.texture.format = RGBAFormat;
      this.texture.encoding = texture.encoding;
      this.texture.generateMipmaps = texture.generateMipmaps;
      this.texture.minFilter = texture.minFilter;
      this.texture.magFilter = texture.magFilter;
      const shader = {
        uniforms: {
          tEquirect: { value: null }
        },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      };
      const geometry = new BoxGeometry(5, 5, 5);
      const material = new ShaderMaterial({
        name: "CubemapFromEquirect",
        uniforms: cloneUniforms(shader.uniforms),
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader,
        side: BackSide,
        blending: NoBlending
      });
      material.uniforms.tEquirect.value = texture;
      const mesh = new Mesh(geometry, material);
      const currentMinFilter = texture.minFilter;
      if (texture.minFilter === LinearMipmapLinearFilter)
        texture.minFilter = LinearFilter;
      const camera = new CubeCamera(1, 10, this);
      camera.update(renderer, mesh);
      texture.minFilter = currentMinFilter;
      mesh.geometry.dispose();
      mesh.material.dispose();
      return this;
    }
    clear(renderer, color, depth, stencil) {
      const currentRenderTarget = renderer.getRenderTarget();
      for (let i = 0; i < 6; i++) {
        renderer.setRenderTarget(this, i);
        renderer.clear(color, depth, stencil);
      }
      renderer.setRenderTarget(currentRenderTarget);
    }
  };
  WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
  var DataTexture = class extends Texture {
    constructor(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
      super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
      this.image = { data: data || null, width: width || 1, height: height || 1 };
      this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
      this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
      this.generateMipmaps = false;
      this.flipY = false;
      this.unpackAlignment = 1;
      this.needsUpdate = true;
    }
  };
  DataTexture.prototype.isDataTexture = true;
  var _sphere$2 = /* @__PURE__ */ new Sphere();
  var _vector$7 = /* @__PURE__ */ new Vector3();
  var Frustum = class {
    constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
      this.planes = [p0, p1, p2, p3, p4, p5];
    }
    set(p0, p1, p2, p3, p4, p5) {
      const planes = this.planes;
      planes[0].copy(p0);
      planes[1].copy(p1);
      planes[2].copy(p2);
      planes[3].copy(p3);
      planes[4].copy(p4);
      planes[5].copy(p5);
      return this;
    }
    copy(frustum) {
      const planes = this.planes;
      for (let i = 0; i < 6; i++) {
        planes[i].copy(frustum.planes[i]);
      }
      return this;
    }
    setFromProjectionMatrix(m) {
      const planes = this.planes;
      const me = m.elements;
      const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
      const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
      const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
      const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
      planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
      planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
      planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
      planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
      planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
      planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
      return this;
    }
    intersectsObject(object) {
      const geometry = object.geometry;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
      return this.intersectsSphere(_sphere$2);
    }
    intersectsSprite(sprite) {
      _sphere$2.center.set(0, 0, 0);
      _sphere$2.radius = 0.7071067811865476;
      _sphere$2.applyMatrix4(sprite.matrixWorld);
      return this.intersectsSphere(_sphere$2);
    }
    intersectsSphere(sphere) {
      const planes = this.planes;
      const center = sphere.center;
      const negRadius = -sphere.radius;
      for (let i = 0; i < 6; i++) {
        const distance = planes[i].distanceToPoint(center);
        if (distance < negRadius) {
          return false;
        }
      }
      return true;
    }
    intersectsBox(box) {
      const planes = this.planes;
      for (let i = 0; i < 6; i++) {
        const plane = planes[i];
        _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
        _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
        _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
        if (plane.distanceToPoint(_vector$7) < 0) {
          return false;
        }
      }
      return true;
    }
    containsPoint(point) {
      const planes = this.planes;
      for (let i = 0; i < 6; i++) {
        if (planes[i].distanceToPoint(point) < 0) {
          return false;
        }
      }
      return true;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  function WebGLAnimation() {
    let context = null;
    let isAnimating = false;
    let animationLoop = null;
    let requestId = null;
    function onAnimationFrame(time, frame) {
      animationLoop(time, frame);
      requestId = context.requestAnimationFrame(onAnimationFrame);
    }
    return {
      start: function() {
        if (isAnimating === true)
          return;
        if (animationLoop === null)
          return;
        requestId = context.requestAnimationFrame(onAnimationFrame);
        isAnimating = true;
      },
      stop: function() {
        context.cancelAnimationFrame(requestId);
        isAnimating = false;
      },
      setAnimationLoop: function(callback) {
        animationLoop = callback;
      },
      setContext: function(value) {
        context = value;
      }
    };
  }
  function WebGLAttributes(gl, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    const buffers = new WeakMap();
    function createBuffer(attribute, bufferType) {
      const array = attribute.array;
      const usage = attribute.usage;
      const buffer = gl.createBuffer();
      gl.bindBuffer(bufferType, buffer);
      gl.bufferData(bufferType, array, usage);
      attribute.onUploadCallback();
      let type = 5126;
      if (array instanceof Float32Array) {
        type = 5126;
      } else if (array instanceof Float64Array) {
        console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
      } else if (array instanceof Uint16Array) {
        if (attribute.isFloat16BufferAttribute) {
          if (isWebGL2) {
            type = 5131;
          } else {
            console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
          }
        } else {
          type = 5123;
        }
      } else if (array instanceof Int16Array) {
        type = 5122;
      } else if (array instanceof Uint32Array) {
        type = 5125;
      } else if (array instanceof Int32Array) {
        type = 5124;
      } else if (array instanceof Int8Array) {
        type = 5120;
      } else if (array instanceof Uint8Array) {
        type = 5121;
      }
      return {
        buffer,
        type,
        bytesPerElement: array.BYTES_PER_ELEMENT,
        version: attribute.version
      };
    }
    function updateBuffer(buffer, attribute, bufferType) {
      const array = attribute.array;
      const updateRange = attribute.updateRange;
      gl.bindBuffer(bufferType, buffer);
      if (updateRange.count === -1) {
        gl.bufferSubData(bufferType, 0, array);
      } else {
        if (isWebGL2) {
          gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
        } else {
          gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
        }
        updateRange.count = -1;
      }
    }
    function get(attribute) {
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      return buffers.get(attribute);
    }
    function remove(attribute) {
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      const data = buffers.get(attribute);
      if (data) {
        gl.deleteBuffer(data.buffer);
        buffers.delete(attribute);
      }
    }
    function update(attribute, bufferType) {
      if (attribute.isGLBufferAttribute) {
        const cached = buffers.get(attribute);
        if (!cached || cached.version < attribute.version) {
          buffers.set(attribute, {
            buffer: attribute.buffer,
            type: attribute.type,
            bytesPerElement: attribute.elementSize,
            version: attribute.version
          });
        }
        return;
      }
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      const data = buffers.get(attribute);
      if (data === void 0) {
        buffers.set(attribute, createBuffer(attribute, bufferType));
      } else if (data.version < attribute.version) {
        updateBuffer(data.buffer, attribute, bufferType);
        data.version = attribute.version;
      }
    }
    return {
      get,
      remove,
      update
    };
  }
  var PlaneGeometry = class extends BufferGeometry {
    constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
      super();
      this.type = "PlaneGeometry";
      this.parameters = {
        width,
        height,
        widthSegments,
        heightSegments
      };
      const width_half = width / 2;
      const height_half = height / 2;
      const gridX = Math.floor(widthSegments);
      const gridY = Math.floor(heightSegments);
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      const segment_width = width / gridX;
      const segment_height = height / gridY;
      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];
      for (let iy = 0; iy < gridY1; iy++) {
        const y = iy * segment_height - height_half;
        for (let ix = 0; ix < gridX1; ix++) {
          const x = ix * segment_width - width_half;
          vertices.push(x, -y, 0);
          normals.push(0, 0, 1);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a = ix + gridX1 * iy;
          const b2 = ix + gridX1 * (iy + 1);
          const c = ix + 1 + gridX1 * (iy + 1);
          const d = ix + 1 + gridX1 * iy;
          indices.push(a, b2, d);
          indices.push(b2, c, d);
        }
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
  };
  var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
  var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
  var alphatest_fragment = "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
  var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif";
  var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
  var begin_vertex = "vec3 transformed = vec3( position );";
  var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
  var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	return vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n#else\n	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n	return Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + viewDir );\n	float dotNL = saturate( dot( normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	return specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	vec3 FssEss = F * brdf.x + brdf.y;\n	float Ess = brdf.x + brdf.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n	float invAlpha = 1.0 / roughness;\n	float cos2h = NoH * NoH;\n	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n	vec3 N = geometry.normal;\n	vec3 V = geometry.viewDir;\n	vec3 H = normalize( V + L );\n	float dotNH = saturate( dot( N, H ) );\n	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";
  var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
  var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
  var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
  var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
  var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
  var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
  var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
  var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
  var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
  var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
  var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
  var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
  var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
  var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
  var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
  var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
  var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
  var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}";
  var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifndef ENVMAP_TYPE_CUBE_UV\n		envColor = envMapTexelToLinear( envColor );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
  var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
  var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
  var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
  var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
  var fog_vertex = "#ifdef USE_FOG\n	fogDepth = - mvPosition.z;\n#endif";
  var fog_pars_vertex = "#ifdef USE_FOG\n	varying float fogDepth;\n#endif";
  var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
  var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
  var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
  var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";
  var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
  var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
  var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif";
  var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float sigma = PI * roughness * roughness / ( 1.0 + roughness );\n		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n		#else\n			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif";
  var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
  var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
  var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
  var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
  var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheen;\n#endif";
  var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float specularRoughness;\n	vec3 specularColor;\n#ifdef CLEARCOAT\n	float clearcoat;\n	float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	vec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifdef CLEARCOAT\n		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = ccDotNL * directLight.color;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			ccIrradiance *= PI;\n		#endif\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n			material.specularRoughness,\n			directLight.direction,\n			geometry,\n			material.sheenColor\n		);\n	#else\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n	#endif\n	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef CLEARCOAT\n		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n		float ccDotNL = ccDotNV;\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	float clearcoatInv = 1.0 - clearcoatDHR;\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
  var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
  var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n	#ifdef CLEARCOAT\n		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n	#endif\n#endif";
  var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
  var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
  var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
  var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
  var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
  var map_fragment = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif";
  var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
  var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
  var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
  var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
  var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
  var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";
  var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifndef USE_MORPHNORMALS\n		uniform float morphTargetInfluences[ 8 ];\n	#else\n		uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif";
  var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n	transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n	transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n	transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n		transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n		transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n		transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n		transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n	#endif\n#endif";
  var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
  var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
  var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
  var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
  var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
  var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
  var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
  var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
  var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
  var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
  var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
  var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
  var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
  var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
  var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
  var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
  var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
  var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
  var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
  var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
  var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
  var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
  var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
  var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
  var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
  var transmissionmap_fragment = "#ifdef USE_TRANSMISSIONMAP\n	totalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif";
  var transmissionmap_pars_fragment = "#ifdef USE_TRANSMISSIONMAP\n	uniform sampler2D transmissionMap;\n#endif";
  var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
  var uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
  var uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
  var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
  var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
  var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
  var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
  var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
  var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
  var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
  var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
  var depth_frag = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
  var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
  var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
  var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
  var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
  var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
  var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
  var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
  var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n	\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
  var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#ifndef FLAT_SHADED\n		vNormal = normalize( transformedNormal );\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
  var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n	#define REFLECTIVITY\n	#define CLEARCOAT\n	#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n	uniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n	uniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#ifdef TRANSMISSION\n		float totalTransmission = transmission;\n	#endif\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <transmissionmap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#ifdef TRANSMISSION\n		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n	#endif\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
  var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
  var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
  var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
  var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
  var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
  var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
  var ShaderChunk = {
    alphamap_fragment,
    alphamap_pars_fragment,
    alphatest_fragment,
    aomap_fragment,
    aomap_pars_fragment,
    begin_vertex,
    beginnormal_vertex,
    bsdfs,
    bumpmap_pars_fragment,
    clipping_planes_fragment,
    clipping_planes_pars_fragment,
    clipping_planes_pars_vertex,
    clipping_planes_vertex,
    color_fragment,
    color_pars_fragment,
    color_pars_vertex,
    color_vertex,
    common,
    cube_uv_reflection_fragment,
    defaultnormal_vertex,
    displacementmap_pars_vertex,
    displacementmap_vertex,
    emissivemap_fragment,
    emissivemap_pars_fragment,
    encodings_fragment,
    encodings_pars_fragment,
    envmap_fragment,
    envmap_common_pars_fragment,
    envmap_pars_fragment,
    envmap_pars_vertex,
    envmap_physical_pars_fragment,
    envmap_vertex,
    fog_vertex,
    fog_pars_vertex,
    fog_fragment,
    fog_pars_fragment,
    gradientmap_pars_fragment,
    lightmap_fragment,
    lightmap_pars_fragment,
    lights_lambert_vertex,
    lights_pars_begin,
    lights_toon_fragment,
    lights_toon_pars_fragment,
    lights_phong_fragment,
    lights_phong_pars_fragment,
    lights_physical_fragment,
    lights_physical_pars_fragment,
    lights_fragment_begin,
    lights_fragment_maps,
    lights_fragment_end,
    logdepthbuf_fragment,
    logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex,
    logdepthbuf_vertex,
    map_fragment,
    map_pars_fragment,
    map_particle_fragment,
    map_particle_pars_fragment,
    metalnessmap_fragment,
    metalnessmap_pars_fragment,
    morphnormal_vertex,
    morphtarget_pars_vertex,
    morphtarget_vertex,
    normal_fragment_begin,
    normal_fragment_maps,
    normalmap_pars_fragment,
    clearcoat_normal_fragment_begin,
    clearcoat_normal_fragment_maps,
    clearcoat_pars_fragment,
    packing,
    premultiplied_alpha_fragment,
    project_vertex,
    dithering_fragment,
    dithering_pars_fragment,
    roughnessmap_fragment,
    roughnessmap_pars_fragment,
    shadowmap_pars_fragment,
    shadowmap_pars_vertex,
    shadowmap_vertex,
    shadowmask_pars_fragment,
    skinbase_vertex,
    skinning_pars_vertex,
    skinning_vertex,
    skinnormal_vertex,
    specularmap_fragment,
    specularmap_pars_fragment,
    tonemapping_fragment,
    tonemapping_pars_fragment,
    transmissionmap_fragment,
    transmissionmap_pars_fragment,
    uv_pars_fragment,
    uv_pars_vertex,
    uv_vertex,
    uv2_pars_fragment,
    uv2_pars_vertex,
    uv2_vertex,
    worldpos_vertex,
    background_frag,
    background_vert,
    cube_frag,
    cube_vert,
    depth_frag,
    depth_vert,
    distanceRGBA_frag,
    distanceRGBA_vert,
    equirect_frag,
    equirect_vert,
    linedashed_frag,
    linedashed_vert,
    meshbasic_frag,
    meshbasic_vert,
    meshlambert_frag,
    meshlambert_vert,
    meshmatcap_frag,
    meshmatcap_vert,
    meshtoon_frag,
    meshtoon_vert,
    meshphong_frag,
    meshphong_vert,
    meshphysical_frag,
    meshphysical_vert,
    normal_frag,
    normal_vert,
    points_frag,
    points_vert,
    shadow_frag,
    shadow_vert,
    sprite_frag,
    sprite_vert
  };
  var UniformsLib = {
    common: {
      diffuse: { value: new Color(15658734) },
      opacity: { value: 1 },
      map: { value: null },
      uvTransform: { value: new Matrix3() },
      uv2Transform: { value: new Matrix3() },
      alphaMap: { value: null }
    },
    specularmap: {
      specularMap: { value: null }
    },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      refractionRatio: { value: 0.98 },
      maxMipLevel: { value: 0 }
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 }
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 }
    },
    emissivemap: {
      emissiveMap: { value: null }
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpScale: { value: 1 }
    },
    normalmap: {
      normalMap: { value: null },
      normalScale: { value: new Vector2(1, 1) }
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 }
    },
    roughnessmap: {
      roughnessMap: { value: null }
    },
    metalnessmap: {
      metalnessMap: { value: null }
    },
    gradientmap: {
      gradientMap: { value: null }
    },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Color(16777215) }
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: { value: [], properties: {
        direction: {},
        color: {}
      } },
      directionalLightShadows: { value: [], properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      } },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: { value: [], properties: {
        color: {},
        position: {},
        direction: {},
        distance: {},
        coneCos: {},
        penumbraCos: {},
        decay: {}
      } },
      spotLightShadows: { value: [], properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      } },
      spotShadowMap: { value: [] },
      spotShadowMatrix: { value: [] },
      pointLights: { value: [], properties: {
        color: {},
        position: {},
        decay: {},
        distance: {}
      } },
      pointLightShadows: { value: [], properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {},
        shadowCameraNear: {},
        shadowCameraFar: {}
      } },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: { value: [], properties: {
        direction: {},
        skyColor: {},
        groundColor: {}
      } },
      rectAreaLights: { value: [], properties: {
        color: {},
        position: {},
        width: {},
        height: {}
      } },
      ltc_1: { value: null },
      ltc_2: { value: null }
    },
    points: {
      diffuse: { value: new Color(15658734) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      uvTransform: { value: new Matrix3() }
    },
    sprite: {
      diffuse: { value: new Color(15658734) },
      opacity: { value: 1 },
      center: { value: new Vector2(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      alphaMap: { value: null },
      uvTransform: { value: new Matrix3() }
    }
  };
  var ShaderLib = {
    basic: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.fog
      ]),
      vertexShader: ShaderChunk.meshbasic_vert,
      fragmentShader: ShaderChunk.meshbasic_frag
    },
    lambert: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color(0) }
        }
      ]),
      vertexShader: ShaderChunk.meshlambert_vert,
      fragmentShader: ShaderChunk.meshlambert_frag
    },
    phong: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color(0) },
          specular: { value: new Color(1118481) },
          shininess: { value: 30 }
        }
      ]),
      vertexShader: ShaderChunk.meshphong_vert,
      fragmentShader: ShaderChunk.meshphong_frag
    },
    standard: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.roughnessmap,
        UniformsLib.metalnessmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 }
        }
      ]),
      vertexShader: ShaderChunk.meshphysical_vert,
      fragmentShader: ShaderChunk.meshphysical_frag
    },
    toon: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.gradientmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color(0) }
        }
      ]),
      vertexShader: ShaderChunk.meshtoon_vert,
      fragmentShader: ShaderChunk.meshtoon_frag
    },
    matcap: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        {
          matcap: { value: null }
        }
      ]),
      vertexShader: ShaderChunk.meshmatcap_vert,
      fragmentShader: ShaderChunk.meshmatcap_frag
    },
    points: {
      uniforms: mergeUniforms([
        UniformsLib.points,
        UniformsLib.fog
      ]),
      vertexShader: ShaderChunk.points_vert,
      fragmentShader: ShaderChunk.points_frag
    },
    dashed: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 }
        }
      ]),
      vertexShader: ShaderChunk.linedashed_vert,
      fragmentShader: ShaderChunk.linedashed_frag
    },
    depth: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.displacementmap
      ]),
      vertexShader: ShaderChunk.depth_vert,
      fragmentShader: ShaderChunk.depth_frag
    },
    normal: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        {
          opacity: { value: 1 }
        }
      ]),
      vertexShader: ShaderChunk.normal_vert,
      fragmentShader: ShaderChunk.normal_frag
    },
    sprite: {
      uniforms: mergeUniforms([
        UniformsLib.sprite,
        UniformsLib.fog
      ]),
      vertexShader: ShaderChunk.sprite_vert,
      fragmentShader: ShaderChunk.sprite_frag
    },
    background: {
      uniforms: {
        uvTransform: { value: new Matrix3() },
        t2D: { value: null }
      },
      vertexShader: ShaderChunk.background_vert,
      fragmentShader: ShaderChunk.background_frag
    },
    cube: {
      uniforms: mergeUniforms([
        UniformsLib.envmap,
        {
          opacity: { value: 1 }
        }
      ]),
      vertexShader: ShaderChunk.cube_vert,
      fragmentShader: ShaderChunk.cube_frag
    },
    equirect: {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: ShaderChunk.equirect_vert,
      fragmentShader: ShaderChunk.equirect_frag
    },
    distanceRGBA: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.displacementmap,
        {
          referencePosition: { value: new Vector3() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 }
        }
      ]),
      vertexShader: ShaderChunk.distanceRGBA_vert,
      fragmentShader: ShaderChunk.distanceRGBA_frag
    },
    shadow: {
      uniforms: mergeUniforms([
        UniformsLib.lights,
        UniformsLib.fog,
        {
          color: { value: new Color(0) },
          opacity: { value: 1 }
        }
      ]),
      vertexShader: ShaderChunk.shadow_vert,
      fragmentShader: ShaderChunk.shadow_frag
    }
  };
  ShaderLib.physical = {
    uniforms: mergeUniforms([
      ShaderLib.standard.uniforms,
      {
        clearcoat: { value: 0 },
        clearcoatMap: { value: null },
        clearcoatRoughness: { value: 0 },
        clearcoatRoughnessMap: { value: null },
        clearcoatNormalScale: { value: new Vector2(1, 1) },
        clearcoatNormalMap: { value: null },
        sheen: { value: new Color(0) },
        transmission: { value: 0 },
        transmissionMap: { value: null }
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  };
  function WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {
    const clearColor = new Color(0);
    let clearAlpha = 0;
    let planeMesh;
    let boxMesh;
    let currentBackground = null;
    let currentBackgroundVersion = 0;
    let currentTonemapping = null;
    function render(renderList, scene, camera, forceClear) {
      let background = scene.isScene === true ? scene.background : null;
      if (background && background.isTexture) {
        background = cubemaps.get(background);
      }
      const xr2 = renderer.xr;
      const session = xr2.getSession && xr2.getSession();
      if (session && session.environmentBlendMode === "additive") {
        background = null;
      }
      if (background === null) {
        setClear(clearColor, clearAlpha);
      } else if (background && background.isColor) {
        setClear(background, 1);
        forceClear = true;
      }
      if (renderer.autoClear || forceClear) {
        renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
      }
      if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
        if (boxMesh === void 0) {
          boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
            name: "BackgroundCubeMaterial",
            uniforms: cloneUniforms(ShaderLib.cube.uniforms),
            vertexShader: ShaderLib.cube.vertexShader,
            fragmentShader: ShaderLib.cube.fragmentShader,
            side: BackSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          }));
          boxMesh.geometry.deleteAttribute("normal");
          boxMesh.geometry.deleteAttribute("uv");
          boxMesh.onBeforeRender = function(renderer2, scene2, camera2) {
            this.matrixWorld.copyPosition(camera2.matrixWorld);
          };
          Object.defineProperty(boxMesh.material, "envMap", {
            get: function() {
              return this.uniforms.envMap.value;
            }
          });
          objects.update(boxMesh);
        }
        boxMesh.material.uniforms.envMap.value = background;
        boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background._needsFlipEnvMap ? -1 : 1;
        if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
          boxMesh.material.needsUpdate = true;
          currentBackground = background;
          currentBackgroundVersion = background.version;
          currentTonemapping = renderer.toneMapping;
        }
        renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
      } else if (background && background.isTexture) {
        if (planeMesh === void 0) {
          planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
            name: "BackgroundMaterial",
            uniforms: cloneUniforms(ShaderLib.background.uniforms),
            vertexShader: ShaderLib.background.vertexShader,
            fragmentShader: ShaderLib.background.fragmentShader,
            side: FrontSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          }));
          planeMesh.geometry.deleteAttribute("normal");
          Object.defineProperty(planeMesh.material, "map", {
            get: function() {
              return this.uniforms.t2D.value;
            }
          });
          objects.update(planeMesh);
        }
        planeMesh.material.uniforms.t2D.value = background;
        if (background.matrixAutoUpdate === true) {
          background.updateMatrix();
        }
        planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
        if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
          planeMesh.material.needsUpdate = true;
          currentBackground = background;
          currentBackgroundVersion = background.version;
          currentTonemapping = renderer.toneMapping;
        }
        renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
      }
    }
    function setClear(color, alpha) {
      state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
    }
    return {
      getClearColor: function() {
        return clearColor;
      },
      setClearColor: function(color, alpha = 1) {
        clearColor.set(color);
        clearAlpha = alpha;
        setClear(clearColor, clearAlpha);
      },
      getClearAlpha: function() {
        return clearAlpha;
      },
      setClearAlpha: function(alpha) {
        clearAlpha = alpha;
        setClear(clearColor, clearAlpha);
      },
      render
    };
  }
  function WebGLBindingStates(gl, extensions, attributes, capabilities) {
    const maxVertexAttributes = gl.getParameter(34921);
    const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
    const vaoAvailable = capabilities.isWebGL2 || extension !== null;
    const bindingStates = {};
    const defaultState = createBindingState(null);
    let currentState = defaultState;
    function setup(object, material, program, geometry, index) {
      let updateBuffers = false;
      if (vaoAvailable) {
        const state = getBindingState(geometry, program, material);
        if (currentState !== state) {
          currentState = state;
          bindVertexArrayObject(currentState.object);
        }
        updateBuffers = needsUpdate(geometry, index);
        if (updateBuffers)
          saveCache(geometry, index);
      } else {
        const wireframe = material.wireframe === true;
        if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
          currentState.geometry = geometry.id;
          currentState.program = program.id;
          currentState.wireframe = wireframe;
          updateBuffers = true;
        }
      }
      if (object.isInstancedMesh === true) {
        updateBuffers = true;
      }
      if (index !== null) {
        attributes.update(index, 34963);
      }
      if (updateBuffers) {
        setupVertexAttributes(object, material, program, geometry);
        if (index !== null) {
          gl.bindBuffer(34963, attributes.get(index).buffer);
        }
      }
    }
    function createVertexArrayObject() {
      if (capabilities.isWebGL2)
        return gl.createVertexArray();
      return extension.createVertexArrayOES();
    }
    function bindVertexArrayObject(vao) {
      if (capabilities.isWebGL2)
        return gl.bindVertexArray(vao);
      return extension.bindVertexArrayOES(vao);
    }
    function deleteVertexArrayObject(vao) {
      if (capabilities.isWebGL2)
        return gl.deleteVertexArray(vao);
      return extension.deleteVertexArrayOES(vao);
    }
    function getBindingState(geometry, program, material) {
      const wireframe = material.wireframe === true;
      let programMap = bindingStates[geometry.id];
      if (programMap === void 0) {
        programMap = {};
        bindingStates[geometry.id] = programMap;
      }
      let stateMap = programMap[program.id];
      if (stateMap === void 0) {
        stateMap = {};
        programMap[program.id] = stateMap;
      }
      let state = stateMap[wireframe];
      if (state === void 0) {
        state = createBindingState(createVertexArrayObject());
        stateMap[wireframe] = state;
      }
      return state;
    }
    function createBindingState(vao) {
      const newAttributes = [];
      const enabledAttributes = [];
      const attributeDivisors = [];
      for (let i = 0; i < maxVertexAttributes; i++) {
        newAttributes[i] = 0;
        enabledAttributes[i] = 0;
        attributeDivisors[i] = 0;
      }
      return {
        geometry: null,
        program: null,
        wireframe: false,
        newAttributes,
        enabledAttributes,
        attributeDivisors,
        object: vao,
        attributes: {},
        index: null
      };
    }
    function needsUpdate(geometry, index) {
      const cachedAttributes = currentState.attributes;
      const geometryAttributes = geometry.attributes;
      let attributesNum = 0;
      for (const key in geometryAttributes) {
        const cachedAttribute = cachedAttributes[key];
        const geometryAttribute = geometryAttributes[key];
        if (cachedAttribute === void 0)
          return true;
        if (cachedAttribute.attribute !== geometryAttribute)
          return true;
        if (cachedAttribute.data !== geometryAttribute.data)
          return true;
        attributesNum++;
      }
      if (currentState.attributesNum !== attributesNum)
        return true;
      if (currentState.index !== index)
        return true;
      return false;
    }
    function saveCache(geometry, index) {
      const cache = {};
      const attributes2 = geometry.attributes;
      let attributesNum = 0;
      for (const key in attributes2) {
        const attribute = attributes2[key];
        const data = {};
        data.attribute = attribute;
        if (attribute.data) {
          data.data = attribute.data;
        }
        cache[key] = data;
        attributesNum++;
      }
      currentState.attributes = cache;
      currentState.attributesNum = attributesNum;
      currentState.index = index;
    }
    function initAttributes() {
      const newAttributes = currentState.newAttributes;
      for (let i = 0, il = newAttributes.length; i < il; i++) {
        newAttributes[i] = 0;
      }
    }
    function enableAttribute(attribute) {
      enableAttributeAndDivisor(attribute, 0);
    }
    function enableAttributeAndDivisor(attribute, meshPerAttribute) {
      const newAttributes = currentState.newAttributes;
      const enabledAttributes = currentState.enabledAttributes;
      const attributeDivisors = currentState.attributeDivisors;
      newAttributes[attribute] = 1;
      if (enabledAttributes[attribute] === 0) {
        gl.enableVertexAttribArray(attribute);
        enabledAttributes[attribute] = 1;
      }
      if (attributeDivisors[attribute] !== meshPerAttribute) {
        const extension2 = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
        extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
        attributeDivisors[attribute] = meshPerAttribute;
      }
    }
    function disableUnusedAttributes() {
      const newAttributes = currentState.newAttributes;
      const enabledAttributes = currentState.enabledAttributes;
      for (let i = 0, il = enabledAttributes.length; i < il; i++) {
        if (enabledAttributes[i] !== newAttributes[i]) {
          gl.disableVertexAttribArray(i);
          enabledAttributes[i] = 0;
        }
      }
    }
    function vertexAttribPointer(index, size2, type, normalized, stride, offset) {
      if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
        gl.vertexAttribIPointer(index, size2, type, stride, offset);
      } else {
        gl.vertexAttribPointer(index, size2, type, normalized, stride, offset);
      }
    }
    function setupVertexAttributes(object, material, program, geometry) {
      if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
        if (extensions.get("ANGLE_instanced_arrays") === null)
          return;
      }
      initAttributes();
      const geometryAttributes = geometry.attributes;
      const programAttributes = program.getAttributes();
      const materialDefaultAttributeValues = material.defaultAttributeValues;
      for (const name in programAttributes) {
        const programAttribute = programAttributes[name];
        if (programAttribute >= 0) {
          const geometryAttribute = geometryAttributes[name];
          if (geometryAttribute !== void 0) {
            const normalized = geometryAttribute.normalized;
            const size2 = geometryAttribute.itemSize;
            const attribute = attributes.get(geometryAttribute);
            if (attribute === void 0)
              continue;
            const buffer = attribute.buffer;
            const type = attribute.type;
            const bytesPerElement = attribute.bytesPerElement;
            if (geometryAttribute.isInterleavedBufferAttribute) {
              const data = geometryAttribute.data;
              const stride = data.stride;
              const offset = geometryAttribute.offset;
              if (data && data.isInstancedInterleavedBuffer) {
                enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
                if (geometry._maxInstanceCount === void 0) {
                  geometry._maxInstanceCount = data.meshPerAttribute * data.count;
                }
              } else {
                enableAttribute(programAttribute);
              }
              gl.bindBuffer(34962, buffer);
              vertexAttribPointer(programAttribute, size2, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
            } else {
              if (geometryAttribute.isInstancedBufferAttribute) {
                enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
                if (geometry._maxInstanceCount === void 0) {
                  geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                }
              } else {
                enableAttribute(programAttribute);
              }
              gl.bindBuffer(34962, buffer);
              vertexAttribPointer(programAttribute, size2, type, normalized, 0, 0);
            }
          } else if (name === "instanceMatrix") {
            const attribute = attributes.get(object.instanceMatrix);
            if (attribute === void 0)
              continue;
            const buffer = attribute.buffer;
            const type = attribute.type;
            enableAttributeAndDivisor(programAttribute + 0, 1);
            enableAttributeAndDivisor(programAttribute + 1, 1);
            enableAttributeAndDivisor(programAttribute + 2, 1);
            enableAttributeAndDivisor(programAttribute + 3, 1);
            gl.bindBuffer(34962, buffer);
            gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);
            gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);
            gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);
            gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);
          } else if (name === "instanceColor") {
            const attribute = attributes.get(object.instanceColor);
            if (attribute === void 0)
              continue;
            const buffer = attribute.buffer;
            const type = attribute.type;
            enableAttributeAndDivisor(programAttribute, 1);
            gl.bindBuffer(34962, buffer);
            gl.vertexAttribPointer(programAttribute, 3, type, false, 12, 0);
          } else if (materialDefaultAttributeValues !== void 0) {
            const value = materialDefaultAttributeValues[name];
            if (value !== void 0) {
              switch (value.length) {
                case 2:
                  gl.vertexAttrib2fv(programAttribute, value);
                  break;
                case 3:
                  gl.vertexAttrib3fv(programAttribute, value);
                  break;
                case 4:
                  gl.vertexAttrib4fv(programAttribute, value);
                  break;
                default:
                  gl.vertexAttrib1fv(programAttribute, value);
              }
            }
          }
        }
      }
      disableUnusedAttributes();
    }
    function dispose() {
      reset();
      for (const geometryId in bindingStates) {
        const programMap = bindingStates[geometryId];
        for (const programId in programMap) {
          const stateMap = programMap[programId];
          for (const wireframe in stateMap) {
            deleteVertexArrayObject(stateMap[wireframe].object);
            delete stateMap[wireframe];
          }
          delete programMap[programId];
        }
        delete bindingStates[geometryId];
      }
    }
    function releaseStatesOfGeometry(geometry) {
      if (bindingStates[geometry.id] === void 0)
        return;
      const programMap = bindingStates[geometry.id];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometry.id];
    }
    function releaseStatesOfProgram(program) {
      for (const geometryId in bindingStates) {
        const programMap = bindingStates[geometryId];
        if (programMap[program.id] === void 0)
          continue;
        const stateMap = programMap[program.id];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[program.id];
      }
    }
    function reset() {
      resetDefaultState();
      if (currentState === defaultState)
        return;
      currentState = defaultState;
      bindVertexArrayObject(currentState.object);
    }
    function resetDefaultState() {
      defaultState.geometry = null;
      defaultState.program = null;
      defaultState.wireframe = false;
    }
    return {
      setup,
      reset,
      resetDefaultState,
      dispose,
      releaseStatesOfGeometry,
      releaseStatesOfProgram,
      initAttributes,
      enableAttribute,
      disableUnusedAttributes
    };
  }
  function WebGLBufferRenderer(gl, extensions, info2, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
      mode = value;
    }
    function render(start, count) {
      gl.drawArrays(mode, start, count);
      info2.update(count, mode, 1);
    }
    function renderInstances(start, count, primcount) {
      if (primcount === 0)
        return;
      let extension, methodName;
      if (isWebGL2) {
        extension = gl;
        methodName = "drawArraysInstanced";
      } else {
        extension = extensions.get("ANGLE_instanced_arrays");
        methodName = "drawArraysInstancedANGLE";
        if (extension === null) {
          console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          return;
        }
      }
      extension[methodName](mode, start, count, primcount);
      info2.update(count, mode, primcount);
    }
    this.setMode = setMode;
    this.render = render;
    this.renderInstances = renderInstances;
  }
  function WebGLCapabilities(gl, extensions, parameters) {
    let maxAnisotropy;
    function getMaxAnisotropy() {
      if (maxAnisotropy !== void 0)
        return maxAnisotropy;
      if (extensions.has("EXT_texture_filter_anisotropic") === true) {
        const extension = extensions.get("EXT_texture_filter_anisotropic");
        maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else {
        maxAnisotropy = 0;
      }
      return maxAnisotropy;
    }
    function getMaxPrecision(precision2) {
      if (precision2 === "highp") {
        if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
          return "highp";
        }
        precision2 = "mediump";
      }
      if (precision2 === "mediump") {
        if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
          return "mediump";
        }
      }
      return "lowp";
    }
    const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
    let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
    const maxPrecision = getMaxPrecision(precision);
    if (maxPrecision !== precision) {
      console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
      precision = maxPrecision;
    }
    const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
    const maxTextures = gl.getParameter(34930);
    const maxVertexTextures = gl.getParameter(35660);
    const maxTextureSize = gl.getParameter(3379);
    const maxCubemapSize = gl.getParameter(34076);
    const maxAttributes = gl.getParameter(34921);
    const maxVertexUniforms = gl.getParameter(36347);
    const maxVaryings = gl.getParameter(36348);
    const maxFragmentUniforms = gl.getParameter(36349);
    const vertexTextures = maxVertexTextures > 0;
    const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
    const floatVertexTextures = vertexTextures && floatFragmentTextures;
    const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
    return {
      isWebGL2,
      getMaxAnisotropy,
      getMaxPrecision,
      precision,
      logarithmicDepthBuffer,
      maxTextures,
      maxVertexTextures,
      maxTextureSize,
      maxCubemapSize,
      maxAttributes,
      maxVertexUniforms,
      maxVaryings,
      maxFragmentUniforms,
      vertexTextures,
      floatFragmentTextures,
      floatVertexTextures,
      maxSamples
    };
  }
  function WebGLClipping(properties) {
    const scope = this;
    let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
    const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
    this.uniform = uniform;
    this.numPlanes = 0;
    this.numIntersection = 0;
    this.init = function(planes, enableLocalClipping, camera) {
      const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
      localClippingEnabled = enableLocalClipping;
      globalState = projectPlanes(planes, camera, 0);
      numGlobalPlanes = planes.length;
      return enabled;
    };
    this.beginShadows = function() {
      renderingShadows = true;
      projectPlanes(null);
    };
    this.endShadows = function() {
      renderingShadows = false;
      resetGlobalState();
    };
    this.setState = function(material, camera, useCache) {
      const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
      const materialProperties = properties.get(material);
      if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
        if (renderingShadows) {
          projectPlanes(null);
        } else {
          resetGlobalState();
        }
      } else {
        const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
        let dstArray = materialProperties.clippingState || null;
        uniform.value = dstArray;
        dstArray = projectPlanes(planes, camera, lGlobal, useCache);
        for (let i = 0; i !== lGlobal; ++i) {
          dstArray[i] = globalState[i];
        }
        materialProperties.clippingState = dstArray;
        this.numIntersection = clipIntersection ? this.numPlanes : 0;
        this.numPlanes += nGlobal;
      }
    };
    function resetGlobalState() {
      if (uniform.value !== globalState) {
        uniform.value = globalState;
        uniform.needsUpdate = numGlobalPlanes > 0;
      }
      scope.numPlanes = numGlobalPlanes;
      scope.numIntersection = 0;
    }
    function projectPlanes(planes, camera, dstOffset, skipTransform) {
      const nPlanes = planes !== null ? planes.length : 0;
      let dstArray = null;
      if (nPlanes !== 0) {
        dstArray = uniform.value;
        if (skipTransform !== true || dstArray === null) {
          const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
          viewNormalMatrix.getNormalMatrix(viewMatrix);
          if (dstArray === null || dstArray.length < flatSize) {
            dstArray = new Float32Array(flatSize);
          }
          for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
            plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
            plane.normal.toArray(dstArray, i4);
            dstArray[i4 + 3] = plane.constant;
          }
        }
        uniform.value = dstArray;
        uniform.needsUpdate = true;
      }
      scope.numPlanes = nPlanes;
      scope.numIntersection = 0;
      return dstArray;
    }
  }
  function WebGLCubeMaps(renderer) {
    let cubemaps = new WeakMap();
    function mapTextureMapping(texture, mapping) {
      if (mapping === EquirectangularReflectionMapping) {
        texture.mapping = CubeReflectionMapping;
      } else if (mapping === EquirectangularRefractionMapping) {
        texture.mapping = CubeRefractionMapping;
      }
      return texture;
    }
    function get(texture) {
      if (texture && texture.isTexture) {
        const mapping = texture.mapping;
        if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
          if (cubemaps.has(texture)) {
            const cubemap = cubemaps.get(texture).texture;
            return mapTextureMapping(cubemap, texture.mapping);
          } else {
            const image = texture.image;
            if (image && image.height > 0) {
              const currentRenderTarget = renderer.getRenderTarget();
              const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
              renderTarget.fromEquirectangularTexture(renderer, texture);
              cubemaps.set(texture, renderTarget);
              renderer.setRenderTarget(currentRenderTarget);
              texture.addEventListener("dispose", onTextureDispose);
              return mapTextureMapping(renderTarget.texture, texture.mapping);
            } else {
              return null;
            }
          }
        }
      }
      return texture;
    }
    function onTextureDispose(event) {
      const texture = event.target;
      texture.removeEventListener("dispose", onTextureDispose);
      const cubemap = cubemaps.get(texture);
      if (cubemap !== void 0) {
        cubemaps.delete(texture);
        cubemap.dispose();
      }
    }
    function dispose() {
      cubemaps = new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  function WebGLExtensions(gl) {
    const extensions = {};
    function getExtension(name) {
      if (extensions[name] !== void 0) {
        return extensions[name];
      }
      let extension;
      switch (name) {
        case "WEBGL_depth_texture":
          extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          extension = gl.getExtension(name);
      }
      extensions[name] = extension;
      return extension;
    }
    return {
      has: function(name) {
        return getExtension(name) !== null;
      },
      init: function(capabilities) {
        if (capabilities.isWebGL2) {
          getExtension("EXT_color_buffer_float");
        } else {
          getExtension("WEBGL_depth_texture");
          getExtension("OES_texture_float");
          getExtension("OES_texture_half_float");
          getExtension("OES_texture_half_float_linear");
          getExtension("OES_standard_derivatives");
          getExtension("OES_element_index_uint");
          getExtension("OES_vertex_array_object");
          getExtension("ANGLE_instanced_arrays");
        }
        getExtension("OES_texture_float_linear");
        getExtension("EXT_color_buffer_half_float");
      },
      get: function(name) {
        const extension = getExtension(name);
        if (extension === null) {
          console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
        }
        return extension;
      }
    };
  }
  function WebGLGeometries(gl, attributes, info2, bindingStates) {
    const geometries = {};
    const wireframeAttributes = new WeakMap();
    function onGeometryDispose(event) {
      const geometry = event.target;
      if (geometry.index !== null) {
        attributes.remove(geometry.index);
      }
      for (const name in geometry.attributes) {
        attributes.remove(geometry.attributes[name]);
      }
      geometry.removeEventListener("dispose", onGeometryDispose);
      delete geometries[geometry.id];
      const attribute = wireframeAttributes.get(geometry);
      if (attribute) {
        attributes.remove(attribute);
        wireframeAttributes.delete(geometry);
      }
      bindingStates.releaseStatesOfGeometry(geometry);
      if (geometry.isInstancedBufferGeometry === true) {
        delete geometry._maxInstanceCount;
      }
      info2.memory.geometries--;
    }
    function get(object, geometry) {
      if (geometries[geometry.id] === true)
        return geometry;
      geometry.addEventListener("dispose", onGeometryDispose);
      geometries[geometry.id] = true;
      info2.memory.geometries++;
      return geometry;
    }
    function update(geometry) {
      const geometryAttributes = geometry.attributes;
      for (const name in geometryAttributes) {
        attributes.update(geometryAttributes[name], 34962);
      }
      const morphAttributes = geometry.morphAttributes;
      for (const name in morphAttributes) {
        const array = morphAttributes[name];
        for (let i = 0, l = array.length; i < l; i++) {
          attributes.update(array[i], 34962);
        }
      }
    }
    function updateWireframeAttribute(geometry) {
      const indices = [];
      const geometryIndex = geometry.index;
      const geometryPosition = geometry.attributes.position;
      let version = 0;
      if (geometryIndex !== null) {
        const array = geometryIndex.array;
        version = geometryIndex.version;
        for (let i = 0, l = array.length; i < l; i += 3) {
          const a = array[i + 0];
          const b2 = array[i + 1];
          const c = array[i + 2];
          indices.push(a, b2, b2, c, c, a);
        }
      } else {
        const array = geometryPosition.array;
        version = geometryPosition.version;
        for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
          const a = i + 0;
          const b2 = i + 1;
          const c = i + 2;
          indices.push(a, b2, b2, c, c, a);
        }
      }
      const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
      attribute.version = version;
      const previousAttribute = wireframeAttributes.get(geometry);
      if (previousAttribute)
        attributes.remove(previousAttribute);
      wireframeAttributes.set(geometry, attribute);
    }
    function getWireframeAttribute(geometry) {
      const currentAttribute = wireframeAttributes.get(geometry);
      if (currentAttribute) {
        const geometryIndex = geometry.index;
        if (geometryIndex !== null) {
          if (currentAttribute.version < geometryIndex.version) {
            updateWireframeAttribute(geometry);
          }
        }
      } else {
        updateWireframeAttribute(geometry);
      }
      return wireframeAttributes.get(geometry);
    }
    return {
      get,
      update,
      getWireframeAttribute
    };
  }
  function WebGLIndexedBufferRenderer(gl, extensions, info2, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
      mode = value;
    }
    let type, bytesPerElement;
    function setIndex(value) {
      type = value.type;
      bytesPerElement = value.bytesPerElement;
    }
    function render(start, count) {
      gl.drawElements(mode, count, type, start * bytesPerElement);
      info2.update(count, mode, 1);
    }
    function renderInstances(start, count, primcount) {
      if (primcount === 0)
        return;
      let extension, methodName;
      if (isWebGL2) {
        extension = gl;
        methodName = "drawElementsInstanced";
      } else {
        extension = extensions.get("ANGLE_instanced_arrays");
        methodName = "drawElementsInstancedANGLE";
        if (extension === null) {
          console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          return;
        }
      }
      extension[methodName](mode, count, type, start * bytesPerElement, primcount);
      info2.update(count, mode, primcount);
    }
    this.setMode = setMode;
    this.setIndex = setIndex;
    this.render = render;
    this.renderInstances = renderInstances;
  }
  function WebGLInfo(gl) {
    const memory = {
      geometries: 0,
      textures: 0
    };
    const render = {
      frame: 0,
      calls: 0,
      triangles: 0,
      points: 0,
      lines: 0
    };
    function update(count, mode, instanceCount) {
      render.calls++;
      switch (mode) {
        case 4:
          render.triangles += instanceCount * (count / 3);
          break;
        case 1:
          render.lines += instanceCount * (count / 2);
          break;
        case 3:
          render.lines += instanceCount * (count - 1);
          break;
        case 2:
          render.lines += instanceCount * count;
          break;
        case 0:
          render.points += instanceCount * count;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
          break;
      }
    }
    function reset() {
      render.frame++;
      render.calls = 0;
      render.triangles = 0;
      render.points = 0;
      render.lines = 0;
    }
    return {
      memory,
      render,
      programs: null,
      autoReset: true,
      reset,
      update
    };
  }
  function numericalSort(a, b2) {
    return a[0] - b2[0];
  }
  function absNumericalSort(a, b2) {
    return Math.abs(b2[1]) - Math.abs(a[1]);
  }
  function WebGLMorphtargets(gl) {
    const influencesList = {};
    const morphInfluences = new Float32Array(8);
    const workInfluences = [];
    for (let i = 0; i < 8; i++) {
      workInfluences[i] = [i, 0];
    }
    function update(object, geometry, material, program) {
      const objectInfluences = object.morphTargetInfluences;
      const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
      let influences = influencesList[geometry.id];
      if (influences === void 0) {
        influences = [];
        for (let i = 0; i < length; i++) {
          influences[i] = [i, 0];
        }
        influencesList[geometry.id] = influences;
      }
      for (let i = 0; i < length; i++) {
        const influence = influences[i];
        influence[0] = i;
        influence[1] = objectInfluences[i];
      }
      influences.sort(absNumericalSort);
      for (let i = 0; i < 8; i++) {
        if (i < length && influences[i][1]) {
          workInfluences[i][0] = influences[i][0];
          workInfluences[i][1] = influences[i][1];
        } else {
          workInfluences[i][0] = Number.MAX_SAFE_INTEGER;
          workInfluences[i][1] = 0;
        }
      }
      workInfluences.sort(numericalSort);
      const morphTargets = material.morphTargets && geometry.morphAttributes.position;
      const morphNormals = material.morphNormals && geometry.morphAttributes.normal;
      let morphInfluencesSum = 0;
      for (let i = 0; i < 8; i++) {
        const influence = workInfluences[i];
        const index = influence[0];
        const value = influence[1];
        if (index !== Number.MAX_SAFE_INTEGER && value) {
          if (morphTargets && geometry.getAttribute("morphTarget" + i) !== morphTargets[index]) {
            geometry.setAttribute("morphTarget" + i, morphTargets[index]);
          }
          if (morphNormals && geometry.getAttribute("morphNormal" + i) !== morphNormals[index]) {
            geometry.setAttribute("morphNormal" + i, morphNormals[index]);
          }
          morphInfluences[i] = value;
          morphInfluencesSum += value;
        } else {
          if (morphTargets && geometry.hasAttribute("morphTarget" + i) === true) {
            geometry.deleteAttribute("morphTarget" + i);
          }
          if (morphNormals && geometry.hasAttribute("morphNormal" + i) === true) {
            geometry.deleteAttribute("morphNormal" + i);
          }
          morphInfluences[i] = 0;
        }
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
    }
    return {
      update
    };
  }
  function WebGLObjects(gl, geometries, attributes, info2) {
    let updateMap = new WeakMap();
    function update(object) {
      const frame = info2.render.frame;
      const geometry = object.geometry;
      const buffergeometry = geometries.get(object, geometry);
      if (updateMap.get(buffergeometry) !== frame) {
        geometries.update(buffergeometry);
        updateMap.set(buffergeometry, frame);
      }
      if (object.isInstancedMesh) {
        if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
          object.addEventListener("dispose", onInstancedMeshDispose);
        }
        attributes.update(object.instanceMatrix, 34962);
        if (object.instanceColor !== null) {
          attributes.update(object.instanceColor, 34962);
        }
      }
      return buffergeometry;
    }
    function dispose() {
      updateMap = new WeakMap();
    }
    function onInstancedMeshDispose(event) {
      const instancedMesh = event.target;
      instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
      attributes.remove(instancedMesh.instanceMatrix);
      if (instancedMesh.instanceColor !== null)
        attributes.remove(instancedMesh.instanceColor);
    }
    return {
      update,
      dispose
    };
  }
  var DataTexture2DArray = class extends Texture {
    constructor(data = null, width = 1, height = 1, depth = 1) {
      super(null);
      this.image = { data, width, height, depth };
      this.magFilter = NearestFilter;
      this.minFilter = NearestFilter;
      this.wrapR = ClampToEdgeWrapping;
      this.generateMipmaps = false;
      this.flipY = false;
      this.needsUpdate = true;
    }
  };
  DataTexture2DArray.prototype.isDataTexture2DArray = true;
  var DataTexture3D = class extends Texture {
    constructor(data = null, width = 1, height = 1, depth = 1) {
      super(null);
      this.image = { data, width, height, depth };
      this.magFilter = NearestFilter;
      this.minFilter = NearestFilter;
      this.wrapR = ClampToEdgeWrapping;
      this.generateMipmaps = false;
      this.flipY = false;
      this.needsUpdate = true;
    }
  };
  DataTexture3D.prototype.isDataTexture3D = true;
  var emptyTexture = new Texture();
  var emptyTexture2dArray = new DataTexture2DArray();
  var emptyTexture3d = new DataTexture3D();
  var emptyCubeTexture = new CubeTexture();
  var arrayCacheF32 = [];
  var arrayCacheI32 = [];
  var mat4array = new Float32Array(16);
  var mat3array = new Float32Array(9);
  var mat2array = new Float32Array(4);
  function flatten(array, nBlocks, blockSize) {
    const firstElem = array[0];
    if (firstElem <= 0 || firstElem > 0)
      return array;
    const n = nBlocks * blockSize;
    let r = arrayCacheF32[n];
    if (r === void 0) {
      r = new Float32Array(n);
      arrayCacheF32[n] = r;
    }
    if (nBlocks !== 0) {
      firstElem.toArray(r, 0);
      for (let i = 1, offset = 0; i !== nBlocks; ++i) {
        offset += blockSize;
        array[i].toArray(r, offset);
      }
    }
    return r;
  }
  function arraysEqual(a, b2) {
    if (a.length !== b2.length)
      return false;
    for (let i = 0, l = a.length; i < l; i++) {
      if (a[i] !== b2[i])
        return false;
    }
    return true;
  }
  function copyArray(a, b2) {
    for (let i = 0, l = b2.length; i < l; i++) {
      a[i] = b2[i];
    }
  }
  function allocTexUnits(textures, n) {
    let r = arrayCacheI32[n];
    if (r === void 0) {
      r = new Int32Array(n);
      arrayCacheI32[n] = r;
    }
    for (let i = 0; i !== n; ++i) {
      r[i] = textures.allocateTextureUnit();
    }
    return r;
  }
  function setValueV1f(gl, v) {
    const cache = this.cache;
    if (cache[0] === v)
      return;
    gl.uniform1f(this.addr, v);
    cache[0] = v;
  }
  function setValueV2f(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y) {
        gl.uniform2f(this.addr, v.x, v.y);
        cache[0] = v.x;
        cache[1] = v.y;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform2fv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueV3f(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
        gl.uniform3f(this.addr, v.x, v.y, v.z);
        cache[0] = v.x;
        cache[1] = v.y;
        cache[2] = v.z;
      }
    } else if (v.r !== void 0) {
      if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
        gl.uniform3f(this.addr, v.r, v.g, v.b);
        cache[0] = v.r;
        cache[1] = v.g;
        cache[2] = v.b;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform3fv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueV4f(gl, v) {
    const cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
        gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
        cache[0] = v.x;
        cache[1] = v.y;
        cache[2] = v.z;
        cache[3] = v.w;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform4fv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValueM2(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v))
        return;
      gl.uniformMatrix2fv(this.addr, false, v);
      copyArray(cache, v);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat2array.set(elements);
      gl.uniformMatrix2fv(this.addr, false, mat2array);
      copyArray(cache, elements);
    }
  }
  function setValueM3(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v))
        return;
      gl.uniformMatrix3fv(this.addr, false, v);
      copyArray(cache, v);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat3array.set(elements);
      gl.uniformMatrix3fv(this.addr, false, mat3array);
      copyArray(cache, elements);
    }
  }
  function setValueM4(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v))
        return;
      gl.uniformMatrix4fv(this.addr, false, v);
      copyArray(cache, v);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat4array.set(elements);
      gl.uniformMatrix4fv(this.addr, false, mat4array);
      copyArray(cache, elements);
    }
  }
  function setValueV1i(gl, v) {
    const cache = this.cache;
    if (cache[0] === v)
      return;
    gl.uniform1i(this.addr, v);
    cache[0] = v;
  }
  function setValueV2i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform2iv(this.addr, v);
    copyArray(cache, v);
  }
  function setValueV3i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform3iv(this.addr, v);
    copyArray(cache, v);
  }
  function setValueV4i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform4iv(this.addr, v);
    copyArray(cache, v);
  }
  function setValueV1ui(gl, v) {
    const cache = this.cache;
    if (cache[0] === v)
      return;
    gl.uniform1ui(this.addr, v);
    cache[0] = v;
  }
  function setValueV2ui(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform2uiv(this.addr, v);
    copyArray(cache, v);
  }
  function setValueV3ui(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform3uiv(this.addr, v);
    copyArray(cache, v);
  }
  function setValueV4ui(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform4uiv(this.addr, v);
    copyArray(cache, v);
  }
  function setValueT1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.safeSetTexture2D(v || emptyTexture, unit);
  }
  function setValueT3D1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTexture3D(v || emptyTexture3d, unit);
  }
  function setValueT6(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.safeSetTextureCube(v || emptyCubeTexture, unit);
  }
  function setValueT2DArray1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTexture2DArray(v || emptyTexture2dArray, unit);
  }
  function getSingularSetter(type) {
    switch (type) {
      case 5126:
        return setValueV1f;
      case 35664:
        return setValueV2f;
      case 35665:
        return setValueV3f;
      case 35666:
        return setValueV4f;
      case 35674:
        return setValueM2;
      case 35675:
        return setValueM3;
      case 35676:
        return setValueM4;
      case 5124:
      case 35670:
        return setValueV1i;
      case 35667:
      case 35671:
        return setValueV2i;
      case 35668:
      case 35672:
        return setValueV3i;
      case 35669:
      case 35673:
        return setValueV4i;
      case 5125:
        return setValueV1ui;
      case 36294:
        return setValueV2ui;
      case 36295:
        return setValueV3ui;
      case 36296:
        return setValueV4ui;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return setValueT1;
      case 35679:
      case 36299:
      case 36307:
        return setValueT3D1;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return setValueT6;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return setValueT2DArray1;
    }
  }
  function setValueV1fArray(gl, v) {
    gl.uniform1fv(this.addr, v);
  }
  function setValueV2fArray(gl, v) {
    const data = flatten(v, this.size, 2);
    gl.uniform2fv(this.addr, data);
  }
  function setValueV3fArray(gl, v) {
    const data = flatten(v, this.size, 3);
    gl.uniform3fv(this.addr, data);
  }
  function setValueV4fArray(gl, v) {
    const data = flatten(v, this.size, 4);
    gl.uniform4fv(this.addr, data);
  }
  function setValueM2Array(gl, v) {
    const data = flatten(v, this.size, 4);
    gl.uniformMatrix2fv(this.addr, false, data);
  }
  function setValueM3Array(gl, v) {
    const data = flatten(v, this.size, 9);
    gl.uniformMatrix3fv(this.addr, false, data);
  }
  function setValueM4Array(gl, v) {
    const data = flatten(v, this.size, 16);
    gl.uniformMatrix4fv(this.addr, false, data);
  }
  function setValueV1iArray(gl, v) {
    gl.uniform1iv(this.addr, v);
  }
  function setValueV2iArray(gl, v) {
    gl.uniform2iv(this.addr, v);
  }
  function setValueV3iArray(gl, v) {
    gl.uniform3iv(this.addr, v);
  }
  function setValueV4iArray(gl, v) {
    gl.uniform4iv(this.addr, v);
  }
  function setValueV1uiArray(gl, v) {
    gl.uniform1uiv(this.addr, v);
  }
  function setValueV2uiArray(gl, v) {
    gl.uniform2uiv(this.addr, v);
  }
  function setValueV3uiArray(gl, v) {
    gl.uniform3uiv(this.addr, v);
  }
  function setValueV4uiArray(gl, v) {
    gl.uniform4uiv(this.addr, v);
  }
  function setValueT1Array(gl, v, textures) {
    const n = v.length;
    const units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for (let i = 0; i !== n; ++i) {
      textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);
    }
  }
  function setValueT6Array(gl, v, textures) {
    const n = v.length;
    const units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for (let i = 0; i !== n; ++i) {
      textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);
    }
  }
  function getPureArraySetter(type) {
    switch (type) {
      case 5126:
        return setValueV1fArray;
      case 35664:
        return setValueV2fArray;
      case 35665:
        return setValueV3fArray;
      case 35666:
        return setValueV4fArray;
      case 35674:
        return setValueM2Array;
      case 35675:
        return setValueM3Array;
      case 35676:
        return setValueM4Array;
      case 5124:
      case 35670:
        return setValueV1iArray;
      case 35667:
      case 35671:
        return setValueV2iArray;
      case 35668:
      case 35672:
        return setValueV3iArray;
      case 35669:
      case 35673:
        return setValueV4iArray;
      case 5125:
        return setValueV1uiArray;
      case 36294:
        return setValueV2uiArray;
      case 36295:
        return setValueV3uiArray;
      case 36296:
        return setValueV4uiArray;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return setValueT1Array;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return setValueT6Array;
    }
  }
  function SingleUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.setValue = getSingularSetter(activeInfo.type);
  }
  function PureArrayUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.size = activeInfo.size;
    this.setValue = getPureArraySetter(activeInfo.type);
  }
  PureArrayUniform.prototype.updateCache = function(data) {
    const cache = this.cache;
    if (data instanceof Float32Array && cache.length !== data.length) {
      this.cache = new Float32Array(data.length);
    }
    copyArray(cache, data);
  };
  function StructuredUniform(id) {
    this.id = id;
    this.seq = [];
    this.map = {};
  }
  StructuredUniform.prototype.setValue = function(gl, value, textures) {
    const seq = this.seq;
    for (let i = 0, n = seq.length; i !== n; ++i) {
      const u = seq[i];
      u.setValue(gl, value[u.id], textures);
    }
  };
  var RePathPart = /(\w+)(\])?(\[|\.)?/g;
  function addUniform(container, uniformObject) {
    container.seq.push(uniformObject);
    container.map[uniformObject.id] = uniformObject;
  }
  function parseUniform(activeInfo, addr, container) {
    const path = activeInfo.name, pathLength = path.length;
    RePathPart.lastIndex = 0;
    while (true) {
      const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
      let id = match[1];
      const idIsIndex = match[2] === "]", subscript = match[3];
      if (idIsIndex)
        id = id | 0;
      if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
        addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
        break;
      } else {
        const map = container.map;
        let next = map[id];
        if (next === void 0) {
          next = new StructuredUniform(id);
          addUniform(container, next);
        }
        container = next;
      }
    }
  }
  function WebGLUniforms(gl, program) {
    this.seq = [];
    this.map = {};
    const n = gl.getProgramParameter(program, 35718);
    for (let i = 0; i < n; ++i) {
      const info2 = gl.getActiveUniform(program, i), addr = gl.getUniformLocation(program, info2.name);
      parseUniform(info2, addr, this);
    }
  }
  WebGLUniforms.prototype.setValue = function(gl, name, value, textures) {
    const u = this.map[name];
    if (u !== void 0)
      u.setValue(gl, value, textures);
  };
  WebGLUniforms.prototype.setOptional = function(gl, object, name) {
    const v = object[name];
    if (v !== void 0)
      this.setValue(gl, name, v);
  };
  WebGLUniforms.upload = function(gl, seq, values, textures) {
    for (let i = 0, n = seq.length; i !== n; ++i) {
      const u = seq[i], v = values[u.id];
      if (v.needsUpdate !== false) {
        u.setValue(gl, v.value, textures);
      }
    }
  };
  WebGLUniforms.seqWithValue = function(seq, values) {
    const r = [];
    for (let i = 0, n = seq.length; i !== n; ++i) {
      const u = seq[i];
      if (u.id in values)
        r.push(u);
    }
    return r;
  };
  function WebGLShader(gl, type, string) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, string);
    gl.compileShader(shader);
    return shader;
  }
  var programIdCount = 0;
  function addLineNumbers(string) {
    const lines = string.split("\n");
    for (let i = 0; i < lines.length; i++) {
      lines[i] = i + 1 + ": " + lines[i];
    }
    return lines.join("\n");
  }
  function getEncodingComponents(encoding) {
    switch (encoding) {
      case LinearEncoding:
        return ["Linear", "( value )"];
      case sRGBEncoding:
        return ["sRGB", "( value )"];
      case RGBEEncoding:
        return ["RGBE", "( value )"];
      case RGBM7Encoding:
        return ["RGBM", "( value, 7.0 )"];
      case RGBM16Encoding:
        return ["RGBM", "( value, 16.0 )"];
      case RGBDEncoding:
        return ["RGBD", "( value, 256.0 )"];
      case GammaEncoding:
        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
      case LogLuvEncoding:
        return ["LogLuv", "( value )"];
      default:
        console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
        return ["Linear", "( value )"];
    }
  }
  function getShaderErrors(gl, shader, type) {
    const status = gl.getShaderParameter(shader, 35713);
    const log = gl.getShaderInfoLog(shader).trim();
    if (status && log === "")
      return "";
    const source = gl.getShaderSource(shader);
    return "THREE.WebGLShader: gl.getShaderInfoLog() " + type + "\n" + log + addLineNumbers(source);
  }
  function getTexelDecodingFunction(functionName, encoding) {
    const components = getEncodingComponents(encoding);
    return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
  }
  function getTexelEncodingFunction(functionName, encoding) {
    const components = getEncodingComponents(encoding);
    return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
  }
  function getToneMappingFunction(functionName, toneMapping) {
    let toneMappingName;
    switch (toneMapping) {
      case LinearToneMapping:
        toneMappingName = "Linear";
        break;
      case ReinhardToneMapping:
        toneMappingName = "Reinhard";
        break;
      case CineonToneMapping:
        toneMappingName = "OptimizedCineon";
        break;
      case ACESFilmicToneMapping:
        toneMappingName = "ACESFilmic";
        break;
      case CustomToneMapping:
        toneMappingName = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
        toneMappingName = "Linear";
    }
    return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
  }
  function generateExtensions(parameters) {
    const chunks = [
      parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
      (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
      parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
      (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
    ];
    return chunks.filter(filterEmptyLine).join("\n");
  }
  function generateDefines(defines) {
    const chunks = [];
    for (const name in defines) {
      const value = defines[name];
      if (value === false)
        continue;
      chunks.push("#define " + name + " " + value);
    }
    return chunks.join("\n");
  }
  function fetchAttributeLocations(gl, program) {
    const attributes = {};
    const n = gl.getProgramParameter(program, 35721);
    for (let i = 0; i < n; i++) {
      const info2 = gl.getActiveAttrib(program, i);
      const name = info2.name;
      attributes[name] = gl.getAttribLocation(program, name);
    }
    return attributes;
  }
  function filterEmptyLine(string) {
    return string !== "";
  }
  function replaceLightNums(string, parameters) {
    return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
  }
  function replaceClippingPlaneNums(string, parameters) {
    return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
  }
  var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function resolveIncludes(string) {
    return string.replace(includePattern, includeReplacer);
  }
  function includeReplacer(match, include) {
    const string = ShaderChunk[include];
    if (string === void 0) {
      throw new Error("Can not resolve #include <" + include + ">");
    }
    return resolveIncludes(string);
  }
  var deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
  var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
  function unrollLoops(string) {
    return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
  }
  function deprecatedLoopReplacer(match, start, end, snippet) {
    console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
    return loopReplacer(match, start, end, snippet);
  }
  function loopReplacer(match, start, end, snippet) {
    let string = "";
    for (let i = parseInt(start); i < parseInt(end); i++) {
      string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i + " ]").replace(/UNROLLED_LOOP_INDEX/g, i);
    }
    return string;
  }
  function generatePrecision(parameters) {
    let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
    if (parameters.precision === "highp") {
      precisionstring += "\n#define HIGH_PRECISION";
    } else if (parameters.precision === "mediump") {
      precisionstring += "\n#define MEDIUM_PRECISION";
    } else if (parameters.precision === "lowp") {
      precisionstring += "\n#define LOW_PRECISION";
    }
    return precisionstring;
  }
  function generateShadowMapTypeDefine(parameters) {
    let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
    if (parameters.shadowMapType === PCFShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
    } else if (parameters.shadowMapType === PCFSoftShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
    } else if (parameters.shadowMapType === VSMShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
    }
    return shadowMapTypeDefine;
  }
  function generateEnvMapTypeDefine(parameters) {
    let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
    if (parameters.envMap) {
      switch (parameters.envMapMode) {
        case CubeReflectionMapping:
        case CubeRefractionMapping:
          envMapTypeDefine = "ENVMAP_TYPE_CUBE";
          break;
        case CubeUVReflectionMapping:
        case CubeUVRefractionMapping:
          envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
          break;
      }
    }
    return envMapTypeDefine;
  }
  function generateEnvMapModeDefine(parameters) {
    let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
    if (parameters.envMap) {
      switch (parameters.envMapMode) {
        case CubeRefractionMapping:
        case CubeUVRefractionMapping:
          envMapModeDefine = "ENVMAP_MODE_REFRACTION";
          break;
      }
    }
    return envMapModeDefine;
  }
  function generateEnvMapBlendingDefine(parameters) {
    let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
    if (parameters.envMap) {
      switch (parameters.combine) {
        case MultiplyOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case MixOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
          break;
        case AddOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
          break;
      }
    }
    return envMapBlendingDefine;
  }
  function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
    const gl = renderer.getContext();
    const defines = parameters.defines;
    let vertexShader = parameters.vertexShader;
    let fragmentShader = parameters.fragmentShader;
    const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
    const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
    const envMapModeDefine = generateEnvMapModeDefine(parameters);
    const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
    const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
    const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
    const customDefines = generateDefines(defines);
    const program = gl.createProgram();
    let prefixVertex, prefixFragment;
    let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
    if (parameters.isRawShaderMaterial) {
      prefixVertex = [
        customDefines
      ].filter(filterEmptyLine).join("\n");
      if (prefixVertex.length > 0) {
        prefixVertex += "\n";
      }
      prefixFragment = [
        customExtensions,
        customDefines
      ].filter(filterEmptyLine).join("\n");
      if (prefixFragment.length > 0) {
        prefixFragment += "\n";
      }
    } else {
      prefixVertex = [
        generatePrecision(parameters),
        "#define SHADER_NAME " + parameters.shaderName,
        customDefines,
        parameters.instancing ? "#define USE_INSTANCING" : "",
        parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
        "#define GAMMA_FACTOR " + gammaFactorDefine,
        "#define MAX_BONES " + parameters.maxBones,
        parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
        parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
        parameters.map ? "#define USE_MAP" : "",
        parameters.envMap ? "#define USE_ENVMAP" : "",
        parameters.envMap ? "#define " + envMapModeDefine : "",
        parameters.lightMap ? "#define USE_LIGHTMAP" : "",
        parameters.aoMap ? "#define USE_AOMAP" : "",
        parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        parameters.bumpMap ? "#define USE_BUMPMAP" : "",
        parameters.normalMap ? "#define USE_NORMALMAP" : "",
        parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
        parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
        parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
        parameters.specularMap ? "#define USE_SPECULARMAP" : "",
        parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
        parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
        parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        parameters.vertexTangents ? "#define USE_TANGENT" : "",
        parameters.vertexColors ? "#define USE_COLOR" : "",
        parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        parameters.vertexUvs ? "#define USE_UV" : "",
        parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        parameters.flatShading ? "#define FLAT_SHADED" : "",
        parameters.skinning ? "#define USE_SKINNING" : "",
        parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
        parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
        parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
        parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
        parameters.flipSided ? "#define FLIP_SIDED" : "",
        parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
        parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#ifdef USE_MORPHTARGETS",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        "\n"
      ].filter(filterEmptyLine).join("\n");
      prefixFragment = [
        customExtensions,
        generatePrecision(parameters),
        "#define SHADER_NAME " + parameters.shaderName,
        customDefines,
        parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest + (parameters.alphaTest % 1 ? "" : ".0") : "",
        "#define GAMMA_FACTOR " + gammaFactorDefine,
        parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
        parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
        parameters.map ? "#define USE_MAP" : "",
        parameters.matcap ? "#define USE_MATCAP" : "",
        parameters.envMap ? "#define USE_ENVMAP" : "",
        parameters.envMap ? "#define " + envMapTypeDefine : "",
        parameters.envMap ? "#define " + envMapModeDefine : "",
        parameters.envMap ? "#define " + envMapBlendingDefine : "",
        parameters.lightMap ? "#define USE_LIGHTMAP" : "",
        parameters.aoMap ? "#define USE_AOMAP" : "",
        parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        parameters.bumpMap ? "#define USE_BUMPMAP" : "",
        parameters.normalMap ? "#define USE_NORMALMAP" : "",
        parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
        parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
        parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        parameters.specularMap ? "#define USE_SPECULARMAP" : "",
        parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
        parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
        parameters.sheen ? "#define USE_SHEEN" : "",
        parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        parameters.vertexTangents ? "#define USE_TANGENT" : "",
        parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
        parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        parameters.vertexUvs ? "#define USE_UV" : "",
        parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
        parameters.flatShading ? "#define FLAT_SHADED" : "",
        parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
        parameters.flipSided ? "#define FLIP_SIDED" : "",
        parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
        parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
        parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
        (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
        parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
        parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
        parameters.dithering ? "#define DITHERING" : "",
        ShaderChunk["encodings_pars_fragment"],
        parameters.map ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "",
        parameters.matcap ? getTexelDecodingFunction("matcapTexelToLinear", parameters.matcapEncoding) : "",
        parameters.envMap ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "",
        parameters.emissiveMap ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "",
        parameters.lightMap ? getTexelDecodingFunction("lightMapTexelToLinear", parameters.lightMapEncoding) : "",
        getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
        parameters.depthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
        "\n"
      ].filter(filterEmptyLine).join("\n");
    }
    vertexShader = resolveIncludes(vertexShader);
    vertexShader = replaceLightNums(vertexShader, parameters);
    vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
    fragmentShader = resolveIncludes(fragmentShader);
    fragmentShader = replaceLightNums(fragmentShader, parameters);
    fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
    vertexShader = unrollLoops(vertexShader);
    fragmentShader = unrollLoops(fragmentShader);
    if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
      versionString = "#version 300 es\n";
      prefixVertex = [
        "#define attribute in",
        "#define varying out",
        "#define texture2D texture"
      ].join("\n") + "\n" + prefixVertex;
      prefixFragment = [
        "#define varying in",
        parameters.glslVersion === GLSL3 ? "" : "out highp vec4 pc_fragColor;",
        parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
        "#define gl_FragDepthEXT gl_FragDepth",
        "#define texture2D texture",
        "#define textureCube texture",
        "#define texture2DProj textureProj",
        "#define texture2DLodEXT textureLod",
        "#define texture2DProjLodEXT textureProjLod",
        "#define textureCubeLodEXT textureLod",
        "#define texture2DGradEXT textureGrad",
        "#define texture2DProjGradEXT textureProjGrad",
        "#define textureCubeGradEXT textureGrad"
      ].join("\n") + "\n" + prefixFragment;
    }
    const vertexGlsl = versionString + prefixVertex + vertexShader;
    const fragmentGlsl = versionString + prefixFragment + fragmentShader;
    const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
    const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
    gl.attachShader(program, glVertexShader);
    gl.attachShader(program, glFragmentShader);
    if (parameters.index0AttributeName !== void 0) {
      gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
    } else if (parameters.morphTargets === true) {
      gl.bindAttribLocation(program, 0, "position");
    }
    gl.linkProgram(program);
    if (renderer.debug.checkShaderErrors) {
      const programLog = gl.getProgramInfoLog(program).trim();
      const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
      const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
      let runnable = true;
      let haveDiagnostics = true;
      if (gl.getProgramParameter(program, 35714) === false) {
        runnable = false;
        const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
        const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
        console.error("THREE.WebGLProgram: shader error: ", gl.getError(), "35715", gl.getProgramParameter(program, 35715), "gl.getProgramInfoLog", programLog, vertexErrors, fragmentErrors);
      } else if (programLog !== "") {
        console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", programLog);
      } else if (vertexLog === "" || fragmentLog === "") {
        haveDiagnostics = false;
      }
      if (haveDiagnostics) {
        this.diagnostics = {
          runnable,
          programLog,
          vertexShader: {
            log: vertexLog,
            prefix: prefixVertex
          },
          fragmentShader: {
            log: fragmentLog,
            prefix: prefixFragment
          }
        };
      }
    }
    gl.deleteShader(glVertexShader);
    gl.deleteShader(glFragmentShader);
    let cachedUniforms;
    this.getUniforms = function() {
      if (cachedUniforms === void 0) {
        cachedUniforms = new WebGLUniforms(gl, program);
      }
      return cachedUniforms;
    };
    let cachedAttributes;
    this.getAttributes = function() {
      if (cachedAttributes === void 0) {
        cachedAttributes = fetchAttributeLocations(gl, program);
      }
      return cachedAttributes;
    };
    this.destroy = function() {
      bindingStates.releaseStatesOfProgram(this);
      gl.deleteProgram(program);
      this.program = void 0;
    };
    this.name = parameters.shaderName;
    this.id = programIdCount++;
    this.cacheKey = cacheKey;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;
    return this;
  }
  function WebGLPrograms(renderer, cubemaps, extensions, capabilities, bindingStates, clipping) {
    const programs = [];
    const isWebGL2 = capabilities.isWebGL2;
    const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
    const floatVertexTextures = capabilities.floatVertexTextures;
    const maxVertexUniforms = capabilities.maxVertexUniforms;
    const vertexTextures = capabilities.vertexTextures;
    let precision = capabilities.precision;
    const shaderIDs = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite"
    };
    const parameterNames = [
      "precision",
      "isWebGL2",
      "supportsVertexTextures",
      "outputEncoding",
      "instancing",
      "instancingColor",
      "map",
      "mapEncoding",
      "matcap",
      "matcapEncoding",
      "envMap",
      "envMapMode",
      "envMapEncoding",
      "envMapCubeUV",
      "lightMap",
      "lightMapEncoding",
      "aoMap",
      "emissiveMap",
      "emissiveMapEncoding",
      "bumpMap",
      "normalMap",
      "objectSpaceNormalMap",
      "tangentSpaceNormalMap",
      "clearcoatMap",
      "clearcoatRoughnessMap",
      "clearcoatNormalMap",
      "displacementMap",
      "specularMap",
      "roughnessMap",
      "metalnessMap",
      "gradientMap",
      "alphaMap",
      "combine",
      "vertexColors",
      "vertexAlphas",
      "vertexTangents",
      "vertexUvs",
      "uvsVertexOnly",
      "fog",
      "useFog",
      "fogExp2",
      "flatShading",
      "sizeAttenuation",
      "logarithmicDepthBuffer",
      "skinning",
      "maxBones",
      "useVertexTexture",
      "morphTargets",
      "morphNormals",
      "premultipliedAlpha",
      "numDirLights",
      "numPointLights",
      "numSpotLights",
      "numHemiLights",
      "numRectAreaLights",
      "numDirLightShadows",
      "numPointLightShadows",
      "numSpotLightShadows",
      "shadowMapEnabled",
      "shadowMapType",
      "toneMapping",
      "physicallyCorrectLights",
      "alphaTest",
      "doubleSided",
      "flipSided",
      "numClippingPlanes",
      "numClipIntersection",
      "depthPacking",
      "dithering",
      "sheen",
      "transmissionMap"
    ];
    function getMaxBones(object) {
      const skeleton = object.skeleton;
      const bones = skeleton.bones;
      if (floatVertexTextures) {
        return 1024;
      } else {
        const nVertexUniforms = maxVertexUniforms;
        const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
        const maxBones = Math.min(nVertexMatrices, bones.length);
        if (maxBones < bones.length) {
          console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
          return 0;
        }
        return maxBones;
      }
    }
    function getTextureEncodingFromMap(map) {
      let encoding;
      if (map && map.isTexture) {
        encoding = map.encoding;
      } else if (map && map.isWebGLRenderTarget) {
        console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
        encoding = map.texture.encoding;
      } else {
        encoding = LinearEncoding;
      }
      return encoding;
    }
    function getParameters(material, lights, shadows, scene, object) {
      const fog = scene.fog;
      const environment = material.isMeshStandardMaterial ? scene.environment : null;
      const envMap = cubemaps.get(material.envMap || environment);
      const shaderID = shaderIDs[material.type];
      const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
      if (material.precision !== null) {
        precision = capabilities.getMaxPrecision(material.precision);
        if (precision !== material.precision) {
          console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
        }
      }
      let vertexShader, fragmentShader;
      if (shaderID) {
        const shader = ShaderLib[shaderID];
        vertexShader = shader.vertexShader;
        fragmentShader = shader.fragmentShader;
      } else {
        vertexShader = material.vertexShader;
        fragmentShader = material.fragmentShader;
      }
      const currentRenderTarget = renderer.getRenderTarget();
      const parameters = {
        isWebGL2,
        shaderID,
        shaderName: material.type,
        vertexShader,
        fragmentShader,
        defines: material.defines,
        isRawShaderMaterial: material.isRawShaderMaterial === true,
        glslVersion: material.glslVersion,
        precision,
        instancing: object.isInstancedMesh === true,
        instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
        supportsVertexTextures: vertexTextures,
        outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
        map: !!material.map,
        mapEncoding: getTextureEncodingFromMap(material.map),
        matcap: !!material.matcap,
        matcapEncoding: getTextureEncodingFromMap(material.matcap),
        envMap: !!envMap,
        envMapMode: envMap && envMap.mapping,
        envMapEncoding: getTextureEncodingFromMap(envMap),
        envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
        lightMap: !!material.lightMap,
        lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
        aoMap: !!material.aoMap,
        emissiveMap: !!material.emissiveMap,
        emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
        bumpMap: !!material.bumpMap,
        normalMap: !!material.normalMap,
        objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
        tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
        clearcoatMap: !!material.clearcoatMap,
        clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
        clearcoatNormalMap: !!material.clearcoatNormalMap,
        displacementMap: !!material.displacementMap,
        roughnessMap: !!material.roughnessMap,
        metalnessMap: !!material.metalnessMap,
        specularMap: !!material.specularMap,
        alphaMap: !!material.alphaMap,
        gradientMap: !!material.gradientMap,
        sheen: !!material.sheen,
        transmissionMap: !!material.transmissionMap,
        combine: material.combine,
        vertexTangents: material.normalMap && material.vertexTangents,
        vertexColors: material.vertexColors,
        vertexAlphas: material.vertexColors === true && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,
        vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap,
        uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmissionMap) && !!material.displacementMap,
        fog: !!fog,
        useFog: material.fog,
        fogExp2: fog && fog.isFogExp2,
        flatShading: !!material.flatShading,
        sizeAttenuation: material.sizeAttenuation,
        logarithmicDepthBuffer,
        skinning: material.skinning && maxBones > 0,
        maxBones,
        useVertexTexture: floatVertexTextures,
        morphTargets: material.morphTargets,
        morphNormals: material.morphNormals,
        numDirLights: lights.directional.length,
        numPointLights: lights.point.length,
        numSpotLights: lights.spot.length,
        numRectAreaLights: lights.rectArea.length,
        numHemiLights: lights.hemi.length,
        numDirLightShadows: lights.directionalShadowMap.length,
        numPointLightShadows: lights.pointShadowMap.length,
        numSpotLightShadows: lights.spotShadowMap.length,
        numClippingPlanes: clipping.numPlanes,
        numClipIntersection: clipping.numIntersection,
        dithering: material.dithering,
        shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
        shadowMapType: renderer.shadowMap.type,
        toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
        physicallyCorrectLights: renderer.physicallyCorrectLights,
        premultipliedAlpha: material.premultipliedAlpha,
        alphaTest: material.alphaTest,
        doubleSided: material.side === DoubleSide,
        flipSided: material.side === BackSide,
        depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false,
        index0AttributeName: material.index0AttributeName,
        extensionDerivatives: material.extensions && material.extensions.derivatives,
        extensionFragDepth: material.extensions && material.extensions.fragDepth,
        extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
        extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
        rendererExtensionFragDepth: isWebGL2 || extensions.has("EXT_frag_depth"),
        rendererExtensionDrawBuffers: isWebGL2 || extensions.has("WEBGL_draw_buffers"),
        rendererExtensionShaderTextureLod: isWebGL2 || extensions.has("EXT_shader_texture_lod"),
        customProgramCacheKey: material.customProgramCacheKey()
      };
      return parameters;
    }
    function getProgramCacheKey(parameters) {
      const array = [];
      if (parameters.shaderID) {
        array.push(parameters.shaderID);
      } else {
        array.push(parameters.fragmentShader);
        array.push(parameters.vertexShader);
      }
      if (parameters.defines !== void 0) {
        for (const name in parameters.defines) {
          array.push(name);
          array.push(parameters.defines[name]);
        }
      }
      if (parameters.isRawShaderMaterial === false) {
        for (let i = 0; i < parameterNames.length; i++) {
          array.push(parameters[parameterNames[i]]);
        }
        array.push(renderer.outputEncoding);
        array.push(renderer.gammaFactor);
      }
      array.push(parameters.customProgramCacheKey);
      return array.join();
    }
    function getUniforms(material) {
      const shaderID = shaderIDs[material.type];
      let uniforms;
      if (shaderID) {
        const shader = ShaderLib[shaderID];
        uniforms = UniformsUtils.clone(shader.uniforms);
      } else {
        uniforms = material.uniforms;
      }
      return uniforms;
    }
    function acquireProgram(parameters, cacheKey) {
      let program;
      for (let p = 0, pl = programs.length; p < pl; p++) {
        const preexistingProgram = programs[p];
        if (preexistingProgram.cacheKey === cacheKey) {
          program = preexistingProgram;
          ++program.usedTimes;
          break;
        }
      }
      if (program === void 0) {
        program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
        programs.push(program);
      }
      return program;
    }
    function releaseProgram(program) {
      if (--program.usedTimes === 0) {
        const i = programs.indexOf(program);
        programs[i] = programs[programs.length - 1];
        programs.pop();
        program.destroy();
      }
    }
    return {
      getParameters,
      getProgramCacheKey,
      getUniforms,
      acquireProgram,
      releaseProgram,
      programs
    };
  }
  function WebGLProperties() {
    let properties = new WeakMap();
    function get(object) {
      let map = properties.get(object);
      if (map === void 0) {
        map = {};
        properties.set(object, map);
      }
      return map;
    }
    function remove(object) {
      properties.delete(object);
    }
    function update(object, key, value) {
      properties.get(object)[key] = value;
    }
    function dispose() {
      properties = new WeakMap();
    }
    return {
      get,
      remove,
      update,
      dispose
    };
  }
  function painterSortStable(a, b2) {
    if (a.groupOrder !== b2.groupOrder) {
      return a.groupOrder - b2.groupOrder;
    } else if (a.renderOrder !== b2.renderOrder) {
      return a.renderOrder - b2.renderOrder;
    } else if (a.program !== b2.program) {
      return a.program.id - b2.program.id;
    } else if (a.material.id !== b2.material.id) {
      return a.material.id - b2.material.id;
    } else if (a.z !== b2.z) {
      return a.z - b2.z;
    } else {
      return a.id - b2.id;
    }
  }
  function reversePainterSortStable(a, b2) {
    if (a.groupOrder !== b2.groupOrder) {
      return a.groupOrder - b2.groupOrder;
    } else if (a.renderOrder !== b2.renderOrder) {
      return a.renderOrder - b2.renderOrder;
    } else if (a.z !== b2.z) {
      return b2.z - a.z;
    } else {
      return a.id - b2.id;
    }
  }
  function WebGLRenderList(properties) {
    const renderItems = [];
    let renderItemsIndex = 0;
    const opaque = [];
    const transparent = [];
    const defaultProgram = { id: -1 };
    function init() {
      renderItemsIndex = 0;
      opaque.length = 0;
      transparent.length = 0;
    }
    function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
      let renderItem = renderItems[renderItemsIndex];
      const materialProperties = properties.get(material);
      if (renderItem === void 0) {
        renderItem = {
          id: object.id,
          object,
          geometry,
          material,
          program: materialProperties.program || defaultProgram,
          groupOrder,
          renderOrder: object.renderOrder,
          z,
          group
        };
        renderItems[renderItemsIndex] = renderItem;
      } else {
        renderItem.id = object.id;
        renderItem.object = object;
        renderItem.geometry = geometry;
        renderItem.material = material;
        renderItem.program = materialProperties.program || defaultProgram;
        renderItem.groupOrder = groupOrder;
        renderItem.renderOrder = object.renderOrder;
        renderItem.z = z;
        renderItem.group = group;
      }
      renderItemsIndex++;
      return renderItem;
    }
    function push(object, geometry, material, groupOrder, z, group) {
      const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
      (material.transparent === true ? transparent : opaque).push(renderItem);
    }
    function unshift(object, geometry, material, groupOrder, z, group) {
      const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
      (material.transparent === true ? transparent : opaque).unshift(renderItem);
    }
    function sort(customOpaqueSort, customTransparentSort) {
      if (opaque.length > 1)
        opaque.sort(customOpaqueSort || painterSortStable);
      if (transparent.length > 1)
        transparent.sort(customTransparentSort || reversePainterSortStable);
    }
    function finish() {
      for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
        const renderItem = renderItems[i];
        if (renderItem.id === null)
          break;
        renderItem.id = null;
        renderItem.object = null;
        renderItem.geometry = null;
        renderItem.material = null;
        renderItem.program = null;
        renderItem.group = null;
      }
    }
    return {
      opaque,
      transparent,
      init,
      push,
      unshift,
      finish,
      sort
    };
  }
  function WebGLRenderLists(properties) {
    let lists = new WeakMap();
    function get(scene, renderCallDepth) {
      let list;
      if (lists.has(scene) === false) {
        list = new WebGLRenderList(properties);
        lists.set(scene, [list]);
      } else {
        if (renderCallDepth >= lists.get(scene).length) {
          list = new WebGLRenderList(properties);
          lists.get(scene).push(list);
        } else {
          list = lists.get(scene)[renderCallDepth];
        }
      }
      return list;
    }
    function dispose() {
      lists = new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  function UniformsCache() {
    const lights = {};
    return {
      get: function(light) {
        if (lights[light.id] !== void 0) {
          return lights[light.id];
        }
        let uniforms;
        switch (light.type) {
          case "DirectionalLight":
            uniforms = {
              direction: new Vector3(),
              color: new Color()
            };
            break;
          case "SpotLight":
            uniforms = {
              position: new Vector3(),
              direction: new Vector3(),
              color: new Color(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0
            };
            break;
          case "PointLight":
            uniforms = {
              position: new Vector3(),
              color: new Color(),
              distance: 0,
              decay: 0
            };
            break;
          case "HemisphereLight":
            uniforms = {
              direction: new Vector3(),
              skyColor: new Color(),
              groundColor: new Color()
            };
            break;
          case "RectAreaLight":
            uniforms = {
              color: new Color(),
              position: new Vector3(),
              halfWidth: new Vector3(),
              halfHeight: new Vector3()
            };
            break;
        }
        lights[light.id] = uniforms;
        return uniforms;
      }
    };
  }
  function ShadowUniformsCache() {
    const lights = {};
    return {
      get: function(light) {
        if (lights[light.id] !== void 0) {
          return lights[light.id];
        }
        let uniforms;
        switch (light.type) {
          case "DirectionalLight":
            uniforms = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2()
            };
            break;
          case "SpotLight":
            uniforms = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2()
            };
            break;
          case "PointLight":
            uniforms = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2(),
              shadowCameraNear: 1,
              shadowCameraFar: 1e3
            };
            break;
        }
        lights[light.id] = uniforms;
        return uniforms;
      }
    };
  }
  var nextVersion = 0;
  function shadowCastingLightsFirst(lightA, lightB) {
    return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
  }
  function WebGLLights(extensions, capabilities) {
    const cache = new UniformsCache();
    const shadowCache = ShadowUniformsCache();
    const state = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotShadow: [],
      spotShadowMap: [],
      spotShadowMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: []
    };
    for (let i = 0; i < 9; i++)
      state.probe.push(new Vector3());
    const vector3 = new Vector3();
    const matrix4 = new Matrix4();
    const matrix42 = new Matrix4();
    function setup(lights) {
      let r = 0, g = 0, b2 = 0;
      for (let i = 0; i < 9; i++)
        state.probe[i].set(0, 0, 0);
      let directionalLength = 0;
      let pointLength = 0;
      let spotLength = 0;
      let rectAreaLength = 0;
      let hemiLength = 0;
      let numDirectionalShadows = 0;
      let numPointShadows = 0;
      let numSpotShadows = 0;
      lights.sort(shadowCastingLightsFirst);
      for (let i = 0, l = lights.length; i < l; i++) {
        const light = lights[i];
        const color = light.color;
        const intensity = light.intensity;
        const distance = light.distance;
        const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
        if (light.isAmbientLight) {
          r += color.r * intensity;
          g += color.g * intensity;
          b2 += color.b * intensity;
        } else if (light.isLightProbe) {
          for (let j = 0; j < 9; j++) {
            state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
          }
        } else if (light.isDirectionalLight) {
          const uniforms = cache.get(light);
          uniforms.color.copy(light.color).multiplyScalar(light.intensity);
          if (light.castShadow) {
            const shadow = light.shadow;
            const shadowUniforms = shadowCache.get(light);
            shadowUniforms.shadowBias = shadow.bias;
            shadowUniforms.shadowNormalBias = shadow.normalBias;
            shadowUniforms.shadowRadius = shadow.radius;
            shadowUniforms.shadowMapSize = shadow.mapSize;
            state.directionalShadow[directionalLength] = shadowUniforms;
            state.directionalShadowMap[directionalLength] = shadowMap;
            state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
            numDirectionalShadows++;
          }
          state.directional[directionalLength] = uniforms;
          directionalLength++;
        } else if (light.isSpotLight) {
          const uniforms = cache.get(light);
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.color.copy(color).multiplyScalar(intensity);
          uniforms.distance = distance;
          uniforms.coneCos = Math.cos(light.angle);
          uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
          uniforms.decay = light.decay;
          if (light.castShadow) {
            const shadow = light.shadow;
            const shadowUniforms = shadowCache.get(light);
            shadowUniforms.shadowBias = shadow.bias;
            shadowUniforms.shadowNormalBias = shadow.normalBias;
            shadowUniforms.shadowRadius = shadow.radius;
            shadowUniforms.shadowMapSize = shadow.mapSize;
            state.spotShadow[spotLength] = shadowUniforms;
            state.spotShadowMap[spotLength] = shadowMap;
            state.spotShadowMatrix[spotLength] = light.shadow.matrix;
            numSpotShadows++;
          }
          state.spot[spotLength] = uniforms;
          spotLength++;
        } else if (light.isRectAreaLight) {
          const uniforms = cache.get(light);
          uniforms.color.copy(color).multiplyScalar(intensity);
          uniforms.halfWidth.set(light.width * 0.5, 0, 0);
          uniforms.halfHeight.set(0, light.height * 0.5, 0);
          state.rectArea[rectAreaLength] = uniforms;
          rectAreaLength++;
        } else if (light.isPointLight) {
          const uniforms = cache.get(light);
          uniforms.color.copy(light.color).multiplyScalar(light.intensity);
          uniforms.distance = light.distance;
          uniforms.decay = light.decay;
          if (light.castShadow) {
            const shadow = light.shadow;
            const shadowUniforms = shadowCache.get(light);
            shadowUniforms.shadowBias = shadow.bias;
            shadowUniforms.shadowNormalBias = shadow.normalBias;
            shadowUniforms.shadowRadius = shadow.radius;
            shadowUniforms.shadowMapSize = shadow.mapSize;
            shadowUniforms.shadowCameraNear = shadow.camera.near;
            shadowUniforms.shadowCameraFar = shadow.camera.far;
            state.pointShadow[pointLength] = shadowUniforms;
            state.pointShadowMap[pointLength] = shadowMap;
            state.pointShadowMatrix[pointLength] = light.shadow.matrix;
            numPointShadows++;
          }
          state.point[pointLength] = uniforms;
          pointLength++;
        } else if (light.isHemisphereLight) {
          const uniforms = cache.get(light);
          uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
          uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
          state.hemi[hemiLength] = uniforms;
          hemiLength++;
        }
      }
      if (rectAreaLength > 0) {
        if (capabilities.isWebGL2) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else {
          if (extensions.has("OES_texture_float_linear") === true) {
            state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
            state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
          } else if (extensions.has("OES_texture_half_float_linear") === true) {
            state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
            state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
          } else {
            console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
          }
        }
      }
      state.ambient[0] = r;
      state.ambient[1] = g;
      state.ambient[2] = b2;
      const hash = state.hash;
      if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
        state.directional.length = directionalLength;
        state.spot.length = spotLength;
        state.rectArea.length = rectAreaLength;
        state.point.length = pointLength;
        state.hemi.length = hemiLength;
        state.directionalShadow.length = numDirectionalShadows;
        state.directionalShadowMap.length = numDirectionalShadows;
        state.pointShadow.length = numPointShadows;
        state.pointShadowMap.length = numPointShadows;
        state.spotShadow.length = numSpotShadows;
        state.spotShadowMap.length = numSpotShadows;
        state.directionalShadowMatrix.length = numDirectionalShadows;
        state.pointShadowMatrix.length = numPointShadows;
        state.spotShadowMatrix.length = numSpotShadows;
        hash.directionalLength = directionalLength;
        hash.pointLength = pointLength;
        hash.spotLength = spotLength;
        hash.rectAreaLength = rectAreaLength;
        hash.hemiLength = hemiLength;
        hash.numDirectionalShadows = numDirectionalShadows;
        hash.numPointShadows = numPointShadows;
        hash.numSpotShadows = numSpotShadows;
        state.version = nextVersion++;
      }
    }
    function setupView(lights, camera) {
      let directionalLength = 0;
      let pointLength = 0;
      let spotLength = 0;
      let rectAreaLength = 0;
      let hemiLength = 0;
      const viewMatrix = camera.matrixWorldInverse;
      for (let i = 0, l = lights.length; i < l; i++) {
        const light = lights[i];
        if (light.isDirectionalLight) {
          const uniforms = state.directional[directionalLength];
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          vector3.setFromMatrixPosition(light.target.matrixWorld);
          uniforms.direction.sub(vector3);
          uniforms.direction.transformDirection(viewMatrix);
          directionalLength++;
        } else if (light.isSpotLight) {
          const uniforms = state.spot[spotLength];
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          vector3.setFromMatrixPosition(light.target.matrixWorld);
          uniforms.direction.sub(vector3);
          uniforms.direction.transformDirection(viewMatrix);
          spotLength++;
        } else if (light.isRectAreaLight) {
          const uniforms = state.rectArea[rectAreaLength];
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          matrix42.identity();
          matrix4.copy(light.matrixWorld);
          matrix4.premultiply(viewMatrix);
          matrix42.extractRotation(matrix4);
          uniforms.halfWidth.set(light.width * 0.5, 0, 0);
          uniforms.halfHeight.set(0, light.height * 0.5, 0);
          uniforms.halfWidth.applyMatrix4(matrix42);
          uniforms.halfHeight.applyMatrix4(matrix42);
          rectAreaLength++;
        } else if (light.isPointLight) {
          const uniforms = state.point[pointLength];
          uniforms.position.setFromMatrixPosition(light.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          pointLength++;
        } else if (light.isHemisphereLight) {
          const uniforms = state.hemi[hemiLength];
          uniforms.direction.setFromMatrixPosition(light.matrixWorld);
          uniforms.direction.transformDirection(viewMatrix);
          uniforms.direction.normalize();
          hemiLength++;
        }
      }
    }
    return {
      setup,
      setupView,
      state
    };
  }
  function WebGLRenderState(extensions, capabilities) {
    const lights = new WebGLLights(extensions, capabilities);
    const lightsArray = [];
    const shadowsArray = [];
    function init() {
      lightsArray.length = 0;
      shadowsArray.length = 0;
    }
    function pushLight(light) {
      lightsArray.push(light);
    }
    function pushShadow(shadowLight) {
      shadowsArray.push(shadowLight);
    }
    function setupLights() {
      lights.setup(lightsArray);
    }
    function setupLightsView(camera) {
      lights.setupView(lightsArray, camera);
    }
    const state = {
      lightsArray,
      shadowsArray,
      lights
    };
    return {
      init,
      state,
      setupLights,
      setupLightsView,
      pushLight,
      pushShadow
    };
  }
  function WebGLRenderStates(extensions, capabilities) {
    let renderStates = new WeakMap();
    function get(scene, renderCallDepth = 0) {
      let renderState;
      if (renderStates.has(scene) === false) {
        renderState = new WebGLRenderState(extensions, capabilities);
        renderStates.set(scene, [renderState]);
      } else {
        if (renderCallDepth >= renderStates.get(scene).length) {
          renderState = new WebGLRenderState(extensions, capabilities);
          renderStates.get(scene).push(renderState);
        } else {
          renderState = renderStates.get(scene)[renderCallDepth];
        }
      }
      return renderState;
    }
    function dispose() {
      renderStates = new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  var MeshDepthMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "MeshDepthMaterial";
      this.depthPacking = BasicDepthPacking;
      this.skinning = false;
      this.morphTargets = false;
      this.map = null;
      this.alphaMap = null;
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.fog = false;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.depthPacking = source.depthPacking;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      return this;
    }
  };
  MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
  var MeshDistanceMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "MeshDistanceMaterial";
      this.referencePosition = new Vector3();
      this.nearDistance = 1;
      this.farDistance = 1e3;
      this.skinning = false;
      this.morphTargets = false;
      this.map = null;
      this.alphaMap = null;
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.fog = false;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.referencePosition.copy(source.referencePosition);
      this.nearDistance = source.nearDistance;
      this.farDistance = source.farDistance;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      return this;
    }
  };
  MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
  var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean * HALF_SAMPLE_RATE;\n	squared_mean = squared_mean * HALF_SAMPLE_RATE;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
  var vsm_vert = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
  function WebGLShadowMap(_renderer, _objects, _capabilities) {
    let _frustum = new Frustum();
    const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterials = [], _distanceMaterials = [], _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
    const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };
    const shadowMaterialVertical = new ShaderMaterial({
      defines: {
        SAMPLE_RATE: 2 / 8,
        HALF_SAMPLE_RATE: 1 / 8
      },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new Vector2() },
        radius: { value: 4 }
      },
      vertexShader: vsm_vert,
      fragmentShader: vsm_frag
    });
    const shadowMaterialHorizontal = shadowMaterialVertical.clone();
    shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
    const fullScreenTri = new BufferGeometry();
    fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
    const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
    const scope = this;
    this.enabled = false;
    this.autoUpdate = true;
    this.needsUpdate = false;
    this.type = PCFShadowMap;
    this.render = function(lights, scene, camera) {
      if (scope.enabled === false)
        return;
      if (scope.autoUpdate === false && scope.needsUpdate === false)
        return;
      if (lights.length === 0)
        return;
      const currentRenderTarget = _renderer.getRenderTarget();
      const activeCubeFace = _renderer.getActiveCubeFace();
      const activeMipmapLevel = _renderer.getActiveMipmapLevel();
      const _state = _renderer.state;
      _state.setBlending(NoBlending);
      _state.buffers.color.setClear(1, 1, 1, 1);
      _state.buffers.depth.setTest(true);
      _state.setScissorTest(false);
      for (let i = 0, il = lights.length; i < il; i++) {
        const light = lights[i];
        const shadow = light.shadow;
        if (shadow === void 0) {
          console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
          continue;
        }
        if (shadow.autoUpdate === false && shadow.needsUpdate === false)
          continue;
        _shadowMapSize.copy(shadow.mapSize);
        const shadowFrameExtents = shadow.getFrameExtents();
        _shadowMapSize.multiply(shadowFrameExtents);
        _viewportSize.copy(shadow.mapSize);
        if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
          if (_shadowMapSize.x > _maxTextureSize) {
            _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
            _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
            shadow.mapSize.x = _viewportSize.x;
          }
          if (_shadowMapSize.y > _maxTextureSize) {
            _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
            _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
            shadow.mapSize.y = _viewportSize.y;
          }
        }
        if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
          const pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };
          shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
          shadow.map.texture.name = light.name + ".shadowMap";
          shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
          shadow.camera.updateProjectionMatrix();
        }
        if (shadow.map === null) {
          const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
          shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
          shadow.map.texture.name = light.name + ".shadowMap";
          shadow.camera.updateProjectionMatrix();
        }
        _renderer.setRenderTarget(shadow.map);
        _renderer.clear();
        const viewportCount = shadow.getViewportCount();
        for (let vp = 0; vp < viewportCount; vp++) {
          const viewport = shadow.getViewport(vp);
          _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
          _state.viewport(_viewport);
          shadow.updateMatrices(light, vp);
          _frustum = shadow.getFrustum();
          renderObject(scene, camera, shadow.camera, light, this.type);
        }
        if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
          VSMPass(shadow, camera);
        }
        shadow.needsUpdate = false;
      }
      scope.needsUpdate = false;
      _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
    };
    function VSMPass(shadow, camera) {
      const geometry = _objects.update(fullScreenMesh);
      shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
      shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
      shadowMaterialVertical.uniforms.radius.value = shadow.radius;
      _renderer.setRenderTarget(shadow.mapPass);
      _renderer.clear();
      _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
      shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
      shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
      shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
      _renderer.setRenderTarget(shadow.map);
      _renderer.clear();
      _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
    }
    function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {
      const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
      let material = _depthMaterials[index];
      if (material === void 0) {
        material = new MeshDepthMaterial({
          depthPacking: RGBADepthPacking,
          morphTargets: useMorphing,
          skinning: useSkinning
        });
        _depthMaterials[index] = material;
      }
      return material;
    }
    function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {
      const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
      let material = _distanceMaterials[index];
      if (material === void 0) {
        material = new MeshDistanceMaterial({
          morphTargets: useMorphing,
          skinning: useSkinning
        });
        _distanceMaterials[index] = material;
      }
      return material;
    }
    function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
      let result = null;
      let getMaterialVariant = getDepthMaterialVariant;
      let customMaterial = object.customDepthMaterial;
      if (light.isPointLight === true) {
        getMaterialVariant = getDistanceMaterialVariant;
        customMaterial = object.customDistanceMaterial;
      }
      if (customMaterial === void 0) {
        let useMorphing = false;
        if (material.morphTargets === true) {
          useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
        }
        let useSkinning = false;
        if (object.isSkinnedMesh === true) {
          if (material.skinning === true) {
            useSkinning = true;
          } else {
            console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", object);
          }
        }
        const useInstancing = object.isInstancedMesh === true;
        result = getMaterialVariant(useMorphing, useSkinning, useInstancing);
      } else {
        result = customMaterial;
      }
      if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
        const keyA = result.uuid, keyB = material.uuid;
        let materialsForVariant = _materialCache[keyA];
        if (materialsForVariant === void 0) {
          materialsForVariant = {};
          _materialCache[keyA] = materialsForVariant;
        }
        let cachedMaterial = materialsForVariant[keyB];
        if (cachedMaterial === void 0) {
          cachedMaterial = result.clone();
          materialsForVariant[keyB] = cachedMaterial;
        }
        result = cachedMaterial;
      }
      result.visible = material.visible;
      result.wireframe = material.wireframe;
      if (type === VSMShadowMap) {
        result.side = material.shadowSide !== null ? material.shadowSide : material.side;
      } else {
        result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
      }
      result.clipShadows = material.clipShadows;
      result.clippingPlanes = material.clippingPlanes;
      result.clipIntersection = material.clipIntersection;
      result.wireframeLinewidth = material.wireframeLinewidth;
      result.linewidth = material.linewidth;
      if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
        result.referencePosition.setFromMatrixPosition(light.matrixWorld);
        result.nearDistance = shadowCameraNear;
        result.farDistance = shadowCameraFar;
      }
      return result;
    }
    function renderObject(object, camera, shadowCamera, light, type) {
      if (object.visible === false)
        return;
      const visible = object.layers.test(camera.layers);
      if (visible && (object.isMesh || object.isLine || object.isPoints)) {
        if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
          object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
          const geometry = _objects.update(object);
          const material = object.material;
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let k = 0, kl = groups.length; k < kl; k++) {
              const group = groups[k];
              const groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
                _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
              }
            }
          } else if (material.visible) {
            const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);
            _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
          }
        }
      }
      const children = object.children;
      for (let i = 0, l = children.length; i < l; i++) {
        renderObject(children[i], camera, shadowCamera, light, type);
      }
    }
  }
  function WebGLState(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function ColorBuffer() {
      let locked = false;
      const color = new Vector4();
      let currentColorMask = null;
      const currentColorClear = new Vector4(0, 0, 0, 0);
      return {
        setMask: function(colorMask) {
          if (currentColorMask !== colorMask && !locked) {
            gl.colorMask(colorMask, colorMask, colorMask, colorMask);
            currentColorMask = colorMask;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(r, g, b2, a, premultipliedAlpha) {
          if (premultipliedAlpha === true) {
            r *= a;
            g *= a;
            b2 *= a;
          }
          color.set(r, g, b2, a);
          if (currentColorClear.equals(color) === false) {
            gl.clearColor(r, g, b2, a);
            currentColorClear.copy(color);
          }
        },
        reset: function() {
          locked = false;
          currentColorMask = null;
          currentColorClear.set(-1, 0, 0, 0);
        }
      };
    }
    function DepthBuffer() {
      let locked = false;
      let currentDepthMask = null;
      let currentDepthFunc = null;
      let currentDepthClear = null;
      return {
        setTest: function(depthTest) {
          if (depthTest) {
            enable(2929);
          } else {
            disable(2929);
          }
        },
        setMask: function(depthMask) {
          if (currentDepthMask !== depthMask && !locked) {
            gl.depthMask(depthMask);
            currentDepthMask = depthMask;
          }
        },
        setFunc: function(depthFunc) {
          if (currentDepthFunc !== depthFunc) {
            if (depthFunc) {
              switch (depthFunc) {
                case NeverDepth:
                  gl.depthFunc(512);
                  break;
                case AlwaysDepth:
                  gl.depthFunc(519);
                  break;
                case LessDepth:
                  gl.depthFunc(513);
                  break;
                case LessEqualDepth:
                  gl.depthFunc(515);
                  break;
                case EqualDepth:
                  gl.depthFunc(514);
                  break;
                case GreaterEqualDepth:
                  gl.depthFunc(518);
                  break;
                case GreaterDepth:
                  gl.depthFunc(516);
                  break;
                case NotEqualDepth:
                  gl.depthFunc(517);
                  break;
                default:
                  gl.depthFunc(515);
              }
            } else {
              gl.depthFunc(515);
            }
            currentDepthFunc = depthFunc;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(depth) {
          if (currentDepthClear !== depth) {
            gl.clearDepth(depth);
            currentDepthClear = depth;
          }
        },
        reset: function() {
          locked = false;
          currentDepthMask = null;
          currentDepthFunc = null;
          currentDepthClear = null;
        }
      };
    }
    function StencilBuffer() {
      let locked = false;
      let currentStencilMask = null;
      let currentStencilFunc = null;
      let currentStencilRef = null;
      let currentStencilFuncMask = null;
      let currentStencilFail = null;
      let currentStencilZFail = null;
      let currentStencilZPass = null;
      let currentStencilClear = null;
      return {
        setTest: function(stencilTest) {
          if (!locked) {
            if (stencilTest) {
              enable(2960);
            } else {
              disable(2960);
            }
          }
        },
        setMask: function(stencilMask) {
          if (currentStencilMask !== stencilMask && !locked) {
            gl.stencilMask(stencilMask);
            currentStencilMask = stencilMask;
          }
        },
        setFunc: function(stencilFunc, stencilRef, stencilMask) {
          if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
            gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
            currentStencilFunc = stencilFunc;
            currentStencilRef = stencilRef;
            currentStencilFuncMask = stencilMask;
          }
        },
        setOp: function(stencilFail, stencilZFail, stencilZPass) {
          if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
            gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
            currentStencilFail = stencilFail;
            currentStencilZFail = stencilZFail;
            currentStencilZPass = stencilZPass;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(stencil) {
          if (currentStencilClear !== stencil) {
            gl.clearStencil(stencil);
            currentStencilClear = stencil;
          }
        },
        reset: function() {
          locked = false;
          currentStencilMask = null;
          currentStencilFunc = null;
          currentStencilRef = null;
          currentStencilFuncMask = null;
          currentStencilFail = null;
          currentStencilZFail = null;
          currentStencilZPass = null;
          currentStencilClear = null;
        }
      };
    }
    const colorBuffer = new ColorBuffer();
    const depthBuffer = new DepthBuffer();
    const stencilBuffer = new StencilBuffer();
    let enabledCapabilities = {};
    let xrFramebuffer = null;
    let currentBoundFramebuffers = {};
    let currentProgram = null;
    let currentBlendingEnabled = false;
    let currentBlending = null;
    let currentBlendEquation = null;
    let currentBlendSrc = null;
    let currentBlendDst = null;
    let currentBlendEquationAlpha = null;
    let currentBlendSrcAlpha = null;
    let currentBlendDstAlpha = null;
    let currentPremultipledAlpha = false;
    let currentFlipSided = null;
    let currentCullFace = null;
    let currentLineWidth = null;
    let currentPolygonOffsetFactor = null;
    let currentPolygonOffsetUnits = null;
    const maxTextures = gl.getParameter(35661);
    let lineWidthAvailable = false;
    let version = 0;
    const glVersion = gl.getParameter(7938);
    if (glVersion.indexOf("WebGL") !== -1) {
      version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
      lineWidthAvailable = version >= 1;
    } else if (glVersion.indexOf("OpenGL ES") !== -1) {
      version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
      lineWidthAvailable = version >= 2;
    }
    let currentTextureSlot = null;
    let currentBoundTextures = {};
    const currentScissor = new Vector4(0, 0, gl.canvas.width, gl.canvas.height);
    const currentViewport = new Vector4(0, 0, gl.canvas.width, gl.canvas.height);
    function createTexture(type, target, count) {
      const data = new Uint8Array(4);
      const texture = gl.createTexture();
      gl.bindTexture(type, texture);
      gl.texParameteri(type, 10241, 9728);
      gl.texParameteri(type, 10240, 9728);
      for (let i = 0; i < count; i++) {
        gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data);
      }
      return texture;
    }
    const emptyTextures = {};
    emptyTextures[3553] = createTexture(3553, 3553, 1);
    emptyTextures[34067] = createTexture(34067, 34069, 6);
    colorBuffer.setClear(0, 0, 0, 1);
    depthBuffer.setClear(1);
    stencilBuffer.setClear(0);
    enable(2929);
    depthBuffer.setFunc(LessEqualDepth);
    setFlipSided(false);
    setCullFace(CullFaceBack);
    enable(2884);
    setBlending(NoBlending);
    function enable(id) {
      if (enabledCapabilities[id] !== true) {
        gl.enable(id);
        enabledCapabilities[id] = true;
      }
    }
    function disable(id) {
      if (enabledCapabilities[id] !== false) {
        gl.disable(id);
        enabledCapabilities[id] = false;
      }
    }
    function bindXRFramebuffer(framebuffer) {
      if (framebuffer !== xrFramebuffer) {
        gl.bindFramebuffer(36160, framebuffer);
        xrFramebuffer = framebuffer;
      }
    }
    function bindFramebuffer(target, framebuffer) {
      if (framebuffer === null && xrFramebuffer !== null)
        framebuffer = xrFramebuffer;
      if (currentBoundFramebuffers[target] !== framebuffer) {
        gl.bindFramebuffer(target, framebuffer);
        currentBoundFramebuffers[target] = framebuffer;
      }
    }
    function useProgram(program) {
      if (currentProgram !== program) {
        gl.useProgram(program);
        currentProgram = program;
        return true;
      }
      return false;
    }
    const equationToGL = {
      [AddEquation]: 32774,
      [SubtractEquation]: 32778,
      [ReverseSubtractEquation]: 32779
    };
    if (isWebGL2) {
      equationToGL[MinEquation] = 32775;
      equationToGL[MaxEquation] = 32776;
    } else {
      const extension = extensions.get("EXT_blend_minmax");
      if (extension !== null) {
        equationToGL[MinEquation] = extension.MIN_EXT;
        equationToGL[MaxEquation] = extension.MAX_EXT;
      }
    }
    const factorToGL = {
      [ZeroFactor]: 0,
      [OneFactor]: 1,
      [SrcColorFactor]: 768,
      [SrcAlphaFactor]: 770,
      [SrcAlphaSaturateFactor]: 776,
      [DstColorFactor]: 774,
      [DstAlphaFactor]: 772,
      [OneMinusSrcColorFactor]: 769,
      [OneMinusSrcAlphaFactor]: 771,
      [OneMinusDstColorFactor]: 775,
      [OneMinusDstAlphaFactor]: 773
    };
    function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
      if (blending === NoBlending) {
        if (currentBlendingEnabled === true) {
          disable(3042);
          currentBlendingEnabled = false;
        }
        return;
      }
      if (currentBlendingEnabled === false) {
        enable(3042);
        currentBlendingEnabled = true;
      }
      if (blending !== CustomBlending) {
        if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
          if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
            gl.blendEquation(32774);
            currentBlendEquation = AddEquation;
            currentBlendEquationAlpha = AddEquation;
          }
          if (premultipliedAlpha) {
            switch (blending) {
              case NormalBlending:
                gl.blendFuncSeparate(1, 771, 1, 771);
                break;
              case AdditiveBlending:
                gl.blendFunc(1, 1);
                break;
              case SubtractiveBlending:
                gl.blendFuncSeparate(0, 0, 769, 771);
                break;
              case MultiplyBlending:
                gl.blendFuncSeparate(0, 768, 0, 770);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", blending);
                break;
            }
          } else {
            switch (blending) {
              case NormalBlending:
                gl.blendFuncSeparate(770, 771, 1, 771);
                break;
              case AdditiveBlending:
                gl.blendFunc(770, 1);
                break;
              case SubtractiveBlending:
                gl.blendFunc(0, 769);
                break;
              case MultiplyBlending:
                gl.blendFunc(0, 768);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", blending);
                break;
            }
          }
          currentBlendSrc = null;
          currentBlendDst = null;
          currentBlendSrcAlpha = null;
          currentBlendDstAlpha = null;
          currentBlending = blending;
          currentPremultipledAlpha = premultipliedAlpha;
        }
        return;
      }
      blendEquationAlpha = blendEquationAlpha || blendEquation;
      blendSrcAlpha = blendSrcAlpha || blendSrc;
      blendDstAlpha = blendDstAlpha || blendDst;
      if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
        gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
        currentBlendEquation = blendEquation;
        currentBlendEquationAlpha = blendEquationAlpha;
      }
      if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
        gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
        currentBlendSrc = blendSrc;
        currentBlendDst = blendDst;
        currentBlendSrcAlpha = blendSrcAlpha;
        currentBlendDstAlpha = blendDstAlpha;
      }
      currentBlending = blending;
      currentPremultipledAlpha = null;
    }
    function setMaterial(material, frontFaceCW) {
      material.side === DoubleSide ? disable(2884) : enable(2884);
      let flipSided = material.side === BackSide;
      if (frontFaceCW)
        flipSided = !flipSided;
      setFlipSided(flipSided);
      material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
      depthBuffer.setFunc(material.depthFunc);
      depthBuffer.setTest(material.depthTest);
      depthBuffer.setMask(material.depthWrite);
      colorBuffer.setMask(material.colorWrite);
      const stencilWrite = material.stencilWrite;
      stencilBuffer.setTest(stencilWrite);
      if (stencilWrite) {
        stencilBuffer.setMask(material.stencilWriteMask);
        stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
        stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
      }
      setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
      material.alphaToCoverage === true ? enable(32926) : disable(32926);
    }
    function setFlipSided(flipSided) {
      if (currentFlipSided !== flipSided) {
        if (flipSided) {
          gl.frontFace(2304);
        } else {
          gl.frontFace(2305);
        }
        currentFlipSided = flipSided;
      }
    }
    function setCullFace(cullFace) {
      if (cullFace !== CullFaceNone) {
        enable(2884);
        if (cullFace !== currentCullFace) {
          if (cullFace === CullFaceBack) {
            gl.cullFace(1029);
          } else if (cullFace === CullFaceFront) {
            gl.cullFace(1028);
          } else {
            gl.cullFace(1032);
          }
        }
      } else {
        disable(2884);
      }
      currentCullFace = cullFace;
    }
    function setLineWidth(width) {
      if (width !== currentLineWidth) {
        if (lineWidthAvailable)
          gl.lineWidth(width);
        currentLineWidth = width;
      }
    }
    function setPolygonOffset(polygonOffset, factor, units) {
      if (polygonOffset) {
        enable(32823);
        if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
          gl.polygonOffset(factor, units);
          currentPolygonOffsetFactor = factor;
          currentPolygonOffsetUnits = units;
        }
      } else {
        disable(32823);
      }
    }
    function setScissorTest(scissorTest) {
      if (scissorTest) {
        enable(3089);
      } else {
        disable(3089);
      }
    }
    function activeTexture(webglSlot) {
      if (webglSlot === void 0)
        webglSlot = 33984 + maxTextures - 1;
      if (currentTextureSlot !== webglSlot) {
        gl.activeTexture(webglSlot);
        currentTextureSlot = webglSlot;
      }
    }
    function bindTexture(webglType, webglTexture) {
      if (currentTextureSlot === null) {
        activeTexture();
      }
      let boundTexture = currentBoundTextures[currentTextureSlot];
      if (boundTexture === void 0) {
        boundTexture = { type: void 0, texture: void 0 };
        currentBoundTextures[currentTextureSlot] = boundTexture;
      }
      if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
        gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
        boundTexture.type = webglType;
        boundTexture.texture = webglTexture;
      }
    }
    function unbindTexture() {
      const boundTexture = currentBoundTextures[currentTextureSlot];
      if (boundTexture !== void 0 && boundTexture.type !== void 0) {
        gl.bindTexture(boundTexture.type, null);
        boundTexture.type = void 0;
        boundTexture.texture = void 0;
      }
    }
    function compressedTexImage2D() {
      try {
        gl.compressedTexImage2D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texImage2D() {
      try {
        gl.texImage2D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texImage3D() {
      try {
        gl.texImage3D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function scissor(scissor2) {
      if (currentScissor.equals(scissor2) === false) {
        gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
        currentScissor.copy(scissor2);
      }
    }
    function viewport(viewport2) {
      if (currentViewport.equals(viewport2) === false) {
        gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
        currentViewport.copy(viewport2);
      }
    }
    function reset() {
      gl.disable(3042);
      gl.disable(2884);
      gl.disable(2929);
      gl.disable(32823);
      gl.disable(3089);
      gl.disable(2960);
      gl.disable(32926);
      gl.blendEquation(32774);
      gl.blendFunc(1, 0);
      gl.blendFuncSeparate(1, 0, 1, 0);
      gl.colorMask(true, true, true, true);
      gl.clearColor(0, 0, 0, 0);
      gl.depthMask(true);
      gl.depthFunc(513);
      gl.clearDepth(1);
      gl.stencilMask(4294967295);
      gl.stencilFunc(519, 0, 4294967295);
      gl.stencilOp(7680, 7680, 7680);
      gl.clearStencil(0);
      gl.cullFace(1029);
      gl.frontFace(2305);
      gl.polygonOffset(0, 0);
      gl.activeTexture(33984);
      gl.bindFramebuffer(36160, null);
      if (isWebGL2 === true) {
        gl.bindFramebuffer(36009, null);
        gl.bindFramebuffer(36008, null);
      }
      gl.useProgram(null);
      gl.lineWidth(1);
      gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      enabledCapabilities = {};
      currentTextureSlot = null;
      currentBoundTextures = {};
      xrFramebuffer = null;
      currentBoundFramebuffers = {};
      currentProgram = null;
      currentBlendingEnabled = false;
      currentBlending = null;
      currentBlendEquation = null;
      currentBlendSrc = null;
      currentBlendDst = null;
      currentBlendEquationAlpha = null;
      currentBlendSrcAlpha = null;
      currentBlendDstAlpha = null;
      currentPremultipledAlpha = false;
      currentFlipSided = null;
      currentCullFace = null;
      currentLineWidth = null;
      currentPolygonOffsetFactor = null;
      currentPolygonOffsetUnits = null;
      currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
      currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
      colorBuffer.reset();
      depthBuffer.reset();
      stencilBuffer.reset();
    }
    return {
      buffers: {
        color: colorBuffer,
        depth: depthBuffer,
        stencil: stencilBuffer
      },
      enable,
      disable,
      bindFramebuffer,
      bindXRFramebuffer,
      useProgram,
      setBlending,
      setMaterial,
      setFlipSided,
      setCullFace,
      setLineWidth,
      setPolygonOffset,
      setScissorTest,
      activeTexture,
      bindTexture,
      unbindTexture,
      compressedTexImage2D,
      texImage2D,
      texImage3D,
      scissor,
      viewport,
      reset
    };
  }
  function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info2) {
    const isWebGL2 = capabilities.isWebGL2;
    const maxTextures = capabilities.maxTextures;
    const maxCubemapSize = capabilities.maxCubemapSize;
    const maxTextureSize = capabilities.maxTextureSize;
    const maxSamples = capabilities.maxSamples;
    const _videoTextures = new WeakMap();
    let _canvas2;
    let useOffscreenCanvas = false;
    try {
      useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
    } catch (err) {
    }
    function createCanvas(width, height) {
      return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    }
    function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
      let scale = 1;
      if (image.width > maxSize || image.height > maxSize) {
        scale = maxSize / Math.max(image.width, image.height);
      }
      if (scale < 1 || needsPowerOfTwo === true) {
        if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
          const floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;
          const width = floor(scale * image.width);
          const height = floor(scale * image.height);
          if (_canvas2 === void 0)
            _canvas2 = createCanvas(width, height);
          const canvas2 = needsNewCanvas ? createCanvas(width, height) : _canvas2;
          canvas2.width = width;
          canvas2.height = height;
          const context = canvas2.getContext("2d");
          context.drawImage(image, 0, 0, width, height);
          console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
          return canvas2;
        } else {
          if ("data" in image) {
            console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
          }
          return image;
        }
      }
      return image;
    }
    function isPowerOfTwo(image) {
      return MathUtils.isPowerOfTwo(image.width) && MathUtils.isPowerOfTwo(image.height);
    }
    function textureNeedsPowerOfTwo(texture) {
      if (isWebGL2)
        return false;
      return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function textureNeedsGenerateMipmaps(texture, supportsMips) {
      return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function generateMipmap(target, texture, width, height) {
      _gl.generateMipmap(target);
      const textureProperties = properties.get(texture);
      textureProperties.__maxMipLevel = Math.log2(Math.max(width, height));
    }
    function getInternalFormat(internalFormatName, glFormat, glType) {
      if (isWebGL2 === false)
        return glFormat;
      if (internalFormatName !== null) {
        if (_gl[internalFormatName] !== void 0)
          return _gl[internalFormatName];
        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
      }
      let internalFormat = glFormat;
      if (glFormat === 6403) {
        if (glType === 5126)
          internalFormat = 33326;
        if (glType === 5131)
          internalFormat = 33325;
        if (glType === 5121)
          internalFormat = 33321;
      }
      if (glFormat === 6407) {
        if (glType === 5126)
          internalFormat = 34837;
        if (glType === 5131)
          internalFormat = 34843;
        if (glType === 5121)
          internalFormat = 32849;
      }
      if (glFormat === 6408) {
        if (glType === 5126)
          internalFormat = 34836;
        if (glType === 5131)
          internalFormat = 34842;
        if (glType === 5121)
          internalFormat = 32856;
      }
      if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {
        extensions.get("EXT_color_buffer_float");
      }
      return internalFormat;
    }
    function filterFallback(f) {
      if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
        return 9728;
      }
      return 9729;
    }
    function onTextureDispose(event) {
      const texture = event.target;
      texture.removeEventListener("dispose", onTextureDispose);
      deallocateTexture(texture);
      if (texture.isVideoTexture) {
        _videoTextures.delete(texture);
      }
      info2.memory.textures--;
    }
    function onRenderTargetDispose(event) {
      const renderTarget = event.target;
      renderTarget.removeEventListener("dispose", onRenderTargetDispose);
      deallocateRenderTarget(renderTarget);
      info2.memory.textures--;
    }
    function deallocateTexture(texture) {
      const textureProperties = properties.get(texture);
      if (textureProperties.__webglInit === void 0)
        return;
      _gl.deleteTexture(textureProperties.__webglTexture);
      properties.remove(texture);
    }
    function deallocateRenderTarget(renderTarget) {
      const texture = renderTarget.texture;
      const renderTargetProperties = properties.get(renderTarget);
      const textureProperties = properties.get(texture);
      if (!renderTarget)
        return;
      if (textureProperties.__webglTexture !== void 0) {
        _gl.deleteTexture(textureProperties.__webglTexture);
      }
      if (renderTarget.depthTexture) {
        renderTarget.depthTexture.dispose();
      }
      if (renderTarget.isWebGLCubeRenderTarget) {
        for (let i = 0; i < 6; i++) {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
          if (renderTargetProperties.__webglDepthbuffer)
            _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
        }
      } else {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
        if (renderTargetProperties.__webglMultisampledFramebuffer)
          _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
        if (renderTargetProperties.__webglColorRenderbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
        if (renderTargetProperties.__webglDepthRenderbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
      }
      properties.remove(texture);
      properties.remove(renderTarget);
    }
    let textureUnits = 0;
    function resetTextureUnits() {
      textureUnits = 0;
    }
    function allocateTextureUnit() {
      const textureUnit = textureUnits;
      if (textureUnit >= maxTextures) {
        console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
      }
      textureUnits += 1;
      return textureUnit;
    }
    function setTexture2D(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.isVideoTexture)
        updateVideoTexture(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        const image = texture.image;
        if (image === void 0) {
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
        } else if (image.complete === false) {
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
        } else {
          uploadTexture(textureProperties, texture, slot);
          return;
        }
      }
      state.activeTexture(33984 + slot);
      state.bindTexture(3553, textureProperties.__webglTexture);
    }
    function setTexture2DArray(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
      state.activeTexture(33984 + slot);
      state.bindTexture(35866, textureProperties.__webglTexture);
    }
    function setTexture3D(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
      state.activeTexture(33984 + slot);
      state.bindTexture(32879, textureProperties.__webglTexture);
    }
    function setTextureCube(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadCubeTexture(textureProperties, texture, slot);
        return;
      }
      state.activeTexture(33984 + slot);
      state.bindTexture(34067, textureProperties.__webglTexture);
    }
    const wrappingToGL = {
      [RepeatWrapping]: 10497,
      [ClampToEdgeWrapping]: 33071,
      [MirroredRepeatWrapping]: 33648
    };
    const filterToGL = {
      [NearestFilter]: 9728,
      [NearestMipmapNearestFilter]: 9984,
      [NearestMipmapLinearFilter]: 9986,
      [LinearFilter]: 9729,
      [LinearMipmapNearestFilter]: 9985,
      [LinearMipmapLinearFilter]: 9987
    };
    function setTextureParameters(textureType, texture, supportsMips) {
      if (supportsMips) {
        _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
        _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
        if (textureType === 32879 || textureType === 35866) {
          _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
        }
        _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
        _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
      } else {
        _gl.texParameteri(textureType, 10242, 33071);
        _gl.texParameteri(textureType, 10243, 33071);
        if (textureType === 32879 || textureType === 35866) {
          _gl.texParameteri(textureType, 32882, 33071);
        }
        if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
          console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
        }
        _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
        _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
        if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
          console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
        }
      }
      if (extensions.has("EXT_texture_filter_anisotropic") === true) {
        const extension = extensions.get("EXT_texture_filter_anisotropic");
        if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false)
          return;
        if (isWebGL2 === false && (texture.type === HalfFloatType && extensions.has("OES_texture_half_float_linear") === false))
          return;
        if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
          _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
          properties.get(texture).__currentAnisotropy = texture.anisotropy;
        }
      }
    }
    function initTexture(textureProperties, texture) {
      if (textureProperties.__webglInit === void 0) {
        textureProperties.__webglInit = true;
        texture.addEventListener("dispose", onTextureDispose);
        textureProperties.__webglTexture = _gl.createTexture();
        info2.memory.textures++;
      }
    }
    function uploadTexture(textureProperties, texture, slot) {
      let textureType = 3553;
      if (texture.isDataTexture2DArray)
        textureType = 35866;
      if (texture.isDataTexture3D)
        textureType = 32879;
      initTexture(textureProperties, texture);
      state.activeTexture(33984 + slot);
      state.bindTexture(textureType, textureProperties.__webglTexture);
      _gl.pixelStorei(37440, texture.flipY);
      _gl.pixelStorei(37441, texture.premultiplyAlpha);
      _gl.pixelStorei(3317, texture.unpackAlignment);
      _gl.pixelStorei(37443, 0);
      const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
      const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
      const supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format);
      let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
      setTextureParameters(textureType, texture, supportsMips);
      let mipmap;
      const mipmaps = texture.mipmaps;
      if (texture.isDepthTexture) {
        glInternalFormat = 6402;
        if (isWebGL2) {
          if (texture.type === FloatType) {
            glInternalFormat = 36012;
          } else if (texture.type === UnsignedIntType) {
            glInternalFormat = 33190;
          } else if (texture.type === UnsignedInt248Type) {
            glInternalFormat = 35056;
          } else {
            glInternalFormat = 33189;
          }
        } else {
          if (texture.type === FloatType) {
            console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
          }
        }
        if (texture.format === DepthFormat && glInternalFormat === 6402) {
          if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
            console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
            texture.type = UnsignedShortType;
            glType = utils.convert(texture.type);
          }
        }
        if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
          glInternalFormat = 34041;
          if (texture.type !== UnsignedInt248Type) {
            console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
            texture.type = UnsignedInt248Type;
            glType = utils.convert(texture.type);
          }
        }
        state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
      } else if (texture.isDataTexture) {
        if (mipmaps.length > 0 && supportsMips) {
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }
          texture.generateMipmaps = false;
          textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else {
          state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
          textureProperties.__maxMipLevel = 0;
        }
      } else if (texture.isCompressedTexture) {
        for (let i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
            if (glFormat !== null) {
              state.compressedTexImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
            } else {
              console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            }
          } else {
            state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }
        }
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else if (texture.isDataTexture2DArray) {
        state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        textureProperties.__maxMipLevel = 0;
      } else if (texture.isDataTexture3D) {
        state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        textureProperties.__maxMipLevel = 0;
      } else {
        if (mipmaps.length > 0 && supportsMips) {
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            state.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap);
          }
          texture.generateMipmaps = false;
          textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else {
          state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
          textureProperties.__maxMipLevel = 0;
        }
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(textureType, texture, image.width, image.height);
      }
      textureProperties.__version = texture.version;
      if (texture.onUpdate)
        texture.onUpdate(texture);
    }
    function uploadCubeTexture(textureProperties, texture, slot) {
      if (texture.image.length !== 6)
        return;
      initTexture(textureProperties, texture);
      state.activeTexture(33984 + slot);
      state.bindTexture(34067, textureProperties.__webglTexture);
      _gl.pixelStorei(37440, texture.flipY);
      _gl.pixelStorei(37441, texture.premultiplyAlpha);
      _gl.pixelStorei(3317, texture.unpackAlignment);
      _gl.pixelStorei(37443, 0);
      const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
      const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
      const cubeImage = [];
      for (let i = 0; i < 6; i++) {
        if (!isCompressed && !isDataTexture) {
          cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
        } else {
          cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
        }
      }
      const image = cubeImage[0], supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
      setTextureParameters(34067, texture, supportsMips);
      let mipmaps;
      if (isCompressed) {
        for (let i = 0; i < 6; i++) {
          mipmaps = cubeImage[i].mipmaps;
          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];
            if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
              if (glFormat !== null) {
                state.compressedTexImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
              }
            } else {
              state.texImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
        }
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        mipmaps = texture.mipmaps;
        for (let i = 0; i < 6; i++) {
          if (isDataTexture) {
            state.texImage2D(34069 + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              const mipmapImage = mipmap.image[i].image;
              state.texImage2D(34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
            }
          } else {
            state.texImage2D(34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              state.texImage2D(34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
            }
          }
        }
        textureProperties.__maxMipLevel = mipmaps.length;
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(34067, texture, image.width, image.height);
      }
      textureProperties.__version = texture.version;
      if (texture.onUpdate)
        texture.onUpdate(texture);
    }
    function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
      const texture = renderTarget.texture;
      const glFormat = utils.convert(texture.format);
      const glType = utils.convert(texture.type);
      const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
      if (textureTarget === 32879 || textureTarget === 35866) {
        state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
      } else {
        state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
      }
      state.bindFramebuffer(36160, framebuffer);
      _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
      state.bindFramebuffer(36160, null);
    }
    function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
      _gl.bindRenderbuffer(36161, renderbuffer);
      if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
        let glInternalFormat = 33189;
        if (isMultisample) {
          const depthTexture = renderTarget.depthTexture;
          if (depthTexture && depthTexture.isDepthTexture) {
            if (depthTexture.type === FloatType) {
              glInternalFormat = 36012;
            } else if (depthTexture.type === UnsignedIntType) {
              glInternalFormat = 33190;
            }
          }
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
        }
        _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
      } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
        if (isMultisample) {
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
        }
        _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
      } else {
        const texture = renderTarget.texture;
        const glFormat = utils.convert(texture.format);
        const glType = utils.convert(texture.type);
        const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
        if (isMultisample) {
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      }
      _gl.bindRenderbuffer(36161, null);
    }
    function setupDepthTexture(framebuffer, renderTarget) {
      const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
      if (isCube)
        throw new Error("Depth Texture with cube render targets is not supported");
      state.bindFramebuffer(36160, framebuffer);
      if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
        throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
      }
      if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
        renderTarget.depthTexture.image.width = renderTarget.width;
        renderTarget.depthTexture.image.height = renderTarget.height;
        renderTarget.depthTexture.needsUpdate = true;
      }
      setTexture2D(renderTarget.depthTexture, 0);
      const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
      if (renderTarget.depthTexture.format === DepthFormat) {
        _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
      } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
        _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
      } else {
        throw new Error("Unknown depthTexture format");
      }
    }
    function setupDepthRenderbuffer(renderTarget) {
      const renderTargetProperties = properties.get(renderTarget);
      const isCube = renderTarget.isWebGLCubeRenderTarget === true;
      if (renderTarget.depthTexture) {
        if (isCube)
          throw new Error("target.depthTexture not supported in Cube render targets");
        setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
      } else {
        if (isCube) {
          renderTargetProperties.__webglDepthbuffer = [];
          for (let i = 0; i < 6; i++) {
            state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i]);
            renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
          }
        } else {
          state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
          renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
        }
      }
      state.bindFramebuffer(36160, null);
    }
    function setupRenderTarget(renderTarget) {
      const texture = renderTarget.texture;
      const renderTargetProperties = properties.get(renderTarget);
      const textureProperties = properties.get(texture);
      renderTarget.addEventListener("dispose", onRenderTargetDispose);
      textureProperties.__webglTexture = _gl.createTexture();
      textureProperties.__version = texture.version;
      info2.memory.textures++;
      const isCube = renderTarget.isWebGLCubeRenderTarget === true;
      const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
      const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
      const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
      if (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {
        texture.format = RGBAFormat;
        console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.");
      }
      if (isCube) {
        renderTargetProperties.__webglFramebuffer = [];
        for (let i = 0; i < 6; i++) {
          renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
        }
      } else {
        renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
        if (isMultisample) {
          if (isWebGL2) {
            renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
            renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
            _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
            const glFormat = utils.convert(texture.format);
            const glType = utils.convert(texture.type);
            const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
            const samples = getRenderTargetSamples(renderTarget);
            _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
            _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
            _gl.bindRenderbuffer(36161, null);
            if (renderTarget.depthBuffer) {
              renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
              setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
            }
            state.bindFramebuffer(36160, null);
          } else {
            console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
          }
        }
      }
      if (isCube) {
        state.bindTexture(34067, textureProperties.__webglTexture);
        setTextureParameters(34067, texture, supportsMips);
        for (let i = 0; i < 6; i++) {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, 36064, 34069 + i);
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(34067, texture, renderTarget.width, renderTarget.height);
        }
        state.bindTexture(34067, null);
      } else {
        let glTextureType = 3553;
        if (isRenderTarget3D) {
          if (isWebGL2) {
            const isTexture3D = texture.isDataTexture3D;
            glTextureType = isTexture3D ? 32879 : 35866;
          } else {
            console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
          }
        }
        state.bindTexture(glTextureType, textureProperties.__webglTexture);
        setTextureParameters(glTextureType, texture, supportsMips);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, glTextureType);
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(3553, texture, renderTarget.width, renderTarget.height);
        }
        state.bindTexture(3553, null);
      }
      if (renderTarget.depthBuffer) {
        setupDepthRenderbuffer(renderTarget);
      }
    }
    function updateRenderTargetMipmap(renderTarget) {
      const texture = renderTarget.texture;
      const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
        const webglTexture = properties.get(texture).__webglTexture;
        state.bindTexture(target, webglTexture);
        generateMipmap(target, texture, renderTarget.width, renderTarget.height);
        state.bindTexture(target, null);
      }
    }
    function updateMultisampleRenderTarget(renderTarget) {
      if (renderTarget.isWebGLMultisampleRenderTarget) {
        if (isWebGL2) {
          const renderTargetProperties = properties.get(renderTarget);
          state.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
          state.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
          const width = renderTarget.width;
          const height = renderTarget.height;
          let mask = 16384;
          if (renderTarget.depthBuffer)
            mask |= 256;
          if (renderTarget.stencilBuffer)
            mask |= 1024;
          _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
          state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        }
      }
    }
    function getRenderTargetSamples(renderTarget) {
      return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
    }
    function updateVideoTexture(texture) {
      const frame = info2.render.frame;
      if (_videoTextures.get(texture) !== frame) {
        _videoTextures.set(texture, frame);
        texture.update();
      }
    }
    let warnedTexture2D = false;
    let warnedTextureCube = false;
    function safeSetTexture2D(texture, slot) {
      if (texture && texture.isWebGLRenderTarget) {
        if (warnedTexture2D === false) {
          console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
          warnedTexture2D = true;
        }
        texture = texture.texture;
      }
      setTexture2D(texture, slot);
    }
    function safeSetTextureCube(texture, slot) {
      if (texture && texture.isWebGLCubeRenderTarget) {
        if (warnedTextureCube === false) {
          console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
          warnedTextureCube = true;
        }
        texture = texture.texture;
      }
      setTextureCube(texture, slot);
    }
    this.allocateTextureUnit = allocateTextureUnit;
    this.resetTextureUnits = resetTextureUnits;
    this.setTexture2D = setTexture2D;
    this.setTexture2DArray = setTexture2DArray;
    this.setTexture3D = setTexture3D;
    this.setTextureCube = setTextureCube;
    this.setupRenderTarget = setupRenderTarget;
    this.updateRenderTargetMipmap = updateRenderTargetMipmap;
    this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
    this.safeSetTexture2D = safeSetTexture2D;
    this.safeSetTextureCube = safeSetTextureCube;
  }
  function WebGLUtils(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function convert(p) {
      let extension;
      if (p === UnsignedByteType)
        return 5121;
      if (p === UnsignedShort4444Type)
        return 32819;
      if (p === UnsignedShort5551Type)
        return 32820;
      if (p === UnsignedShort565Type)
        return 33635;
      if (p === ByteType)
        return 5120;
      if (p === ShortType)
        return 5122;
      if (p === UnsignedShortType)
        return 5123;
      if (p === IntType)
        return 5124;
      if (p === UnsignedIntType)
        return 5125;
      if (p === FloatType)
        return 5126;
      if (p === HalfFloatType) {
        if (isWebGL2)
          return 5131;
        extension = extensions.get("OES_texture_half_float");
        if (extension !== null) {
          return extension.HALF_FLOAT_OES;
        } else {
          return null;
        }
      }
      if (p === AlphaFormat)
        return 6406;
      if (p === RGBFormat)
        return 6407;
      if (p === RGBAFormat)
        return 6408;
      if (p === LuminanceFormat)
        return 6409;
      if (p === LuminanceAlphaFormat)
        return 6410;
      if (p === DepthFormat)
        return 6402;
      if (p === DepthStencilFormat)
        return 34041;
      if (p === RedFormat)
        return 6403;
      if (p === RedIntegerFormat)
        return 36244;
      if (p === RGFormat)
        return 33319;
      if (p === RGIntegerFormat)
        return 33320;
      if (p === RGBIntegerFormat)
        return 36248;
      if (p === RGBAIntegerFormat)
        return 36249;
      if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
        extension = extensions.get("WEBGL_compressed_texture_s3tc");
        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      }
      if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
        extension = extensions.get("WEBGL_compressed_texture_pvrtc");
        if (extension !== null) {
          if (p === RGB_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (p === RGB_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (p === RGBA_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (p === RGBA_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        } else {
          return null;
        }
      }
      if (p === RGB_ETC1_Format) {
        extension = extensions.get("WEBGL_compressed_texture_etc1");
        if (extension !== null) {
          return extension.COMPRESSED_RGB_ETC1_WEBGL;
        } else {
          return null;
        }
      }
      if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
        extension = extensions.get("WEBGL_compressed_texture_etc");
        if (extension !== null) {
          if (p === RGB_ETC2_Format)
            return extension.COMPRESSED_RGB8_ETC2;
          if (p === RGBA_ETC2_EAC_Format)
            return extension.COMPRESSED_RGBA8_ETC2_EAC;
        }
      }
      if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {
        extension = extensions.get("WEBGL_compressed_texture_astc");
        if (extension !== null) {
          return p;
        } else {
          return null;
        }
      }
      if (p === RGBA_BPTC_Format) {
        extension = extensions.get("EXT_texture_compression_bptc");
        if (extension !== null) {
          return p;
        } else {
          return null;
        }
      }
      if (p === UnsignedInt248Type) {
        if (isWebGL2)
          return 34042;
        extension = extensions.get("WEBGL_depth_texture");
        if (extension !== null) {
          return extension.UNSIGNED_INT_24_8_WEBGL;
        } else {
          return null;
        }
      }
    }
    return { convert };
  }
  var ArrayCamera = class extends PerspectiveCamera {
    constructor(array = []) {
      super();
      this.cameras = array;
    }
  };
  ArrayCamera.prototype.isArrayCamera = true;
  var Group = class extends Object3D {
    constructor() {
      super();
      this.type = "Group";
    }
  };
  Group.prototype.isGroup = true;
  function WebXRController() {
    this._targetRay = null;
    this._grip = null;
    this._hand = null;
  }
  Object.assign(WebXRController.prototype, {
    constructor: WebXRController,
    getHandSpace: function() {
      if (this._hand === null) {
        this._hand = new Group();
        this._hand.matrixAutoUpdate = false;
        this._hand.visible = false;
        this._hand.joints = {};
        this._hand.inputState = { pinching: false };
      }
      return this._hand;
    },
    getTargetRaySpace: function() {
      if (this._targetRay === null) {
        this._targetRay = new Group();
        this._targetRay.matrixAutoUpdate = false;
        this._targetRay.visible = false;
      }
      return this._targetRay;
    },
    getGripSpace: function() {
      if (this._grip === null) {
        this._grip = new Group();
        this._grip.matrixAutoUpdate = false;
        this._grip.visible = false;
      }
      return this._grip;
    },
    dispatchEvent: function(event) {
      if (this._targetRay !== null) {
        this._targetRay.dispatchEvent(event);
      }
      if (this._grip !== null) {
        this._grip.dispatchEvent(event);
      }
      if (this._hand !== null) {
        this._hand.dispatchEvent(event);
      }
      return this;
    },
    disconnect: function(inputSource) {
      this.dispatchEvent({ type: "disconnected", data: inputSource });
      if (this._targetRay !== null) {
        this._targetRay.visible = false;
      }
      if (this._grip !== null) {
        this._grip.visible = false;
      }
      if (this._hand !== null) {
        this._hand.visible = false;
      }
      return this;
    },
    update: function(inputSource, frame, referenceSpace) {
      let inputPose = null;
      let gripPose = null;
      let handPose = null;
      const targetRay = this._targetRay;
      const grip = this._grip;
      const hand = this._hand;
      if (inputSource && frame.session.visibilityState !== "visible-blurred") {
        if (targetRay !== null) {
          inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
          if (inputPose !== null) {
            targetRay.matrix.fromArray(inputPose.transform.matrix);
            targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
          }
        }
        if (hand && inputSource.hand) {
          handPose = true;
          for (const inputjoint of inputSource.hand.values()) {
            const jointPose = frame.getJointPose(inputjoint, referenceSpace);
            if (hand.joints[inputjoint.jointName] === void 0) {
              const joint2 = new Group();
              joint2.matrixAutoUpdate = false;
              joint2.visible = false;
              hand.joints[inputjoint.jointName] = joint2;
              hand.add(joint2);
            }
            const joint = hand.joints[inputjoint.jointName];
            if (jointPose !== null) {
              joint.matrix.fromArray(jointPose.transform.matrix);
              joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
              joint.jointRadius = jointPose.radius;
            }
            joint.visible = jointPose !== null;
          }
          const indexTip = hand.joints["index-finger-tip"];
          const thumbTip = hand.joints["thumb-tip"];
          const distance = indexTip.position.distanceTo(thumbTip.position);
          const distanceToPinch = 0.02;
          const threshold = 5e-3;
          if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
            hand.inputState.pinching = false;
            this.dispatchEvent({
              type: "pinchend",
              handedness: inputSource.handedness,
              target: this
            });
          } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
            hand.inputState.pinching = true;
            this.dispatchEvent({
              type: "pinchstart",
              handedness: inputSource.handedness,
              target: this
            });
          }
        } else {
          if (grip !== null && inputSource.gripSpace) {
            gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
            if (gripPose !== null) {
              grip.matrix.fromArray(gripPose.transform.matrix);
              grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
            }
          }
        }
      }
      if (targetRay !== null) {
        targetRay.visible = inputPose !== null;
      }
      if (grip !== null) {
        grip.visible = gripPose !== null;
      }
      if (hand !== null) {
        hand.visible = handPose !== null;
      }
      return this;
    }
  });
  function WebXRManager(renderer, gl) {
    const scope = this;
    const state = renderer.state;
    let session = null;
    let framebufferScaleFactor = 1;
    let referenceSpace = null;
    let referenceSpaceType = "local-floor";
    let pose = null;
    const controllers = [];
    const inputSourcesMap = new Map();
    const cameraL = new PerspectiveCamera();
    cameraL.layers.enable(1);
    cameraL.viewport = new Vector4();
    const cameraR = new PerspectiveCamera();
    cameraR.layers.enable(2);
    cameraR.viewport = new Vector4();
    const cameras = [cameraL, cameraR];
    const cameraVR = new ArrayCamera();
    cameraVR.layers.enable(1);
    cameraVR.layers.enable(2);
    let _currentDepthNear = null;
    let _currentDepthFar = null;
    this.enabled = false;
    this.isPresenting = false;
    this.getController = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getTargetRaySpace();
    };
    this.getControllerGrip = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getGripSpace();
    };
    this.getHand = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getHandSpace();
    };
    function onSessionEvent(event) {
      const controller = inputSourcesMap.get(event.inputSource);
      if (controller) {
        controller.dispatchEvent({ type: event.type, data: event.inputSource });
      }
    }
    function onSessionEnd() {
      inputSourcesMap.forEach(function(controller, inputSource) {
        controller.disconnect(inputSource);
      });
      inputSourcesMap.clear();
      _currentDepthNear = null;
      _currentDepthFar = null;
      state.bindXRFramebuffer(null);
      renderer.setRenderTarget(renderer.getRenderTarget());
      animation.stop();
      scope.isPresenting = false;
      scope.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(value) {
      framebufferScaleFactor = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }
    };
    this.setReferenceSpaceType = function(value) {
      referenceSpaceType = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }
    };
    this.getReferenceSpace = function() {
      return referenceSpace;
    };
    this.getSession = function() {
      return session;
    };
    this.setSession = async function(value) {
      session = value;
      if (session !== null) {
        session.addEventListener("select", onSessionEvent);
        session.addEventListener("selectstart", onSessionEvent);
        session.addEventListener("selectend", onSessionEvent);
        session.addEventListener("squeeze", onSessionEvent);
        session.addEventListener("squeezestart", onSessionEvent);
        session.addEventListener("squeezeend", onSessionEvent);
        session.addEventListener("end", onSessionEnd);
        session.addEventListener("inputsourceschange", onInputSourcesChange);
        const attributes = gl.getContextAttributes();
        if (attributes.xrCompatible !== true) {
          await gl.makeXRCompatible();
        }
        const layerInit = {
          antialias: attributes.antialias,
          alpha: attributes.alpha,
          depth: attributes.depth,
          stencil: attributes.stencil,
          framebufferScaleFactor
        };
        const baseLayer = new XRWebGLLayer(session, gl, layerInit);
        session.updateRenderState({ baseLayer });
        referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
        animation.setContext(session);
        animation.start();
        scope.isPresenting = true;
        scope.dispatchEvent({ type: "sessionstart" });
      }
    };
    function onInputSourcesChange(event) {
      const inputSources = session.inputSources;
      for (let i = 0; i < controllers.length; i++) {
        inputSourcesMap.set(inputSources[i], controllers[i]);
      }
      for (let i = 0; i < event.removed.length; i++) {
        const inputSource = event.removed[i];
        const controller = inputSourcesMap.get(inputSource);
        if (controller) {
          controller.dispatchEvent({ type: "disconnected", data: inputSource });
          inputSourcesMap.delete(inputSource);
        }
      }
      for (let i = 0; i < event.added.length; i++) {
        const inputSource = event.added[i];
        const controller = inputSourcesMap.get(inputSource);
        if (controller) {
          controller.dispatchEvent({ type: "connected", data: inputSource });
        }
      }
    }
    const cameraLPos = new Vector3();
    const cameraRPos = new Vector3();
    function setProjectionFromUnion(camera, cameraL2, cameraR2) {
      cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
      cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
      const ipd = cameraLPos.distanceTo(cameraRPos);
      const projL = cameraL2.projectionMatrix.elements;
      const projR = cameraR2.projectionMatrix.elements;
      const near = projL[14] / (projL[10] - 1);
      const far = projL[14] / (projL[10] + 1);
      const topFov = (projL[9] + 1) / projL[5];
      const bottomFov = (projL[9] - 1) / projL[5];
      const leftFov = (projL[8] - 1) / projL[0];
      const rightFov = (projR[8] + 1) / projR[0];
      const left = near * leftFov;
      const right = near * rightFov;
      const zOffset = ipd / (-leftFov + rightFov);
      const xOffset = zOffset * -leftFov;
      cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
      camera.translateX(xOffset);
      camera.translateZ(zOffset);
      camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
      const near2 = near + zOffset;
      const far2 = far + zOffset;
      const left2 = left - xOffset;
      const right2 = right + (ipd - xOffset);
      const top2 = topFov * far / far2 * near2;
      const bottom2 = bottomFov * far / far2 * near2;
      camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
    }
    function updateCamera(camera, parent) {
      if (parent === null) {
        camera.matrixWorld.copy(camera.matrix);
      } else {
        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
      }
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    }
    this.getCamera = function(camera) {
      cameraVR.near = cameraR.near = cameraL.near = camera.near;
      cameraVR.far = cameraR.far = cameraL.far = camera.far;
      if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
        session.updateRenderState({
          depthNear: cameraVR.near,
          depthFar: cameraVR.far
        });
        _currentDepthNear = cameraVR.near;
        _currentDepthFar = cameraVR.far;
      }
      const parent = camera.parent;
      const cameras2 = cameraVR.cameras;
      updateCamera(cameraVR, parent);
      for (let i = 0; i < cameras2.length; i++) {
        updateCamera(cameras2[i], parent);
      }
      camera.matrixWorld.copy(cameraVR.matrixWorld);
      camera.matrix.copy(cameraVR.matrix);
      camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
      const children = camera.children;
      for (let i = 0, l = children.length; i < l; i++) {
        children[i].updateMatrixWorld(true);
      }
      if (cameras2.length === 2) {
        setProjectionFromUnion(cameraVR, cameraL, cameraR);
      } else {
        cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
      }
      return cameraVR;
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time, frame) {
      pose = frame.getViewerPose(referenceSpace);
      if (pose !== null) {
        const views = pose.views;
        const baseLayer = session.renderState.baseLayer;
        state.bindXRFramebuffer(baseLayer.framebuffer);
        let cameraVRNeedsUpdate = false;
        if (views.length !== cameraVR.cameras.length) {
          cameraVR.cameras.length = 0;
          cameraVRNeedsUpdate = true;
        }
        for (let i = 0; i < views.length; i++) {
          const view = views[i];
          const viewport = baseLayer.getViewport(view);
          const camera = cameras[i];
          camera.matrix.fromArray(view.transform.matrix);
          camera.projectionMatrix.fromArray(view.projectionMatrix);
          camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
          if (i === 0) {
            cameraVR.matrix.copy(camera.matrix);
          }
          if (cameraVRNeedsUpdate === true) {
            cameraVR.cameras.push(camera);
          }
        }
      }
      const inputSources = session.inputSources;
      for (let i = 0; i < controllers.length; i++) {
        const controller = controllers[i];
        const inputSource = inputSources[i];
        controller.update(inputSource, frame, referenceSpace);
      }
      if (onAnimationFrameCallback)
        onAnimationFrameCallback(time, frame);
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
    };
    this.dispose = function() {
    };
  }
  Object.assign(WebXRManager.prototype, EventDispatcher.prototype);
  function WebGLMaterials(properties) {
    function refreshFogUniforms(uniforms, fog) {
      uniforms.fogColor.value.copy(fog.color);
      if (fog.isFog) {
        uniforms.fogNear.value = fog.near;
        uniforms.fogFar.value = fog.far;
      } else if (fog.isFogExp2) {
        uniforms.fogDensity.value = fog.density;
      }
    }
    function refreshMaterialUniforms(uniforms, material, pixelRatio, height) {
      if (material.isMeshBasicMaterial) {
        refreshUniformsCommon(uniforms, material);
      } else if (material.isMeshLambertMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsLambert(uniforms, material);
      } else if (material.isMeshToonMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsToon(uniforms, material);
      } else if (material.isMeshPhongMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsPhong(uniforms, material);
      } else if (material.isMeshStandardMaterial) {
        refreshUniformsCommon(uniforms, material);
        if (material.isMeshPhysicalMaterial) {
          refreshUniformsPhysical(uniforms, material);
        } else {
          refreshUniformsStandard(uniforms, material);
        }
      } else if (material.isMeshMatcapMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsMatcap(uniforms, material);
      } else if (material.isMeshDepthMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsDepth(uniforms, material);
      } else if (material.isMeshDistanceMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsDistance(uniforms, material);
      } else if (material.isMeshNormalMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsNormal(uniforms, material);
      } else if (material.isLineBasicMaterial) {
        refreshUniformsLine(uniforms, material);
        if (material.isLineDashedMaterial) {
          refreshUniformsDash(uniforms, material);
        }
      } else if (material.isPointsMaterial) {
        refreshUniformsPoints(uniforms, material, pixelRatio, height);
      } else if (material.isSpriteMaterial) {
        refreshUniformsSprites(uniforms, material);
      } else if (material.isShadowMaterial) {
        uniforms.color.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
      } else if (material.isShaderMaterial) {
        material.uniformsNeedUpdate = false;
      }
    }
    function refreshUniformsCommon(uniforms, material) {
      uniforms.opacity.value = material.opacity;
      if (material.color) {
        uniforms.diffuse.value.copy(material.color);
      }
      if (material.emissive) {
        uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
      }
      if (material.map) {
        uniforms.map.value = material.map;
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
      }
      if (material.specularMap) {
        uniforms.specularMap.value = material.specularMap;
      }
      const envMap = properties.get(material).envMap;
      if (envMap) {
        uniforms.envMap.value = envMap;
        uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap._needsFlipEnvMap ? -1 : 1;
        uniforms.reflectivity.value = material.reflectivity;
        uniforms.refractionRatio.value = material.refractionRatio;
        const maxMipLevel = properties.get(envMap).__maxMipLevel;
        if (maxMipLevel !== void 0) {
          uniforms.maxMipLevel.value = maxMipLevel;
        }
      }
      if (material.lightMap) {
        uniforms.lightMap.value = material.lightMap;
        uniforms.lightMapIntensity.value = material.lightMapIntensity;
      }
      if (material.aoMap) {
        uniforms.aoMap.value = material.aoMap;
        uniforms.aoMapIntensity.value = material.aoMapIntensity;
      }
      let uvScaleMap;
      if (material.map) {
        uvScaleMap = material.map;
      } else if (material.specularMap) {
        uvScaleMap = material.specularMap;
      } else if (material.displacementMap) {
        uvScaleMap = material.displacementMap;
      } else if (material.normalMap) {
        uvScaleMap = material.normalMap;
      } else if (material.bumpMap) {
        uvScaleMap = material.bumpMap;
      } else if (material.roughnessMap) {
        uvScaleMap = material.roughnessMap;
      } else if (material.metalnessMap) {
        uvScaleMap = material.metalnessMap;
      } else if (material.alphaMap) {
        uvScaleMap = material.alphaMap;
      } else if (material.emissiveMap) {
        uvScaleMap = material.emissiveMap;
      } else if (material.clearcoatMap) {
        uvScaleMap = material.clearcoatMap;
      } else if (material.clearcoatNormalMap) {
        uvScaleMap = material.clearcoatNormalMap;
      } else if (material.clearcoatRoughnessMap) {
        uvScaleMap = material.clearcoatRoughnessMap;
      }
      if (uvScaleMap !== void 0) {
        if (uvScaleMap.isWebGLRenderTarget) {
          uvScaleMap = uvScaleMap.texture;
        }
        if (uvScaleMap.matrixAutoUpdate === true) {
          uvScaleMap.updateMatrix();
        }
        uniforms.uvTransform.value.copy(uvScaleMap.matrix);
      }
      let uv2ScaleMap;
      if (material.aoMap) {
        uv2ScaleMap = material.aoMap;
      } else if (material.lightMap) {
        uv2ScaleMap = material.lightMap;
      }
      if (uv2ScaleMap !== void 0) {
        if (uv2ScaleMap.isWebGLRenderTarget) {
          uv2ScaleMap = uv2ScaleMap.texture;
        }
        if (uv2ScaleMap.matrixAutoUpdate === true) {
          uv2ScaleMap.updateMatrix();
        }
        uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
      }
    }
    function refreshUniformsLine(uniforms, material) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    }
    function refreshUniformsDash(uniforms, material) {
      uniforms.dashSize.value = material.dashSize;
      uniforms.totalSize.value = material.dashSize + material.gapSize;
      uniforms.scale.value = material.scale;
    }
    function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
      uniforms.size.value = material.size * pixelRatio;
      uniforms.scale.value = height * 0.5;
      if (material.map) {
        uniforms.map.value = material.map;
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
      }
      let uvScaleMap;
      if (material.map) {
        uvScaleMap = material.map;
      } else if (material.alphaMap) {
        uvScaleMap = material.alphaMap;
      }
      if (uvScaleMap !== void 0) {
        if (uvScaleMap.matrixAutoUpdate === true) {
          uvScaleMap.updateMatrix();
        }
        uniforms.uvTransform.value.copy(uvScaleMap.matrix);
      }
    }
    function refreshUniformsSprites(uniforms, material) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
      uniforms.rotation.value = material.rotation;
      if (material.map) {
        uniforms.map.value = material.map;
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
      }
      let uvScaleMap;
      if (material.map) {
        uvScaleMap = material.map;
      } else if (material.alphaMap) {
        uvScaleMap = material.alphaMap;
      }
      if (uvScaleMap !== void 0) {
        if (uvScaleMap.matrixAutoUpdate === true) {
          uvScaleMap.updateMatrix();
        }
        uniforms.uvTransform.value.copy(uvScaleMap.matrix);
      }
    }
    function refreshUniformsLambert(uniforms, material) {
      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
      }
    }
    function refreshUniformsPhong(uniforms, material) {
      uniforms.specular.value.copy(material.specular);
      uniforms.shininess.value = Math.max(material.shininess, 1e-4);
      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
      }
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide)
          uniforms.bumpScale.value *= -1;
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide)
          uniforms.normalScale.value.negate();
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }
    function refreshUniformsToon(uniforms, material) {
      if (material.gradientMap) {
        uniforms.gradientMap.value = material.gradientMap;
      }
      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
      }
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide)
          uniforms.bumpScale.value *= -1;
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide)
          uniforms.normalScale.value.negate();
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }
    function refreshUniformsStandard(uniforms, material) {
      uniforms.roughness.value = material.roughness;
      uniforms.metalness.value = material.metalness;
      if (material.roughnessMap) {
        uniforms.roughnessMap.value = material.roughnessMap;
      }
      if (material.metalnessMap) {
        uniforms.metalnessMap.value = material.metalnessMap;
      }
      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
      }
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide)
          uniforms.bumpScale.value *= -1;
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide)
          uniforms.normalScale.value.negate();
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
      const envMap = properties.get(material).envMap;
      if (envMap) {
        uniforms.envMapIntensity.value = material.envMapIntensity;
      }
    }
    function refreshUniformsPhysical(uniforms, material) {
      refreshUniformsStandard(uniforms, material);
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.clearcoat.value = material.clearcoat;
      uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
      if (material.sheen)
        uniforms.sheen.value.copy(material.sheen);
      if (material.clearcoatMap) {
        uniforms.clearcoatMap.value = material.clearcoatMap;
      }
      if (material.clearcoatRoughnessMap) {
        uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
      }
      if (material.clearcoatNormalMap) {
        uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
        uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
        if (material.side === BackSide) {
          uniforms.clearcoatNormalScale.value.negate();
        }
      }
      uniforms.transmission.value = material.transmission;
      if (material.transmissionMap) {
        uniforms.transmissionMap.value = material.transmissionMap;
      }
    }
    function refreshUniformsMatcap(uniforms, material) {
      if (material.matcap) {
        uniforms.matcap.value = material.matcap;
      }
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide)
          uniforms.bumpScale.value *= -1;
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide)
          uniforms.normalScale.value.negate();
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }
    function refreshUniformsDepth(uniforms, material) {
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }
    function refreshUniformsDistance(uniforms, material) {
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
      uniforms.referencePosition.value.copy(material.referencePosition);
      uniforms.nearDistance.value = material.nearDistance;
      uniforms.farDistance.value = material.farDistance;
    }
    function refreshUniformsNormal(uniforms, material) {
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide)
          uniforms.bumpScale.value *= -1;
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide)
          uniforms.normalScale.value.negate();
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }
    return {
      refreshFogUniforms,
      refreshMaterialUniforms
    };
  }
  function createCanvasElement() {
    const canvas2 = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    canvas2.style.display = "block";
    return canvas2;
  }
  function WebGLRenderer(parameters) {
    parameters = parameters || {};
    const _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement(), _context2 = parameters.context !== void 0 ? parameters.context : null, _alpha = parameters.alpha !== void 0 ? parameters.alpha : false, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
    let currentRenderList = null;
    let currentRenderState = null;
    const renderListStack = [];
    const renderStateStack = [];
    this.domElement = _canvas2;
    this.debug = {
      checkShaderErrors: true
    };
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.sortObjects = true;
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    this.gammaFactor = 2;
    this.outputEncoding = LinearEncoding;
    this.physicallyCorrectLights = false;
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1;
    const _this = this;
    let _isContextLost = false;
    let _currentActiveCubeFace = 0;
    let _currentActiveMipmapLevel = 0;
    let _currentRenderTarget = null;
    let _currentMaterialId = -1;
    let _currentCamera = null;
    const _currentViewport = new Vector4();
    const _currentScissor = new Vector4();
    let _currentScissorTest = null;
    let _width = _canvas2.width;
    let _height = _canvas2.height;
    let _pixelRatio = 1;
    let _opaqueSort = null;
    let _transparentSort = null;
    const _viewport = new Vector4(0, 0, _width, _height);
    const _scissor = new Vector4(0, 0, _width, _height);
    let _scissorTest = false;
    const _frustum = new Frustum();
    let _clippingEnabled = false;
    let _localClippingEnabled = false;
    const _projScreenMatrix2 = new Matrix4();
    const _vector3 = new Vector3();
    const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
    function getTargetPixelRatio() {
      return _currentRenderTarget === null ? _pixelRatio : 1;
    }
    let _gl = _context2;
    function getContext(contextNames, contextAttributes) {
      for (let i = 0; i < contextNames.length; i++) {
        const contextName = contextNames[i];
        const context = _canvas2.getContext(contextName, contextAttributes);
        if (context !== null)
          return context;
      }
      return null;
    }
    try {
      const contextAttributes = {
        alpha: _alpha,
        depth: _depth,
        stencil: _stencil,
        antialias: _antialias,
        premultipliedAlpha: _premultipliedAlpha,
        preserveDrawingBuffer: _preserveDrawingBuffer,
        powerPreference: _powerPreference,
        failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
      };
      _canvas2.addEventListener("webglcontextlost", onContextLost, false);
      _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
      if (_gl === null) {
        const contextNames = ["webgl2", "webgl", "experimental-webgl"];
        if (_this.isWebGL1Renderer === true) {
          contextNames.shift();
        }
        _gl = getContext(contextNames, contextAttributes);
        if (_gl === null) {
          if (getContext(contextNames)) {
            throw new Error("Error creating WebGL context with your selected attributes.");
          } else {
            throw new Error("Error creating WebGL context.");
          }
        }
      }
      if (_gl.getShaderPrecisionFormat === void 0) {
        _gl.getShaderPrecisionFormat = function() {
          return { "rangeMin": 1, "rangeMax": 1, "precision": 1 };
        };
      }
    } catch (error) {
      console.error("THREE.WebGLRenderer: " + error.message);
      throw error;
    }
    let extensions, capabilities, state, info2;
    let properties, textures, cubemaps, attributes, geometries, objects;
    let programCache, materials, renderLists, renderStates, clipping, shadowMap;
    let background, morphtargets, bufferRenderer, indexedBufferRenderer;
    let utils, bindingStates;
    function initGLContext() {
      extensions = new WebGLExtensions(_gl);
      capabilities = new WebGLCapabilities(_gl, extensions, parameters);
      extensions.init(capabilities);
      utils = new WebGLUtils(_gl, extensions, capabilities);
      state = new WebGLState(_gl, extensions, capabilities);
      info2 = new WebGLInfo(_gl);
      properties = new WebGLProperties();
      textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info2);
      cubemaps = new WebGLCubeMaps(_this);
      attributes = new WebGLAttributes(_gl, capabilities);
      bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
      geometries = new WebGLGeometries(_gl, attributes, info2, bindingStates);
      objects = new WebGLObjects(_gl, geometries, attributes, info2);
      morphtargets = new WebGLMorphtargets(_gl);
      clipping = new WebGLClipping(properties);
      programCache = new WebGLPrograms(_this, cubemaps, extensions, capabilities, bindingStates, clipping);
      materials = new WebGLMaterials(properties);
      renderLists = new WebGLRenderLists(properties);
      renderStates = new WebGLRenderStates(extensions, capabilities);
      background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);
      shadowMap = new WebGLShadowMap(_this, objects, capabilities);
      bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info2, capabilities);
      indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info2, capabilities);
      info2.programs = programCache.programs;
      _this.capabilities = capabilities;
      _this.extensions = extensions;
      _this.properties = properties;
      _this.renderLists = renderLists;
      _this.shadowMap = shadowMap;
      _this.state = state;
      _this.info = info2;
    }
    initGLContext();
    const xr2 = new WebXRManager(_this, _gl);
    this.xr = xr2;
    this.getContext = function() {
      return _gl;
    };
    this.getContextAttributes = function() {
      return _gl.getContextAttributes();
    };
    this.forceContextLoss = function() {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension)
        extension.loseContext();
    };
    this.forceContextRestore = function() {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension)
        extension.restoreContext();
    };
    this.getPixelRatio = function() {
      return _pixelRatio;
    };
    this.setPixelRatio = function(value) {
      if (value === void 0)
        return;
      _pixelRatio = value;
      this.setSize(_width, _height, false);
    };
    this.getSize = function(target) {
      if (target === void 0) {
        console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument");
        target = new Vector2();
      }
      return target.set(_width, _height);
    };
    this.setSize = function(width, height, updateStyle) {
      if (xr2.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      _width = width;
      _height = height;
      _canvas2.width = Math.floor(width * _pixelRatio);
      _canvas2.height = Math.floor(height * _pixelRatio);
      if (updateStyle !== false) {
        _canvas2.style.width = width + "px";
        _canvas2.style.height = height + "px";
      }
      this.setViewport(0, 0, width, height);
    };
    this.getDrawingBufferSize = function(target) {
      if (target === void 0) {
        console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument");
        target = new Vector2();
      }
      return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
    };
    this.setDrawingBufferSize = function(width, height, pixelRatio) {
      _width = width;
      _height = height;
      _pixelRatio = pixelRatio;
      _canvas2.width = Math.floor(width * pixelRatio);
      _canvas2.height = Math.floor(height * pixelRatio);
      this.setViewport(0, 0, width, height);
    };
    this.getCurrentViewport = function(target) {
      if (target === void 0) {
        console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument");
        target = new Vector4();
      }
      return target.copy(_currentViewport);
    };
    this.getViewport = function(target) {
      return target.copy(_viewport);
    };
    this.setViewport = function(x, y, width, height) {
      if (x.isVector4) {
        _viewport.set(x.x, x.y, x.z, x.w);
      } else {
        _viewport.set(x, y, width, height);
      }
      state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissor = function(target) {
      return target.copy(_scissor);
    };
    this.setScissor = function(x, y, width, height) {
      if (x.isVector4) {
        _scissor.set(x.x, x.y, x.z, x.w);
      } else {
        _scissor.set(x, y, width, height);
      }
      state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissorTest = function() {
      return _scissorTest;
    };
    this.setScissorTest = function(boolean) {
      state.setScissorTest(_scissorTest = boolean);
    };
    this.setOpaqueSort = function(method) {
      _opaqueSort = method;
    };
    this.setTransparentSort = function(method) {
      _transparentSort = method;
    };
    this.getClearColor = function(target) {
      if (target === void 0) {
        console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument");
        target = new Color();
      }
      return target.copy(background.getClearColor());
    };
    this.setClearColor = function() {
      background.setClearColor.apply(background, arguments);
    };
    this.getClearAlpha = function() {
      return background.getClearAlpha();
    };
    this.setClearAlpha = function() {
      background.setClearAlpha.apply(background, arguments);
    };
    this.clear = function(color, depth, stencil) {
      let bits = 0;
      if (color === void 0 || color)
        bits |= 16384;
      if (depth === void 0 || depth)
        bits |= 256;
      if (stencil === void 0 || stencil)
        bits |= 1024;
      _gl.clear(bits);
    };
    this.clearColor = function() {
      this.clear(true, false, false);
    };
    this.clearDepth = function() {
      this.clear(false, true, false);
    };
    this.clearStencil = function() {
      this.clear(false, false, true);
    };
    this.dispose = function() {
      _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
      _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
      renderLists.dispose();
      renderStates.dispose();
      properties.dispose();
      cubemaps.dispose();
      objects.dispose();
      bindingStates.dispose();
      xr2.dispose();
      xr2.removeEventListener("sessionstart", onXRSessionStart);
      xr2.removeEventListener("sessionend", onXRSessionEnd);
      animation.stop();
    };
    function onContextLost(event) {
      event.preventDefault();
      console.log("THREE.WebGLRenderer: Context Lost.");
      _isContextLost = true;
    }
    function onContextRestore() {
      console.log("THREE.WebGLRenderer: Context Restored.");
      _isContextLost = false;
      const infoAutoReset = info2.autoReset;
      const shadowMapEnabled = shadowMap.enabled;
      const shadowMapAutoUpdate = shadowMap.autoUpdate;
      const shadowMapNeedsUpdate = shadowMap.needsUpdate;
      const shadowMapType = shadowMap.type;
      initGLContext();
      info2.autoReset = infoAutoReset;
      shadowMap.enabled = shadowMapEnabled;
      shadowMap.autoUpdate = shadowMapAutoUpdate;
      shadowMap.needsUpdate = shadowMapNeedsUpdate;
      shadowMap.type = shadowMapType;
    }
    function onMaterialDispose(event) {
      const material = event.target;
      material.removeEventListener("dispose", onMaterialDispose);
      deallocateMaterial(material);
    }
    function deallocateMaterial(material) {
      releaseMaterialProgramReferences(material);
      properties.remove(material);
    }
    function releaseMaterialProgramReferences(material) {
      const programs = properties.get(material).programs;
      if (programs !== void 0) {
        programs.forEach(function(program) {
          programCache.releaseProgram(program);
        });
      }
    }
    function renderObjectImmediate(object, program) {
      object.render(function(object2) {
        _this.renderBufferImmediate(object2, program);
      });
    }
    this.renderBufferImmediate = function(object, program) {
      bindingStates.initAttributes();
      const buffers = properties.get(object);
      if (object.hasPositions && !buffers.position)
        buffers.position = _gl.createBuffer();
      if (object.hasNormals && !buffers.normal)
        buffers.normal = _gl.createBuffer();
      if (object.hasUvs && !buffers.uv)
        buffers.uv = _gl.createBuffer();
      if (object.hasColors && !buffers.color)
        buffers.color = _gl.createBuffer();
      const programAttributes = program.getAttributes();
      if (object.hasPositions) {
        _gl.bindBuffer(34962, buffers.position);
        _gl.bufferData(34962, object.positionArray, 35048);
        bindingStates.enableAttribute(programAttributes.position);
        _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
      }
      if (object.hasNormals) {
        _gl.bindBuffer(34962, buffers.normal);
        _gl.bufferData(34962, object.normalArray, 35048);
        bindingStates.enableAttribute(programAttributes.normal);
        _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
      }
      if (object.hasUvs) {
        _gl.bindBuffer(34962, buffers.uv);
        _gl.bufferData(34962, object.uvArray, 35048);
        bindingStates.enableAttribute(programAttributes.uv);
        _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
      }
      if (object.hasColors) {
        _gl.bindBuffer(34962, buffers.color);
        _gl.bufferData(34962, object.colorArray, 35048);
        bindingStates.enableAttribute(programAttributes.color);
        _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
      }
      bindingStates.disableUnusedAttributes();
      _gl.drawArrays(4, 0, object.count);
      object.count = 0;
    };
    this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
      if (scene === null)
        scene = _emptyScene;
      const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
      const program = setProgram(camera, scene, material, object);
      state.setMaterial(material, frontFaceCW);
      let index = geometry.index;
      const position = geometry.attributes.position;
      if (index === null) {
        if (position === void 0 || position.count === 0)
          return;
      } else if (index.count === 0) {
        return;
      }
      let rangeFactor = 1;
      if (material.wireframe === true) {
        index = geometries.getWireframeAttribute(geometry);
        rangeFactor = 2;
      }
      if (material.morphTargets || material.morphNormals) {
        morphtargets.update(object, geometry, material, program);
      }
      bindingStates.setup(object, material, program, geometry, index);
      let attribute;
      let renderer = bufferRenderer;
      if (index !== null) {
        attribute = attributes.get(index);
        renderer = indexedBufferRenderer;
        renderer.setIndex(attribute);
      }
      const dataCount = index !== null ? index.count : position.count;
      const rangeStart = geometry.drawRange.start * rangeFactor;
      const rangeCount = geometry.drawRange.count * rangeFactor;
      const groupStart = group !== null ? group.start * rangeFactor : 0;
      const groupCount = group !== null ? group.count * rangeFactor : Infinity;
      const drawStart = Math.max(rangeStart, groupStart);
      const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
      const drawCount = Math.max(0, drawEnd - drawStart + 1);
      if (drawCount === 0)
        return;
      if (object.isMesh) {
        if (material.wireframe === true) {
          state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
          renderer.setMode(1);
        } else {
          renderer.setMode(4);
        }
      } else if (object.isLine) {
        let lineWidth = material.linewidth;
        if (lineWidth === void 0)
          lineWidth = 1;
        state.setLineWidth(lineWidth * getTargetPixelRatio());
        if (object.isLineSegments) {
          renderer.setMode(1);
        } else if (object.isLineLoop) {
          renderer.setMode(2);
        } else {
          renderer.setMode(3);
        }
      } else if (object.isPoints) {
        renderer.setMode(0);
      } else if (object.isSprite) {
        renderer.setMode(4);
      }
      if (object.isInstancedMesh) {
        renderer.renderInstances(drawStart, drawCount, object.count);
      } else if (geometry.isInstancedBufferGeometry) {
        const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
        renderer.renderInstances(drawStart, drawCount, instanceCount);
      } else {
        renderer.render(drawStart, drawCount);
      }
    };
    this.compile = function(scene, camera) {
      currentRenderState = renderStates.get(scene);
      currentRenderState.init();
      scene.traverseVisible(function(object) {
        if (object.isLight && object.layers.test(camera.layers)) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        }
      });
      currentRenderState.setupLights();
      scene.traverse(function(object) {
        const material = object.material;
        if (material) {
          if (Array.isArray(material)) {
            for (let i = 0; i < material.length; i++) {
              const material2 = material[i];
              getProgram(material2, scene, object);
            }
          } else {
            getProgram(material, scene, object);
          }
        }
      });
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time) {
      if (onAnimationFrameCallback)
        onAnimationFrameCallback(time);
    }
    function onXRSessionStart() {
      animation.stop();
    }
    function onXRSessionEnd() {
      animation.start();
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    if (typeof window !== "undefined")
      animation.setContext(window);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
      xr2.setAnimationLoop(callback);
      callback === null ? animation.stop() : animation.start();
    };
    xr2.addEventListener("sessionstart", onXRSessionStart);
    xr2.addEventListener("sessionend", onXRSessionEnd);
    this.render = function(scene, camera) {
      let renderTarget, forceClear;
      if (arguments[2] !== void 0) {
        console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
        renderTarget = arguments[2];
      }
      if (arguments[3] !== void 0) {
        console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
        forceClear = arguments[3];
      }
      if (camera !== void 0 && camera.isCamera !== true) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (_isContextLost === true)
        return;
      if (scene.autoUpdate === true)
        scene.updateMatrixWorld();
      if (camera.parent === null)
        camera.updateMatrixWorld();
      if (xr2.enabled === true && xr2.isPresenting === true) {
        camera = xr2.getCamera(camera);
      }
      if (scene.isScene === true)
        scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);
      currentRenderState = renderStates.get(scene, renderStateStack.length);
      currentRenderState.init();
      renderStateStack.push(currentRenderState);
      _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      _frustum.setFromProjectionMatrix(_projScreenMatrix2);
      _localClippingEnabled = this.localClippingEnabled;
      _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
      currentRenderList = renderLists.get(scene, renderListStack.length);
      currentRenderList.init();
      renderListStack.push(currentRenderList);
      projectObject(scene, camera, 0, _this.sortObjects);
      currentRenderList.finish();
      if (_this.sortObjects === true) {
        currentRenderList.sort(_opaqueSort, _transparentSort);
      }
      if (_clippingEnabled === true)
        clipping.beginShadows();
      const shadowsArray = currentRenderState.state.shadowsArray;
      shadowMap.render(shadowsArray, scene, camera);
      currentRenderState.setupLights();
      currentRenderState.setupLightsView(camera);
      if (_clippingEnabled === true)
        clipping.endShadows();
      if (this.info.autoReset === true)
        this.info.reset();
      if (renderTarget !== void 0) {
        this.setRenderTarget(renderTarget);
      }
      background.render(currentRenderList, scene, camera, forceClear);
      const opaqueObjects = currentRenderList.opaque;
      const transparentObjects = currentRenderList.transparent;
      if (opaqueObjects.length > 0)
        renderObjects(opaqueObjects, scene, camera);
      if (transparentObjects.length > 0)
        renderObjects(transparentObjects, scene, camera);
      if (_currentRenderTarget !== null) {
        textures.updateRenderTargetMipmap(_currentRenderTarget);
        textures.updateMultisampleRenderTarget(_currentRenderTarget);
      }
      if (scene.isScene === true)
        scene.onAfterRender(_this, scene, camera);
      state.buffers.depth.setTest(true);
      state.buffers.depth.setMask(true);
      state.buffers.color.setMask(true);
      state.setPolygonOffset(false);
      bindingStates.resetDefaultState();
      _currentMaterialId = -1;
      _currentCamera = null;
      renderStateStack.pop();
      if (renderStateStack.length > 0) {
        currentRenderState = renderStateStack[renderStateStack.length - 1];
      } else {
        currentRenderState = null;
      }
      renderListStack.pop();
      if (renderListStack.length > 0) {
        currentRenderList = renderListStack[renderListStack.length - 1];
      } else {
        currentRenderList = null;
      }
    };
    function projectObject(object, camera, groupOrder, sortObjects) {
      if (object.visible === false)
        return;
      const visible = object.layers.test(camera.layers);
      if (visible) {
        if (object.isGroup) {
          groupOrder = object.renderOrder;
        } else if (object.isLOD) {
          if (object.autoUpdate === true)
            object.update(camera);
        } else if (object.isLight) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        } else if (object.isSprite) {
          if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
            if (sortObjects) {
              _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
            }
            const geometry = objects.update(object);
            const material = object.material;
            if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
            }
          }
        } else if (object.isImmediateRenderObject) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
        } else if (object.isMesh || object.isLine || object.isPoints) {
          if (object.isSkinnedMesh) {
            if (object.skeleton.frame !== info2.render.frame) {
              object.skeleton.update();
              object.skeleton.frame = info2.render.frame;
            }
          }
          if (!object.frustumCulled || _frustum.intersectsObject(object)) {
            if (sortObjects) {
              _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
            }
            const geometry = objects.update(object);
            const material = object.material;
            if (Array.isArray(material)) {
              const groups = geometry.groups;
              for (let i = 0, l = groups.length; i < l; i++) {
                const group = groups[i];
                const groupMaterial = material[group.materialIndex];
                if (groupMaterial && groupMaterial.visible) {
                  currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
                }
              }
            } else if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
            }
          }
        }
      }
      const children = object.children;
      for (let i = 0, l = children.length; i < l; i++) {
        projectObject(children[i], camera, groupOrder, sortObjects);
      }
    }
    function renderObjects(renderList, scene, camera) {
      const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
      for (let i = 0, l = renderList.length; i < l; i++) {
        const renderItem = renderList[i];
        const object = renderItem.object;
        const geometry = renderItem.geometry;
        const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
        const group = renderItem.group;
        if (camera.isArrayCamera) {
          const cameras = camera.cameras;
          for (let j = 0, jl = cameras.length; j < jl; j++) {
            const camera2 = cameras[j];
            if (object.layers.test(camera2.layers)) {
              state.viewport(_currentViewport.copy(camera2.viewport));
              currentRenderState.setupLightsView(camera2);
              renderObject(object, scene, camera2, geometry, material, group);
            }
          }
        } else {
          renderObject(object, scene, camera, geometry, material, group);
        }
      }
    }
    function renderObject(object, scene, camera, geometry, material, group) {
      object.onBeforeRender(_this, scene, camera, geometry, material, group);
      object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
      object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
      if (object.isImmediateRenderObject) {
        const program = setProgram(camera, scene, material, object);
        state.setMaterial(material);
        bindingStates.reset();
        renderObjectImmediate(object, program);
      } else {
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
      }
      object.onAfterRender(_this, scene, camera, geometry, material, group);
    }
    function getProgram(material, scene, object) {
      if (scene.isScene !== true)
        scene = _emptyScene;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      const shadowsArray = currentRenderState.state.shadowsArray;
      const lightsStateVersion = lights.state.version;
      const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
      const programCacheKey = programCache.getProgramCacheKey(parameters2);
      let programs = materialProperties.programs;
      materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
      materialProperties.fog = scene.fog;
      materialProperties.envMap = cubemaps.get(material.envMap || materialProperties.environment);
      if (programs === void 0) {
        material.addEventListener("dispose", onMaterialDispose);
        programs = new Map();
        materialProperties.programs = programs;
      }
      let program = programs.get(programCacheKey);
      if (program !== void 0) {
        if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
          updateCommonMaterialProperties(material, parameters2);
          return program;
        }
      } else {
        parameters2.uniforms = programCache.getUniforms(material);
        material.onBeforeCompile(parameters2, _this);
        program = programCache.acquireProgram(parameters2, programCacheKey);
        programs.set(programCacheKey, program);
        materialProperties.uniforms = parameters2.uniforms;
      }
      const uniforms = materialProperties.uniforms;
      if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
        uniforms.clippingPlanes = clipping.uniform;
      }
      updateCommonMaterialProperties(material, parameters2);
      materialProperties.needsLights = materialNeedsLights(material);
      materialProperties.lightsStateVersion = lightsStateVersion;
      if (materialProperties.needsLights) {
        uniforms.ambientLightColor.value = lights.state.ambient;
        uniforms.lightProbe.value = lights.state.probe;
        uniforms.directionalLights.value = lights.state.directional;
        uniforms.directionalLightShadows.value = lights.state.directionalShadow;
        uniforms.spotLights.value = lights.state.spot;
        uniforms.spotLightShadows.value = lights.state.spotShadow;
        uniforms.rectAreaLights.value = lights.state.rectArea;
        uniforms.ltc_1.value = lights.state.rectAreaLTC1;
        uniforms.ltc_2.value = lights.state.rectAreaLTC2;
        uniforms.pointLights.value = lights.state.point;
        uniforms.pointLightShadows.value = lights.state.pointShadow;
        uniforms.hemisphereLights.value = lights.state.hemi;
        uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
        uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
        uniforms.spotShadowMap.value = lights.state.spotShadowMap;
        uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
        uniforms.pointShadowMap.value = lights.state.pointShadowMap;
        uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
      }
      const progUniforms = program.getUniforms();
      const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
      materialProperties.currentProgram = program;
      materialProperties.uniformsList = uniformsList;
      return program;
    }
    function updateCommonMaterialProperties(material, parameters2) {
      const materialProperties = properties.get(material);
      materialProperties.outputEncoding = parameters2.outputEncoding;
      materialProperties.instancing = parameters2.instancing;
      materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
      materialProperties.numIntersection = parameters2.numClipIntersection;
      materialProperties.vertexAlphas = parameters2.vertexAlphas;
    }
    function setProgram(camera, scene, material, object) {
      if (scene.isScene !== true)
        scene = _emptyScene;
      textures.resetTextureUnits();
      const fog = scene.fog;
      const environment = material.isMeshStandardMaterial ? scene.environment : null;
      const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
      const envMap = cubemaps.get(material.envMap || environment);
      const vertexAlphas = material.vertexColors === true && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      if (_clippingEnabled === true) {
        if (_localClippingEnabled === true || camera !== _currentCamera) {
          const useCache = camera === _currentCamera && material.id === _currentMaterialId;
          clipping.setState(material, camera, useCache);
        }
      }
      let needsProgramChange = false;
      if (material.version === materialProperties.__version) {
        if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
          needsProgramChange = true;
        } else if (materialProperties.outputEncoding !== encoding) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancing === false) {
          needsProgramChange = true;
        } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
          needsProgramChange = true;
        } else if (materialProperties.envMap !== envMap) {
          needsProgramChange = true;
        } else if (material.fog && materialProperties.fog !== fog) {
          needsProgramChange = true;
        } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
          needsProgramChange = true;
        } else if (materialProperties.vertexAlphas !== vertexAlphas) {
          needsProgramChange = true;
        }
      } else {
        needsProgramChange = true;
        materialProperties.__version = material.version;
      }
      let program = materialProperties.currentProgram;
      if (needsProgramChange === true) {
        program = getProgram(material, scene, object);
      }
      let refreshProgram = false;
      let refreshMaterial = false;
      let refreshLights = false;
      const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
      if (state.useProgram(program.program)) {
        refreshProgram = true;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.id !== _currentMaterialId) {
        _currentMaterialId = material.id;
        refreshMaterial = true;
      }
      if (refreshProgram || _currentCamera !== camera) {
        p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
        if (capabilities.logarithmicDepthBuffer) {
          p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2));
        }
        if (_currentCamera !== camera) {
          _currentCamera = camera;
          refreshMaterial = true;
          refreshLights = true;
        }
        if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
          const uCamPos = p_uniforms.map.cameraPosition;
          if (uCamPos !== void 0) {
            uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
          }
        }
        if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
          p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
        }
        if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || material.skinning) {
          p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
        }
      }
      if (material.skinning) {
        p_uniforms.setOptional(_gl, object, "bindMatrix");
        p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
        const skeleton = object.skeleton;
        if (skeleton) {
          const bones = skeleton.bones;
          if (capabilities.floatVertexTextures) {
            if (skeleton.boneTexture === null) {
              let size2 = Math.sqrt(bones.length * 4);
              size2 = MathUtils.ceilPowerOfTwo(size2);
              size2 = Math.max(size2, 4);
              const boneMatrices = new Float32Array(size2 * size2 * 4);
              boneMatrices.set(skeleton.boneMatrices);
              const boneTexture = new DataTexture(boneMatrices, size2, size2, RGBAFormat, FloatType);
              skeleton.boneMatrices = boneMatrices;
              skeleton.boneTexture = boneTexture;
              skeleton.boneTextureSize = size2;
            }
            p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
            p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
          } else {
            p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
          }
        }
      }
      if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
        materialProperties.receiveShadow = object.receiveShadow;
        p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
      }
      if (refreshMaterial) {
        p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
        if (materialProperties.needsLights) {
          markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
        }
        if (fog && material.fog) {
          materials.refreshFogUniforms(m_uniforms, fog);
        }
        materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height);
        WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      }
      if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
        WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
        material.uniformsNeedUpdate = false;
      }
      if (material.isSpriteMaterial) {
        p_uniforms.setValue(_gl, "center", object.center);
      }
      p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
      p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
      p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
      return program;
    }
    function markUniformsLightsNeedsUpdate(uniforms, value) {
      uniforms.ambientLightColor.needsUpdate = value;
      uniforms.lightProbe.needsUpdate = value;
      uniforms.directionalLights.needsUpdate = value;
      uniforms.directionalLightShadows.needsUpdate = value;
      uniforms.pointLights.needsUpdate = value;
      uniforms.pointLightShadows.needsUpdate = value;
      uniforms.spotLights.needsUpdate = value;
      uniforms.spotLightShadows.needsUpdate = value;
      uniforms.rectAreaLights.needsUpdate = value;
      uniforms.hemisphereLights.needsUpdate = value;
    }
    function materialNeedsLights(material) {
      return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
    }
    this.getActiveCubeFace = function() {
      return _currentActiveCubeFace;
    };
    this.getActiveMipmapLevel = function() {
      return _currentActiveMipmapLevel;
    };
    this.getRenderTarget = function() {
      return _currentRenderTarget;
    };
    this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
      _currentRenderTarget = renderTarget;
      _currentActiveCubeFace = activeCubeFace;
      _currentActiveMipmapLevel = activeMipmapLevel;
      if (renderTarget && properties.get(renderTarget).__webglFramebuffer === void 0) {
        textures.setupRenderTarget(renderTarget);
      }
      let framebuffer = null;
      let isCube = false;
      let isRenderTarget3D = false;
      if (renderTarget) {
        const texture = renderTarget.texture;
        if (texture.isDataTexture3D || texture.isDataTexture2DArray) {
          isRenderTarget3D = true;
        }
        const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget) {
          framebuffer = __webglFramebuffer[activeCubeFace];
          isCube = true;
        } else if (renderTarget.isWebGLMultisampleRenderTarget) {
          framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
        } else {
          framebuffer = __webglFramebuffer;
        }
        _currentViewport.copy(renderTarget.viewport);
        _currentScissor.copy(renderTarget.scissor);
        _currentScissorTest = renderTarget.scissorTest;
      } else {
        _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
        _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
        _currentScissorTest = _scissorTest;
      }
      state.bindFramebuffer(36160, framebuffer);
      state.viewport(_currentViewport);
      state.scissor(_currentScissor);
      state.setScissorTest(_currentScissorTest);
      if (isCube) {
        const textureProperties = properties.get(renderTarget.texture);
        _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
      } else if (isRenderTarget3D) {
        const textureProperties = properties.get(renderTarget.texture);
        const layer = activeCubeFace || 0;
        _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
      }
    };
    this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
      if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let framebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
        framebuffer = framebuffer[activeCubeFaceIndex];
      }
      if (framebuffer) {
        state.bindFramebuffer(36160, framebuffer);
        try {
          const texture = renderTarget.texture;
          const textureFormat = texture.format;
          const textureType = texture.type;
          if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
          if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && !halfFloatSupportedByExt) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          if (_gl.checkFramebufferStatus(36160) === 36053) {
            if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {
              _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
            }
          } else {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
          }
        } finally {
          const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
          state.bindFramebuffer(36160, framebuffer2);
        }
      }
    };
    this.copyFramebufferToTexture = function(position, texture, level = 0) {
      const levelScale = Math.pow(2, -level);
      const width = Math.floor(texture.image.width * levelScale);
      const height = Math.floor(texture.image.height * levelScale);
      const glFormat = utils.convert(texture.format);
      textures.setTexture2D(texture, 0);
      _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0);
      state.unbindTexture();
    };
    this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
      const width = srcTexture.image.width;
      const height = srcTexture.image.height;
      const glFormat = utils.convert(dstTexture.format);
      const glType = utils.convert(dstTexture.type);
      textures.setTexture2D(dstTexture, 0);
      _gl.pixelStorei(37440, dstTexture.flipY);
      _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(3317, dstTexture.unpackAlignment);
      if (srcTexture.isDataTexture) {
        _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
      } else {
        if (srcTexture.isCompressedTexture) {
          _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
        } else {
          _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
        }
      }
      if (level === 0 && dstTexture.generateMipmaps)
        _gl.generateMipmap(3553);
      state.unbindTexture();
    };
    this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
      if (_this.isWebGL1Renderer) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        return;
      }
      const { width, height, data } = srcTexture.image;
      const glFormat = utils.convert(dstTexture.format);
      const glType = utils.convert(dstTexture.type);
      let glTarget;
      if (dstTexture.isDataTexture3D) {
        textures.setTexture3D(dstTexture, 0);
        glTarget = 32879;
      } else if (dstTexture.isDataTexture2DArray) {
        textures.setTexture2DArray(dstTexture, 0);
        glTarget = 35866;
      } else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      _gl.pixelStorei(37440, dstTexture.flipY);
      _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(3317, dstTexture.unpackAlignment);
      const unpackRowLen = _gl.getParameter(3314);
      const unpackImageHeight = _gl.getParameter(32878);
      const unpackSkipPixels = _gl.getParameter(3316);
      const unpackSkipRows = _gl.getParameter(3315);
      const unpackSkipImages = _gl.getParameter(32877);
      _gl.pixelStorei(3314, width);
      _gl.pixelStorei(32878, height);
      _gl.pixelStorei(3316, sourceBox.min.x);
      _gl.pixelStorei(3315, sourceBox.min.y);
      _gl.pixelStorei(32877, sourceBox.min.z);
      _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, sourceBox.max.x - sourceBox.min.x + 1, sourceBox.max.y - sourceBox.min.y + 1, sourceBox.max.z - sourceBox.min.z + 1, glFormat, glType, data);
      _gl.pixelStorei(3314, unpackRowLen);
      _gl.pixelStorei(32878, unpackImageHeight);
      _gl.pixelStorei(3316, unpackSkipPixels);
      _gl.pixelStorei(3315, unpackSkipRows);
      _gl.pixelStorei(32877, unpackSkipImages);
      if (level === 0 && dstTexture.generateMipmaps)
        _gl.generateMipmap(glTarget);
      state.unbindTexture();
    };
    this.initTexture = function(texture) {
      textures.setTexture2D(texture, 0);
      state.unbindTexture();
    };
    this.resetState = function() {
      _currentActiveCubeFace = 0;
      _currentActiveMipmapLevel = 0;
      _currentRenderTarget = null;
      state.reset();
      bindingStates.reset();
    };
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  var WebGL1Renderer = class extends WebGLRenderer {
  };
  WebGL1Renderer.prototype.isWebGL1Renderer = true;
  var FogExp2 = class {
    constructor(color, density = 25e-5) {
      this.name = "";
      this.color = new Color(color);
      this.density = density;
    }
    clone() {
      return new FogExp2(this.color, this.density);
    }
    toJSON() {
      return {
        type: "FogExp2",
        color: this.color.getHex(),
        density: this.density
      };
    }
  };
  FogExp2.prototype.isFogExp2 = true;
  var Fog = class {
    constructor(color, near = 1, far = 1e3) {
      this.name = "";
      this.color = new Color(color);
      this.near = near;
      this.far = far;
    }
    clone() {
      return new Fog(this.color, this.near, this.far);
    }
    toJSON() {
      return {
        type: "Fog",
        color: this.color.getHex(),
        near: this.near,
        far: this.far
      };
    }
  };
  Fog.prototype.isFog = true;
  var Scene = class extends Object3D {
    constructor() {
      super();
      this.type = "Scene";
      this.background = null;
      this.environment = null;
      this.fog = null;
      this.overrideMaterial = null;
      this.autoUpdate = true;
      if (typeof __THREE_DEVTOOLS__ !== "undefined") {
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
      }
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      if (source.background !== null)
        this.background = source.background.clone();
      if (source.environment !== null)
        this.environment = source.environment.clone();
      if (source.fog !== null)
        this.fog = source.fog.clone();
      if (source.overrideMaterial !== null)
        this.overrideMaterial = source.overrideMaterial.clone();
      this.autoUpdate = source.autoUpdate;
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      return this;
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      if (this.background !== null)
        data.object.background = this.background.toJSON(meta);
      if (this.environment !== null)
        data.object.environment = this.environment.toJSON(meta);
      if (this.fog !== null)
        data.object.fog = this.fog.toJSON();
      return data;
    }
  };
  Scene.prototype.isScene = true;
  function InterleavedBuffer(array, stride) {
    this.array = array;
    this.stride = stride;
    this.count = array !== void 0 ? array.length / stride : 0;
    this.usage = StaticDrawUsage;
    this.updateRange = { offset: 0, count: -1 };
    this.version = 0;
    this.uuid = MathUtils.generateUUID();
  }
  Object.defineProperty(InterleavedBuffer.prototype, "needsUpdate", {
    set: function(value) {
      if (value === true)
        this.version++;
    }
  });
  Object.assign(InterleavedBuffer.prototype, {
    isInterleavedBuffer: true,
    onUploadCallback: function() {
    },
    setUsage: function(value) {
      this.usage = value;
      return this;
    },
    copy: function(source) {
      this.array = new source.array.constructor(source.array);
      this.count = source.count;
      this.stride = source.stride;
      this.usage = source.usage;
      return this;
    },
    copyAt: function(index1, attribute, index2) {
      index1 *= this.stride;
      index2 *= attribute.stride;
      for (let i = 0, l = this.stride; i < l; i++) {
        this.array[index1 + i] = attribute.array[index2 + i];
      }
      return this;
    },
    set: function(value, offset = 0) {
      this.array.set(value, offset);
      return this;
    },
    clone: function(data) {
      if (data.arrayBuffers === void 0) {
        data.arrayBuffers = {};
      }
      if (this.array.buffer._uuid === void 0) {
        this.array.buffer._uuid = MathUtils.generateUUID();
      }
      if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
        data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
      }
      const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
      const ib = new InterleavedBuffer(array, this.stride);
      ib.setUsage(this.usage);
      return ib;
    },
    onUpload: function(callback) {
      this.onUploadCallback = callback;
      return this;
    },
    toJSON: function(data) {
      if (data.arrayBuffers === void 0) {
        data.arrayBuffers = {};
      }
      if (this.array.buffer._uuid === void 0) {
        this.array.buffer._uuid = MathUtils.generateUUID();
      }
      if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
        data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
      }
      return {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride
      };
    }
  });
  var _vector$6 = new Vector3();
  function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
    this.name = "";
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized === true;
  }
  Object.defineProperties(InterleavedBufferAttribute.prototype, {
    count: {
      get: function() {
        return this.data.count;
      }
    },
    array: {
      get: function() {
        return this.data.array;
      }
    },
    needsUpdate: {
      set: function(value) {
        this.data.needsUpdate = value;
      }
    }
  });
  Object.assign(InterleavedBufferAttribute.prototype, {
    isInterleavedBufferAttribute: true,
    applyMatrix4: function(m) {
      for (let i = 0, l = this.data.count; i < l; i++) {
        _vector$6.x = this.getX(i);
        _vector$6.y = this.getY(i);
        _vector$6.z = this.getZ(i);
        _vector$6.applyMatrix4(m);
        this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
      }
      return this;
    },
    applyNormalMatrix: function(m) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$6.x = this.getX(i);
        _vector$6.y = this.getY(i);
        _vector$6.z = this.getZ(i);
        _vector$6.applyNormalMatrix(m);
        this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
      }
      return this;
    },
    transformDirection: function(m) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$6.x = this.getX(i);
        _vector$6.y = this.getY(i);
        _vector$6.z = this.getZ(i);
        _vector$6.transformDirection(m);
        this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
      }
      return this;
    },
    setX: function(index, x) {
      this.data.array[index * this.data.stride + this.offset] = x;
      return this;
    },
    setY: function(index, y) {
      this.data.array[index * this.data.stride + this.offset + 1] = y;
      return this;
    },
    setZ: function(index, z) {
      this.data.array[index * this.data.stride + this.offset + 2] = z;
      return this;
    },
    setW: function(index, w) {
      this.data.array[index * this.data.stride + this.offset + 3] = w;
      return this;
    },
    getX: function(index) {
      return this.data.array[index * this.data.stride + this.offset];
    },
    getY: function(index) {
      return this.data.array[index * this.data.stride + this.offset + 1];
    },
    getZ: function(index) {
      return this.data.array[index * this.data.stride + this.offset + 2];
    },
    getW: function(index) {
      return this.data.array[index * this.data.stride + this.offset + 3];
    },
    setXY: function(index, x, y) {
      index = index * this.data.stride + this.offset;
      this.data.array[index + 0] = x;
      this.data.array[index + 1] = y;
      return this;
    },
    setXYZ: function(index, x, y, z) {
      index = index * this.data.stride + this.offset;
      this.data.array[index + 0] = x;
      this.data.array[index + 1] = y;
      this.data.array[index + 2] = z;
      return this;
    },
    setXYZW: function(index, x, y, z, w) {
      index = index * this.data.stride + this.offset;
      this.data.array[index + 0] = x;
      this.data.array[index + 1] = y;
      this.data.array[index + 2] = z;
      this.data.array[index + 3] = w;
      return this;
    },
    clone: function(data) {
      if (data === void 0) {
        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
        const array = [];
        for (let i = 0; i < this.count; i++) {
          const index = i * this.data.stride + this.offset;
          for (let j = 0; j < this.itemSize; j++) {
            array.push(this.data.array[index + j]);
          }
        }
        return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
      } else {
        if (data.interleavedBuffers === void 0) {
          data.interleavedBuffers = {};
        }
        if (data.interleavedBuffers[this.data.uuid] === void 0) {
          data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
        }
        return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
      }
    },
    toJSON: function(data) {
      if (data === void 0) {
        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
        const array = [];
        for (let i = 0; i < this.count; i++) {
          const index = i * this.data.stride + this.offset;
          for (let j = 0; j < this.itemSize; j++) {
            array.push(this.data.array[index + j]);
          }
        }
        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array,
          normalized: this.normalized
        };
      } else {
        if (data.interleavedBuffers === void 0) {
          data.interleavedBuffers = {};
        }
        if (data.interleavedBuffers[this.data.uuid] === void 0) {
          data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
        }
        return {
          isInterleavedBufferAttribute: true,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized
        };
      }
    }
  });
  var SpriteMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "SpriteMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.alphaMap = null;
      this.rotation = 0;
      this.sizeAttenuation = true;
      this.transparent = true;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.rotation = source.rotation;
      this.sizeAttenuation = source.sizeAttenuation;
      return this;
    }
  };
  SpriteMaterial.prototype.isSpriteMaterial = true;
  var _geometry;
  var _intersectPoint = /* @__PURE__ */ new Vector3();
  var _worldScale = /* @__PURE__ */ new Vector3();
  var _mvPosition = /* @__PURE__ */ new Vector3();
  var _alignedPosition = /* @__PURE__ */ new Vector2();
  var _rotatedPosition = /* @__PURE__ */ new Vector2();
  var _viewWorldMatrix = /* @__PURE__ */ new Matrix4();
  var _vA = /* @__PURE__ */ new Vector3();
  var _vB = /* @__PURE__ */ new Vector3();
  var _vC = /* @__PURE__ */ new Vector3();
  var _uvA = /* @__PURE__ */ new Vector2();
  var _uvB = /* @__PURE__ */ new Vector2();
  var _uvC = /* @__PURE__ */ new Vector2();
  var Sprite = class extends Object3D {
    constructor(material) {
      super();
      this.type = "Sprite";
      if (_geometry === void 0) {
        _geometry = new BufferGeometry();
        const float32Array = new Float32Array([
          -0.5,
          -0.5,
          0,
          0,
          0,
          0.5,
          -0.5,
          0,
          1,
          0,
          0.5,
          0.5,
          0,
          1,
          1,
          -0.5,
          0.5,
          0,
          0,
          1
        ]);
        const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
        _geometry.setIndex([0, 1, 2, 0, 2, 3]);
        _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
        _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
      }
      this.geometry = _geometry;
      this.material = material !== void 0 ? material : new SpriteMaterial();
      this.center = new Vector2(0.5, 0.5);
    }
    raycast(raycaster2, intersects2) {
      if (raycaster2.camera === null) {
        console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
      }
      _worldScale.setFromMatrixScale(this.matrixWorld);
      _viewWorldMatrix.copy(raycaster2.camera.matrixWorld);
      this.modelViewMatrix.multiplyMatrices(raycaster2.camera.matrixWorldInverse, this.matrixWorld);
      _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
      if (raycaster2.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
        _worldScale.multiplyScalar(-_mvPosition.z);
      }
      const rotation = this.material.rotation;
      let sin, cos;
      if (rotation !== 0) {
        cos = Math.cos(rotation);
        sin = Math.sin(rotation);
      }
      const center = this.center;
      transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      _uvA.set(0, 0);
      _uvB.set(1, 0);
      _uvC.set(1, 1);
      let intersect = raycaster2.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);
      if (intersect === null) {
        transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        _uvB.set(0, 1);
        intersect = raycaster2.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);
        if (intersect === null) {
          return;
        }
      }
      const distance = raycaster2.ray.origin.distanceTo(_intersectPoint);
      if (distance < raycaster2.near || distance > raycaster2.far)
        return;
      intersects2.push({
        distance,
        point: _intersectPoint.clone(),
        uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
        face: null,
        object: this
      });
    }
    copy(source) {
      super.copy(source);
      if (source.center !== void 0)
        this.center.copy(source.center);
      this.material = source.material;
      return this;
    }
  };
  Sprite.prototype.isSprite = true;
  function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
    _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
    if (sin !== void 0) {
      _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
      _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
    } else {
      _rotatedPosition.copy(_alignedPosition);
    }
    vertexPosition.copy(mvPosition);
    vertexPosition.x += _rotatedPosition.x;
    vertexPosition.y += _rotatedPosition.y;
    vertexPosition.applyMatrix4(_viewWorldMatrix);
  }
  var _v1$2 = /* @__PURE__ */ new Vector3();
  var _v2$1 = /* @__PURE__ */ new Vector3();
  var LOD = class extends Object3D {
    constructor() {
      super();
      this._currentLevel = 0;
      this.type = "LOD";
      Object.defineProperties(this, {
        levels: {
          enumerable: true,
          value: []
        },
        isLOD: {
          value: true
        }
      });
      this.autoUpdate = true;
    }
    copy(source) {
      super.copy(source, false);
      const levels = source.levels;
      for (let i = 0, l = levels.length; i < l; i++) {
        const level = levels[i];
        this.addLevel(level.object.clone(), level.distance);
      }
      this.autoUpdate = source.autoUpdate;
      return this;
    }
    addLevel(object, distance = 0) {
      distance = Math.abs(distance);
      const levels = this.levels;
      let l;
      for (l = 0; l < levels.length; l++) {
        if (distance < levels[l].distance) {
          break;
        }
      }
      levels.splice(l, 0, { distance, object });
      this.add(object);
      return this;
    }
    getCurrentLevel() {
      return this._currentLevel;
    }
    getObjectForDistance(distance) {
      const levels = this.levels;
      if (levels.length > 0) {
        let i, l;
        for (i = 1, l = levels.length; i < l; i++) {
          if (distance < levels[i].distance) {
            break;
          }
        }
        return levels[i - 1].object;
      }
      return null;
    }
    raycast(raycaster2, intersects2) {
      const levels = this.levels;
      if (levels.length > 0) {
        _v1$2.setFromMatrixPosition(this.matrixWorld);
        const distance = raycaster2.ray.origin.distanceTo(_v1$2);
        this.getObjectForDistance(distance).raycast(raycaster2, intersects2);
      }
    }
    update(camera) {
      const levels = this.levels;
      if (levels.length > 1) {
        _v1$2.setFromMatrixPosition(camera.matrixWorld);
        _v2$1.setFromMatrixPosition(this.matrixWorld);
        const distance = _v1$2.distanceTo(_v2$1) / camera.zoom;
        levels[0].object.visible = true;
        let i, l;
        for (i = 1, l = levels.length; i < l; i++) {
          if (distance >= levels[i].distance) {
            levels[i - 1].object.visible = false;
            levels[i].object.visible = true;
          } else {
            break;
          }
        }
        this._currentLevel = i - 1;
        for (; i < l; i++) {
          levels[i].object.visible = false;
        }
      }
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      if (this.autoUpdate === false)
        data.object.autoUpdate = false;
      data.object.levels = [];
      const levels = this.levels;
      for (let i = 0, l = levels.length; i < l; i++) {
        const level = levels[i];
        data.object.levels.push({
          object: level.object.uuid,
          distance: level.distance
        });
      }
      return data;
    }
  };
  var _basePosition = new Vector3();
  var _skinIndex = new Vector4();
  var _skinWeight = new Vector4();
  var _vector$5 = new Vector3();
  var _matrix = new Matrix4();
  function SkinnedMesh(geometry, material) {
    Mesh.call(this, geometry, material);
    this.type = "SkinnedMesh";
    this.bindMode = "attached";
    this.bindMatrix = new Matrix4();
    this.bindMatrixInverse = new Matrix4();
  }
  SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
    constructor: SkinnedMesh,
    isSkinnedMesh: true,
    copy: function(source) {
      Mesh.prototype.copy.call(this, source);
      this.bindMode = source.bindMode;
      this.bindMatrix.copy(source.bindMatrix);
      this.bindMatrixInverse.copy(source.bindMatrixInverse);
      this.skeleton = source.skeleton;
      return this;
    },
    bind: function(skeleton, bindMatrix) {
      this.skeleton = skeleton;
      if (bindMatrix === void 0) {
        this.updateMatrixWorld(true);
        this.skeleton.calculateInverses();
        bindMatrix = this.matrixWorld;
      }
      this.bindMatrix.copy(bindMatrix);
      this.bindMatrixInverse.copy(bindMatrix).invert();
    },
    pose: function() {
      this.skeleton.pose();
    },
    normalizeSkinWeights: function() {
      const vector = new Vector4();
      const skinWeight = this.geometry.attributes.skinWeight;
      for (let i = 0, l = skinWeight.count; i < l; i++) {
        vector.x = skinWeight.getX(i);
        vector.y = skinWeight.getY(i);
        vector.z = skinWeight.getZ(i);
        vector.w = skinWeight.getW(i);
        const scale = 1 / vector.manhattanLength();
        if (scale !== Infinity) {
          vector.multiplyScalar(scale);
        } else {
          vector.set(1, 0, 0, 0);
        }
        skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
      }
    },
    updateMatrixWorld: function(force) {
      Mesh.prototype.updateMatrixWorld.call(this, force);
      if (this.bindMode === "attached") {
        this.bindMatrixInverse.copy(this.matrixWorld).invert();
      } else if (this.bindMode === "detached") {
        this.bindMatrixInverse.copy(this.bindMatrix).invert();
      } else {
        console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
      }
    },
    boneTransform: function(index, target) {
      const skeleton = this.skeleton;
      const geometry = this.geometry;
      _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
      _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
      _basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);
      target.set(0, 0, 0);
      for (let i = 0; i < 4; i++) {
        const weight = _skinWeight.getComponent(i);
        if (weight !== 0) {
          const boneIndex = _skinIndex.getComponent(i);
          _matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
          target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
        }
      }
      return target.applyMatrix4(this.bindMatrixInverse);
    }
  });
  function Bone() {
    Object3D.call(this);
    this.type = "Bone";
  }
  Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Bone,
    isBone: true
  });
  var _offsetMatrix = /* @__PURE__ */ new Matrix4();
  var _identityMatrix = /* @__PURE__ */ new Matrix4();
  var Skeleton = class {
    constructor(bones = [], boneInverses = []) {
      this.uuid = MathUtils.generateUUID();
      this.bones = bones.slice(0);
      this.boneInverses = boneInverses;
      this.boneMatrices = null;
      this.boneTexture = null;
      this.boneTextureSize = 0;
      this.frame = -1;
      this.init();
    }
    init() {
      const bones = this.bones;
      const boneInverses = this.boneInverses;
      this.boneMatrices = new Float32Array(bones.length * 16);
      if (boneInverses.length === 0) {
        this.calculateInverses();
      } else {
        if (bones.length !== boneInverses.length) {
          console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
          this.boneInverses = [];
          for (let i = 0, il = this.bones.length; i < il; i++) {
            this.boneInverses.push(new Matrix4());
          }
        }
      }
    }
    calculateInverses() {
      this.boneInverses.length = 0;
      for (let i = 0, il = this.bones.length; i < il; i++) {
        const inverse = new Matrix4();
        if (this.bones[i]) {
          inverse.copy(this.bones[i].matrixWorld).invert();
        }
        this.boneInverses.push(inverse);
      }
    }
    pose() {
      for (let i = 0, il = this.bones.length; i < il; i++) {
        const bone = this.bones[i];
        if (bone) {
          bone.matrixWorld.copy(this.boneInverses[i]).invert();
        }
      }
      for (let i = 0, il = this.bones.length; i < il; i++) {
        const bone = this.bones[i];
        if (bone) {
          if (bone.parent && bone.parent.isBone) {
            bone.matrix.copy(bone.parent.matrixWorld).invert();
            bone.matrix.multiply(bone.matrixWorld);
          } else {
            bone.matrix.copy(bone.matrixWorld);
          }
          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
        }
      }
    }
    update() {
      const bones = this.bones;
      const boneInverses = this.boneInverses;
      const boneMatrices = this.boneMatrices;
      const boneTexture = this.boneTexture;
      for (let i = 0, il = bones.length; i < il; i++) {
        const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;
        _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
        _offsetMatrix.toArray(boneMatrices, i * 16);
      }
      if (boneTexture !== null) {
        boneTexture.needsUpdate = true;
      }
    }
    clone() {
      return new Skeleton(this.bones, this.boneInverses);
    }
    getBoneByName(name) {
      for (let i = 0, il = this.bones.length; i < il; i++) {
        const bone = this.bones[i];
        if (bone.name === name) {
          return bone;
        }
      }
      return void 0;
    }
    dispose() {
      if (this.boneTexture !== null) {
        this.boneTexture.dispose();
        this.boneTexture = null;
      }
    }
    fromJSON(json, bones) {
      this.uuid = json.uuid;
      for (let i = 0, l = json.bones.length; i < l; i++) {
        const uuid = json.bones[i];
        let bone = bones[uuid];
        if (bone === void 0) {
          console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
          bone = new Bone();
        }
        this.bones.push(bone);
        this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));
      }
      this.init();
      return this;
    }
    toJSON() {
      const data = {
        metadata: {
          version: 4.5,
          type: "Skeleton",
          generator: "Skeleton.toJSON"
        },
        bones: [],
        boneInverses: []
      };
      data.uuid = this.uuid;
      const bones = this.bones;
      const boneInverses = this.boneInverses;
      for (let i = 0, l = bones.length; i < l; i++) {
        const bone = bones[i];
        data.bones.push(bone.uuid);
        const boneInverse = boneInverses[i];
        data.boneInverses.push(boneInverse.toArray());
      }
      return data;
    }
  };
  var _instanceLocalMatrix = new Matrix4();
  var _instanceWorldMatrix = new Matrix4();
  var _instanceIntersects = [];
  var _mesh = new Mesh();
  function InstancedMesh(geometry, material, count) {
    Mesh.call(this, geometry, material);
    this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);
    this.instanceColor = null;
    this.count = count;
    this.frustumCulled = false;
  }
  InstancedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
    constructor: InstancedMesh,
    isInstancedMesh: true,
    copy: function(source) {
      Mesh.prototype.copy.call(this, source);
      this.instanceMatrix.copy(source.instanceMatrix);
      if (source.instanceColor !== null)
        this.instanceColor = source.instanceColor.clone();
      this.count = source.count;
      return this;
    },
    getColorAt: function(index, color) {
      color.fromArray(this.instanceColor.array, index * 3);
    },
    getMatrixAt: function(index, matrix) {
      matrix.fromArray(this.instanceMatrix.array, index * 16);
    },
    raycast: function(raycaster2, intersects2) {
      const matrixWorld = this.matrixWorld;
      const raycastTimes = this.count;
      _mesh.geometry = this.geometry;
      _mesh.material = this.material;
      if (_mesh.material === void 0)
        return;
      for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
        this.getMatrixAt(instanceId, _instanceLocalMatrix);
        _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
        _mesh.matrixWorld = _instanceWorldMatrix;
        _mesh.raycast(raycaster2, _instanceIntersects);
        for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
          const intersect = _instanceIntersects[i];
          intersect.instanceId = instanceId;
          intersect.object = this;
          intersects2.push(intersect);
        }
        _instanceIntersects.length = 0;
      }
    },
    setColorAt: function(index, color) {
      if (this.instanceColor === null) {
        this.instanceColor = new BufferAttribute(new Float32Array(this.count * 3), 3);
      }
      color.toArray(this.instanceColor.array, index * 3);
    },
    setMatrixAt: function(index, matrix) {
      matrix.toArray(this.instanceMatrix.array, index * 16);
    },
    updateMorphTargets: function() {
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  });
  var LineBasicMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "LineBasicMaterial";
      this.color = new Color(16777215);
      this.linewidth = 1;
      this.linecap = "round";
      this.linejoin = "round";
      this.morphTargets = false;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.linewidth = source.linewidth;
      this.linecap = source.linecap;
      this.linejoin = source.linejoin;
      this.morphTargets = source.morphTargets;
      return this;
    }
  };
  LineBasicMaterial.prototype.isLineBasicMaterial = true;
  var _start$1 = new Vector3();
  var _end$1 = new Vector3();
  var _inverseMatrix$1 = new Matrix4();
  var _ray$1 = new Ray();
  var _sphere$1 = new Sphere();
  function Line(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
    Object3D.call(this);
    this.type = "Line";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  Line.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Line,
    isLine: true,
    copy: function(source) {
      Object3D.prototype.copy.call(this, source);
      this.material = source.material;
      this.geometry = source.geometry;
      return this;
    },
    computeLineDistances: function() {
      const geometry = this.geometry;
      if (geometry.isBufferGeometry) {
        if (geometry.index === null) {
          const positionAttribute = geometry.attributes.position;
          const lineDistances = [0];
          for (let i = 1, l = positionAttribute.count; i < l; i++) {
            _start$1.fromBufferAttribute(positionAttribute, i - 1);
            _end$1.fromBufferAttribute(positionAttribute, i);
            lineDistances[i] = lineDistances[i - 1];
            lineDistances[i] += _start$1.distanceTo(_end$1);
          }
          geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
        } else {
          console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        }
      } else if (geometry.isGeometry) {
        console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
      return this;
    },
    raycast: function(raycaster2, intersects2) {
      const geometry = this.geometry;
      const matrixWorld = this.matrixWorld;
      const threshold = raycaster2.params.Line.threshold;
      const drawRange = geometry.drawRange;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      _sphere$1.copy(geometry.boundingSphere);
      _sphere$1.applyMatrix4(matrixWorld);
      _sphere$1.radius += threshold;
      if (raycaster2.ray.intersectsSphere(_sphere$1) === false)
        return;
      _inverseMatrix$1.copy(matrixWorld).invert();
      _ray$1.copy(raycaster2.ray).applyMatrix4(_inverseMatrix$1);
      const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
      const localThresholdSq = localThreshold * localThreshold;
      const vStart = new Vector3();
      const vEnd = new Vector3();
      const interSegment = new Vector3();
      const interRay = new Vector3();
      const step = this.isLineSegments ? 2 : 1;
      if (geometry.isBufferGeometry) {
        const index = geometry.index;
        const attributes = geometry.attributes;
        const positionAttribute = attributes.position;
        if (index !== null) {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(index.count, drawRange.start + drawRange.count);
          for (let i = start, l = end - 1; i < l; i += step) {
            const a = index.getX(i);
            const b2 = index.getX(i + 1);
            vStart.fromBufferAttribute(positionAttribute, a);
            vEnd.fromBufferAttribute(positionAttribute, b2);
            const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
            if (distSq > localThresholdSq)
              continue;
            interRay.applyMatrix4(this.matrixWorld);
            const distance = raycaster2.ray.origin.distanceTo(interRay);
            if (distance < raycaster2.near || distance > raycaster2.far)
              continue;
            intersects2.push({
              distance,
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
          for (let i = start, l = end - 1; i < l; i += step) {
            vStart.fromBufferAttribute(positionAttribute, i);
            vEnd.fromBufferAttribute(positionAttribute, i + 1);
            const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
            if (distSq > localThresholdSq)
              continue;
            interRay.applyMatrix4(this.matrixWorld);
            const distance = raycaster2.ray.origin.distanceTo(interRay);
            if (distance < raycaster2.near || distance > raycaster2.far)
              continue;
            intersects2.push({
              distance,
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        }
      } else if (geometry.isGeometry) {
        console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    },
    updateMorphTargets: function() {
      const geometry = this.geometry;
      if (geometry.isBufferGeometry) {
        const morphAttributes = geometry.morphAttributes;
        const keys = Object.keys(morphAttributes);
        if (keys.length > 0) {
          const morphAttribute = morphAttributes[keys[0]];
          if (morphAttribute !== void 0) {
            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};
            for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
              const name = morphAttribute[m].name || String(m);
              this.morphTargetInfluences.push(0);
              this.morphTargetDictionary[name] = m;
            }
          }
        }
      } else {
        const morphTargets = geometry.morphTargets;
        if (morphTargets !== void 0 && morphTargets.length > 0) {
          console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }
    }
  });
  var _start = new Vector3();
  var _end = new Vector3();
  function LineSegments(geometry, material) {
    Line.call(this, geometry, material);
    this.type = "LineSegments";
  }
  LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
    constructor: LineSegments,
    isLineSegments: true,
    computeLineDistances: function() {
      const geometry = this.geometry;
      if (geometry.isBufferGeometry) {
        if (geometry.index === null) {
          const positionAttribute = geometry.attributes.position;
          const lineDistances = [];
          for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
            _start.fromBufferAttribute(positionAttribute, i);
            _end.fromBufferAttribute(positionAttribute, i + 1);
            lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
            lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);
          }
          geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
        } else {
          console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        }
      } else if (geometry.isGeometry) {
        console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
      return this;
    }
  });
  var LineLoop = class extends Line {
    constructor(geometry, material) {
      super(geometry, material);
      this.type = "LineLoop";
    }
  };
  LineLoop.prototype.isLineLoop = true;
  var PointsMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "PointsMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.alphaMap = null;
      this.size = 1;
      this.sizeAttenuation = true;
      this.morphTargets = false;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.size = source.size;
      this.sizeAttenuation = source.sizeAttenuation;
      this.morphTargets = source.morphTargets;
      return this;
    }
  };
  PointsMaterial.prototype.isPointsMaterial = true;
  var _inverseMatrix = new Matrix4();
  var _ray = new Ray();
  var _sphere = new Sphere();
  var _position$2 = new Vector3();
  function Points(geometry = new BufferGeometry(), material = new PointsMaterial()) {
    Object3D.call(this);
    this.type = "Points";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  Points.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Points,
    isPoints: true,
    copy: function(source) {
      Object3D.prototype.copy.call(this, source);
      this.material = source.material;
      this.geometry = source.geometry;
      return this;
    },
    raycast: function(raycaster2, intersects2) {
      const geometry = this.geometry;
      const matrixWorld = this.matrixWorld;
      const threshold = raycaster2.params.Points.threshold;
      const drawRange = geometry.drawRange;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      _sphere.copy(geometry.boundingSphere);
      _sphere.applyMatrix4(matrixWorld);
      _sphere.radius += threshold;
      if (raycaster2.ray.intersectsSphere(_sphere) === false)
        return;
      _inverseMatrix.copy(matrixWorld).invert();
      _ray.copy(raycaster2.ray).applyMatrix4(_inverseMatrix);
      const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
      const localThresholdSq = localThreshold * localThreshold;
      if (geometry.isBufferGeometry) {
        const index = geometry.index;
        const attributes = geometry.attributes;
        const positionAttribute = attributes.position;
        if (index !== null) {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(index.count, drawRange.start + drawRange.count);
          for (let i = start, il = end; i < il; i++) {
            const a = index.getX(i);
            _position$2.fromBufferAttribute(positionAttribute, a);
            testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster2, intersects2, this);
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
          for (let i = start, l = end; i < l; i++) {
            _position$2.fromBufferAttribute(positionAttribute, i);
            testPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster2, intersects2, this);
          }
        }
      } else {
        console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    },
    updateMorphTargets: function() {
      const geometry = this.geometry;
      if (geometry.isBufferGeometry) {
        const morphAttributes = geometry.morphAttributes;
        const keys = Object.keys(morphAttributes);
        if (keys.length > 0) {
          const morphAttribute = morphAttributes[keys[0]];
          if (morphAttribute !== void 0) {
            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};
            for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
              const name = morphAttribute[m].name || String(m);
              this.morphTargetInfluences.push(0);
              this.morphTargetDictionary[name] = m;
            }
          }
        }
      } else {
        const morphTargets = geometry.morphTargets;
        if (morphTargets !== void 0 && morphTargets.length > 0) {
          console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }
    }
  });
  function testPoint(point, index, localThresholdSq, matrixWorld, raycaster2, intersects2, object) {
    const rayPointDistanceSq = _ray.distanceSqToPoint(point);
    if (rayPointDistanceSq < localThresholdSq) {
      const intersectPoint = new Vector3();
      _ray.closestPointToPoint(point, intersectPoint);
      intersectPoint.applyMatrix4(matrixWorld);
      const distance = raycaster2.ray.origin.distanceTo(intersectPoint);
      if (distance < raycaster2.near || distance > raycaster2.far)
        return;
      intersects2.push({
        distance,
        distanceToRay: Math.sqrt(rayPointDistanceSq),
        point: intersectPoint,
        index,
        face: null,
        object
      });
    }
  }
  var VideoTexture = class extends Texture {
    constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
      super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.format = format !== void 0 ? format : RGBFormat;
      this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
      this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
      this.generateMipmaps = false;
      const scope = this;
      function updateVideo() {
        scope.needsUpdate = true;
        video.requestVideoFrameCallback(updateVideo);
      }
      if ("requestVideoFrameCallback" in video) {
        video.requestVideoFrameCallback(updateVideo);
      }
    }
    clone() {
      return new this.constructor(this.image).copy(this);
    }
    update() {
      const video = this.image;
      const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
      if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
        this.needsUpdate = true;
      }
    }
  };
  VideoTexture.prototype.isVideoTexture = true;
  var CompressedTexture = class extends Texture {
    constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
      super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
      this.image = { width, height };
      this.mipmaps = mipmaps;
      this.flipY = false;
      this.generateMipmaps = false;
    }
  };
  CompressedTexture.prototype.isCompressedTexture = true;
  var CanvasTexture = class extends Texture {
    constructor(canvas2, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
      super(canvas2, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.needsUpdate = true;
    }
  };
  CanvasTexture.prototype.isCanvasTexture = true;
  var DepthTexture = class extends Texture {
    constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
      format = format !== void 0 ? format : DepthFormat;
      if (format !== DepthFormat && format !== DepthStencilFormat) {
        throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
      }
      if (type === void 0 && format === DepthFormat)
        type = UnsignedShortType;
      if (type === void 0 && format === DepthStencilFormat)
        type = UnsignedInt248Type;
      super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.image = { width, height };
      this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
      this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
      this.flipY = false;
      this.generateMipmaps = false;
    }
  };
  DepthTexture.prototype.isDepthTexture = true;
  var CircleGeometry = class extends BufferGeometry {
    constructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {
      super();
      this.type = "CircleGeometry";
      this.parameters = {
        radius,
        segments,
        thetaStart,
        thetaLength
      };
      segments = Math.max(3, segments);
      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];
      const vertex = new Vector3();
      const uv = new Vector2();
      vertices.push(0, 0, 0);
      normals.push(0, 0, 1);
      uvs.push(0.5, 0.5);
      for (let s = 0, i = 3; s <= segments; s++, i += 3) {
        const segment = thetaStart + s / segments * thetaLength;
        vertex.x = radius * Math.cos(segment);
        vertex.y = radius * Math.sin(segment);
        vertices.push(vertex.x, vertex.y, vertex.z);
        normals.push(0, 0, 1);
        uv.x = (vertices[i] / radius + 1) / 2;
        uv.y = (vertices[i + 1] / radius + 1) / 2;
        uvs.push(uv.x, uv.y);
      }
      for (let i = 1; i <= segments; i++) {
        indices.push(i, i + 1, 0);
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
  };
  var CylinderGeometry = class extends BufferGeometry {
    constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
      super();
      this.type = "CylinderGeometry";
      this.parameters = {
        radiusTop,
        radiusBottom,
        height,
        radialSegments,
        heightSegments,
        openEnded,
        thetaStart,
        thetaLength
      };
      const scope = this;
      radialSegments = Math.floor(radialSegments);
      heightSegments = Math.floor(heightSegments);
      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];
      let index = 0;
      const indexArray = [];
      const halfHeight = height / 2;
      let groupStart = 0;
      generateTorso();
      if (openEnded === false) {
        if (radiusTop > 0)
          generateCap(true);
        if (radiusBottom > 0)
          generateCap(false);
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      function generateTorso() {
        const normal = new Vector3();
        const vertex = new Vector3();
        let groupCount = 0;
        const slope = (radiusBottom - radiusTop) / height;
        for (let y = 0; y <= heightSegments; y++) {
          const indexRow = [];
          const v = y / heightSegments;
          const radius = v * (radiusBottom - radiusTop) + radiusTop;
          for (let x = 0; x <= radialSegments; x++) {
            const u = x / radialSegments;
            const theta = u * thetaLength + thetaStart;
            const sinTheta = Math.sin(theta);
            const cosTheta = Math.cos(theta);
            vertex.x = radius * sinTheta;
            vertex.y = -v * height + halfHeight;
            vertex.z = radius * cosTheta;
            vertices.push(vertex.x, vertex.y, vertex.z);
            normal.set(sinTheta, slope, cosTheta).normalize();
            normals.push(normal.x, normal.y, normal.z);
            uvs.push(u, 1 - v);
            indexRow.push(index++);
          }
          indexArray.push(indexRow);
        }
        for (let x = 0; x < radialSegments; x++) {
          for (let y = 0; y < heightSegments; y++) {
            const a = indexArray[y][x];
            const b2 = indexArray[y + 1][x];
            const c = indexArray[y + 1][x + 1];
            const d = indexArray[y][x + 1];
            indices.push(a, b2, d);
            indices.push(b2, c, d);
            groupCount += 6;
          }
        }
        scope.addGroup(groupStart, groupCount, 0);
        groupStart += groupCount;
      }
      function generateCap(top) {
        const centerIndexStart = index;
        const uv = new Vector2();
        const vertex = new Vector3();
        let groupCount = 0;
        const radius = top === true ? radiusTop : radiusBottom;
        const sign2 = top === true ? 1 : -1;
        for (let x = 1; x <= radialSegments; x++) {
          vertices.push(0, halfHeight * sign2, 0);
          normals.push(0, sign2, 0);
          uvs.push(0.5, 0.5);
          index++;
        }
        const centerIndexEnd = index;
        for (let x = 0; x <= radialSegments; x++) {
          const u = x / radialSegments;
          const theta = u * thetaLength + thetaStart;
          const cosTheta = Math.cos(theta);
          const sinTheta = Math.sin(theta);
          vertex.x = radius * sinTheta;
          vertex.y = halfHeight * sign2;
          vertex.z = radius * cosTheta;
          vertices.push(vertex.x, vertex.y, vertex.z);
          normals.push(0, sign2, 0);
          uv.x = cosTheta * 0.5 + 0.5;
          uv.y = sinTheta * 0.5 * sign2 + 0.5;
          uvs.push(uv.x, uv.y);
          index++;
        }
        for (let x = 0; x < radialSegments; x++) {
          const c = centerIndexStart + x;
          const i = centerIndexEnd + x;
          if (top === true) {
            indices.push(i, i + 1, c);
          } else {
            indices.push(i + 1, i, c);
          }
          groupCount += 3;
        }
        scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
        groupStart += groupCount;
      }
    }
  };
  var ConeGeometry = class extends CylinderGeometry {
    constructor(radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
      super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
      this.type = "ConeGeometry";
      this.parameters = {
        radius,
        height,
        radialSegments,
        heightSegments,
        openEnded,
        thetaStart,
        thetaLength
      };
    }
  };
  var PolyhedronGeometry = class extends BufferGeometry {
    constructor(vertices, indices, radius = 1, detail = 0) {
      super();
      this.type = "PolyhedronGeometry";
      this.parameters = {
        vertices,
        indices,
        radius,
        detail
      };
      const vertexBuffer = [];
      const uvBuffer = [];
      subdivide(detail);
      applyRadius(radius);
      generateUVs();
      this.setAttribute("position", new Float32BufferAttribute(vertexBuffer, 3));
      this.setAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvBuffer, 2));
      if (detail === 0) {
        this.computeVertexNormals();
      } else {
        this.normalizeNormals();
      }
      function subdivide(detail2) {
        const a = new Vector3();
        const b2 = new Vector3();
        const c = new Vector3();
        for (let i = 0; i < indices.length; i += 3) {
          getVertexByIndex(indices[i + 0], a);
          getVertexByIndex(indices[i + 1], b2);
          getVertexByIndex(indices[i + 2], c);
          subdivideFace(a, b2, c, detail2);
        }
      }
      function subdivideFace(a, b2, c, detail2) {
        const cols = detail2 + 1;
        const v = [];
        for (let i = 0; i <= cols; i++) {
          v[i] = [];
          const aj = a.clone().lerp(c, i / cols);
          const bj = b2.clone().lerp(c, i / cols);
          const rows = cols - i;
          for (let j = 0; j <= rows; j++) {
            if (j === 0 && i === cols) {
              v[i][j] = aj;
            } else {
              v[i][j] = aj.clone().lerp(bj, j / rows);
            }
          }
        }
        for (let i = 0; i < cols; i++) {
          for (let j = 0; j < 2 * (cols - i) - 1; j++) {
            const k = Math.floor(j / 2);
            if (j % 2 === 0) {
              pushVertex(v[i][k + 1]);
              pushVertex(v[i + 1][k]);
              pushVertex(v[i][k]);
            } else {
              pushVertex(v[i][k + 1]);
              pushVertex(v[i + 1][k + 1]);
              pushVertex(v[i + 1][k]);
            }
          }
        }
      }
      function applyRadius(radius2) {
        const vertex = new Vector3();
        for (let i = 0; i < vertexBuffer.length; i += 3) {
          vertex.x = vertexBuffer[i + 0];
          vertex.y = vertexBuffer[i + 1];
          vertex.z = vertexBuffer[i + 2];
          vertex.normalize().multiplyScalar(radius2);
          vertexBuffer[i + 0] = vertex.x;
          vertexBuffer[i + 1] = vertex.y;
          vertexBuffer[i + 2] = vertex.z;
        }
      }
      function generateUVs() {
        const vertex = new Vector3();
        for (let i = 0; i < vertexBuffer.length; i += 3) {
          vertex.x = vertexBuffer[i + 0];
          vertex.y = vertexBuffer[i + 1];
          vertex.z = vertexBuffer[i + 2];
          const u = azimuth(vertex) / 2 / Math.PI + 0.5;
          const v = inclination(vertex) / Math.PI + 0.5;
          uvBuffer.push(u, 1 - v);
        }
        correctUVs();
        correctSeam();
      }
      function correctSeam() {
        for (let i = 0; i < uvBuffer.length; i += 6) {
          const x0 = uvBuffer[i + 0];
          const x1 = uvBuffer[i + 2];
          const x2 = uvBuffer[i + 4];
          const max = Math.max(x0, x1, x2);
          const min = Math.min(x0, x1, x2);
          if (max > 0.9 && min < 0.1) {
            if (x0 < 0.2)
              uvBuffer[i + 0] += 1;
            if (x1 < 0.2)
              uvBuffer[i + 2] += 1;
            if (x2 < 0.2)
              uvBuffer[i + 4] += 1;
          }
        }
      }
      function pushVertex(vertex) {
        vertexBuffer.push(vertex.x, vertex.y, vertex.z);
      }
      function getVertexByIndex(index, vertex) {
        const stride = index * 3;
        vertex.x = vertices[stride + 0];
        vertex.y = vertices[stride + 1];
        vertex.z = vertices[stride + 2];
      }
      function correctUVs() {
        const a = new Vector3();
        const b2 = new Vector3();
        const c = new Vector3();
        const centroid = new Vector3();
        const uvA = new Vector2();
        const uvB = new Vector2();
        const uvC = new Vector2();
        for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
          a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
          b2.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
          c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
          uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
          uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
          uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
          centroid.copy(a).add(b2).add(c).divideScalar(3);
          const azi = azimuth(centroid);
          correctUV(uvA, j + 0, a, azi);
          correctUV(uvB, j + 2, b2, azi);
          correctUV(uvC, j + 4, c, azi);
        }
      }
      function correctUV(uv, stride, vector, azimuth2) {
        if (azimuth2 < 0 && uv.x === 1) {
          uvBuffer[stride] = uv.x - 1;
        }
        if (vector.x === 0 && vector.z === 0) {
          uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
        }
      }
      function azimuth(vector) {
        return Math.atan2(vector.z, -vector.x);
      }
      function inclination(vector) {
        return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
      }
    }
  };
  var DodecahedronGeometry = class extends PolyhedronGeometry {
    constructor(radius = 1, detail = 0) {
      const t = (1 + Math.sqrt(5)) / 2;
      const r = 1 / t;
      const vertices = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -r,
        -t,
        0,
        -r,
        t,
        0,
        r,
        -t,
        0,
        r,
        t,
        -r,
        -t,
        0,
        -r,
        t,
        0,
        r,
        -t,
        0,
        r,
        t,
        0,
        -t,
        0,
        -r,
        t,
        0,
        -r,
        -t,
        0,
        r,
        t,
        0,
        r
      ];
      const indices = [
        3,
        11,
        7,
        3,
        7,
        15,
        3,
        15,
        13,
        7,
        19,
        17,
        7,
        17,
        6,
        7,
        6,
        15,
        17,
        4,
        8,
        17,
        8,
        10,
        17,
        10,
        6,
        8,
        0,
        16,
        8,
        16,
        2,
        8,
        2,
        10,
        0,
        12,
        1,
        0,
        1,
        18,
        0,
        18,
        16,
        6,
        10,
        2,
        6,
        2,
        13,
        6,
        13,
        15,
        2,
        16,
        18,
        2,
        18,
        3,
        2,
        3,
        13,
        18,
        1,
        9,
        18,
        9,
        11,
        18,
        11,
        3,
        4,
        14,
        12,
        4,
        12,
        0,
        4,
        0,
        8,
        11,
        9,
        5,
        11,
        5,
        19,
        11,
        19,
        7,
        19,
        5,
        14,
        19,
        14,
        4,
        19,
        4,
        17,
        1,
        12,
        14,
        1,
        14,
        5,
        1,
        5,
        9
      ];
      super(vertices, indices, radius, detail);
      this.type = "DodecahedronGeometry";
      this.parameters = {
        radius,
        detail
      };
    }
  };
  var _v0 = new Vector3();
  var _v1$1 = new Vector3();
  var _normal = new Vector3();
  var _triangle = new Triangle();
  var EdgesGeometry = class extends BufferGeometry {
    constructor(geometry, thresholdAngle) {
      super();
      this.type = "EdgesGeometry";
      this.parameters = {
        thresholdAngle
      };
      thresholdAngle = thresholdAngle !== void 0 ? thresholdAngle : 1;
      if (geometry.isGeometry === true) {
        console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        return;
      }
      const precisionPoints = 4;
      const precision = Math.pow(10, precisionPoints);
      const thresholdDot = Math.cos(MathUtils.DEG2RAD * thresholdAngle);
      const indexAttr = geometry.getIndex();
      const positionAttr = geometry.getAttribute("position");
      const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
      const indexArr = [0, 0, 0];
      const vertKeys = ["a", "b", "c"];
      const hashes = new Array(3);
      const edgeData = {};
      const vertices = [];
      for (let i = 0; i < indexCount; i += 3) {
        if (indexAttr) {
          indexArr[0] = indexAttr.getX(i);
          indexArr[1] = indexAttr.getX(i + 1);
          indexArr[2] = indexAttr.getX(i + 2);
        } else {
          indexArr[0] = i;
          indexArr[1] = i + 1;
          indexArr[2] = i + 2;
        }
        const { a, b: b2, c } = _triangle;
        a.fromBufferAttribute(positionAttr, indexArr[0]);
        b2.fromBufferAttribute(positionAttr, indexArr[1]);
        c.fromBufferAttribute(positionAttr, indexArr[2]);
        _triangle.getNormal(_normal);
        hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;
        hashes[1] = `${Math.round(b2.x * precision)},${Math.round(b2.y * precision)},${Math.round(b2.z * precision)}`;
        hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`;
        if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
          continue;
        }
        for (let j = 0; j < 3; j++) {
          const jNext = (j + 1) % 3;
          const vecHash0 = hashes[j];
          const vecHash1 = hashes[jNext];
          const v0 = _triangle[vertKeys[j]];
          const v1 = _triangle[vertKeys[jNext]];
          const hash = `${vecHash0}_${vecHash1}`;
          const reverseHash = `${vecHash1}_${vecHash0}`;
          if (reverseHash in edgeData && edgeData[reverseHash]) {
            if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
              vertices.push(v0.x, v0.y, v0.z);
              vertices.push(v1.x, v1.y, v1.z);
            }
            edgeData[reverseHash] = null;
          } else if (!(hash in edgeData)) {
            edgeData[hash] = {
              index0: indexArr[j],
              index1: indexArr[jNext],
              normal: _normal.clone()
            };
          }
        }
      }
      for (const key in edgeData) {
        if (edgeData[key]) {
          const { index0, index1 } = edgeData[key];
          _v0.fromBufferAttribute(positionAttr, index0);
          _v1$1.fromBufferAttribute(positionAttr, index1);
          vertices.push(_v0.x, _v0.y, _v0.z);
          vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
        }
      }
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    }
  };
  var Earcut = {
    triangulate: function(data, holeIndices, dim) {
      dim = dim || 2;
      const hasHoles = holeIndices && holeIndices.length;
      const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      let outerNode = linkedList(data, 0, outerLen, dim, true);
      const triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev)
        return triangles;
      let minX, minY, maxX, maxY, x, y, invSize;
      if (hasHoles)
        outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (let i = dim; i < outerLen; i += dim) {
          x = data[i];
          y = data[i + 1];
          if (x < minX)
            minX = x;
          if (y < minY)
            minY = y;
          if (x > maxX)
            maxX = x;
          if (y > maxY)
            maxY = y;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
      return triangles;
    }
  };
  function linkedList(data, start, end, dim, clockwise) {
    let i, last;
    if (clockwise === signedArea(data, start, end, dim) > 0) {
      for (i = start; i < end; i += dim)
        last = insertNode(i, data[i], data[i + 1], last);
    } else {
      for (i = end - dim; i >= start; i -= dim)
        last = insertNode(i, data[i], data[i + 1], last);
    }
    if (last && equals(last, last.next)) {
      removeNode(last);
      last = last.next;
    }
    return last;
  }
  function filterPoints(start, end) {
    if (!start)
      return start;
    if (!end)
      end = start;
    let p = start, again;
    do {
      again = false;
      if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
        removeNode(p);
        p = end = p.prev;
        if (p === p.next)
          break;
        again = true;
      } else {
        p = p.next;
      }
    } while (again || p !== end);
    return end;
  }
  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear)
      return;
    if (!pass && invSize)
      indexCurve(ear, minX, minY, invSize);
    let stop = ear, prev, next;
    while (ear.prev !== ear.next) {
      prev = ear.prev;
      next = ear.next;
      if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
        triangles.push(prev.i / dim);
        triangles.push(ear.i / dim);
        triangles.push(next.i / dim);
        removeNode(ear);
        ear = next.next;
        stop = next.next;
        continue;
      }
      ear = next;
      if (ear === stop) {
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
        } else if (pass === 1) {
          ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
          earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, invSize);
        }
        break;
      }
    }
  }
  function isEar(ear) {
    const a = ear.prev, b2 = ear, c = ear.next;
    if (area(a, b2, c) >= 0)
      return false;
    let p = ear.next.next;
    while (p !== ear.prev) {
      if (pointInTriangle(a.x, a.y, b2.x, b2.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.next;
    }
    return true;
  }
  function isEarHashed(ear, minX, minY, invSize) {
    const a = ear.prev, b2 = ear, c = ear.next;
    if (area(a, b2, c) >= 0)
      return false;
    const minTX = a.x < b2.x ? a.x < c.x ? a.x : c.x : b2.x < c.x ? b2.x : c.x, minTY = a.y < b2.y ? a.y < c.y ? a.y : c.y : b2.y < c.y ? b2.y : c.y, maxTX = a.x > b2.x ? a.x > c.x ? a.x : c.x : b2.x > c.x ? b2.x : c.x, maxTY = a.y > b2.y ? a.y > c.y ? a.y : c.y : b2.y > c.y ? b2.y : c.y;
    const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
    let p = ear.prevZ, n = ear.nextZ;
    while (p && p.z >= minZ && n && n.z <= maxZ) {
      if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b2.x, b2.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.prevZ;
      if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b2.x, b2.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
        return false;
      n = n.nextZ;
    }
    while (p && p.z >= minZ) {
      if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b2.x, b2.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
        return false;
      p = p.prevZ;
    }
    while (n && n.z <= maxZ) {
      if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b2.x, b2.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
        return false;
      n = n.nextZ;
    }
    return true;
  }
  function cureLocalIntersections(start, triangles, dim) {
    let p = start;
    do {
      const a = p.prev, b2 = p.next.next;
      if (!equals(a, b2) && intersects(a, p, p.next, b2) && locallyInside(a, b2) && locallyInside(b2, a)) {
        triangles.push(a.i / dim);
        triangles.push(p.i / dim);
        triangles.push(b2.i / dim);
        removeNode(p);
        removeNode(p.next);
        p = start = b2;
      }
      p = p.next;
    } while (p !== start);
    return filterPoints(p);
  }
  function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    let a = start;
    do {
      let b2 = a.next.next;
      while (b2 !== a.prev) {
        if (a.i !== b2.i && isValidDiagonal(a, b2)) {
          let c = splitPolygon(a, b2);
          a = filterPoints(a, a.next);
          c = filterPoints(c, c.next);
          earcutLinked(a, triangles, dim, minX, minY, invSize);
          earcutLinked(c, triangles, dim, minX, minY, invSize);
          return;
        }
        b2 = b2.next;
      }
      a = a.next;
    } while (a !== start);
  }
  function eliminateHoles(data, holeIndices, outerNode, dim) {
    const queue = [];
    let i, len, start, end, list;
    for (i = 0, len = holeIndices.length; i < len; i++) {
      start = holeIndices[i] * dim;
      end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      list = linkedList(data, start, end, dim, false);
      if (list === list.next)
        list.steiner = true;
      queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    for (i = 0; i < queue.length; i++) {
      eliminateHole(queue[i], outerNode);
      outerNode = filterPoints(outerNode, outerNode.next);
    }
    return outerNode;
  }
  function compareX(a, b2) {
    return a.x - b2.x;
  }
  function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
      const b2 = splitPolygon(outerNode, hole);
      filterPoints(outerNode, outerNode.next);
      filterPoints(b2, b2.next);
    }
  }
  function findHoleBridge(hole, outerNode) {
    let p = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity, m;
    do {
      if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
        const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
        if (x <= hx && x > qx) {
          qx = x;
          if (x === hx) {
            if (hy === p.y)
              return p;
            if (hy === p.next.y)
              return p.next;
          }
          m = p.x < p.next.x ? p : p.next;
        }
      }
      p = p.next;
    } while (p !== outerNode);
    if (!m)
      return null;
    if (hx === qx)
      return m;
    const stop = m, mx = m.x, my = m.y;
    let tanMin = Infinity, tan;
    p = m;
    do {
      if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
        tan = Math.abs(hy - p.y) / (hx - p.x);
        if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
          m = p;
          tanMin = tan;
        }
      }
      p = p.next;
    } while (p !== stop);
    return m;
  }
  function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
  }
  function indexCurve(start, minX, minY, invSize) {
    let p = start;
    do {
      if (p.z === null)
        p.z = zOrder(p.x, p.y, minX, minY, invSize);
      p.prevZ = p.prev;
      p.nextZ = p.next;
      p = p.next;
    } while (p !== start);
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
  }
  function sortLinked(list) {
    let i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
      p = list;
      list = null;
      tail = null;
      numMerges = 0;
      while (p) {
        numMerges++;
        q = p;
        pSize = 0;
        for (i = 0; i < inSize; i++) {
          pSize++;
          q = q.nextZ;
          if (!q)
            break;
        }
        qSize = inSize;
        while (pSize > 0 || qSize > 0 && q) {
          if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
            e = p;
            p = p.nextZ;
            pSize--;
          } else {
            e = q;
            q = q.nextZ;
            qSize--;
          }
          if (tail)
            tail.nextZ = e;
          else
            list = e;
          e.prevZ = tail;
          tail = e;
        }
        p = q;
      }
      tail.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);
    return list;
  }
  function zOrder(x, y, minX, minY, invSize) {
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;
    x = (x | x << 8) & 16711935;
    x = (x | x << 4) & 252645135;
    x = (x | x << 2) & 858993459;
    x = (x | x << 1) & 1431655765;
    y = (y | y << 8) & 16711935;
    y = (y | y << 4) & 252645135;
    y = (y | y << 2) & 858993459;
    y = (y | y << 1) & 1431655765;
    return x | y << 1;
  }
  function getLeftmost(start) {
    let p = start, leftmost = start;
    do {
      if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
        leftmost = p;
      p = p.next;
    } while (p !== start);
    return leftmost;
  }
  function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
    return (cx - px2) * (ay - py2) - (ax - px2) * (cy - py2) >= 0 && (ax - px2) * (by - py2) - (bx - px2) * (ay - py2) >= 0 && (bx - px2) * (cy - py2) - (cx - px2) * (by - py2) >= 0;
  }
  function isValidDiagonal(a, b2) {
    return a.next.i !== b2.i && a.prev.i !== b2.i && !intersectsPolygon(a, b2) && (locallyInside(a, b2) && locallyInside(b2, a) && middleInside(a, b2) && (area(a.prev, a, b2.prev) || area(a, b2.prev, b2)) || equals(a, b2) && area(a.prev, a, a.next) > 0 && area(b2.prev, b2, b2.next) > 0);
  }
  function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
  }
  function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
  }
  function intersects(p1, q1, p2, q2) {
    const o1 = sign(area(p1, q1, p2));
    const o2 = sign(area(p1, q1, q2));
    const o3 = sign(area(p2, q2, p1));
    const o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4)
      return true;
    if (o1 === 0 && onSegment(p1, p2, q1))
      return true;
    if (o2 === 0 && onSegment(p1, q2, q1))
      return true;
    if (o3 === 0 && onSegment(p2, p1, q2))
      return true;
    if (o4 === 0 && onSegment(p2, q1, q2))
      return true;
    return false;
  }
  function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
  }
  function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
  }
  function intersectsPolygon(a, b2) {
    let p = a;
    do {
      if (p.i !== a.i && p.next.i !== a.i && p.i !== b2.i && p.next.i !== b2.i && intersects(p, p.next, a, b2))
        return true;
      p = p.next;
    } while (p !== a);
    return false;
  }
  function locallyInside(a, b2) {
    return area(a.prev, a, a.next) < 0 ? area(a, b2, a.next) >= 0 && area(a, a.prev, b2) >= 0 : area(a, b2, a.prev) < 0 || area(a, a.next, b2) < 0;
  }
  function middleInside(a, b2) {
    let p = a, inside = false;
    const px2 = (a.x + b2.x) / 2, py2 = (a.y + b2.y) / 2;
    do {
      if (p.y > py2 !== p.next.y > py2 && p.next.y !== p.y && px2 < (p.next.x - p.x) * (py2 - p.y) / (p.next.y - p.y) + p.x)
        inside = !inside;
      p = p.next;
    } while (p !== a);
    return inside;
  }
  function splitPolygon(a, b2) {
    const a2 = new Node(a.i, a.x, a.y), b22 = new Node(b2.i, b2.x, b2.y), an2 = a.next, bp = b2.prev;
    a.next = b2;
    b2.prev = a;
    a2.next = an2;
    an2.prev = a2;
    b22.next = a2;
    a2.prev = b22;
    bp.next = b22;
    b22.prev = bp;
    return b22;
  }
  function insertNode(i, x, y, last) {
    const p = new Node(i, x, y);
    if (!last) {
      p.prev = p;
      p.next = p;
    } else {
      p.next = last.next;
      p.prev = last;
      last.next.prev = p;
      last.next = p;
    }
    return p;
  }
  function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ)
      p.prevZ.nextZ = p.nextZ;
    if (p.nextZ)
      p.nextZ.prevZ = p.prevZ;
  }
  function Node(i, x, y) {
    this.i = i;
    this.x = x;
    this.y = y;
    this.prev = null;
    this.next = null;
    this.z = null;
    this.prevZ = null;
    this.nextZ = null;
    this.steiner = false;
  }
  function signedArea(data, start, end, dim) {
    let sum = 0;
    for (let i = start, j = end - dim; i < end; i += dim) {
      sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
      j = i;
    }
    return sum;
  }
  var ShapeUtils = {
    area: function(contour) {
      const n = contour.length;
      let a = 0;
      for (let p = n - 1, q = 0; q < n; p = q++) {
        a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
      }
      return a * 0.5;
    },
    isClockWise: function(pts) {
      return ShapeUtils.area(pts) < 0;
    },
    triangulateShape: function(contour, holes) {
      const vertices = [];
      const holeIndices = [];
      const faces = [];
      removeDupEndPts(contour);
      addContour(vertices, contour);
      let holeIndex = contour.length;
      holes.forEach(removeDupEndPts);
      for (let i = 0; i < holes.length; i++) {
        holeIndices.push(holeIndex);
        holeIndex += holes[i].length;
        addContour(vertices, holes[i]);
      }
      const triangles = Earcut.triangulate(vertices, holeIndices);
      for (let i = 0; i < triangles.length; i += 3) {
        faces.push(triangles.slice(i, i + 3));
      }
      return faces;
    }
  };
  function removeDupEndPts(points) {
    const l = points.length;
    if (l > 2 && points[l - 1].equals(points[0])) {
      points.pop();
    }
  }
  function addContour(vertices, contour) {
    for (let i = 0; i < contour.length; i++) {
      vertices.push(contour[i].x);
      vertices.push(contour[i].y);
    }
  }
  var ExtrudeGeometry = class extends BufferGeometry {
    constructor(shapes, options) {
      super();
      this.type = "ExtrudeGeometry";
      this.parameters = {
        shapes,
        options
      };
      shapes = Array.isArray(shapes) ? shapes : [shapes];
      const scope = this;
      const verticesArray = [];
      const uvArray = [];
      for (let i = 0, l = shapes.length; i < l; i++) {
        const shape = shapes[i];
        addShape(shape);
      }
      this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
      this.computeVertexNormals();
      function addShape(shape) {
        const placeholder = [];
        const curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
        const steps = options.steps !== void 0 ? options.steps : 1;
        let depth = options.depth !== void 0 ? options.depth : 100;
        let bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
        let bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 6;
        let bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 2;
        let bevelOffset = options.bevelOffset !== void 0 ? options.bevelOffset : 0;
        let bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;
        const extrudePath = options.extrudePath;
        const uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator;
        if (options.amount !== void 0) {
          console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
          depth = options.amount;
        }
        let extrudePts, extrudeByPath = false;
        let splineTube, binormal, normal, position2;
        if (extrudePath) {
          extrudePts = extrudePath.getSpacedPoints(steps);
          extrudeByPath = true;
          bevelEnabled = false;
          splineTube = extrudePath.computeFrenetFrames(steps, false);
          binormal = new Vector3();
          normal = new Vector3();
          position2 = new Vector3();
        }
        if (!bevelEnabled) {
          bevelSegments = 0;
          bevelThickness = 0;
          bevelSize = 0;
          bevelOffset = 0;
        }
        const shapePoints = shape.extractPoints(curveSegments);
        let vertices = shapePoints.shape;
        const holes = shapePoints.holes;
        const reverse = !ShapeUtils.isClockWise(vertices);
        if (reverse) {
          vertices = vertices.reverse();
          for (let h = 0, hl = holes.length; h < hl; h++) {
            const ahole = holes[h];
            if (ShapeUtils.isClockWise(ahole)) {
              holes[h] = ahole.reverse();
            }
          }
        }
        const faces = ShapeUtils.triangulateShape(vertices, holes);
        const contour = vertices;
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          vertices = vertices.concat(ahole);
        }
        function scalePt2(pt2, vec, size2) {
          if (!vec)
            console.error("THREE.ExtrudeGeometry: vec does not exist");
          return vec.clone().multiplyScalar(size2).add(pt2);
        }
        const vlen = vertices.length, flen = faces.length;
        function getBevelVec(inPt, inPrev, inNext) {
          let v_trans_x, v_trans_y, shrink_by;
          const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
          const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
          const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
          const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
          if (Math.abs(collinear0) > Number.EPSILON) {
            const v_prev_len = Math.sqrt(v_prev_lensq);
            const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
            const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
            const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
            const ptNextShift_x = inNext.x - v_next_y / v_next_len;
            const ptNextShift_y = inNext.y + v_next_x / v_next_len;
            const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
            v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
            v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
            const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
            if (v_trans_lensq <= 2) {
              return new Vector2(v_trans_x, v_trans_y);
            } else {
              shrink_by = Math.sqrt(v_trans_lensq / 2);
            }
          } else {
            let direction_eq = false;
            if (v_prev_x > Number.EPSILON) {
              if (v_next_x > Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (v_prev_x < -Number.EPSILON) {
                if (v_next_x < -Number.EPSILON) {
                  direction_eq = true;
                }
              } else {
                if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                  direction_eq = true;
                }
              }
            }
            if (direction_eq) {
              v_trans_x = -v_prev_y;
              v_trans_y = v_prev_x;
              shrink_by = Math.sqrt(v_prev_lensq);
            } else {
              v_trans_x = v_prev_x;
              v_trans_y = v_prev_y;
              shrink_by = Math.sqrt(v_prev_lensq / 2);
            }
          }
          return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
        }
        const contourMovements = [];
        for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
          if (j === il)
            j = 0;
          if (k === il)
            k = 0;
          contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
        }
        const holesMovements = [];
        let oneHoleMovements, verticesMovements = contourMovements.concat();
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = [];
          for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
            if (j === il)
              j = 0;
            if (k === il)
              k = 0;
            oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
          }
          holesMovements.push(oneHoleMovements);
          verticesMovements = verticesMovements.concat(oneHoleMovements);
        }
        for (let b2 = 0; b2 < bevelSegments; b2++) {
          const t = b2 / bevelSegments;
          const z = bevelThickness * Math.cos(t * Math.PI / 2);
          const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
          for (let i = 0, il = contour.length; i < il; i++) {
            const vert = scalePt2(contour[i], contourMovements[i], bs2);
            v(vert.x, vert.y, -z);
          }
          for (let h = 0, hl = holes.length; h < hl; h++) {
            const ahole = holes[h];
            oneHoleMovements = holesMovements[h];
            for (let i = 0, il = ahole.length; i < il; i++) {
              const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
              v(vert.x, vert.y, -z);
            }
          }
        }
        const bs = bevelSize + bevelOffset;
        for (let i = 0; i < vlen; i++) {
          const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
          if (!extrudeByPath) {
            v(vert.x, vert.y, 0);
          } else {
            normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
            position2.copy(extrudePts[0]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
          }
        }
        for (let s = 1; s <= steps; s++) {
          for (let i = 0; i < vlen; i++) {
            const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
            if (!extrudeByPath) {
              v(vert.x, vert.y, depth / steps * s);
            } else {
              normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
              binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
              position2.copy(extrudePts[s]).add(normal).add(binormal);
              v(position2.x, position2.y, position2.z);
            }
          }
        }
        for (let b2 = bevelSegments - 1; b2 >= 0; b2--) {
          const t = b2 / bevelSegments;
          const z = bevelThickness * Math.cos(t * Math.PI / 2);
          const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
          for (let i = 0, il = contour.length; i < il; i++) {
            const vert = scalePt2(contour[i], contourMovements[i], bs2);
            v(vert.x, vert.y, depth + z);
          }
          for (let h = 0, hl = holes.length; h < hl; h++) {
            const ahole = holes[h];
            oneHoleMovements = holesMovements[h];
            for (let i = 0, il = ahole.length; i < il; i++) {
              const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
              if (!extrudeByPath) {
                v(vert.x, vert.y, depth + z);
              } else {
                v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
              }
            }
          }
        }
        buildLidFaces();
        buildSideFaces();
        function buildLidFaces() {
          const start = verticesArray.length / 3;
          if (bevelEnabled) {
            let layer = 0;
            let offset = vlen * layer;
            for (let i = 0; i < flen; i++) {
              const face = faces[i];
              f3(face[2] + offset, face[1] + offset, face[0] + offset);
            }
            layer = steps + bevelSegments * 2;
            offset = vlen * layer;
            for (let i = 0; i < flen; i++) {
              const face = faces[i];
              f3(face[0] + offset, face[1] + offset, face[2] + offset);
            }
          } else {
            for (let i = 0; i < flen; i++) {
              const face = faces[i];
              f3(face[2], face[1], face[0]);
            }
            for (let i = 0; i < flen; i++) {
              const face = faces[i];
              f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
            }
          }
          scope.addGroup(start, verticesArray.length / 3 - start, 0);
        }
        function buildSideFaces() {
          const start = verticesArray.length / 3;
          let layeroffset = 0;
          sidewalls(contour, layeroffset);
          layeroffset += contour.length;
          for (let h = 0, hl = holes.length; h < hl; h++) {
            const ahole = holes[h];
            sidewalls(ahole, layeroffset);
            layeroffset += ahole.length;
          }
          scope.addGroup(start, verticesArray.length / 3 - start, 1);
        }
        function sidewalls(contour2, layeroffset) {
          let i = contour2.length;
          while (--i >= 0) {
            const j = i;
            let k = i - 1;
            if (k < 0)
              k = contour2.length - 1;
            for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
              const slen1 = vlen * s;
              const slen2 = vlen * (s + 1);
              const a = layeroffset + j + slen1, b2 = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
              f4(a, b2, c, d);
            }
          }
        }
        function v(x, y, z) {
          placeholder.push(x);
          placeholder.push(y);
          placeholder.push(z);
        }
        function f3(a, b2, c) {
          addVertex(a);
          addVertex(b2);
          addVertex(c);
          const nextIndex = verticesArray.length / 3;
          const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
          addUV(uvs[0]);
          addUV(uvs[1]);
          addUV(uvs[2]);
        }
        function f4(a, b2, c, d) {
          addVertex(a);
          addVertex(b2);
          addVertex(d);
          addVertex(b2);
          addVertex(c);
          addVertex(d);
          const nextIndex = verticesArray.length / 3;
          const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
          addUV(uvs[0]);
          addUV(uvs[1]);
          addUV(uvs[3]);
          addUV(uvs[1]);
          addUV(uvs[2]);
          addUV(uvs[3]);
        }
        function addVertex(index) {
          verticesArray.push(placeholder[index * 3 + 0]);
          verticesArray.push(placeholder[index * 3 + 1]);
          verticesArray.push(placeholder[index * 3 + 2]);
        }
        function addUV(vector2) {
          uvArray.push(vector2.x);
          uvArray.push(vector2.y);
        }
      }
    }
    toJSON() {
      const data = BufferGeometry.prototype.toJSON.call(this);
      const shapes = this.parameters.shapes;
      const options = this.parameters.options;
      return toJSON$1(shapes, options, data);
    }
  };
  var WorldUVGenerator = {
    generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
      const a_x = vertices[indexA * 3];
      const a_y = vertices[indexA * 3 + 1];
      const b_x = vertices[indexB * 3];
      const b_y = vertices[indexB * 3 + 1];
      const c_x = vertices[indexC * 3];
      const c_y = vertices[indexC * 3 + 1];
      return [
        new Vector2(a_x, a_y),
        new Vector2(b_x, b_y),
        new Vector2(c_x, c_y)
      ];
    },
    generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
      const a_x = vertices[indexA * 3];
      const a_y = vertices[indexA * 3 + 1];
      const a_z = vertices[indexA * 3 + 2];
      const b_x = vertices[indexB * 3];
      const b_y = vertices[indexB * 3 + 1];
      const b_z = vertices[indexB * 3 + 2];
      const c_x = vertices[indexC * 3];
      const c_y = vertices[indexC * 3 + 1];
      const c_z = vertices[indexC * 3 + 2];
      const d_x = vertices[indexD * 3];
      const d_y = vertices[indexD * 3 + 1];
      const d_z = vertices[indexD * 3 + 2];
      if (Math.abs(a_y - b_y) < 0.01) {
        return [
          new Vector2(a_x, 1 - a_z),
          new Vector2(b_x, 1 - b_z),
          new Vector2(c_x, 1 - c_z),
          new Vector2(d_x, 1 - d_z)
        ];
      } else {
        return [
          new Vector2(a_y, 1 - a_z),
          new Vector2(b_y, 1 - b_z),
          new Vector2(c_y, 1 - c_z),
          new Vector2(d_y, 1 - d_z)
        ];
      }
    }
  };
  function toJSON$1(shapes, options, data) {
    data.shapes = [];
    if (Array.isArray(shapes)) {
      for (let i = 0, l = shapes.length; i < l; i++) {
        const shape = shapes[i];
        data.shapes.push(shape.uuid);
      }
    } else {
      data.shapes.push(shapes.uuid);
    }
    if (options.extrudePath !== void 0)
      data.options.extrudePath = options.extrudePath.toJSON();
    return data;
  }
  var IcosahedronGeometry = class extends PolyhedronGeometry {
    constructor(radius = 1, detail = 0) {
      const t = (1 + Math.sqrt(5)) / 2;
      const vertices = [
        -1,
        t,
        0,
        1,
        t,
        0,
        -1,
        -t,
        0,
        1,
        -t,
        0,
        0,
        -1,
        t,
        0,
        1,
        t,
        0,
        -1,
        -t,
        0,
        1,
        -t,
        t,
        0,
        -1,
        t,
        0,
        1,
        -t,
        0,
        -1,
        -t,
        0,
        1
      ];
      const indices = [
        0,
        11,
        5,
        0,
        5,
        1,
        0,
        1,
        7,
        0,
        7,
        10,
        0,
        10,
        11,
        1,
        5,
        9,
        5,
        11,
        4,
        11,
        10,
        2,
        10,
        7,
        6,
        7,
        1,
        8,
        3,
        9,
        4,
        3,
        4,
        2,
        3,
        2,
        6,
        3,
        6,
        8,
        3,
        8,
        9,
        4,
        9,
        5,
        2,
        4,
        11,
        6,
        2,
        10,
        8,
        6,
        7,
        9,
        8,
        1
      ];
      super(vertices, indices, radius, detail);
      this.type = "IcosahedronGeometry";
      this.parameters = {
        radius,
        detail
      };
    }
  };
  var LatheGeometry = class extends BufferGeometry {
    constructor(points, segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
      super();
      this.type = "LatheGeometry";
      this.parameters = {
        points,
        segments,
        phiStart,
        phiLength
      };
      segments = Math.floor(segments);
      phiLength = MathUtils.clamp(phiLength, 0, Math.PI * 2);
      const indices = [];
      const vertices = [];
      const uvs = [];
      const inverseSegments = 1 / segments;
      const vertex = new Vector3();
      const uv = new Vector2();
      for (let i = 0; i <= segments; i++) {
        const phi = phiStart + i * inverseSegments * phiLength;
        const sin = Math.sin(phi);
        const cos = Math.cos(phi);
        for (let j = 0; j <= points.length - 1; j++) {
          vertex.x = points[j].x * sin;
          vertex.y = points[j].y;
          vertex.z = points[j].x * cos;
          vertices.push(vertex.x, vertex.y, vertex.z);
          uv.x = i / segments;
          uv.y = j / (points.length - 1);
          uvs.push(uv.x, uv.y);
        }
      }
      for (let i = 0; i < segments; i++) {
        for (let j = 0; j < points.length - 1; j++) {
          const base = j + i * points.length;
          const a = base;
          const b2 = base + points.length;
          const c = base + points.length + 1;
          const d = base + 1;
          indices.push(a, b2, d);
          indices.push(b2, c, d);
        }
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      this.computeVertexNormals();
      if (phiLength === Math.PI * 2) {
        const normals = this.attributes.normal.array;
        const n1 = new Vector3();
        const n2 = new Vector3();
        const n = new Vector3();
        const base = segments * points.length * 3;
        for (let i = 0, j = 0; i < points.length; i++, j += 3) {
          n1.x = normals[j + 0];
          n1.y = normals[j + 1];
          n1.z = normals[j + 2];
          n2.x = normals[base + j + 0];
          n2.y = normals[base + j + 1];
          n2.z = normals[base + j + 2];
          n.addVectors(n1, n2).normalize();
          normals[j + 0] = normals[base + j + 0] = n.x;
          normals[j + 1] = normals[base + j + 1] = n.y;
          normals[j + 2] = normals[base + j + 2] = n.z;
        }
      }
    }
  };
  var OctahedronGeometry = class extends PolyhedronGeometry {
    constructor(radius = 1, detail = 0) {
      const vertices = [
        1,
        0,
        0,
        -1,
        0,
        0,
        0,
        1,
        0,
        0,
        -1,
        0,
        0,
        0,
        1,
        0,
        0,
        -1
      ];
      const indices = [
        0,
        2,
        4,
        0,
        4,
        3,
        0,
        3,
        5,
        0,
        5,
        2,
        1,
        2,
        5,
        1,
        5,
        3,
        1,
        3,
        4,
        1,
        4,
        2
      ];
      super(vertices, indices, radius, detail);
      this.type = "OctahedronGeometry";
      this.parameters = {
        radius,
        detail
      };
    }
  };
  function ParametricGeometry(func, slices, stacks) {
    BufferGeometry.call(this);
    this.type = "ParametricGeometry";
    this.parameters = {
      func,
      slices,
      stacks
    };
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const EPS = 1e-5;
    const normal = new Vector3();
    const p0 = new Vector3(), p1 = new Vector3();
    const pu = new Vector3(), pv = new Vector3();
    if (func.length < 3) {
      console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
    }
    const sliceCount = slices + 1;
    for (let i = 0; i <= stacks; i++) {
      const v = i / stacks;
      for (let j = 0; j <= slices; j++) {
        const u = j / slices;
        func(u, v, p0);
        vertices.push(p0.x, p0.y, p0.z);
        if (u - EPS >= 0) {
          func(u - EPS, v, p1);
          pu.subVectors(p0, p1);
        } else {
          func(u + EPS, v, p1);
          pu.subVectors(p1, p0);
        }
        if (v - EPS >= 0) {
          func(u, v - EPS, p1);
          pv.subVectors(p0, p1);
        } else {
          func(u, v + EPS, p1);
          pv.subVectors(p1, p0);
        }
        normal.crossVectors(pu, pv).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u, v);
      }
    }
    for (let i = 0; i < stacks; i++) {
      for (let j = 0; j < slices; j++) {
        const a = i * sliceCount + j;
        const b2 = i * sliceCount + j + 1;
        const c = (i + 1) * sliceCount + j + 1;
        const d = (i + 1) * sliceCount + j;
        indices.push(a, b2, d);
        indices.push(b2, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  ParametricGeometry.prototype = Object.create(BufferGeometry.prototype);
  ParametricGeometry.prototype.constructor = ParametricGeometry;
  var RingGeometry = class extends BufferGeometry {
    constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
      super();
      this.type = "RingGeometry";
      this.parameters = {
        innerRadius,
        outerRadius,
        thetaSegments,
        phiSegments,
        thetaStart,
        thetaLength
      };
      thetaSegments = Math.max(3, thetaSegments);
      phiSegments = Math.max(1, phiSegments);
      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];
      let radius = innerRadius;
      const radiusStep = (outerRadius - innerRadius) / phiSegments;
      const vertex = new Vector3();
      const uv = new Vector2();
      for (let j = 0; j <= phiSegments; j++) {
        for (let i = 0; i <= thetaSegments; i++) {
          const segment = thetaStart + i / thetaSegments * thetaLength;
          vertex.x = radius * Math.cos(segment);
          vertex.y = radius * Math.sin(segment);
          vertices.push(vertex.x, vertex.y, vertex.z);
          normals.push(0, 0, 1);
          uv.x = (vertex.x / outerRadius + 1) / 2;
          uv.y = (vertex.y / outerRadius + 1) / 2;
          uvs.push(uv.x, uv.y);
        }
        radius += radiusStep;
      }
      for (let j = 0; j < phiSegments; j++) {
        const thetaSegmentLevel = j * (thetaSegments + 1);
        for (let i = 0; i < thetaSegments; i++) {
          const segment = i + thetaSegmentLevel;
          const a = segment;
          const b2 = segment + thetaSegments + 1;
          const c = segment + thetaSegments + 2;
          const d = segment + 1;
          indices.push(a, b2, d);
          indices.push(b2, c, d);
        }
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
  };
  var ShapeGeometry = class extends BufferGeometry {
    constructor(shapes, curveSegments = 12) {
      super();
      this.type = "ShapeGeometry";
      this.parameters = {
        shapes,
        curveSegments
      };
      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];
      let groupStart = 0;
      let groupCount = 0;
      if (Array.isArray(shapes) === false) {
        addShape(shapes);
      } else {
        for (let i = 0; i < shapes.length; i++) {
          addShape(shapes[i]);
          this.addGroup(groupStart, groupCount, i);
          groupStart += groupCount;
          groupCount = 0;
        }
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      function addShape(shape) {
        const indexOffset = vertices.length / 3;
        const points = shape.extractPoints(curveSegments);
        let shapeVertices = points.shape;
        const shapeHoles = points.holes;
        if (ShapeUtils.isClockWise(shapeVertices) === false) {
          shapeVertices = shapeVertices.reverse();
        }
        for (let i = 0, l = shapeHoles.length; i < l; i++) {
          const shapeHole = shapeHoles[i];
          if (ShapeUtils.isClockWise(shapeHole) === true) {
            shapeHoles[i] = shapeHole.reverse();
          }
        }
        const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
        for (let i = 0, l = shapeHoles.length; i < l; i++) {
          const shapeHole = shapeHoles[i];
          shapeVertices = shapeVertices.concat(shapeHole);
        }
        for (let i = 0, l = shapeVertices.length; i < l; i++) {
          const vertex = shapeVertices[i];
          vertices.push(vertex.x, vertex.y, 0);
          normals.push(0, 0, 1);
          uvs.push(vertex.x, vertex.y);
        }
        for (let i = 0, l = faces.length; i < l; i++) {
          const face = faces[i];
          const a = face[0] + indexOffset;
          const b2 = face[1] + indexOffset;
          const c = face[2] + indexOffset;
          indices.push(a, b2, c);
          groupCount += 3;
        }
      }
    }
    toJSON() {
      const data = BufferGeometry.prototype.toJSON.call(this);
      const shapes = this.parameters.shapes;
      return toJSON(shapes, data);
    }
  };
  function toJSON(shapes, data) {
    data.shapes = [];
    if (Array.isArray(shapes)) {
      for (let i = 0, l = shapes.length; i < l; i++) {
        const shape = shapes[i];
        data.shapes.push(shape.uuid);
      }
    } else {
      data.shapes.push(shapes.uuid);
    }
    return data;
  }
  var SphereGeometry = class extends BufferGeometry {
    constructor(radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
      super();
      this.type = "SphereGeometry";
      this.parameters = {
        radius,
        widthSegments,
        heightSegments,
        phiStart,
        phiLength,
        thetaStart,
        thetaLength
      };
      widthSegments = Math.max(3, Math.floor(widthSegments));
      heightSegments = Math.max(2, Math.floor(heightSegments));
      const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
      let index = 0;
      const grid = [];
      const vertex = new Vector3();
      const normal = new Vector3();
      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];
      for (let iy = 0; iy <= heightSegments; iy++) {
        const verticesRow = [];
        const v = iy / heightSegments;
        let uOffset = 0;
        if (iy == 0 && thetaStart == 0) {
          uOffset = 0.5 / widthSegments;
        } else if (iy == heightSegments && thetaEnd == Math.PI) {
          uOffset = -0.5 / widthSegments;
        }
        for (let ix = 0; ix <= widthSegments; ix++) {
          const u = ix / widthSegments;
          vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
          vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
          vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
          vertices.push(vertex.x, vertex.y, vertex.z);
          normal.copy(vertex).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(u + uOffset, 1 - v);
          verticesRow.push(index++);
        }
        grid.push(verticesRow);
      }
      for (let iy = 0; iy < heightSegments; iy++) {
        for (let ix = 0; ix < widthSegments; ix++) {
          const a = grid[iy][ix + 1];
          const b2 = grid[iy][ix];
          const c = grid[iy + 1][ix];
          const d = grid[iy + 1][ix + 1];
          if (iy !== 0 || thetaStart > 0)
            indices.push(a, b2, d);
          if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
            indices.push(b2, c, d);
        }
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
  };
  var TetrahedronGeometry = class extends PolyhedronGeometry {
    constructor(radius = 1, detail = 0) {
      const vertices = [
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        1,
        -1,
        -1
      ];
      const indices = [
        2,
        1,
        0,
        0,
        3,
        2,
        1,
        3,
        0,
        2,
        3,
        1
      ];
      super(vertices, indices, radius, detail);
      this.type = "TetrahedronGeometry";
      this.parameters = {
        radius,
        detail
      };
    }
  };
  var TextGeometry = class extends ExtrudeGeometry {
    constructor(text, parameters = {}) {
      const font = parameters.font;
      if (!(font && font.isFont)) {
        console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font.");
        return new BufferGeometry();
      }
      const shapes = font.generateShapes(text, parameters.size);
      parameters.depth = parameters.height !== void 0 ? parameters.height : 50;
      if (parameters.bevelThickness === void 0)
        parameters.bevelThickness = 10;
      if (parameters.bevelSize === void 0)
        parameters.bevelSize = 8;
      if (parameters.bevelEnabled === void 0)
        parameters.bevelEnabled = false;
      super(shapes, parameters);
      this.type = "TextGeometry";
    }
  };
  var TorusGeometry = class extends BufferGeometry {
    constructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {
      super();
      this.type = "TorusGeometry";
      this.parameters = {
        radius,
        tube,
        radialSegments,
        tubularSegments,
        arc
      };
      radialSegments = Math.floor(radialSegments);
      tubularSegments = Math.floor(tubularSegments);
      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];
      const center = new Vector3();
      const vertex = new Vector3();
      const normal = new Vector3();
      for (let j = 0; j <= radialSegments; j++) {
        for (let i = 0; i <= tubularSegments; i++) {
          const u = i / tubularSegments * arc;
          const v = j / radialSegments * Math.PI * 2;
          vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
          vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
          vertex.z = tube * Math.sin(v);
          vertices.push(vertex.x, vertex.y, vertex.z);
          center.x = radius * Math.cos(u);
          center.y = radius * Math.sin(u);
          normal.subVectors(vertex, center).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(i / tubularSegments);
          uvs.push(j / radialSegments);
        }
      }
      for (let j = 1; j <= radialSegments; j++) {
        for (let i = 1; i <= tubularSegments; i++) {
          const a = (tubularSegments + 1) * j + i - 1;
          const b2 = (tubularSegments + 1) * (j - 1) + i - 1;
          const c = (tubularSegments + 1) * (j - 1) + i;
          const d = (tubularSegments + 1) * j + i;
          indices.push(a, b2, d);
          indices.push(b2, c, d);
        }
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
  };
  var TorusKnotGeometry = class extends BufferGeometry {
    constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {
      super();
      this.type = "TorusKnotGeometry";
      this.parameters = {
        radius,
        tube,
        tubularSegments,
        radialSegments,
        p,
        q
      };
      tubularSegments = Math.floor(tubularSegments);
      radialSegments = Math.floor(radialSegments);
      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];
      const vertex = new Vector3();
      const normal = new Vector3();
      const P1 = new Vector3();
      const P2 = new Vector3();
      const B = new Vector3();
      const T = new Vector3();
      const N = new Vector3();
      for (let i = 0; i <= tubularSegments; ++i) {
        const u = i / tubularSegments * p * Math.PI * 2;
        calculatePositionOnCurve(u, p, q, radius, P1);
        calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
        T.subVectors(P2, P1);
        N.addVectors(P2, P1);
        B.crossVectors(T, N);
        N.crossVectors(B, T);
        B.normalize();
        N.normalize();
        for (let j = 0; j <= radialSegments; ++j) {
          const v = j / radialSegments * Math.PI * 2;
          const cx = -tube * Math.cos(v);
          const cy = tube * Math.sin(v);
          vertex.x = P1.x + (cx * N.x + cy * B.x);
          vertex.y = P1.y + (cx * N.y + cy * B.y);
          vertex.z = P1.z + (cx * N.z + cy * B.z);
          vertices.push(vertex.x, vertex.y, vertex.z);
          normal.subVectors(vertex, P1).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(i / tubularSegments);
          uvs.push(j / radialSegments);
        }
      }
      for (let j = 1; j <= tubularSegments; j++) {
        for (let i = 1; i <= radialSegments; i++) {
          const a = (radialSegments + 1) * (j - 1) + (i - 1);
          const b2 = (radialSegments + 1) * j + (i - 1);
          const c = (radialSegments + 1) * j + i;
          const d = (radialSegments + 1) * (j - 1) + i;
          indices.push(a, b2, d);
          indices.push(b2, c, d);
        }
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      function calculatePositionOnCurve(u, p2, q2, radius2, position) {
        const cu = Math.cos(u);
        const su = Math.sin(u);
        const quOverP = q2 / p2 * u;
        const cs = Math.cos(quOverP);
        position.x = radius2 * (2 + cs) * 0.5 * cu;
        position.y = radius2 * (2 + cs) * su * 0.5;
        position.z = radius2 * Math.sin(quOverP) * 0.5;
      }
    }
  };
  var TubeGeometry = class extends BufferGeometry {
    constructor(path, tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
      super();
      this.type = "TubeGeometry";
      this.parameters = {
        path,
        tubularSegments,
        radius,
        radialSegments,
        closed
      };
      const frames = path.computeFrenetFrames(tubularSegments, closed);
      this.tangents = frames.tangents;
      this.normals = frames.normals;
      this.binormals = frames.binormals;
      const vertex = new Vector3();
      const normal = new Vector3();
      const uv = new Vector2();
      let P2 = new Vector3();
      const vertices = [];
      const normals = [];
      const uvs = [];
      const indices = [];
      generateBufferData();
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      function generateBufferData() {
        for (let i = 0; i < tubularSegments; i++) {
          generateSegment(i);
        }
        generateSegment(closed === false ? tubularSegments : 0);
        generateUVs();
        generateIndices();
      }
      function generateSegment(i) {
        P2 = path.getPointAt(i / tubularSegments, P2);
        const N = frames.normals[i];
        const B = frames.binormals[i];
        for (let j = 0; j <= radialSegments; j++) {
          const v = j / radialSegments * Math.PI * 2;
          const sin = Math.sin(v);
          const cos = -Math.cos(v);
          normal.x = cos * N.x + sin * B.x;
          normal.y = cos * N.y + sin * B.y;
          normal.z = cos * N.z + sin * B.z;
          normal.normalize();
          normals.push(normal.x, normal.y, normal.z);
          vertex.x = P2.x + radius * normal.x;
          vertex.y = P2.y + radius * normal.y;
          vertex.z = P2.z + radius * normal.z;
          vertices.push(vertex.x, vertex.y, vertex.z);
        }
      }
      function generateIndices() {
        for (let j = 1; j <= tubularSegments; j++) {
          for (let i = 1; i <= radialSegments; i++) {
            const a = (radialSegments + 1) * (j - 1) + (i - 1);
            const b2 = (radialSegments + 1) * j + (i - 1);
            const c = (radialSegments + 1) * j + i;
            const d = (radialSegments + 1) * (j - 1) + i;
            indices.push(a, b2, d);
            indices.push(b2, c, d);
          }
        }
      }
      function generateUVs() {
        for (let i = 0; i <= tubularSegments; i++) {
          for (let j = 0; j <= radialSegments; j++) {
            uv.x = i / tubularSegments;
            uv.y = j / radialSegments;
            uvs.push(uv.x, uv.y);
          }
        }
      }
    }
    toJSON() {
      const data = BufferGeometry.prototype.toJSON.call(this);
      data.path = this.parameters.path.toJSON();
      return data;
    }
  };
  var WireframeGeometry = class extends BufferGeometry {
    constructor(geometry) {
      super();
      this.type = "WireframeGeometry";
      if (geometry.isGeometry === true) {
        console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        return;
      }
      const vertices = [];
      const edge = [0, 0], edges = {};
      const vertex = new Vector3();
      if (geometry.index !== null) {
        const position = geometry.attributes.position;
        const indices = geometry.index;
        let groups = geometry.groups;
        if (groups.length === 0) {
          groups = [{ start: 0, count: indices.count, materialIndex: 0 }];
        }
        for (let o = 0, ol = groups.length; o < ol; ++o) {
          const group = groups[o];
          const start = group.start;
          const count = group.count;
          for (let i = start, l = start + count; i < l; i += 3) {
            for (let j = 0; j < 3; j++) {
              const edge1 = indices.getX(i + j);
              const edge2 = indices.getX(i + (j + 1) % 3);
              edge[0] = Math.min(edge1, edge2);
              edge[1] = Math.max(edge1, edge2);
              const key = edge[0] + "," + edge[1];
              if (edges[key] === void 0) {
                edges[key] = { index1: edge[0], index2: edge[1] };
              }
            }
          }
        }
        for (const key in edges) {
          const e = edges[key];
          vertex.fromBufferAttribute(position, e.index1);
          vertices.push(vertex.x, vertex.y, vertex.z);
          vertex.fromBufferAttribute(position, e.index2);
          vertices.push(vertex.x, vertex.y, vertex.z);
        }
      } else {
        const position = geometry.attributes.position;
        for (let i = 0, l = position.count / 3; i < l; i++) {
          for (let j = 0; j < 3; j++) {
            const index1 = 3 * i + j;
            vertex.fromBufferAttribute(position, index1);
            vertices.push(vertex.x, vertex.y, vertex.z);
            const index2 = 3 * i + (j + 1) % 3;
            vertex.fromBufferAttribute(position, index2);
            vertices.push(vertex.x, vertex.y, vertex.z);
          }
        }
      }
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    }
  };
  var Geometries = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    BoxGeometry,
    BoxBufferGeometry: BoxGeometry,
    CircleGeometry,
    CircleBufferGeometry: CircleGeometry,
    ConeGeometry,
    ConeBufferGeometry: ConeGeometry,
    CylinderGeometry,
    CylinderBufferGeometry: CylinderGeometry,
    DodecahedronGeometry,
    DodecahedronBufferGeometry: DodecahedronGeometry,
    EdgesGeometry,
    ExtrudeGeometry,
    ExtrudeBufferGeometry: ExtrudeGeometry,
    IcosahedronGeometry,
    IcosahedronBufferGeometry: IcosahedronGeometry,
    LatheGeometry,
    LatheBufferGeometry: LatheGeometry,
    OctahedronGeometry,
    OctahedronBufferGeometry: OctahedronGeometry,
    ParametricGeometry,
    ParametricBufferGeometry: ParametricGeometry,
    PlaneGeometry,
    PlaneBufferGeometry: PlaneGeometry,
    PolyhedronGeometry,
    PolyhedronBufferGeometry: PolyhedronGeometry,
    RingGeometry,
    RingBufferGeometry: RingGeometry,
    ShapeGeometry,
    ShapeBufferGeometry: ShapeGeometry,
    SphereGeometry,
    SphereBufferGeometry: SphereGeometry,
    TetrahedronGeometry,
    TetrahedronBufferGeometry: TetrahedronGeometry,
    TextGeometry,
    TextBufferGeometry: TextGeometry,
    TorusGeometry,
    TorusBufferGeometry: TorusGeometry,
    TorusKnotGeometry,
    TorusKnotBufferGeometry: TorusKnotGeometry,
    TubeGeometry,
    TubeBufferGeometry: TubeGeometry,
    WireframeGeometry
  });
  var ShadowMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "ShadowMaterial";
      this.color = new Color(0);
      this.transparent = true;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      return this;
    }
  };
  ShadowMaterial.prototype.isShadowMaterial = true;
  var RawShaderMaterial = class extends ShaderMaterial {
    constructor(parameters) {
      super(parameters);
      this.type = "RawShaderMaterial";
    }
  };
  RawShaderMaterial.prototype.isRawShaderMaterial = true;
  function MeshStandardMaterial(parameters) {
    Material.call(this);
    this.defines = { "STANDARD": "" };
    this.type = "MeshStandardMaterial";
    this.color = new Color(16777215);
    this.roughness = 1;
    this.metalness = 0;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = null;
    this.metalnessMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapIntensity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.flatShading = false;
    this.vertexTangents = false;
    this.setValues(parameters);
  }
  MeshStandardMaterial.prototype = Object.create(Material.prototype);
  MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
  MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
  MeshStandardMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.defines = { "STANDARD": "" };
    this.color.copy(source.color);
    this.roughness = source.roughness;
    this.metalness = source.metalness;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.roughnessMap = source.roughnessMap;
    this.metalnessMap = source.metalnessMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapIntensity = source.envMapIntensity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.flatShading = source.flatShading;
    this.vertexTangents = source.vertexTangents;
    return this;
  };
  function MeshPhysicalMaterial(parameters) {
    MeshStandardMaterial.call(this);
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": ""
    };
    this.type = "MeshPhysicalMaterial";
    this.clearcoat = 0;
    this.clearcoatMap = null;
    this.clearcoatRoughness = 0;
    this.clearcoatRoughnessMap = null;
    this.clearcoatNormalScale = new Vector2(1, 1);
    this.clearcoatNormalMap = null;
    this.reflectivity = 0.5;
    Object.defineProperty(this, "ior", {
      get: function() {
        return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
      },
      set: function(ior) {
        this.reflectivity = MathUtils.clamp(2.5 * (ior - 1) / (ior + 1), 0, 1);
      }
    });
    this.sheen = null;
    this.transmission = 0;
    this.transmissionMap = null;
    this.setValues(parameters);
  }
  MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
  MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
  MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
  MeshPhysicalMaterial.prototype.copy = function(source) {
    MeshStandardMaterial.prototype.copy.call(this, source);
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": ""
    };
    this.clearcoat = source.clearcoat;
    this.clearcoatMap = source.clearcoatMap;
    this.clearcoatRoughness = source.clearcoatRoughness;
    this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
    this.clearcoatNormalMap = source.clearcoatNormalMap;
    this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
    this.reflectivity = source.reflectivity;
    if (source.sheen) {
      this.sheen = (this.sheen || new Color()).copy(source.sheen);
    } else {
      this.sheen = null;
    }
    this.transmission = source.transmission;
    this.transmissionMap = source.transmissionMap;
    return this;
  };
  var MeshPhongMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "MeshPhongMaterial";
      this.color = new Color(16777215);
      this.specular = new Color(1118481);
      this.shininess = 30;
      this.map = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.emissive = new Color(0);
      this.emissiveIntensity = 1;
      this.emissiveMap = null;
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.combine = MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;
      this.flatShading = false;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.specular.copy(source.specular);
      this.shininess = source.shininess;
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;
      this.flatShading = source.flatShading;
      return this;
    }
  };
  MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
  var MeshToonMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.defines = { "TOON": "" };
      this.type = "MeshToonMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.gradientMap = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.emissive = new Color(0);
      this.emissiveIntensity = 1;
      this.emissiveMap = null;
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.alphaMap = null;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.map = source.map;
      this.gradientMap = source.gradientMap;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.alphaMap = source.alphaMap;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;
      return this;
    }
  };
  MeshToonMaterial.prototype.isMeshToonMaterial = true;
  var MeshNormalMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "MeshNormalMaterial";
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.fog = false;
      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;
      this.flatShading = false;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;
      this.flatShading = source.flatShading;
      return this;
    }
  };
  MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
  var MeshLambertMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "MeshLambertMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.emissive = new Color(0);
      this.emissiveIntensity = 1;
      this.emissiveMap = null;
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.combine = MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;
      return this;
    }
  };
  MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
  var MeshMatcapMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.defines = { "MATCAP": "" };
      this.type = "MeshMatcapMaterial";
      this.color = new Color(16777215);
      this.matcap = null;
      this.map = null;
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.alphaMap = null;
      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;
      this.flatShading = false;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.defines = { "MATCAP": "" };
      this.color.copy(source.color);
      this.matcap = source.matcap;
      this.map = source.map;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.alphaMap = source.alphaMap;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;
      this.flatShading = source.flatShading;
      return this;
    }
  };
  MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
  var LineDashedMaterial = class extends LineBasicMaterial {
    constructor(parameters) {
      super();
      this.type = "LineDashedMaterial";
      this.scale = 1;
      this.dashSize = 3;
      this.gapSize = 1;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.scale = source.scale;
      this.dashSize = source.dashSize;
      this.gapSize = source.gapSize;
      return this;
    }
  };
  LineDashedMaterial.prototype.isLineDashedMaterial = true;
  var Materials = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ShadowMaterial,
    SpriteMaterial,
    RawShaderMaterial,
    ShaderMaterial,
    PointsMaterial,
    MeshPhysicalMaterial,
    MeshStandardMaterial,
    MeshPhongMaterial,
    MeshToonMaterial,
    MeshNormalMaterial,
    MeshLambertMaterial,
    MeshDepthMaterial,
    MeshDistanceMaterial,
    MeshBasicMaterial,
    MeshMatcapMaterial,
    LineDashedMaterial,
    LineBasicMaterial,
    Material
  });
  var AnimationUtils = {
    arraySlice: function(array, from, to) {
      if (AnimationUtils.isTypedArray(array)) {
        return new array.constructor(array.subarray(from, to !== void 0 ? to : array.length));
      }
      return array.slice(from, to);
    },
    convertArray: function(array, type, forceClone) {
      if (!array || !forceClone && array.constructor === type)
        return array;
      if (typeof type.BYTES_PER_ELEMENT === "number") {
        return new type(array);
      }
      return Array.prototype.slice.call(array);
    },
    isTypedArray: function(object) {
      return ArrayBuffer.isView(object) && !(object instanceof DataView);
    },
    getKeyframeOrder: function(times) {
      function compareTime(i, j) {
        return times[i] - times[j];
      }
      const n = times.length;
      const result = new Array(n);
      for (let i = 0; i !== n; ++i)
        result[i] = i;
      result.sort(compareTime);
      return result;
    },
    sortedArray: function(values, stride, order) {
      const nValues = values.length;
      const result = new values.constructor(nValues);
      for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
        const srcOffset = order[i] * stride;
        for (let j = 0; j !== stride; ++j) {
          result[dstOffset++] = values[srcOffset + j];
        }
      }
      return result;
    },
    flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
      let i = 1, key = jsonKeys[0];
      while (key !== void 0 && key[valuePropertyName] === void 0) {
        key = jsonKeys[i++];
      }
      if (key === void 0)
        return;
      let value = key[valuePropertyName];
      if (value === void 0)
        return;
      if (Array.isArray(value)) {
        do {
          value = key[valuePropertyName];
          if (value !== void 0) {
            times.push(key.time);
            values.push.apply(values, value);
          }
          key = jsonKeys[i++];
        } while (key !== void 0);
      } else if (value.toArray !== void 0) {
        do {
          value = key[valuePropertyName];
          if (value !== void 0) {
            times.push(key.time);
            value.toArray(values, values.length);
          }
          key = jsonKeys[i++];
        } while (key !== void 0);
      } else {
        do {
          value = key[valuePropertyName];
          if (value !== void 0) {
            times.push(key.time);
            values.push(value);
          }
          key = jsonKeys[i++];
        } while (key !== void 0);
      }
    },
    subclip: function(sourceClip, name, startFrame, endFrame, fps = 30) {
      const clip = sourceClip.clone();
      clip.name = name;
      const tracks = [];
      for (let i = 0; i < clip.tracks.length; ++i) {
        const track = clip.tracks[i];
        const valueSize = track.getValueSize();
        const times = [];
        const values = [];
        for (let j = 0; j < track.times.length; ++j) {
          const frame = track.times[j] * fps;
          if (frame < startFrame || frame >= endFrame)
            continue;
          times.push(track.times[j]);
          for (let k = 0; k < valueSize; ++k) {
            values.push(track.values[j * valueSize + k]);
          }
        }
        if (times.length === 0)
          continue;
        track.times = AnimationUtils.convertArray(times, track.times.constructor);
        track.values = AnimationUtils.convertArray(values, track.values.constructor);
        tracks.push(track);
      }
      clip.tracks = tracks;
      let minStartTime = Infinity;
      for (let i = 0; i < clip.tracks.length; ++i) {
        if (minStartTime > clip.tracks[i].times[0]) {
          minStartTime = clip.tracks[i].times[0];
        }
      }
      for (let i = 0; i < clip.tracks.length; ++i) {
        clip.tracks[i].shift(-1 * minStartTime);
      }
      clip.resetDuration();
      return clip;
    },
    makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
      if (fps <= 0)
        fps = 30;
      const numTracks = referenceClip.tracks.length;
      const referenceTime = referenceFrame / fps;
      for (let i = 0; i < numTracks; ++i) {
        const referenceTrack = referenceClip.tracks[i];
        const referenceTrackType = referenceTrack.ValueTypeName;
        if (referenceTrackType === "bool" || referenceTrackType === "string")
          continue;
        const targetTrack = targetClip.tracks.find(function(track) {
          return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
        });
        if (targetTrack === void 0)
          continue;
        let referenceOffset = 0;
        const referenceValueSize = referenceTrack.getValueSize();
        if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
          referenceOffset = referenceValueSize / 3;
        }
        let targetOffset = 0;
        const targetValueSize = targetTrack.getValueSize();
        if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
          targetOffset = targetValueSize / 3;
        }
        const lastIndex = referenceTrack.times.length - 1;
        let referenceValue;
        if (referenceTime <= referenceTrack.times[0]) {
          const startIndex = referenceOffset;
          const endIndex = referenceValueSize - referenceOffset;
          referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
        } else if (referenceTime >= referenceTrack.times[lastIndex]) {
          const startIndex = lastIndex * referenceValueSize + referenceOffset;
          const endIndex = startIndex + referenceValueSize - referenceOffset;
          referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
        } else {
          const interpolant = referenceTrack.createInterpolant();
          const startIndex = referenceOffset;
          const endIndex = referenceValueSize - referenceOffset;
          interpolant.evaluate(referenceTime);
          referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
        }
        if (referenceTrackType === "quaternion") {
          const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
          referenceQuat.toArray(referenceValue);
        }
        const numTimes = targetTrack.times.length;
        for (let j = 0; j < numTimes; ++j) {
          const valueStart = j * targetValueSize + targetOffset;
          if (referenceTrackType === "quaternion") {
            Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
          } else {
            const valueEnd = targetValueSize - targetOffset * 2;
            for (let k = 0; k < valueEnd; ++k) {
              targetTrack.values[valueStart + k] -= referenceValue[k];
            }
          }
        }
      }
      targetClip.blendMode = AdditiveAnimationBlendMode;
      return targetClip;
    }
  };
  function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
  }
  Object.assign(Interpolant.prototype, {
    evaluate: function(t) {
      const pp = this.parameterPositions;
      let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
      validate_interval: {
        seek: {
          let right;
          linear_scan: {
            forward_scan:
              if (!(t < t1)) {
                for (let giveUpAt = i1 + 2; ; ) {
                  if (t1 === void 0) {
                    if (t < t0)
                      break forward_scan;
                    i1 = pp.length;
                    this._cachedIndex = i1;
                    return this.afterEnd_(i1 - 1, t, t0);
                  }
                  if (i1 === giveUpAt)
                    break;
                  t0 = t1;
                  t1 = pp[++i1];
                  if (t < t1) {
                    break seek;
                  }
                }
                right = pp.length;
                break linear_scan;
              }
            if (!(t >= t0)) {
              const t1global = pp[1];
              if (t < t1global) {
                i1 = 2;
                t0 = t1global;
              }
              for (let giveUpAt = i1 - 2; ; ) {
                if (t0 === void 0) {
                  this._cachedIndex = 0;
                  return this.beforeStart_(0, t, t1);
                }
                if (i1 === giveUpAt)
                  break;
                t1 = t0;
                t0 = pp[--i1 - 1];
                if (t >= t0) {
                  break seek;
                }
              }
              right = i1;
              i1 = 0;
              break linear_scan;
            }
            break validate_interval;
          }
          while (i1 < right) {
            const mid = i1 + right >>> 1;
            if (t < pp[mid]) {
              right = mid;
            } else {
              i1 = mid + 1;
            }
          }
          t1 = pp[i1];
          t0 = pp[i1 - 1];
          if (t0 === void 0) {
            this._cachedIndex = 0;
            return this.beforeStart_(0, t, t1);
          }
          if (t1 === void 0) {
            i1 = pp.length;
            this._cachedIndex = i1;
            return this.afterEnd_(i1 - 1, t0, t);
          }
        }
        this._cachedIndex = i1;
        this.intervalChanged_(i1, t0, t1);
      }
      return this.interpolate_(i1, t0, t, t1);
    },
    settings: null,
    DefaultSettings_: {},
    getSettings_: function() {
      return this.settings || this.DefaultSettings_;
    },
    copySampleValue_: function(index) {
      const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
      for (let i = 0; i !== stride; ++i) {
        result[i] = values[offset + i];
      }
      return result;
    },
    interpolate_: function() {
      throw new Error("call to abstract method");
    },
    intervalChanged_: function() {
    }
  });
  Object.assign(Interpolant.prototype, {
    beforeStart_: Interpolant.prototype.copySampleValue_,
    afterEnd_: Interpolant.prototype.copySampleValue_
  });
  function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
  }
  CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: CubicInterpolant,
    DefaultSettings_: {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    },
    intervalChanged_: function(i1, t0, t1) {
      const pp = this.parameterPositions;
      let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
      if (tPrev === void 0) {
        switch (this.getSettings_().endingStart) {
          case ZeroSlopeEnding:
            iPrev = i1;
            tPrev = 2 * t0 - t1;
            break;
          case WrapAroundEnding:
            iPrev = pp.length - 2;
            tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
            break;
          default:
            iPrev = i1;
            tPrev = t1;
        }
      }
      if (tNext === void 0) {
        switch (this.getSettings_().endingEnd) {
          case ZeroSlopeEnding:
            iNext = i1;
            tNext = 2 * t1 - t0;
            break;
          case WrapAroundEnding:
            iNext = 1;
            tNext = t1 + pp[1] - pp[0];
            break;
          default:
            iNext = i1 - 1;
            tNext = t0;
        }
      }
      const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
      this._weightPrev = halfDt / (t0 - tPrev);
      this._weightNext = halfDt / (tNext - t1);
      this._offsetPrev = iPrev * stride;
      this._offsetNext = iNext * stride;
    },
    interpolate_: function(i1, t0, t, t1) {
      const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
      const sP = -wP * ppp + 2 * wP * pp - wP * p;
      const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
      const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
      const sN = wN * ppp - wN * pp;
      for (let i = 0; i !== stride; ++i) {
        result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
      }
      return result;
    }
  });
  function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: LinearInterpolant,
    interpolate_: function(i1, t0, t, t1) {
      const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
      for (let i = 0; i !== stride; ++i) {
        result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
      }
      return result;
    }
  });
  function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: DiscreteInterpolant,
    interpolate_: function(i1) {
      return this.copySampleValue_(i1 - 1);
    }
  });
  var KeyframeTrack = class {
    constructor(name, times, values, interpolation) {
      if (name === void 0)
        throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (times === void 0 || times.length === 0)
        throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
      this.name = name;
      this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
      this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
      this.setInterpolation(interpolation || this.DefaultInterpolation);
    }
    static toJSON(track) {
      const trackType = track.constructor;
      let json;
      if (trackType.toJSON !== this.toJSON) {
        json = trackType.toJSON(track);
      } else {
        json = {
          "name": track.name,
          "times": AnimationUtils.convertArray(track.times, Array),
          "values": AnimationUtils.convertArray(track.values, Array)
        };
        const interpolation = track.getInterpolation();
        if (interpolation !== track.DefaultInterpolation) {
          json.interpolation = interpolation;
        }
      }
      json.type = track.ValueTypeName;
      return json;
    }
    InterpolantFactoryMethodDiscrete(result) {
      return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
    }
    InterpolantFactoryMethodLinear(result) {
      return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
    }
    InterpolantFactoryMethodSmooth(result) {
      return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
    }
    setInterpolation(interpolation) {
      let factoryMethod;
      switch (interpolation) {
        case InterpolateDiscrete:
          factoryMethod = this.InterpolantFactoryMethodDiscrete;
          break;
        case InterpolateLinear:
          factoryMethod = this.InterpolantFactoryMethodLinear;
          break;
        case InterpolateSmooth:
          factoryMethod = this.InterpolantFactoryMethodSmooth;
          break;
      }
      if (factoryMethod === void 0) {
        const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
        if (this.createInterpolant === void 0) {
          if (interpolation !== this.DefaultInterpolation) {
            this.setInterpolation(this.DefaultInterpolation);
          } else {
            throw new Error(message);
          }
        }
        console.warn("THREE.KeyframeTrack:", message);
        return this;
      }
      this.createInterpolant = factoryMethod;
      return this;
    }
    getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return InterpolateDiscrete;
        case this.InterpolantFactoryMethodLinear:
          return InterpolateLinear;
        case this.InterpolantFactoryMethodSmooth:
          return InterpolateSmooth;
      }
    }
    getValueSize() {
      return this.values.length / this.times.length;
    }
    shift(timeOffset) {
      if (timeOffset !== 0) {
        const times = this.times;
        for (let i = 0, n = times.length; i !== n; ++i) {
          times[i] += timeOffset;
        }
      }
      return this;
    }
    scale(timeScale) {
      if (timeScale !== 1) {
        const times = this.times;
        for (let i = 0, n = times.length; i !== n; ++i) {
          times[i] *= timeScale;
        }
      }
      return this;
    }
    trim(startTime, endTime) {
      const times = this.times, nKeys = times.length;
      let from = 0, to = nKeys - 1;
      while (from !== nKeys && times[from] < startTime) {
        ++from;
      }
      while (to !== -1 && times[to] > endTime) {
        --to;
      }
      ++to;
      if (from !== 0 || to !== nKeys) {
        if (from >= to) {
          to = Math.max(to, 1);
          from = to - 1;
        }
        const stride = this.getValueSize();
        this.times = AnimationUtils.arraySlice(times, from, to);
        this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
      }
      return this;
    }
    validate() {
      let valid = true;
      const valueSize = this.getValueSize();
      if (valueSize - Math.floor(valueSize) !== 0) {
        console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
        valid = false;
      }
      const times = this.times, values = this.values, nKeys = times.length;
      if (nKeys === 0) {
        console.error("THREE.KeyframeTrack: Track is empty.", this);
        valid = false;
      }
      let prevTime = null;
      for (let i = 0; i !== nKeys; i++) {
        const currTime = times[i];
        if (typeof currTime === "number" && isNaN(currTime)) {
          console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i, currTime);
          valid = false;
          break;
        }
        if (prevTime !== null && prevTime > currTime) {
          console.error("THREE.KeyframeTrack: Out of order keys.", this, i, currTime, prevTime);
          valid = false;
          break;
        }
        prevTime = currTime;
      }
      if (values !== void 0) {
        if (AnimationUtils.isTypedArray(values)) {
          for (let i = 0, n = values.length; i !== n; ++i) {
            const value = values[i];
            if (isNaN(value)) {
              console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i, value);
              valid = false;
              break;
            }
          }
        }
      }
      return valid;
    }
    optimize() {
      const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
      let writeIndex = 1;
      for (let i = 1; i < lastIndex; ++i) {
        let keep = false;
        const time = times[i];
        const timeNext = times[i + 1];
        if (time !== timeNext && (i !== 1 || time !== times[0])) {
          if (!smoothInterpolation) {
            const offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
            for (let j = 0; j !== stride; ++j) {
              const value = values[offset + j];
              if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                keep = true;
                break;
              }
            }
          } else {
            keep = true;
          }
        }
        if (keep) {
          if (i !== writeIndex) {
            times[writeIndex] = times[i];
            const readOffset = i * stride, writeOffset = writeIndex * stride;
            for (let j = 0; j !== stride; ++j) {
              values[writeOffset + j] = values[readOffset + j];
            }
          }
          ++writeIndex;
        }
      }
      if (lastIndex > 0) {
        times[writeIndex] = times[lastIndex];
        for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
          values[writeOffset + j] = values[readOffset + j];
        }
        ++writeIndex;
      }
      if (writeIndex !== times.length) {
        this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
        this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
      } else {
        this.times = times;
        this.values = values;
      }
      return this;
    }
    clone() {
      const times = AnimationUtils.arraySlice(this.times, 0);
      const values = AnimationUtils.arraySlice(this.values, 0);
      const TypedKeyframeTrack = this.constructor;
      const track = new TypedKeyframeTrack(this.name, times, values);
      track.createInterpolant = this.createInterpolant;
      return track;
    }
  };
  KeyframeTrack.prototype.TimeBufferType = Float32Array;
  KeyframeTrack.prototype.ValueBufferType = Float32Array;
  KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
  var BooleanKeyframeTrack = class extends KeyframeTrack {
  };
  BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
  BooleanKeyframeTrack.prototype.ValueBufferType = Array;
  BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
  BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
  BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
  var ColorKeyframeTrack = class extends KeyframeTrack {
  };
  ColorKeyframeTrack.prototype.ValueTypeName = "color";
  var NumberKeyframeTrack = class extends KeyframeTrack {
  };
  NumberKeyframeTrack.prototype.ValueTypeName = "number";
  function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: QuaternionLinearInterpolant,
    interpolate_: function(i1, t0, t, t1) {
      const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0);
      let offset = i1 * stride;
      for (let end = offset + stride; offset !== end; offset += 4) {
        Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
      }
      return result;
    }
  });
  var QuaternionKeyframeTrack = class extends KeyframeTrack {
    InterpolantFactoryMethodLinear(result) {
      return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
    }
  };
  QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
  QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
  QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
  var StringKeyframeTrack = class extends KeyframeTrack {
  };
  StringKeyframeTrack.prototype.ValueTypeName = "string";
  StringKeyframeTrack.prototype.ValueBufferType = Array;
  StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
  StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
  StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
  var VectorKeyframeTrack = class extends KeyframeTrack {
  };
  VectorKeyframeTrack.prototype.ValueTypeName = "vector";
  var AnimationClip = class {
    constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
      this.name = name;
      this.tracks = tracks;
      this.duration = duration;
      this.blendMode = blendMode;
      this.uuid = MathUtils.generateUUID();
      if (this.duration < 0) {
        this.resetDuration();
      }
    }
    static parse(json) {
      const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
      for (let i = 0, n = jsonTracks.length; i !== n; ++i) {
        tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
      }
      const clip = new this(json.name, json.duration, tracks, json.blendMode);
      clip.uuid = json.uuid;
      return clip;
    }
    static toJSON(clip) {
      const tracks = [], clipTracks = clip.tracks;
      const json = {
        "name": clip.name,
        "duration": clip.duration,
        "tracks": tracks,
        "uuid": clip.uuid,
        "blendMode": clip.blendMode
      };
      for (let i = 0, n = clipTracks.length; i !== n; ++i) {
        tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
      }
      return json;
    }
    static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
      const numMorphTargets = morphTargetSequence.length;
      const tracks = [];
      for (let i = 0; i < numMorphTargets; i++) {
        let times = [];
        let values = [];
        times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
        values.push(0, 1, 0);
        const order = AnimationUtils.getKeyframeOrder(times);
        times = AnimationUtils.sortedArray(times, 1, order);
        values = AnimationUtils.sortedArray(values, 1, order);
        if (!noLoop && times[0] === 0) {
          times.push(numMorphTargets);
          values.push(values[0]);
        }
        tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i].name + "]", times, values).scale(1 / fps));
      }
      return new this(name, -1, tracks);
    }
    static findByName(objectOrClipArray, name) {
      let clipArray = objectOrClipArray;
      if (!Array.isArray(objectOrClipArray)) {
        const o = objectOrClipArray;
        clipArray = o.geometry && o.geometry.animations || o.animations;
      }
      for (let i = 0; i < clipArray.length; i++) {
        if (clipArray[i].name === name) {
          return clipArray[i];
        }
      }
      return null;
    }
    static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
      const animationToMorphTargets = {};
      const pattern = /^([\w-]*?)([\d]+)$/;
      for (let i = 0, il = morphTargets.length; i < il; i++) {
        const morphTarget = morphTargets[i];
        const parts = morphTarget.name.match(pattern);
        if (parts && parts.length > 1) {
          const name = parts[1];
          let animationMorphTargets = animationToMorphTargets[name];
          if (!animationMorphTargets) {
            animationToMorphTargets[name] = animationMorphTargets = [];
          }
          animationMorphTargets.push(morphTarget);
        }
      }
      const clips = [];
      for (const name in animationToMorphTargets) {
        clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
      }
      return clips;
    }
    static parseAnimation(animation, bones) {
      if (!animation) {
        console.error("THREE.AnimationClip: No animation in JSONLoader data.");
        return null;
      }
      const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
        if (animationKeys.length !== 0) {
          const times = [];
          const values = [];
          AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
          if (times.length !== 0) {
            destTracks.push(new trackType(trackName, times, values));
          }
        }
      };
      const tracks = [];
      const clipName = animation.name || "default";
      const fps = animation.fps || 30;
      const blendMode = animation.blendMode;
      let duration = animation.length || -1;
      const hierarchyTracks = animation.hierarchy || [];
      for (let h = 0; h < hierarchyTracks.length; h++) {
        const animationKeys = hierarchyTracks[h].keys;
        if (!animationKeys || animationKeys.length === 0)
          continue;
        if (animationKeys[0].morphTargets) {
          const morphTargetNames = {};
          let k;
          for (k = 0; k < animationKeys.length; k++) {
            if (animationKeys[k].morphTargets) {
              for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
                morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
              }
            }
          }
          for (const morphTargetName in morphTargetNames) {
            const times = [];
            const values = [];
            for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
              const animationKey = animationKeys[k];
              times.push(animationKey.time);
              values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
            }
            tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
          }
          duration = morphTargetNames.length * (fps || 1);
        } else {
          const boneName = ".bones[" + bones[h].name + "]";
          addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
          addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
          addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
        }
      }
      if (tracks.length === 0) {
        return null;
      }
      const clip = new this(clipName, duration, tracks, blendMode);
      return clip;
    }
    resetDuration() {
      const tracks = this.tracks;
      let duration = 0;
      for (let i = 0, n = tracks.length; i !== n; ++i) {
        const track = this.tracks[i];
        duration = Math.max(duration, track.times[track.times.length - 1]);
      }
      this.duration = duration;
      return this;
    }
    trim() {
      for (let i = 0; i < this.tracks.length; i++) {
        this.tracks[i].trim(0, this.duration);
      }
      return this;
    }
    validate() {
      let valid = true;
      for (let i = 0; i < this.tracks.length; i++) {
        valid = valid && this.tracks[i].validate();
      }
      return valid;
    }
    optimize() {
      for (let i = 0; i < this.tracks.length; i++) {
        this.tracks[i].optimize();
      }
      return this;
    }
    clone() {
      const tracks = [];
      for (let i = 0; i < this.tracks.length; i++) {
        tracks.push(this.tracks[i].clone());
      }
      return new this.constructor(this.name, this.duration, tracks, this.blendMode);
    }
    toJSON() {
      return this.constructor.toJSON(this);
    }
  };
  function getTrackTypeForValueTypeName(typeName) {
    switch (typeName.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return NumberKeyframeTrack;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return VectorKeyframeTrack;
      case "color":
        return ColorKeyframeTrack;
      case "quaternion":
        return QuaternionKeyframeTrack;
      case "bool":
      case "boolean":
        return BooleanKeyframeTrack;
      case "string":
        return StringKeyframeTrack;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
  }
  function parseKeyframeTrack(json) {
    if (json.type === void 0) {
      throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    }
    const trackType = getTrackTypeForValueTypeName(json.type);
    if (json.times === void 0) {
      const times = [], values = [];
      AnimationUtils.flattenJSON(json.keys, times, values, "value");
      json.times = times;
      json.values = values;
    }
    if (trackType.parse !== void 0) {
      return trackType.parse(json);
    } else {
      return new trackType(json.name, json.times, json.values, json.interpolation);
    }
  }
  var Cache = {
    enabled: false,
    files: {},
    add: function(key, file) {
      if (this.enabled === false)
        return;
      this.files[key] = file;
    },
    get: function(key) {
      if (this.enabled === false)
        return;
      return this.files[key];
    },
    remove: function(key) {
      delete this.files[key];
    },
    clear: function() {
      this.files = {};
    }
  };
  function LoadingManager(onLoad, onProgress, onError) {
    const scope = this;
    let isLoading = false;
    let itemsLoaded = 0;
    let itemsTotal = 0;
    let urlModifier = void 0;
    const handlers = [];
    this.onStart = void 0;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function(url) {
      itemsTotal++;
      if (isLoading === false) {
        if (scope.onStart !== void 0) {
          scope.onStart(url, itemsLoaded, itemsTotal);
        }
      }
      isLoading = true;
    };
    this.itemEnd = function(url) {
      itemsLoaded++;
      if (scope.onProgress !== void 0) {
        scope.onProgress(url, itemsLoaded, itemsTotal);
      }
      if (itemsLoaded === itemsTotal) {
        isLoading = false;
        if (scope.onLoad !== void 0) {
          scope.onLoad();
        }
      }
    };
    this.itemError = function(url) {
      if (scope.onError !== void 0) {
        scope.onError(url);
      }
    };
    this.resolveURL = function(url) {
      if (urlModifier) {
        return urlModifier(url);
      }
      return url;
    };
    this.setURLModifier = function(transform) {
      urlModifier = transform;
      return this;
    };
    this.addHandler = function(regex, loader) {
      handlers.push(regex, loader);
      return this;
    };
    this.removeHandler = function(regex) {
      const index = handlers.indexOf(regex);
      if (index !== -1) {
        handlers.splice(index, 2);
      }
      return this;
    };
    this.getHandler = function(file) {
      for (let i = 0, l = handlers.length; i < l; i += 2) {
        const regex = handlers[i];
        const loader = handlers[i + 1];
        if (regex.global)
          regex.lastIndex = 0;
        if (regex.test(file)) {
          return loader;
        }
      }
      return null;
    };
  }
  var DefaultLoadingManager = new LoadingManager();
  function Loader(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
    this.crossOrigin = "anonymous";
    this.withCredentials = false;
    this.path = "";
    this.resourcePath = "";
    this.requestHeader = {};
  }
  Object.assign(Loader.prototype, {
    load: function() {
    },
    loadAsync: function(url, onProgress) {
      const scope = this;
      return new Promise(function(resolve, reject) {
        scope.load(url, resolve, onProgress, reject);
      });
    },
    parse: function() {
    },
    setCrossOrigin: function(crossOrigin) {
      this.crossOrigin = crossOrigin;
      return this;
    },
    setWithCredentials: function(value) {
      this.withCredentials = value;
      return this;
    },
    setPath: function(path) {
      this.path = path;
      return this;
    },
    setResourcePath: function(resourcePath) {
      this.resourcePath = resourcePath;
      return this;
    },
    setRequestHeader: function(requestHeader) {
      this.requestHeader = requestHeader;
      return this;
    }
  });
  var loading = {};
  function FileLoader(manager) {
    Loader.call(this, manager);
  }
  FileLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: FileLoader,
    load: function(url, onLoad, onProgress, onError) {
      if (url === void 0)
        url = "";
      if (this.path !== void 0)
        url = this.path + url;
      url = this.manager.resolveURL(url);
      const scope = this;
      const cached = Cache.get(url);
      if (cached !== void 0) {
        scope.manager.itemStart(url);
        setTimeout(function() {
          if (onLoad)
            onLoad(cached);
          scope.manager.itemEnd(url);
        }, 0);
        return cached;
      }
      if (loading[url] !== void 0) {
        loading[url].push({
          onLoad,
          onProgress,
          onError
        });
        return;
      }
      const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
      const dataUriRegexResult = url.match(dataUriRegex);
      let request;
      if (dataUriRegexResult) {
        const mimeType = dataUriRegexResult[1];
        const isBase64 = !!dataUriRegexResult[2];
        let data = dataUriRegexResult[3];
        data = decodeURIComponent(data);
        if (isBase64)
          data = atob(data);
        try {
          let response;
          const responseType = (this.responseType || "").toLowerCase();
          switch (responseType) {
            case "arraybuffer":
            case "blob":
              const view = new Uint8Array(data.length);
              for (let i = 0; i < data.length; i++) {
                view[i] = data.charCodeAt(i);
              }
              if (responseType === "blob") {
                response = new Blob([view.buffer], { type: mimeType });
              } else {
                response = view.buffer;
              }
              break;
            case "document":
              const parser = new DOMParser();
              response = parser.parseFromString(data, mimeType);
              break;
            case "json":
              response = JSON.parse(data);
              break;
            default:
              response = data;
              break;
          }
          setTimeout(function() {
            if (onLoad)
              onLoad(response);
            scope.manager.itemEnd(url);
          }, 0);
        } catch (error) {
          setTimeout(function() {
            if (onError)
              onError(error);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          }, 0);
        }
      } else {
        loading[url] = [];
        loading[url].push({
          onLoad,
          onProgress,
          onError
        });
        request = new XMLHttpRequest();
        request.open("GET", url, true);
        request.addEventListener("load", function(event) {
          const response = this.response;
          const callbacks = loading[url];
          delete loading[url];
          if (this.status === 200 || this.status === 0) {
            if (this.status === 0)
              console.warn("THREE.FileLoader: HTTP Status 0 received.");
            Cache.add(url, response);
            for (let i = 0, il = callbacks.length; i < il; i++) {
              const callback = callbacks[i];
              if (callback.onLoad)
                callback.onLoad(response);
            }
            scope.manager.itemEnd(url);
          } else {
            for (let i = 0, il = callbacks.length; i < il; i++) {
              const callback = callbacks[i];
              if (callback.onError)
                callback.onError(event);
            }
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          }
        }, false);
        request.addEventListener("progress", function(event) {
          const callbacks = loading[url];
          for (let i = 0, il = callbacks.length; i < il; i++) {
            const callback = callbacks[i];
            if (callback.onProgress)
              callback.onProgress(event);
          }
        }, false);
        request.addEventListener("error", function(event) {
          const callbacks = loading[url];
          delete loading[url];
          for (let i = 0, il = callbacks.length; i < il; i++) {
            const callback = callbacks[i];
            if (callback.onError)
              callback.onError(event);
          }
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }, false);
        request.addEventListener("abort", function(event) {
          const callbacks = loading[url];
          delete loading[url];
          for (let i = 0, il = callbacks.length; i < il; i++) {
            const callback = callbacks[i];
            if (callback.onError)
              callback.onError(event);
          }
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }, false);
        if (this.responseType !== void 0)
          request.responseType = this.responseType;
        if (this.withCredentials !== void 0)
          request.withCredentials = this.withCredentials;
        if (request.overrideMimeType)
          request.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
        for (const header in this.requestHeader) {
          request.setRequestHeader(header, this.requestHeader[header]);
        }
        request.send(null);
      }
      scope.manager.itemStart(url);
      return request;
    },
    setResponseType: function(value) {
      this.responseType = value;
      return this;
    },
    setMimeType: function(value) {
      this.mimeType = value;
      return this;
    }
  });
  function CompressedTextureLoader(manager) {
    Loader.call(this, manager);
  }
  CompressedTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: CompressedTextureLoader,
    load: function(url, onLoad, onProgress, onError) {
      const scope = this;
      const images = [];
      const texture = new CompressedTexture();
      const loader = new FileLoader(this.manager);
      loader.setPath(this.path);
      loader.setResponseType("arraybuffer");
      loader.setRequestHeader(this.requestHeader);
      loader.setWithCredentials(scope.withCredentials);
      let loaded = 0;
      function loadTexture(i) {
        loader.load(url[i], function(buffer) {
          const texDatas = scope.parse(buffer, true);
          images[i] = {
            width: texDatas.width,
            height: texDatas.height,
            format: texDatas.format,
            mipmaps: texDatas.mipmaps
          };
          loaded += 1;
          if (loaded === 6) {
            if (texDatas.mipmapCount === 1)
              texture.minFilter = LinearFilter;
            texture.image = images;
            texture.format = texDatas.format;
            texture.needsUpdate = true;
            if (onLoad)
              onLoad(texture);
          }
        }, onProgress, onError);
      }
      if (Array.isArray(url)) {
        for (let i = 0, il = url.length; i < il; ++i) {
          loadTexture(i);
        }
      } else {
        loader.load(url, function(buffer) {
          const texDatas = scope.parse(buffer, true);
          if (texDatas.isCubemap) {
            const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
            for (let f = 0; f < faces; f++) {
              images[f] = { mipmaps: [] };
              for (let i = 0; i < texDatas.mipmapCount; i++) {
                images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                images[f].format = texDatas.format;
                images[f].width = texDatas.width;
                images[f].height = texDatas.height;
              }
            }
            texture.image = images;
          } else {
            texture.image.width = texDatas.width;
            texture.image.height = texDatas.height;
            texture.mipmaps = texDatas.mipmaps;
          }
          if (texDatas.mipmapCount === 1) {
            texture.minFilter = LinearFilter;
          }
          texture.format = texDatas.format;
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }, onProgress, onError);
      }
      return texture;
    }
  });
  var ImageLoader = class extends Loader {
    constructor(manager) {
      super(manager);
    }
    load(url, onLoad, onProgress, onError) {
      if (this.path !== void 0)
        url = this.path + url;
      url = this.manager.resolveURL(url);
      const scope = this;
      const cached = Cache.get(url);
      if (cached !== void 0) {
        scope.manager.itemStart(url);
        setTimeout(function() {
          if (onLoad)
            onLoad(cached);
          scope.manager.itemEnd(url);
        }, 0);
        return cached;
      }
      const image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
      function onImageLoad() {
        image.removeEventListener("load", onImageLoad, false);
        image.removeEventListener("error", onImageError, false);
        Cache.add(url, this);
        if (onLoad)
          onLoad(this);
        scope.manager.itemEnd(url);
      }
      function onImageError(event) {
        image.removeEventListener("load", onImageLoad, false);
        image.removeEventListener("error", onImageError, false);
        if (onError)
          onError(event);
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }
      image.addEventListener("load", onImageLoad, false);
      image.addEventListener("error", onImageError, false);
      if (url.substr(0, 5) !== "data:") {
        if (this.crossOrigin !== void 0)
          image.crossOrigin = this.crossOrigin;
      }
      scope.manager.itemStart(url);
      image.src = url;
      return image;
    }
  };
  var CubeTextureLoader = class extends Loader {
    constructor(manager) {
      super(manager);
    }
    load(urls, onLoad, onProgress, onError) {
      const texture = new CubeTexture();
      const loader = new ImageLoader(this.manager);
      loader.setCrossOrigin(this.crossOrigin);
      loader.setPath(this.path);
      let loaded = 0;
      function loadTexture(i) {
        loader.load(urls[i], function(image) {
          texture.images[i] = image;
          loaded++;
          if (loaded === 6) {
            texture.needsUpdate = true;
            if (onLoad)
              onLoad(texture);
          }
        }, void 0, onError);
      }
      for (let i = 0; i < urls.length; ++i) {
        loadTexture(i);
      }
      return texture;
    }
  };
  function DataTextureLoader(manager) {
    Loader.call(this, manager);
  }
  DataTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: DataTextureLoader,
    load: function(url, onLoad, onProgress, onError) {
      const scope = this;
      const texture = new DataTexture();
      const loader = new FileLoader(this.manager);
      loader.setResponseType("arraybuffer");
      loader.setRequestHeader(this.requestHeader);
      loader.setPath(this.path);
      loader.setWithCredentials(scope.withCredentials);
      loader.load(url, function(buffer) {
        const texData = scope.parse(buffer);
        if (!texData)
          return;
        if (texData.image !== void 0) {
          texture.image = texData.image;
        } else if (texData.data !== void 0) {
          texture.image.width = texData.width;
          texture.image.height = texData.height;
          texture.image.data = texData.data;
        }
        texture.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping;
        texture.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping;
        texture.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter;
        texture.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearFilter;
        texture.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1;
        if (texData.encoding !== void 0) {
          texture.encoding = texData.encoding;
        }
        if (texData.flipY !== void 0) {
          texture.flipY = texData.flipY;
        }
        if (texData.format !== void 0) {
          texture.format = texData.format;
        }
        if (texData.type !== void 0) {
          texture.type = texData.type;
        }
        if (texData.mipmaps !== void 0) {
          texture.mipmaps = texData.mipmaps;
          texture.minFilter = LinearMipmapLinearFilter;
        }
        if (texData.mipmapCount === 1) {
          texture.minFilter = LinearFilter;
        }
        if (texData.generateMipmaps !== void 0) {
          texture.generateMipmaps = texData.generateMipmaps;
        }
        texture.needsUpdate = true;
        if (onLoad)
          onLoad(texture, texData);
      }, onProgress, onError);
      return texture;
    }
  });
  function TextureLoader(manager) {
    Loader.call(this, manager);
  }
  TextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: TextureLoader,
    load: function(url, onLoad, onProgress, onError) {
      const texture = new Texture();
      const loader = new ImageLoader(this.manager);
      loader.setCrossOrigin(this.crossOrigin);
      loader.setPath(this.path);
      loader.load(url, function(image) {
        texture.image = image;
        const isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
        texture.format = isJPEG ? RGBFormat : RGBAFormat;
        texture.needsUpdate = true;
        if (onLoad !== void 0) {
          onLoad(texture);
        }
      }, onProgress, onError);
      return texture;
    }
  });
  function Curve() {
    this.type = "Curve";
    this.arcLengthDivisions = 200;
  }
  Object.assign(Curve.prototype, {
    getPoint: function() {
      console.warn("THREE.Curve: .getPoint() not implemented.");
      return null;
    },
    getPointAt: function(u, optionalTarget) {
      const t = this.getUtoTmapping(u);
      return this.getPoint(t, optionalTarget);
    },
    getPoints: function(divisions = 5) {
      const points = [];
      for (let d = 0; d <= divisions; d++) {
        points.push(this.getPoint(d / divisions));
      }
      return points;
    },
    getSpacedPoints: function(divisions = 5) {
      const points = [];
      for (let d = 0; d <= divisions; d++) {
        points.push(this.getPointAt(d / divisions));
      }
      return points;
    },
    getLength: function() {
      const lengths = this.getLengths();
      return lengths[lengths.length - 1];
    },
    getLengths: function(divisions) {
      if (divisions === void 0)
        divisions = this.arcLengthDivisions;
      if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
        return this.cacheArcLengths;
      }
      this.needsUpdate = false;
      const cache = [];
      let current, last = this.getPoint(0);
      let sum = 0;
      cache.push(0);
      for (let p = 1; p <= divisions; p++) {
        current = this.getPoint(p / divisions);
        sum += current.distanceTo(last);
        cache.push(sum);
        last = current;
      }
      this.cacheArcLengths = cache;
      return cache;
    },
    updateArcLengths: function() {
      this.needsUpdate = true;
      this.getLengths();
    },
    getUtoTmapping: function(u, distance) {
      const arcLengths = this.getLengths();
      let i = 0;
      const il = arcLengths.length;
      let targetArcLength;
      if (distance) {
        targetArcLength = distance;
      } else {
        targetArcLength = u * arcLengths[il - 1];
      }
      let low = 0, high = il - 1, comparison;
      while (low <= high) {
        i = Math.floor(low + (high - low) / 2);
        comparison = arcLengths[i] - targetArcLength;
        if (comparison < 0) {
          low = i + 1;
        } else if (comparison > 0) {
          high = i - 1;
        } else {
          high = i;
          break;
        }
      }
      i = high;
      if (arcLengths[i] === targetArcLength) {
        return i / (il - 1);
      }
      const lengthBefore = arcLengths[i];
      const lengthAfter = arcLengths[i + 1];
      const segmentLength = lengthAfter - lengthBefore;
      const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
      const t = (i + segmentFraction) / (il - 1);
      return t;
    },
    getTangent: function(t, optionalTarget) {
      const delta = 1e-4;
      let t1 = t - delta;
      let t2 = t + delta;
      if (t1 < 0)
        t1 = 0;
      if (t2 > 1)
        t2 = 1;
      const pt1 = this.getPoint(t1);
      const pt2 = this.getPoint(t2);
      const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
      tangent.copy(pt2).sub(pt1).normalize();
      return tangent;
    },
    getTangentAt: function(u, optionalTarget) {
      const t = this.getUtoTmapping(u);
      return this.getTangent(t, optionalTarget);
    },
    computeFrenetFrames: function(segments, closed) {
      const normal = new Vector3();
      const tangents = [];
      const normals = [];
      const binormals = [];
      const vec = new Vector3();
      const mat = new Matrix4();
      for (let i = 0; i <= segments; i++) {
        const u = i / segments;
        tangents[i] = this.getTangentAt(u, new Vector3());
        tangents[i].normalize();
      }
      normals[0] = new Vector3();
      binormals[0] = new Vector3();
      let min = Number.MAX_VALUE;
      const tx = Math.abs(tangents[0].x);
      const ty = Math.abs(tangents[0].y);
      const tz = Math.abs(tangents[0].z);
      if (tx <= min) {
        min = tx;
        normal.set(1, 0, 0);
      }
      if (ty <= min) {
        min = ty;
        normal.set(0, 1, 0);
      }
      if (tz <= min) {
        normal.set(0, 0, 1);
      }
      vec.crossVectors(tangents[0], normal).normalize();
      normals[0].crossVectors(tangents[0], vec);
      binormals[0].crossVectors(tangents[0], normals[0]);
      for (let i = 1; i <= segments; i++) {
        normals[i] = normals[i - 1].clone();
        binormals[i] = binormals[i - 1].clone();
        vec.crossVectors(tangents[i - 1], tangents[i]);
        if (vec.length() > Number.EPSILON) {
          vec.normalize();
          const theta = Math.acos(MathUtils.clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
          normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
        }
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
      if (closed === true) {
        let theta = Math.acos(MathUtils.clamp(normals[0].dot(normals[segments]), -1, 1));
        theta /= segments;
        if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
          theta = -theta;
        }
        for (let i = 1; i <= segments; i++) {
          normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
          binormals[i].crossVectors(tangents[i], normals[i]);
        }
      }
      return {
        tangents,
        normals,
        binormals
      };
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(source) {
      this.arcLengthDivisions = source.arcLengthDivisions;
      return this;
    },
    toJSON: function() {
      const data = {
        metadata: {
          version: 4.5,
          type: "Curve",
          generator: "Curve.toJSON"
        }
      };
      data.arcLengthDivisions = this.arcLengthDivisions;
      data.type = this.type;
      return data;
    },
    fromJSON: function(json) {
      this.arcLengthDivisions = json.arcLengthDivisions;
      return this;
    }
  });
  var EllipseCurve = class extends Curve {
    constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
      super();
      this.type = "EllipseCurve";
      this.aX = aX;
      this.aY = aY;
      this.xRadius = xRadius;
      this.yRadius = yRadius;
      this.aStartAngle = aStartAngle;
      this.aEndAngle = aEndAngle;
      this.aClockwise = aClockwise;
      this.aRotation = aRotation;
    }
    getPoint(t, optionalTarget) {
      const point = optionalTarget || new Vector2();
      const twoPi = Math.PI * 2;
      let deltaAngle = this.aEndAngle - this.aStartAngle;
      const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
      while (deltaAngle < 0)
        deltaAngle += twoPi;
      while (deltaAngle > twoPi)
        deltaAngle -= twoPi;
      if (deltaAngle < Number.EPSILON) {
        if (samePoints) {
          deltaAngle = 0;
        } else {
          deltaAngle = twoPi;
        }
      }
      if (this.aClockwise === true && !samePoints) {
        if (deltaAngle === twoPi) {
          deltaAngle = -twoPi;
        } else {
          deltaAngle = deltaAngle - twoPi;
        }
      }
      const angle = this.aStartAngle + t * deltaAngle;
      let x = this.aX + this.xRadius * Math.cos(angle);
      let y = this.aY + this.yRadius * Math.sin(angle);
      if (this.aRotation !== 0) {
        const cos = Math.cos(this.aRotation);
        const sin = Math.sin(this.aRotation);
        const tx = x - this.aX;
        const ty = y - this.aY;
        x = tx * cos - ty * sin + this.aX;
        y = tx * sin + ty * cos + this.aY;
      }
      return point.set(x, y);
    }
    copy(source) {
      super.copy(source);
      this.aX = source.aX;
      this.aY = source.aY;
      this.xRadius = source.xRadius;
      this.yRadius = source.yRadius;
      this.aStartAngle = source.aStartAngle;
      this.aEndAngle = source.aEndAngle;
      this.aClockwise = source.aClockwise;
      this.aRotation = source.aRotation;
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.aX = this.aX;
      data.aY = this.aY;
      data.xRadius = this.xRadius;
      data.yRadius = this.yRadius;
      data.aStartAngle = this.aStartAngle;
      data.aEndAngle = this.aEndAngle;
      data.aClockwise = this.aClockwise;
      data.aRotation = this.aRotation;
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.aX = json.aX;
      this.aY = json.aY;
      this.xRadius = json.xRadius;
      this.yRadius = json.yRadius;
      this.aStartAngle = json.aStartAngle;
      this.aEndAngle = json.aEndAngle;
      this.aClockwise = json.aClockwise;
      this.aRotation = json.aRotation;
      return this;
    }
  };
  EllipseCurve.prototype.isEllipseCurve = true;
  var ArcCurve = class extends EllipseCurve {
    constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
      this.type = "ArcCurve";
    }
  };
  ArcCurve.prototype.isArcCurve = true;
  function CubicPoly() {
    let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
    function init(x0, x1, t0, t1) {
      c0 = x0;
      c1 = t0;
      c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
      c3 = 2 * x0 - 2 * x1 + t0 + t1;
    }
    return {
      initCatmullRom: function(x0, x1, x2, x3, tension) {
        init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
      },
      initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
        let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
        let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
        t1 *= dt1;
        t2 *= dt1;
        init(x1, x2, t1, t2);
      },
      calc: function(t) {
        const t2 = t * t;
        const t3 = t2 * t;
        return c0 + c1 * t + c2 * t2 + c3 * t3;
      }
    };
  }
  var tmp = new Vector3();
  var px = new CubicPoly();
  var py = new CubicPoly();
  var pz = new CubicPoly();
  var CatmullRomCurve3 = class extends Curve {
    constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
      super();
      this.type = "CatmullRomCurve3";
      this.points = points;
      this.closed = closed;
      this.curveType = curveType;
      this.tension = tension;
    }
    getPoint(t, optionalTarget = new Vector3()) {
      const point = optionalTarget;
      const points = this.points;
      const l = points.length;
      const p = (l - (this.closed ? 0 : 1)) * t;
      let intPoint = Math.floor(p);
      let weight = p - intPoint;
      if (this.closed) {
        intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
      } else if (weight === 0 && intPoint === l - 1) {
        intPoint = l - 2;
        weight = 1;
      }
      let p0, p3;
      if (this.closed || intPoint > 0) {
        p0 = points[(intPoint - 1) % l];
      } else {
        tmp.subVectors(points[0], points[1]).add(points[0]);
        p0 = tmp;
      }
      const p1 = points[intPoint % l];
      const p2 = points[(intPoint + 1) % l];
      if (this.closed || intPoint + 2 < l) {
        p3 = points[(intPoint + 2) % l];
      } else {
        tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
        p3 = tmp;
      }
      if (this.curveType === "centripetal" || this.curveType === "chordal") {
        const pow = this.curveType === "chordal" ? 0.5 : 0.25;
        let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
        let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
        let dt2 = Math.pow(p2.distanceToSquared(p3), pow);
        if (dt1 < 1e-4)
          dt1 = 1;
        if (dt0 < 1e-4)
          dt0 = dt1;
        if (dt2 < 1e-4)
          dt2 = dt1;
        px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
        py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
        pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
      } else if (this.curveType === "catmullrom") {
        px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
        py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
        pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
      }
      point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
      return point;
    }
    copy(source) {
      super.copy(source);
      this.points = [];
      for (let i = 0, l = source.points.length; i < l; i++) {
        const point = source.points[i];
        this.points.push(point.clone());
      }
      this.closed = source.closed;
      this.curveType = source.curveType;
      this.tension = source.tension;
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.points = [];
      for (let i = 0, l = this.points.length; i < l; i++) {
        const point = this.points[i];
        data.points.push(point.toArray());
      }
      data.closed = this.closed;
      data.curveType = this.curveType;
      data.tension = this.tension;
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.points = [];
      for (let i = 0, l = json.points.length; i < l; i++) {
        const point = json.points[i];
        this.points.push(new Vector3().fromArray(point));
      }
      this.closed = json.closed;
      this.curveType = json.curveType;
      this.tension = json.tension;
      return this;
    }
  };
  CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
  function CatmullRom(t, p0, p1, p2, p3) {
    const v0 = (p2 - p0) * 0.5;
    const v1 = (p3 - p1) * 0.5;
    const t2 = t * t;
    const t3 = t * t2;
    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
  }
  function QuadraticBezierP0(t, p) {
    const k = 1 - t;
    return k * k * p;
  }
  function QuadraticBezierP1(t, p) {
    return 2 * (1 - t) * t * p;
  }
  function QuadraticBezierP2(t, p) {
    return t * t * p;
  }
  function QuadraticBezier(t, p0, p1, p2) {
    return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
  }
  function CubicBezierP0(t, p) {
    const k = 1 - t;
    return k * k * k * p;
  }
  function CubicBezierP1(t, p) {
    const k = 1 - t;
    return 3 * k * k * t * p;
  }
  function CubicBezierP2(t, p) {
    return 3 * (1 - t) * t * t * p;
  }
  function CubicBezierP3(t, p) {
    return t * t * t * p;
  }
  function CubicBezier(t, p0, p1, p2, p3) {
    return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
  }
  var CubicBezierCurve = class extends Curve {
    constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
      super();
      this.type = "CubicBezierCurve";
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
      this.v3 = v3;
    }
    getPoint(t, optionalTarget = new Vector2()) {
      const point = optionalTarget;
      const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
      point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
      return point;
    }
    copy(source) {
      super.copy(source);
      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      this.v3.copy(source.v3);
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      data.v3 = this.v3.toArray();
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      this.v3.fromArray(json.v3);
      return this;
    }
  };
  CubicBezierCurve.prototype.isCubicBezierCurve = true;
  var CubicBezierCurve3 = class extends Curve {
    constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
      super();
      this.type = "CubicBezierCurve3";
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
      this.v3 = v3;
    }
    getPoint(t, optionalTarget = new Vector3()) {
      const point = optionalTarget;
      const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
      point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
      return point;
    }
    copy(source) {
      super.copy(source);
      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      this.v3.copy(source.v3);
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      data.v3 = this.v3.toArray();
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      this.v3.fromArray(json.v3);
      return this;
    }
  };
  CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
  var LineCurve = class extends Curve {
    constructor(v1 = new Vector2(), v2 = new Vector2()) {
      super();
      this.type = "LineCurve";
      this.v1 = v1;
      this.v2 = v2;
    }
    getPoint(t, optionalTarget = new Vector2()) {
      const point = optionalTarget;
      if (t === 1) {
        point.copy(this.v2);
      } else {
        point.copy(this.v2).sub(this.v1);
        point.multiplyScalar(t).add(this.v1);
      }
      return point;
    }
    getPointAt(u, optionalTarget) {
      return this.getPoint(u, optionalTarget);
    }
    getTangent(t, optionalTarget) {
      const tangent = optionalTarget || new Vector2();
      tangent.copy(this.v2).sub(this.v1).normalize();
      return tangent;
    }
    copy(source) {
      super.copy(source);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      return this;
    }
  };
  LineCurve.prototype.isLineCurve = true;
  var LineCurve3 = class extends Curve {
    constructor(v1 = new Vector3(), v2 = new Vector3()) {
      super();
      this.type = "LineCurve3";
      this.isLineCurve3 = true;
      this.v1 = v1;
      this.v2 = v2;
    }
    getPoint(t, optionalTarget = new Vector3()) {
      const point = optionalTarget;
      if (t === 1) {
        point.copy(this.v2);
      } else {
        point.copy(this.v2).sub(this.v1);
        point.multiplyScalar(t).add(this.v1);
      }
      return point;
    }
    getPointAt(u, optionalTarget) {
      return this.getPoint(u, optionalTarget);
    }
    copy(source) {
      super.copy(source);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      return this;
    }
  };
  var QuadraticBezierCurve = class extends Curve {
    constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
      super();
      this.type = "QuadraticBezierCurve";
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
    }
    getPoint(t, optionalTarget = new Vector2()) {
      const point = optionalTarget;
      const v0 = this.v0, v1 = this.v1, v2 = this.v2;
      point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
      return point;
    }
    copy(source) {
      super.copy(source);
      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      return this;
    }
  };
  QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
  var QuadraticBezierCurve3 = class extends Curve {
    constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
      super();
      this.type = "QuadraticBezierCurve3";
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
    }
    getPoint(t, optionalTarget = new Vector3()) {
      const point = optionalTarget;
      const v0 = this.v0, v1 = this.v1, v2 = this.v2;
      point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
      return point;
    }
    copy(source) {
      super.copy(source);
      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      return this;
    }
  };
  QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
  var SplineCurve = class extends Curve {
    constructor(points = []) {
      super();
      this.type = "SplineCurve";
      this.points = points;
    }
    getPoint(t, optionalTarget = new Vector2()) {
      const point = optionalTarget;
      const points = this.points;
      const p = (points.length - 1) * t;
      const intPoint = Math.floor(p);
      const weight = p - intPoint;
      const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
      const p1 = points[intPoint];
      const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
      const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
      point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
      return point;
    }
    copy(source) {
      super.copy(source);
      this.points = [];
      for (let i = 0, l = source.points.length; i < l; i++) {
        const point = source.points[i];
        this.points.push(point.clone());
      }
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.points = [];
      for (let i = 0, l = this.points.length; i < l; i++) {
        const point = this.points[i];
        data.points.push(point.toArray());
      }
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.points = [];
      for (let i = 0, l = json.points.length; i < l; i++) {
        const point = json.points[i];
        this.points.push(new Vector2().fromArray(point));
      }
      return this;
    }
  };
  SplineCurve.prototype.isSplineCurve = true;
  var Curves = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ArcCurve,
    CatmullRomCurve3,
    CubicBezierCurve,
    CubicBezierCurve3,
    EllipseCurve,
    LineCurve,
    LineCurve3,
    QuadraticBezierCurve,
    QuadraticBezierCurve3,
    SplineCurve
  });
  var CurvePath = class extends Curve {
    constructor() {
      super();
      this.type = "CurvePath";
      this.curves = [];
      this.autoClose = false;
    }
    add(curve) {
      this.curves.push(curve);
    }
    closePath() {
      const startPoint = this.curves[0].getPoint(0);
      const endPoint = this.curves[this.curves.length - 1].getPoint(1);
      if (!startPoint.equals(endPoint)) {
        this.curves.push(new LineCurve(endPoint, startPoint));
      }
    }
    getPoint(t) {
      const d = t * this.getLength();
      const curveLengths = this.getCurveLengths();
      let i = 0;
      while (i < curveLengths.length) {
        if (curveLengths[i] >= d) {
          const diff = curveLengths[i] - d;
          const curve = this.curves[i];
          const segmentLength = curve.getLength();
          const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
          return curve.getPointAt(u);
        }
        i++;
      }
      return null;
    }
    getLength() {
      const lens = this.getCurveLengths();
      return lens[lens.length - 1];
    }
    updateArcLengths() {
      this.needsUpdate = true;
      this.cacheLengths = null;
      this.getCurveLengths();
    }
    getCurveLengths() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
        return this.cacheLengths;
      }
      const lengths = [];
      let sums = 0;
      for (let i = 0, l = this.curves.length; i < l; i++) {
        sums += this.curves[i].getLength();
        lengths.push(sums);
      }
      this.cacheLengths = lengths;
      return lengths;
    }
    getSpacedPoints(divisions = 40) {
      const points = [];
      for (let i = 0; i <= divisions; i++) {
        points.push(this.getPoint(i / divisions));
      }
      if (this.autoClose) {
        points.push(points[0]);
      }
      return points;
    }
    getPoints(divisions = 12) {
      const points = [];
      let last;
      for (let i = 0, curves = this.curves; i < curves.length; i++) {
        const curve = curves[i];
        const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
        const pts = curve.getPoints(resolution);
        for (let j = 0; j < pts.length; j++) {
          const point = pts[j];
          if (last && last.equals(point))
            continue;
          points.push(point);
          last = point;
        }
      }
      if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
        points.push(points[0]);
      }
      return points;
    }
    copy(source) {
      super.copy(source);
      this.curves = [];
      for (let i = 0, l = source.curves.length; i < l; i++) {
        const curve = source.curves[i];
        this.curves.push(curve.clone());
      }
      this.autoClose = source.autoClose;
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.autoClose = this.autoClose;
      data.curves = [];
      for (let i = 0, l = this.curves.length; i < l; i++) {
        const curve = this.curves[i];
        data.curves.push(curve.toJSON());
      }
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.autoClose = json.autoClose;
      this.curves = [];
      for (let i = 0, l = json.curves.length; i < l; i++) {
        const curve = json.curves[i];
        this.curves.push(new Curves[curve.type]().fromJSON(curve));
      }
      return this;
    }
  };
  var Path = class extends CurvePath {
    constructor(points) {
      super();
      this.type = "Path";
      this.currentPoint = new Vector2();
      if (points) {
        this.setFromPoints(points);
      }
    }
    setFromPoints(points) {
      this.moveTo(points[0].x, points[0].y);
      for (let i = 1, l = points.length; i < l; i++) {
        this.lineTo(points[i].x, points[i].y);
      }
      return this;
    }
    moveTo(x, y) {
      this.currentPoint.set(x, y);
      return this;
    }
    lineTo(x, y) {
      const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
      this.curves.push(curve);
      this.currentPoint.set(x, y);
      return this;
    }
    quadraticCurveTo(aCPx, aCPy, aX, aY) {
      const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
      this.curves.push(curve);
      this.currentPoint.set(aX, aY);
      return this;
    }
    bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
      const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
      this.curves.push(curve);
      this.currentPoint.set(aX, aY);
      return this;
    }
    splineThru(pts) {
      const npts = [this.currentPoint.clone()].concat(pts);
      const curve = new SplineCurve(npts);
      this.curves.push(curve);
      this.currentPoint.copy(pts[pts.length - 1]);
      return this;
    }
    arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      const x0 = this.currentPoint.x;
      const y0 = this.currentPoint.y;
      this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
      return this;
    }
    absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
      return this;
    }
    ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
      const x0 = this.currentPoint.x;
      const y0 = this.currentPoint.y;
      this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
      return this;
    }
    absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
      const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
      if (this.curves.length > 0) {
        const firstPoint = curve.getPoint(0);
        if (!firstPoint.equals(this.currentPoint)) {
          this.lineTo(firstPoint.x, firstPoint.y);
        }
      }
      this.curves.push(curve);
      const lastPoint = curve.getPoint(1);
      this.currentPoint.copy(lastPoint);
      return this;
    }
    copy(source) {
      super.copy(source);
      this.currentPoint.copy(source.currentPoint);
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.currentPoint = this.currentPoint.toArray();
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.currentPoint.fromArray(json.currentPoint);
      return this;
    }
  };
  var Shape = class extends Path {
    constructor(points) {
      super(points);
      this.uuid = MathUtils.generateUUID();
      this.type = "Shape";
      this.holes = [];
    }
    getPointsHoles(divisions) {
      const holesPts = [];
      for (let i = 0, l = this.holes.length; i < l; i++) {
        holesPts[i] = this.holes[i].getPoints(divisions);
      }
      return holesPts;
    }
    extractPoints(divisions) {
      return {
        shape: this.getPoints(divisions),
        holes: this.getPointsHoles(divisions)
      };
    }
    copy(source) {
      super.copy(source);
      this.holes = [];
      for (let i = 0, l = source.holes.length; i < l; i++) {
        const hole = source.holes[i];
        this.holes.push(hole.clone());
      }
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.uuid = this.uuid;
      data.holes = [];
      for (let i = 0, l = this.holes.length; i < l; i++) {
        const hole = this.holes[i];
        data.holes.push(hole.toJSON());
      }
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.uuid = json.uuid;
      this.holes = [];
      for (let i = 0, l = json.holes.length; i < l; i++) {
        const hole = json.holes[i];
        this.holes.push(new Path().fromJSON(hole));
      }
      return this;
    }
  };
  var Light = class extends Object3D {
    constructor(color, intensity = 1) {
      super();
      this.type = "Light";
      this.color = new Color(color);
      this.intensity = intensity;
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.intensity = source.intensity;
      return this;
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      data.object.color = this.color.getHex();
      data.object.intensity = this.intensity;
      if (this.groundColor !== void 0)
        data.object.groundColor = this.groundColor.getHex();
      if (this.distance !== void 0)
        data.object.distance = this.distance;
      if (this.angle !== void 0)
        data.object.angle = this.angle;
      if (this.decay !== void 0)
        data.object.decay = this.decay;
      if (this.penumbra !== void 0)
        data.object.penumbra = this.penumbra;
      if (this.shadow !== void 0)
        data.object.shadow = this.shadow.toJSON();
      return data;
    }
  };
  Light.prototype.isLight = true;
  var HemisphereLight = class extends Light {
    constructor(skyColor, groundColor, intensity) {
      super(skyColor, intensity);
      this.type = "HemisphereLight";
      this.position.copy(Object3D.DefaultUp);
      this.updateMatrix();
      this.groundColor = new Color(groundColor);
    }
    copy(source) {
      Light.prototype.copy.call(this, source);
      this.groundColor.copy(source.groundColor);
      return this;
    }
  };
  HemisphereLight.prototype.isHemisphereLight = true;
  var _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
  var _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
  var _lookTarget$1 = /* @__PURE__ */ new Vector3();
  var LightShadow = class {
    constructor(camera) {
      this.camera = camera;
      this.bias = 0;
      this.normalBias = 0;
      this.radius = 1;
      this.mapSize = new Vector2(512, 512);
      this.map = null;
      this.mapPass = null;
      this.matrix = new Matrix4();
      this.autoUpdate = true;
      this.needsUpdate = false;
      this._frustum = new Frustum();
      this._frameExtents = new Vector2(1, 1);
      this._viewportCount = 1;
      this._viewports = [
        new Vector4(0, 0, 1, 1)
      ];
    }
    getViewportCount() {
      return this._viewportCount;
    }
    getFrustum() {
      return this._frustum;
    }
    updateMatrices(light) {
      const shadowCamera = this.camera;
      const shadowMatrix = this.matrix;
      _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
      shadowCamera.position.copy(_lightPositionWorld$1);
      _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
      shadowCamera.lookAt(_lookTarget$1);
      shadowCamera.updateMatrixWorld();
      _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
      this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
      shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      shadowMatrix.multiply(shadowCamera.projectionMatrix);
      shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
    }
    getViewport(viewportIndex) {
      return this._viewports[viewportIndex];
    }
    getFrameExtents() {
      return this._frameExtents;
    }
    copy(source) {
      this.camera = source.camera.clone();
      this.bias = source.bias;
      this.radius = source.radius;
      this.mapSize.copy(source.mapSize);
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      const object = {};
      if (this.bias !== 0)
        object.bias = this.bias;
      if (this.normalBias !== 0)
        object.normalBias = this.normalBias;
      if (this.radius !== 1)
        object.radius = this.radius;
      if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
        object.mapSize = this.mapSize.toArray();
      object.camera = this.camera.toJSON(false).object;
      delete object.camera.matrix;
      return object;
    }
  };
  var SpotLightShadow = class extends LightShadow {
    constructor() {
      super(new PerspectiveCamera(50, 1, 0.5, 500));
      this.focus = 1;
    }
    updateMatrices(light) {
      const camera = this.camera;
      const fov2 = MathUtils.RAD2DEG * 2 * light.angle * this.focus;
      const aspect2 = this.mapSize.width / this.mapSize.height;
      const far = light.distance || camera.far;
      if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
        camera.fov = fov2;
        camera.aspect = aspect2;
        camera.far = far;
        camera.updateProjectionMatrix();
      }
      super.updateMatrices(light);
    }
    copy(source) {
      super.copy(source);
      this.focus = source.focus;
      return this;
    }
  };
  SpotLightShadow.prototype.isSpotLightShadow = true;
  var SpotLight = class extends Light {
    constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
      super(color, intensity);
      this.type = "SpotLight";
      this.position.copy(Object3D.DefaultUp);
      this.updateMatrix();
      this.target = new Object3D();
      this.distance = distance;
      this.angle = angle;
      this.penumbra = penumbra;
      this.decay = decay;
      this.shadow = new SpotLightShadow();
    }
    get power() {
      return this.intensity * Math.PI;
    }
    set power(power) {
      this.intensity = power / Math.PI;
    }
    copy(source) {
      super.copy(source);
      this.distance = source.distance;
      this.angle = source.angle;
      this.penumbra = source.penumbra;
      this.decay = source.decay;
      this.target = source.target.clone();
      this.shadow = source.shadow.clone();
      return this;
    }
  };
  SpotLight.prototype.isSpotLight = true;
  var _projScreenMatrix = /* @__PURE__ */ new Matrix4();
  var _lightPositionWorld = /* @__PURE__ */ new Vector3();
  var _lookTarget = /* @__PURE__ */ new Vector3();
  var PointLightShadow = class extends LightShadow {
    constructor() {
      super(new PerspectiveCamera(90, 1, 0.5, 500));
      this._frameExtents = new Vector2(4, 2);
      this._viewportCount = 6;
      this._viewports = [
        new Vector4(2, 1, 1, 1),
        new Vector4(0, 1, 1, 1),
        new Vector4(3, 1, 1, 1),
        new Vector4(1, 1, 1, 1),
        new Vector4(3, 0, 1, 1),
        new Vector4(1, 0, 1, 1)
      ];
      this._cubeDirections = [
        new Vector3(1, 0, 0),
        new Vector3(-1, 0, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1),
        new Vector3(0, 1, 0),
        new Vector3(0, -1, 0)
      ];
      this._cubeUps = [
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1)
      ];
    }
    updateMatrices(light, viewportIndex = 0) {
      const camera = this.camera;
      const shadowMatrix = this.matrix;
      const far = light.distance || camera.far;
      if (far !== camera.far) {
        camera.far = far;
        camera.updateProjectionMatrix();
      }
      _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
      camera.position.copy(_lightPositionWorld);
      _lookTarget.copy(camera.position);
      _lookTarget.add(this._cubeDirections[viewportIndex]);
      camera.up.copy(this._cubeUps[viewportIndex]);
      camera.lookAt(_lookTarget);
      camera.updateMatrixWorld();
      shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
      _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      this._frustum.setFromProjectionMatrix(_projScreenMatrix);
    }
  };
  PointLightShadow.prototype.isPointLightShadow = true;
  var PointLight = class extends Light {
    constructor(color, intensity, distance = 0, decay = 1) {
      super(color, intensity);
      this.type = "PointLight";
      this.distance = distance;
      this.decay = decay;
      this.shadow = new PointLightShadow();
    }
    get power() {
      return this.intensity * 4 * Math.PI;
    }
    set power(power) {
      this.intensity = power / (4 * Math.PI);
    }
    copy(source) {
      super.copy(source);
      this.distance = source.distance;
      this.decay = source.decay;
      this.shadow = source.shadow.clone();
      return this;
    }
  };
  PointLight.prototype.isPointLight = true;
  var OrthographicCamera = class extends Camera {
    constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
      super();
      this.type = "OrthographicCamera";
      this.zoom = 1;
      this.view = null;
      this.left = left;
      this.right = right;
      this.top = top;
      this.bottom = bottom;
      this.near = near;
      this.far = far;
      this.updateProjectionMatrix();
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      this.left = source.left;
      this.right = source.right;
      this.top = source.top;
      this.bottom = source.bottom;
      this.near = source.near;
      this.far = source.far;
      this.zoom = source.zoom;
      this.view = source.view === null ? null : Object.assign({}, source.view);
      return this;
    }
    setViewOffset(fullWidth, fullHeight, x, y, width, height) {
      if (this.view === null) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }
      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x;
      this.view.offsetY = y;
      this.view.width = width;
      this.view.height = height;
      this.updateProjectionMatrix();
    }
    clearViewOffset() {
      if (this.view !== null) {
        this.view.enabled = false;
      }
      this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const dx = (this.right - this.left) / (2 * this.zoom);
      const dy = (this.top - this.bottom) / (2 * this.zoom);
      const cx = (this.right + this.left) / 2;
      const cy = (this.top + this.bottom) / 2;
      let left = cx - dx;
      let right = cx + dx;
      let top = cy + dy;
      let bottom = cy - dy;
      if (this.view !== null && this.view.enabled) {
        const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
        const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        left += scaleW * this.view.offsetX;
        right = left + scaleW * this.view.width;
        top -= scaleH * this.view.offsetY;
        bottom = top - scaleH * this.view.height;
      }
      this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(meta) {
      const data = Object3D.prototype.toJSON.call(this, meta);
      data.object.zoom = this.zoom;
      data.object.left = this.left;
      data.object.right = this.right;
      data.object.top = this.top;
      data.object.bottom = this.bottom;
      data.object.near = this.near;
      data.object.far = this.far;
      if (this.view !== null)
        data.object.view = Object.assign({}, this.view);
      return data;
    }
  };
  OrthographicCamera.prototype.isOrthographicCamera = true;
  var DirectionalLightShadow = class extends LightShadow {
    constructor() {
      super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
    }
  };
  DirectionalLightShadow.prototype.isDirectionalLightShadow = true;
  var DirectionalLight = class extends Light {
    constructor(color, intensity) {
      super(color, intensity);
      this.type = "DirectionalLight";
      this.position.copy(Object3D.DefaultUp);
      this.updateMatrix();
      this.target = new Object3D();
      this.shadow = new DirectionalLightShadow();
    }
    copy(source) {
      super.copy(source);
      this.target = source.target.clone();
      this.shadow = source.shadow.clone();
      return this;
    }
  };
  DirectionalLight.prototype.isDirectionalLight = true;
  var AmbientLight = class extends Light {
    constructor(color, intensity) {
      super(color, intensity);
      this.type = "AmbientLight";
    }
  };
  AmbientLight.prototype.isAmbientLight = true;
  var RectAreaLight = class extends Light {
    constructor(color, intensity, width = 10, height = 10) {
      super(color, intensity);
      this.type = "RectAreaLight";
      this.width = width;
      this.height = height;
    }
    copy(source) {
      super.copy(source);
      this.width = source.width;
      this.height = source.height;
      return this;
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      data.object.width = this.width;
      data.object.height = this.height;
      return data;
    }
  };
  RectAreaLight.prototype.isRectAreaLight = true;
  var SphericalHarmonics3 = class {
    constructor() {
      this.coefficients = [];
      for (let i = 0; i < 9; i++) {
        this.coefficients.push(new Vector3());
      }
    }
    set(coefficients) {
      for (let i = 0; i < 9; i++) {
        this.coefficients[i].copy(coefficients[i]);
      }
      return this;
    }
    zero() {
      for (let i = 0; i < 9; i++) {
        this.coefficients[i].set(0, 0, 0);
      }
      return this;
    }
    getAt(normal, target) {
      const x = normal.x, y = normal.y, z = normal.z;
      const coeff = this.coefficients;
      target.copy(coeff[0]).multiplyScalar(0.282095);
      target.addScaledVector(coeff[1], 0.488603 * y);
      target.addScaledVector(coeff[2], 0.488603 * z);
      target.addScaledVector(coeff[3], 0.488603 * x);
      target.addScaledVector(coeff[4], 1.092548 * (x * y));
      target.addScaledVector(coeff[5], 1.092548 * (y * z));
      target.addScaledVector(coeff[6], 0.315392 * (3 * z * z - 1));
      target.addScaledVector(coeff[7], 1.092548 * (x * z));
      target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
      return target;
    }
    getIrradianceAt(normal, target) {
      const x = normal.x, y = normal.y, z = normal.z;
      const coeff = this.coefficients;
      target.copy(coeff[0]).multiplyScalar(0.886227);
      target.addScaledVector(coeff[1], 2 * 0.511664 * y);
      target.addScaledVector(coeff[2], 2 * 0.511664 * z);
      target.addScaledVector(coeff[3], 2 * 0.511664 * x);
      target.addScaledVector(coeff[4], 2 * 0.429043 * x * y);
      target.addScaledVector(coeff[5], 2 * 0.429043 * y * z);
      target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708);
      target.addScaledVector(coeff[7], 2 * 0.429043 * x * z);
      target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y));
      return target;
    }
    add(sh) {
      for (let i = 0; i < 9; i++) {
        this.coefficients[i].add(sh.coefficients[i]);
      }
      return this;
    }
    addScaledSH(sh, s) {
      for (let i = 0; i < 9; i++) {
        this.coefficients[i].addScaledVector(sh.coefficients[i], s);
      }
      return this;
    }
    scale(s) {
      for (let i = 0; i < 9; i++) {
        this.coefficients[i].multiplyScalar(s);
      }
      return this;
    }
    lerp(sh, alpha) {
      for (let i = 0; i < 9; i++) {
        this.coefficients[i].lerp(sh.coefficients[i], alpha);
      }
      return this;
    }
    equals(sh) {
      for (let i = 0; i < 9; i++) {
        if (!this.coefficients[i].equals(sh.coefficients[i])) {
          return false;
        }
      }
      return true;
    }
    copy(sh) {
      return this.set(sh.coefficients);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(array, offset = 0) {
      const coefficients = this.coefficients;
      for (let i = 0; i < 9; i++) {
        coefficients[i].fromArray(array, offset + i * 3);
      }
      return this;
    }
    toArray(array = [], offset = 0) {
      const coefficients = this.coefficients;
      for (let i = 0; i < 9; i++) {
        coefficients[i].toArray(array, offset + i * 3);
      }
      return array;
    }
    static getBasisAt(normal, shBasis) {
      const x = normal.x, y = normal.y, z = normal.z;
      shBasis[0] = 0.282095;
      shBasis[1] = 0.488603 * y;
      shBasis[2] = 0.488603 * z;
      shBasis[3] = 0.488603 * x;
      shBasis[4] = 1.092548 * x * y;
      shBasis[5] = 1.092548 * y * z;
      shBasis[6] = 0.315392 * (3 * z * z - 1);
      shBasis[7] = 1.092548 * x * z;
      shBasis[8] = 0.546274 * (x * x - y * y);
    }
  };
  SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;
  var LightProbe = class extends Light {
    constructor(sh = new SphericalHarmonics3(), intensity = 1) {
      super(void 0, intensity);
      this.sh = sh;
    }
    copy(source) {
      super.copy(source);
      this.sh.copy(source.sh);
      return this;
    }
    fromJSON(json) {
      this.intensity = json.intensity;
      this.sh.fromArray(json.sh);
      return this;
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      data.object.sh = this.sh.toArray();
      return data;
    }
  };
  LightProbe.prototype.isLightProbe = true;
  var MaterialLoader = class extends Loader {
    constructor(manager) {
      super(manager);
      this.textures = {};
    }
    load(url, onLoad, onProgress, onError) {
      const scope = this;
      const loader = new FileLoader(scope.manager);
      loader.setPath(scope.path);
      loader.setRequestHeader(scope.requestHeader);
      loader.setWithCredentials(scope.withCredentials);
      loader.load(url, function(text) {
        try {
          onLoad(scope.parse(JSON.parse(text)));
        } catch (e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }
          scope.manager.itemError(url);
        }
      }, onProgress, onError);
    }
    parse(json) {
      const textures = this.textures;
      function getTexture(name) {
        if (textures[name] === void 0) {
          console.warn("THREE.MaterialLoader: Undefined texture", name);
        }
        return textures[name];
      }
      const material = new Materials[json.type]();
      if (json.uuid !== void 0)
        material.uuid = json.uuid;
      if (json.name !== void 0)
        material.name = json.name;
      if (json.color !== void 0 && material.color !== void 0)
        material.color.setHex(json.color);
      if (json.roughness !== void 0)
        material.roughness = json.roughness;
      if (json.metalness !== void 0)
        material.metalness = json.metalness;
      if (json.sheen !== void 0)
        material.sheen = new Color().setHex(json.sheen);
      if (json.emissive !== void 0 && material.emissive !== void 0)
        material.emissive.setHex(json.emissive);
      if (json.specular !== void 0 && material.specular !== void 0)
        material.specular.setHex(json.specular);
      if (json.shininess !== void 0)
        material.shininess = json.shininess;
      if (json.clearcoat !== void 0)
        material.clearcoat = json.clearcoat;
      if (json.clearcoatRoughness !== void 0)
        material.clearcoatRoughness = json.clearcoatRoughness;
      if (json.fog !== void 0)
        material.fog = json.fog;
      if (json.flatShading !== void 0)
        material.flatShading = json.flatShading;
      if (json.blending !== void 0)
        material.blending = json.blending;
      if (json.combine !== void 0)
        material.combine = json.combine;
      if (json.side !== void 0)
        material.side = json.side;
      if (json.shadowSide !== void 0)
        material.shadowSide = json.shadowSide;
      if (json.opacity !== void 0)
        material.opacity = json.opacity;
      if (json.transparent !== void 0)
        material.transparent = json.transparent;
      if (json.alphaTest !== void 0)
        material.alphaTest = json.alphaTest;
      if (json.depthTest !== void 0)
        material.depthTest = json.depthTest;
      if (json.depthWrite !== void 0)
        material.depthWrite = json.depthWrite;
      if (json.colorWrite !== void 0)
        material.colorWrite = json.colorWrite;
      if (json.stencilWrite !== void 0)
        material.stencilWrite = json.stencilWrite;
      if (json.stencilWriteMask !== void 0)
        material.stencilWriteMask = json.stencilWriteMask;
      if (json.stencilFunc !== void 0)
        material.stencilFunc = json.stencilFunc;
      if (json.stencilRef !== void 0)
        material.stencilRef = json.stencilRef;
      if (json.stencilFuncMask !== void 0)
        material.stencilFuncMask = json.stencilFuncMask;
      if (json.stencilFail !== void 0)
        material.stencilFail = json.stencilFail;
      if (json.stencilZFail !== void 0)
        material.stencilZFail = json.stencilZFail;
      if (json.stencilZPass !== void 0)
        material.stencilZPass = json.stencilZPass;
      if (json.wireframe !== void 0)
        material.wireframe = json.wireframe;
      if (json.wireframeLinewidth !== void 0)
        material.wireframeLinewidth = json.wireframeLinewidth;
      if (json.wireframeLinecap !== void 0)
        material.wireframeLinecap = json.wireframeLinecap;
      if (json.wireframeLinejoin !== void 0)
        material.wireframeLinejoin = json.wireframeLinejoin;
      if (json.rotation !== void 0)
        material.rotation = json.rotation;
      if (json.linewidth !== 1)
        material.linewidth = json.linewidth;
      if (json.dashSize !== void 0)
        material.dashSize = json.dashSize;
      if (json.gapSize !== void 0)
        material.gapSize = json.gapSize;
      if (json.scale !== void 0)
        material.scale = json.scale;
      if (json.polygonOffset !== void 0)
        material.polygonOffset = json.polygonOffset;
      if (json.polygonOffsetFactor !== void 0)
        material.polygonOffsetFactor = json.polygonOffsetFactor;
      if (json.polygonOffsetUnits !== void 0)
        material.polygonOffsetUnits = json.polygonOffsetUnits;
      if (json.skinning !== void 0)
        material.skinning = json.skinning;
      if (json.morphTargets !== void 0)
        material.morphTargets = json.morphTargets;
      if (json.morphNormals !== void 0)
        material.morphNormals = json.morphNormals;
      if (json.dithering !== void 0)
        material.dithering = json.dithering;
      if (json.alphaToCoverage !== void 0)
        material.alphaToCoverage = json.alphaToCoverage;
      if (json.premultipliedAlpha !== void 0)
        material.premultipliedAlpha = json.premultipliedAlpha;
      if (json.vertexTangents !== void 0)
        material.vertexTangents = json.vertexTangents;
      if (json.visible !== void 0)
        material.visible = json.visible;
      if (json.toneMapped !== void 0)
        material.toneMapped = json.toneMapped;
      if (json.userData !== void 0)
        material.userData = json.userData;
      if (json.vertexColors !== void 0) {
        if (typeof json.vertexColors === "number") {
          material.vertexColors = json.vertexColors > 0 ? true : false;
        } else {
          material.vertexColors = json.vertexColors;
        }
      }
      if (json.uniforms !== void 0) {
        for (const name in json.uniforms) {
          const uniform = json.uniforms[name];
          material.uniforms[name] = {};
          switch (uniform.type) {
            case "t":
              material.uniforms[name].value = getTexture(uniform.value);
              break;
            case "c":
              material.uniforms[name].value = new Color().setHex(uniform.value);
              break;
            case "v2":
              material.uniforms[name].value = new Vector2().fromArray(uniform.value);
              break;
            case "v3":
              material.uniforms[name].value = new Vector3().fromArray(uniform.value);
              break;
            case "v4":
              material.uniforms[name].value = new Vector4().fromArray(uniform.value);
              break;
            case "m3":
              material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
              break;
            case "m4":
              material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
              break;
            default:
              material.uniforms[name].value = uniform.value;
          }
        }
      }
      if (json.defines !== void 0)
        material.defines = json.defines;
      if (json.vertexShader !== void 0)
        material.vertexShader = json.vertexShader;
      if (json.fragmentShader !== void 0)
        material.fragmentShader = json.fragmentShader;
      if (json.extensions !== void 0) {
        for (const key in json.extensions) {
          material.extensions[key] = json.extensions[key];
        }
      }
      if (json.shading !== void 0)
        material.flatShading = json.shading === 1;
      if (json.size !== void 0)
        material.size = json.size;
      if (json.sizeAttenuation !== void 0)
        material.sizeAttenuation = json.sizeAttenuation;
      if (json.map !== void 0)
        material.map = getTexture(json.map);
      if (json.matcap !== void 0)
        material.matcap = getTexture(json.matcap);
      if (json.alphaMap !== void 0)
        material.alphaMap = getTexture(json.alphaMap);
      if (json.bumpMap !== void 0)
        material.bumpMap = getTexture(json.bumpMap);
      if (json.bumpScale !== void 0)
        material.bumpScale = json.bumpScale;
      if (json.normalMap !== void 0)
        material.normalMap = getTexture(json.normalMap);
      if (json.normalMapType !== void 0)
        material.normalMapType = json.normalMapType;
      if (json.normalScale !== void 0) {
        let normalScale = json.normalScale;
        if (Array.isArray(normalScale) === false) {
          normalScale = [normalScale, normalScale];
        }
        material.normalScale = new Vector2().fromArray(normalScale);
      }
      if (json.displacementMap !== void 0)
        material.displacementMap = getTexture(json.displacementMap);
      if (json.displacementScale !== void 0)
        material.displacementScale = json.displacementScale;
      if (json.displacementBias !== void 0)
        material.displacementBias = json.displacementBias;
      if (json.roughnessMap !== void 0)
        material.roughnessMap = getTexture(json.roughnessMap);
      if (json.metalnessMap !== void 0)
        material.metalnessMap = getTexture(json.metalnessMap);
      if (json.emissiveMap !== void 0)
        material.emissiveMap = getTexture(json.emissiveMap);
      if (json.emissiveIntensity !== void 0)
        material.emissiveIntensity = json.emissiveIntensity;
      if (json.specularMap !== void 0)
        material.specularMap = getTexture(json.specularMap);
      if (json.envMap !== void 0)
        material.envMap = getTexture(json.envMap);
      if (json.envMapIntensity !== void 0)
        material.envMapIntensity = json.envMapIntensity;
      if (json.reflectivity !== void 0)
        material.reflectivity = json.reflectivity;
      if (json.refractionRatio !== void 0)
        material.refractionRatio = json.refractionRatio;
      if (json.lightMap !== void 0)
        material.lightMap = getTexture(json.lightMap);
      if (json.lightMapIntensity !== void 0)
        material.lightMapIntensity = json.lightMapIntensity;
      if (json.aoMap !== void 0)
        material.aoMap = getTexture(json.aoMap);
      if (json.aoMapIntensity !== void 0)
        material.aoMapIntensity = json.aoMapIntensity;
      if (json.gradientMap !== void 0)
        material.gradientMap = getTexture(json.gradientMap);
      if (json.clearcoatMap !== void 0)
        material.clearcoatMap = getTexture(json.clearcoatMap);
      if (json.clearcoatRoughnessMap !== void 0)
        material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
      if (json.clearcoatNormalMap !== void 0)
        material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
      if (json.clearcoatNormalScale !== void 0)
        material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
      if (json.transmission !== void 0)
        material.transmission = json.transmission;
      if (json.transmissionMap !== void 0)
        material.transmissionMap = getTexture(json.transmissionMap);
      return material;
    }
    setTextures(value) {
      this.textures = value;
      return this;
    }
  };
  var LoaderUtils = {
    decodeText: function(array) {
      if (typeof TextDecoder !== "undefined") {
        return new TextDecoder().decode(array);
      }
      let s = "";
      for (let i = 0, il = array.length; i < il; i++) {
        s += String.fromCharCode(array[i]);
      }
      try {
        return decodeURIComponent(escape(s));
      } catch (e) {
        return s;
      }
    },
    extractUrlBase: function(url) {
      const index = url.lastIndexOf("/");
      if (index === -1)
        return "./";
      return url.substr(0, index + 1);
    }
  };
  function InstancedBufferGeometry() {
    BufferGeometry.call(this);
    this.type = "InstancedBufferGeometry";
    this.instanceCount = Infinity;
  }
  InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
    constructor: InstancedBufferGeometry,
    isInstancedBufferGeometry: true,
    copy: function(source) {
      BufferGeometry.prototype.copy.call(this, source);
      this.instanceCount = source.instanceCount;
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    toJSON: function() {
      const data = BufferGeometry.prototype.toJSON.call(this);
      data.instanceCount = this.instanceCount;
      data.isInstancedBufferGeometry = true;
      return data;
    }
  });
  function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
    if (typeof normalized === "number") {
      meshPerAttribute = normalized;
      normalized = false;
      console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
    }
    BufferAttribute.call(this, array, itemSize, normalized);
    this.meshPerAttribute = meshPerAttribute || 1;
  }
  InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
    constructor: InstancedBufferAttribute,
    isInstancedBufferAttribute: true,
    copy: function(source) {
      BufferAttribute.prototype.copy.call(this, source);
      this.meshPerAttribute = source.meshPerAttribute;
      return this;
    },
    toJSON: function() {
      const data = BufferAttribute.prototype.toJSON.call(this);
      data.meshPerAttribute = this.meshPerAttribute;
      data.isInstancedBufferAttribute = true;
      return data;
    }
  });
  var BufferGeometryLoader = class extends Loader {
    constructor(manager) {
      super(manager);
    }
    load(url, onLoad, onProgress, onError) {
      const scope = this;
      const loader = new FileLoader(scope.manager);
      loader.setPath(scope.path);
      loader.setRequestHeader(scope.requestHeader);
      loader.setWithCredentials(scope.withCredentials);
      loader.load(url, function(text) {
        try {
          onLoad(scope.parse(JSON.parse(text)));
        } catch (e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }
          scope.manager.itemError(url);
        }
      }, onProgress, onError);
    }
    parse(json) {
      const interleavedBufferMap = {};
      const arrayBufferMap = {};
      function getInterleavedBuffer(json2, uuid) {
        if (interleavedBufferMap[uuid] !== void 0)
          return interleavedBufferMap[uuid];
        const interleavedBuffers = json2.interleavedBuffers;
        const interleavedBuffer = interleavedBuffers[uuid];
        const buffer = getArrayBuffer(json2, interleavedBuffer.buffer);
        const array = getTypedArray(interleavedBuffer.type, buffer);
        const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
        ib.uuid = interleavedBuffer.uuid;
        interleavedBufferMap[uuid] = ib;
        return ib;
      }
      function getArrayBuffer(json2, uuid) {
        if (arrayBufferMap[uuid] !== void 0)
          return arrayBufferMap[uuid];
        const arrayBuffers = json2.arrayBuffers;
        const arrayBuffer = arrayBuffers[uuid];
        const ab = new Uint32Array(arrayBuffer).buffer;
        arrayBufferMap[uuid] = ab;
        return ab;
      }
      const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
      const index = json.data.index;
      if (index !== void 0) {
        const typedArray = getTypedArray(index.type, index.array);
        geometry.setIndex(new BufferAttribute(typedArray, 1));
      }
      const attributes = json.data.attributes;
      for (const key in attributes) {
        const attribute = attributes[key];
        let bufferAttribute;
        if (attribute.isInterleavedBufferAttribute) {
          const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
          bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
        } else {
          const typedArray = getTypedArray(attribute.type, attribute.array);
          const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
          bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
        }
        if (attribute.name !== void 0)
          bufferAttribute.name = attribute.name;
        if (attribute.usage !== void 0)
          bufferAttribute.setUsage(attribute.usage);
        if (attribute.updateRange !== void 0) {
          bufferAttribute.updateRange.offset = attribute.updateRange.offset;
          bufferAttribute.updateRange.count = attribute.updateRange.count;
        }
        geometry.setAttribute(key, bufferAttribute);
      }
      const morphAttributes = json.data.morphAttributes;
      if (morphAttributes) {
        for (const key in morphAttributes) {
          const attributeArray = morphAttributes[key];
          const array = [];
          for (let i = 0, il = attributeArray.length; i < il; i++) {
            const attribute = attributeArray[i];
            let bufferAttribute;
            if (attribute.isInterleavedBufferAttribute) {
              const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
              bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
            } else {
              const typedArray = getTypedArray(attribute.type, attribute.array);
              bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
            }
            if (attribute.name !== void 0)
              bufferAttribute.name = attribute.name;
            array.push(bufferAttribute);
          }
          geometry.morphAttributes[key] = array;
        }
      }
      const morphTargetsRelative = json.data.morphTargetsRelative;
      if (morphTargetsRelative) {
        geometry.morphTargetsRelative = true;
      }
      const groups = json.data.groups || json.data.drawcalls || json.data.offsets;
      if (groups !== void 0) {
        for (let i = 0, n = groups.length; i !== n; ++i) {
          const group = groups[i];
          geometry.addGroup(group.start, group.count, group.materialIndex);
        }
      }
      const boundingSphere = json.data.boundingSphere;
      if (boundingSphere !== void 0) {
        const center = new Vector3();
        if (boundingSphere.center !== void 0) {
          center.fromArray(boundingSphere.center);
        }
        geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
      }
      if (json.name)
        geometry.name = json.name;
      if (json.userData)
        geometry.userData = json.userData;
      return geometry;
    }
  };
  var ObjectLoader = class extends Loader {
    constructor(manager) {
      super(manager);
    }
    load(url, onLoad, onProgress, onError) {
      const scope = this;
      const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
      this.resourcePath = this.resourcePath || path;
      const loader = new FileLoader(this.manager);
      loader.setPath(this.path);
      loader.setRequestHeader(this.requestHeader);
      loader.setWithCredentials(this.withCredentials);
      loader.load(url, function(text) {
        let json = null;
        try {
          json = JSON.parse(text);
        } catch (error) {
          if (onError !== void 0)
            onError(error);
          console.error("THREE:ObjectLoader: Can't parse " + url + ".", error.message);
          return;
        }
        const metadata = json.metadata;
        if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
          console.error("THREE.ObjectLoader: Can't load " + url);
          return;
        }
        scope.parse(json, onLoad);
      }, onProgress, onError);
    }
    parse(json, onLoad) {
      const animations = this.parseAnimations(json.animations);
      const shapes = this.parseShapes(json.shapes);
      const geometries = this.parseGeometries(json.geometries, shapes);
      const images = this.parseImages(json.images, function() {
        if (onLoad !== void 0)
          onLoad(object);
      });
      const textures = this.parseTextures(json.textures, images);
      const materials = this.parseMaterials(json.materials, textures);
      const object = this.parseObject(json.object, geometries, materials, animations);
      const skeletons = this.parseSkeletons(json.skeletons, object);
      this.bindSkeletons(object, skeletons);
      if (onLoad !== void 0) {
        let hasImages = false;
        for (const uuid in images) {
          if (images[uuid] instanceof HTMLImageElement) {
            hasImages = true;
            break;
          }
        }
        if (hasImages === false)
          onLoad(object);
      }
      return object;
    }
    parseShapes(json) {
      const shapes = {};
      if (json !== void 0) {
        for (let i = 0, l = json.length; i < l; i++) {
          const shape = new Shape().fromJSON(json[i]);
          shapes[shape.uuid] = shape;
        }
      }
      return shapes;
    }
    parseSkeletons(json, object) {
      const skeletons = {};
      const bones = {};
      object.traverse(function(child) {
        if (child.isBone)
          bones[child.uuid] = child;
      });
      if (json !== void 0) {
        for (let i = 0, l = json.length; i < l; i++) {
          const skeleton = new Skeleton().fromJSON(json[i], bones);
          skeletons[skeleton.uuid] = skeleton;
        }
      }
      return skeletons;
    }
    parseGeometries(json, shapes) {
      const geometries = {};
      let geometryShapes;
      if (json !== void 0) {
        const bufferGeometryLoader = new BufferGeometryLoader();
        for (let i = 0, l = json.length; i < l; i++) {
          let geometry;
          const data = json[i];
          switch (data.type) {
            case "PlaneGeometry":
            case "PlaneBufferGeometry":
              geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
              break;
            case "BoxGeometry":
            case "BoxBufferGeometry":
              geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
              break;
            case "CircleGeometry":
            case "CircleBufferGeometry":
              geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
              break;
            case "CylinderGeometry":
            case "CylinderBufferGeometry":
              geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
              break;
            case "ConeGeometry":
            case "ConeBufferGeometry":
              geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
              break;
            case "SphereGeometry":
            case "SphereBufferGeometry":
              geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
              break;
            case "DodecahedronGeometry":
            case "DodecahedronBufferGeometry":
            case "IcosahedronGeometry":
            case "IcosahedronBufferGeometry":
            case "OctahedronGeometry":
            case "OctahedronBufferGeometry":
            case "TetrahedronGeometry":
            case "TetrahedronBufferGeometry":
              geometry = new Geometries[data.type](data.radius, data.detail);
              break;
            case "RingGeometry":
            case "RingBufferGeometry":
              geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
              break;
            case "TorusGeometry":
            case "TorusBufferGeometry":
              geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
              break;
            case "TorusKnotGeometry":
            case "TorusKnotBufferGeometry":
              geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
              break;
            case "TubeGeometry":
            case "TubeBufferGeometry":
              geometry = new Geometries[data.type](new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
              break;
            case "LatheGeometry":
            case "LatheBufferGeometry":
              geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
              break;
            case "PolyhedronGeometry":
            case "PolyhedronBufferGeometry":
              geometry = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);
              break;
            case "ShapeGeometry":
            case "ShapeBufferGeometry":
              geometryShapes = [];
              for (let j = 0, jl = data.shapes.length; j < jl; j++) {
                const shape = shapes[data.shapes[j]];
                geometryShapes.push(shape);
              }
              geometry = new Geometries[data.type](geometryShapes, data.curveSegments);
              break;
            case "ExtrudeGeometry":
            case "ExtrudeBufferGeometry":
              geometryShapes = [];
              for (let j = 0, jl = data.shapes.length; j < jl; j++) {
                const shape = shapes[data.shapes[j]];
                geometryShapes.push(shape);
              }
              const extrudePath = data.options.extrudePath;
              if (extrudePath !== void 0) {
                data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
              }
              geometry = new Geometries[data.type](geometryShapes, data.options);
              break;
            case "BufferGeometry":
            case "InstancedBufferGeometry":
              geometry = bufferGeometryLoader.parse(data);
              break;
            case "Geometry":
              console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
              break;
            default:
              console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
              continue;
          }
          geometry.uuid = data.uuid;
          if (data.name !== void 0)
            geometry.name = data.name;
          if (geometry.isBufferGeometry === true && data.userData !== void 0)
            geometry.userData = data.userData;
          geometries[data.uuid] = geometry;
        }
      }
      return geometries;
    }
    parseMaterials(json, textures) {
      const cache = {};
      const materials = {};
      if (json !== void 0) {
        const loader = new MaterialLoader();
        loader.setTextures(textures);
        for (let i = 0, l = json.length; i < l; i++) {
          const data = json[i];
          if (data.type === "MultiMaterial") {
            const array = [];
            for (let j = 0; j < data.materials.length; j++) {
              const material = data.materials[j];
              if (cache[material.uuid] === void 0) {
                cache[material.uuid] = loader.parse(material);
              }
              array.push(cache[material.uuid]);
            }
            materials[data.uuid] = array;
          } else {
            if (cache[data.uuid] === void 0) {
              cache[data.uuid] = loader.parse(data);
            }
            materials[data.uuid] = cache[data.uuid];
          }
        }
      }
      return materials;
    }
    parseAnimations(json) {
      const animations = {};
      if (json !== void 0) {
        for (let i = 0; i < json.length; i++) {
          const data = json[i];
          const clip = AnimationClip.parse(data);
          animations[clip.uuid] = clip;
        }
      }
      return animations;
    }
    parseImages(json, onLoad) {
      const scope = this;
      const images = {};
      let loader;
      function loadImage(url) {
        scope.manager.itemStart(url);
        return loader.load(url, function() {
          scope.manager.itemEnd(url);
        }, void 0, function() {
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        });
      }
      function deserializeImage(image) {
        if (typeof image === "string") {
          const url = image;
          const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
          return loadImage(path);
        } else {
          if (image.data) {
            return {
              data: getTypedArray(image.type, image.data),
              width: image.width,
              height: image.height
            };
          } else {
            return null;
          }
        }
      }
      if (json !== void 0 && json.length > 0) {
        const manager = new LoadingManager(onLoad);
        loader = new ImageLoader(manager);
        loader.setCrossOrigin(this.crossOrigin);
        for (let i = 0, il = json.length; i < il; i++) {
          const image = json[i];
          const url = image.url;
          if (Array.isArray(url)) {
            images[image.uuid] = [];
            for (let j = 0, jl = url.length; j < jl; j++) {
              const currentUrl = url[j];
              const deserializedImage = deserializeImage(currentUrl);
              if (deserializedImage !== null) {
                if (deserializedImage instanceof HTMLImageElement) {
                  images[image.uuid].push(deserializedImage);
                } else {
                  images[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                }
              }
            }
          } else {
            const deserializedImage = deserializeImage(image.url);
            if (deserializedImage !== null) {
              images[image.uuid] = deserializedImage;
            }
          }
        }
      }
      return images;
    }
    parseTextures(json, images) {
      function parseConstant(value, type) {
        if (typeof value === "number")
          return value;
        console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value);
        return type[value];
      }
      const textures = {};
      if (json !== void 0) {
        for (let i = 0, l = json.length; i < l; i++) {
          const data = json[i];
          if (data.image === void 0) {
            console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
          }
          if (images[data.image] === void 0) {
            console.warn("THREE.ObjectLoader: Undefined image", data.image);
          }
          let texture;
          const image = images[data.image];
          if (Array.isArray(image)) {
            texture = new CubeTexture(image);
            if (image.length === 6)
              texture.needsUpdate = true;
          } else {
            if (image && image.data) {
              texture = new DataTexture(image.data, image.width, image.height);
            } else {
              texture = new Texture(image);
            }
            if (image)
              texture.needsUpdate = true;
          }
          texture.uuid = data.uuid;
          if (data.name !== void 0)
            texture.name = data.name;
          if (data.mapping !== void 0)
            texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
          if (data.offset !== void 0)
            texture.offset.fromArray(data.offset);
          if (data.repeat !== void 0)
            texture.repeat.fromArray(data.repeat);
          if (data.center !== void 0)
            texture.center.fromArray(data.center);
          if (data.rotation !== void 0)
            texture.rotation = data.rotation;
          if (data.wrap !== void 0) {
            texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
            texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
          }
          if (data.format !== void 0)
            texture.format = data.format;
          if (data.type !== void 0)
            texture.type = data.type;
          if (data.encoding !== void 0)
            texture.encoding = data.encoding;
          if (data.minFilter !== void 0)
            texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
          if (data.magFilter !== void 0)
            texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
          if (data.anisotropy !== void 0)
            texture.anisotropy = data.anisotropy;
          if (data.flipY !== void 0)
            texture.flipY = data.flipY;
          if (data.premultiplyAlpha !== void 0)
            texture.premultiplyAlpha = data.premultiplyAlpha;
          if (data.unpackAlignment !== void 0)
            texture.unpackAlignment = data.unpackAlignment;
          textures[data.uuid] = texture;
        }
      }
      return textures;
    }
    parseObject(data, geometries, materials, animations) {
      let object;
      function getGeometry(name) {
        if (geometries[name] === void 0) {
          console.warn("THREE.ObjectLoader: Undefined geometry", name);
        }
        return geometries[name];
      }
      function getMaterial(name) {
        if (name === void 0)
          return void 0;
        if (Array.isArray(name)) {
          const array = [];
          for (let i = 0, l = name.length; i < l; i++) {
            const uuid = name[i];
            if (materials[uuid] === void 0) {
              console.warn("THREE.ObjectLoader: Undefined material", uuid);
            }
            array.push(materials[uuid]);
          }
          return array;
        }
        if (materials[name] === void 0) {
          console.warn("THREE.ObjectLoader: Undefined material", name);
        }
        return materials[name];
      }
      let geometry, material;
      switch (data.type) {
        case "Scene":
          object = new Scene();
          if (data.background !== void 0) {
            if (Number.isInteger(data.background)) {
              object.background = new Color(data.background);
            }
          }
          if (data.fog !== void 0) {
            if (data.fog.type === "Fog") {
              object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
            } else if (data.fog.type === "FogExp2") {
              object.fog = new FogExp2(data.fog.color, data.fog.density);
            }
          }
          break;
        case "PerspectiveCamera":
          object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
          if (data.focus !== void 0)
            object.focus = data.focus;
          if (data.zoom !== void 0)
            object.zoom = data.zoom;
          if (data.filmGauge !== void 0)
            object.filmGauge = data.filmGauge;
          if (data.filmOffset !== void 0)
            object.filmOffset = data.filmOffset;
          if (data.view !== void 0)
            object.view = Object.assign({}, data.view);
          break;
        case "OrthographicCamera":
          object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
          if (data.zoom !== void 0)
            object.zoom = data.zoom;
          if (data.view !== void 0)
            object.view = Object.assign({}, data.view);
          break;
        case "AmbientLight":
          object = new AmbientLight(data.color, data.intensity);
          break;
        case "DirectionalLight":
          object = new DirectionalLight(data.color, data.intensity);
          break;
        case "PointLight":
          object = new PointLight(data.color, data.intensity, data.distance, data.decay);
          break;
        case "RectAreaLight":
          object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
          break;
        case "SpotLight":
          object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
          break;
        case "HemisphereLight":
          object = new HemisphereLight(data.color, data.groundColor, data.intensity);
          break;
        case "LightProbe":
          object = new LightProbe().fromJSON(data);
          break;
        case "SkinnedMesh":
          geometry = getGeometry(data.geometry);
          material = getMaterial(data.material);
          object = new SkinnedMesh(geometry, material);
          if (data.bindMode !== void 0)
            object.bindMode = data.bindMode;
          if (data.bindMatrix !== void 0)
            object.bindMatrix.fromArray(data.bindMatrix);
          if (data.skeleton !== void 0)
            object.skeleton = data.skeleton;
          break;
        case "Mesh":
          geometry = getGeometry(data.geometry);
          material = getMaterial(data.material);
          object = new Mesh(geometry, material);
          break;
        case "InstancedMesh":
          geometry = getGeometry(data.geometry);
          material = getMaterial(data.material);
          const count = data.count;
          const instanceMatrix = data.instanceMatrix;
          const instanceColor = data.instanceColor;
          object = new InstancedMesh(geometry, material, count);
          object.instanceMatrix = new BufferAttribute(new Float32Array(instanceMatrix.array), 16);
          if (instanceColor !== void 0)
            object.instanceColor = new BufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);
          break;
        case "LOD":
          object = new LOD();
          break;
        case "Line":
          object = new Line(getGeometry(data.geometry), getMaterial(data.material));
          break;
        case "LineLoop":
          object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
          break;
        case "LineSegments":
          object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
          break;
        case "PointCloud":
        case "Points":
          object = new Points(getGeometry(data.geometry), getMaterial(data.material));
          break;
        case "Sprite":
          object = new Sprite(getMaterial(data.material));
          break;
        case "Group":
          object = new Group();
          break;
        case "Bone":
          object = new Bone();
          break;
        default:
          object = new Object3D();
      }
      object.uuid = data.uuid;
      if (data.name !== void 0)
        object.name = data.name;
      if (data.matrix !== void 0) {
        object.matrix.fromArray(data.matrix);
        if (data.matrixAutoUpdate !== void 0)
          object.matrixAutoUpdate = data.matrixAutoUpdate;
        if (object.matrixAutoUpdate)
          object.matrix.decompose(object.position, object.quaternion, object.scale);
      } else {
        if (data.position !== void 0)
          object.position.fromArray(data.position);
        if (data.rotation !== void 0)
          object.rotation.fromArray(data.rotation);
        if (data.quaternion !== void 0)
          object.quaternion.fromArray(data.quaternion);
        if (data.scale !== void 0)
          object.scale.fromArray(data.scale);
      }
      if (data.castShadow !== void 0)
        object.castShadow = data.castShadow;
      if (data.receiveShadow !== void 0)
        object.receiveShadow = data.receiveShadow;
      if (data.shadow) {
        if (data.shadow.bias !== void 0)
          object.shadow.bias = data.shadow.bias;
        if (data.shadow.normalBias !== void 0)
          object.shadow.normalBias = data.shadow.normalBias;
        if (data.shadow.radius !== void 0)
          object.shadow.radius = data.shadow.radius;
        if (data.shadow.mapSize !== void 0)
          object.shadow.mapSize.fromArray(data.shadow.mapSize);
        if (data.shadow.camera !== void 0)
          object.shadow.camera = this.parseObject(data.shadow.camera);
      }
      if (data.visible !== void 0)
        object.visible = data.visible;
      if (data.frustumCulled !== void 0)
        object.frustumCulled = data.frustumCulled;
      if (data.renderOrder !== void 0)
        object.renderOrder = data.renderOrder;
      if (data.userData !== void 0)
        object.userData = data.userData;
      if (data.layers !== void 0)
        object.layers.mask = data.layers;
      if (data.children !== void 0) {
        const children = data.children;
        for (let i = 0; i < children.length; i++) {
          object.add(this.parseObject(children[i], geometries, materials, animations));
        }
      }
      if (data.animations !== void 0) {
        const objectAnimations = data.animations;
        for (let i = 0; i < objectAnimations.length; i++) {
          const uuid = objectAnimations[i];
          object.animations.push(animations[uuid]);
        }
      }
      if (data.type === "LOD") {
        if (data.autoUpdate !== void 0)
          object.autoUpdate = data.autoUpdate;
        const levels = data.levels;
        for (let l = 0; l < levels.length; l++) {
          const level = levels[l];
          const child = object.getObjectByProperty("uuid", level.object);
          if (child !== void 0) {
            object.addLevel(child, level.distance);
          }
        }
      }
      return object;
    }
    bindSkeletons(object, skeletons) {
      if (Object.keys(skeletons).length === 0)
        return;
      object.traverse(function(child) {
        if (child.isSkinnedMesh === true && child.skeleton !== void 0) {
          const skeleton = skeletons[child.skeleton];
          if (skeleton === void 0) {
            console.warn("THREE.ObjectLoader: No skeleton found with UUID:", child.skeleton);
          } else {
            child.bind(skeleton, child.bindMatrix);
          }
        }
      });
    }
    setTexturePath(value) {
      console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().");
      return this.setResourcePath(value);
    }
  };
  var TEXTURE_MAPPING = {
    UVMapping,
    CubeReflectionMapping,
    CubeRefractionMapping,
    EquirectangularReflectionMapping,
    EquirectangularRefractionMapping,
    CubeUVReflectionMapping,
    CubeUVRefractionMapping
  };
  var TEXTURE_WRAPPING = {
    RepeatWrapping,
    ClampToEdgeWrapping,
    MirroredRepeatWrapping
  };
  var TEXTURE_FILTER = {
    NearestFilter,
    NearestMipmapNearestFilter,
    NearestMipmapLinearFilter,
    LinearFilter,
    LinearMipmapNearestFilter,
    LinearMipmapLinearFilter
  };
  function ImageBitmapLoader(manager) {
    if (typeof createImageBitmap === "undefined") {
      console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
    }
    if (typeof fetch === "undefined") {
      console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
    }
    Loader.call(this, manager);
    this.options = { premultiplyAlpha: "none" };
  }
  ImageBitmapLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: ImageBitmapLoader,
    isImageBitmapLoader: true,
    setOptions: function setOptions(options) {
      this.options = options;
      return this;
    },
    load: function(url, onLoad, onProgress, onError) {
      if (url === void 0)
        url = "";
      if (this.path !== void 0)
        url = this.path + url;
      url = this.manager.resolveURL(url);
      const scope = this;
      const cached = Cache.get(url);
      if (cached !== void 0) {
        scope.manager.itemStart(url);
        setTimeout(function() {
          if (onLoad)
            onLoad(cached);
          scope.manager.itemEnd(url);
        }, 0);
        return cached;
      }
      const fetchOptions = {};
      fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
      fetchOptions.headers = this.requestHeader;
      fetch(url, fetchOptions).then(function(res) {
        return res.blob();
      }).then(function(blob) {
        return createImageBitmap(blob, Object.assign(scope.options, { colorSpaceConversion: "none" }));
      }).then(function(imageBitmap) {
        Cache.add(url, imageBitmap);
        if (onLoad)
          onLoad(imageBitmap);
        scope.manager.itemEnd(url);
      }).catch(function(e) {
        if (onError)
          onError(e);
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      });
      scope.manager.itemStart(url);
    }
  });
  var ShapePath = class {
    constructor() {
      this.type = "ShapePath";
      this.color = new Color();
      this.subPaths = [];
      this.currentPath = null;
    }
    moveTo(x, y) {
      this.currentPath = new Path();
      this.subPaths.push(this.currentPath);
      this.currentPath.moveTo(x, y);
      return this;
    }
    lineTo(x, y) {
      this.currentPath.lineTo(x, y);
      return this;
    }
    quadraticCurveTo(aCPx, aCPy, aX, aY) {
      this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
      return this;
    }
    bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
      this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
      return this;
    }
    splineThru(pts) {
      this.currentPath.splineThru(pts);
      return this;
    }
    toShapes(isCCW, noHoles) {
      function toShapesNoHoles(inSubpaths) {
        const shapes2 = [];
        for (let i = 0, l = inSubpaths.length; i < l; i++) {
          const tmpPath2 = inSubpaths[i];
          const tmpShape2 = new Shape();
          tmpShape2.curves = tmpPath2.curves;
          shapes2.push(tmpShape2);
        }
        return shapes2;
      }
      function isPointInsidePolygon(inPt, inPolygon) {
        const polyLen = inPolygon.length;
        let inside = false;
        for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
          let edgeLowPt = inPolygon[p];
          let edgeHighPt = inPolygon[q];
          let edgeDx = edgeHighPt.x - edgeLowPt.x;
          let edgeDy = edgeHighPt.y - edgeLowPt.y;
          if (Math.abs(edgeDy) > Number.EPSILON) {
            if (edgeDy < 0) {
              edgeLowPt = inPolygon[q];
              edgeDx = -edgeDx;
              edgeHighPt = inPolygon[p];
              edgeDy = -edgeDy;
            }
            if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y)
              continue;
            if (inPt.y === edgeLowPt.y) {
              if (inPt.x === edgeLowPt.x)
                return true;
            } else {
              const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
              if (perpEdge === 0)
                return true;
              if (perpEdge < 0)
                continue;
              inside = !inside;
            }
          } else {
            if (inPt.y !== edgeLowPt.y)
              continue;
            if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x)
              return true;
          }
        }
        return inside;
      }
      const isClockWise = ShapeUtils.isClockWise;
      const subPaths = this.subPaths;
      if (subPaths.length === 0)
        return [];
      if (noHoles === true)
        return toShapesNoHoles(subPaths);
      let solid, tmpPath, tmpShape;
      const shapes = [];
      if (subPaths.length === 1) {
        tmpPath = subPaths[0];
        tmpShape = new Shape();
        tmpShape.curves = tmpPath.curves;
        shapes.push(tmpShape);
        return shapes;
      }
      let holesFirst = !isClockWise(subPaths[0].getPoints());
      holesFirst = isCCW ? !holesFirst : holesFirst;
      const betterShapeHoles = [];
      const newShapes = [];
      let newShapeHoles = [];
      let mainIdx = 0;
      let tmpPoints;
      newShapes[mainIdx] = void 0;
      newShapeHoles[mainIdx] = [];
      for (let i = 0, l = subPaths.length; i < l; i++) {
        tmpPath = subPaths[i];
        tmpPoints = tmpPath.getPoints();
        solid = isClockWise(tmpPoints);
        solid = isCCW ? !solid : solid;
        if (solid) {
          if (!holesFirst && newShapes[mainIdx])
            mainIdx++;
          newShapes[mainIdx] = { s: new Shape(), p: tmpPoints };
          newShapes[mainIdx].s.curves = tmpPath.curves;
          if (holesFirst)
            mainIdx++;
          newShapeHoles[mainIdx] = [];
        } else {
          newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });
        }
      }
      if (!newShapes[0])
        return toShapesNoHoles(subPaths);
      if (newShapes.length > 1) {
        let ambiguous = false;
        const toChange = [];
        for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
          betterShapeHoles[sIdx] = [];
        }
        for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
          const sho = newShapeHoles[sIdx];
          for (let hIdx = 0; hIdx < sho.length; hIdx++) {
            const ho = sho[hIdx];
            let hole_unassigned = true;
            for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
              if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                if (sIdx !== s2Idx)
                  toChange.push({ froms: sIdx, tos: s2Idx, hole: hIdx });
                if (hole_unassigned) {
                  hole_unassigned = false;
                  betterShapeHoles[s2Idx].push(ho);
                } else {
                  ambiguous = true;
                }
              }
            }
            if (hole_unassigned) {
              betterShapeHoles[sIdx].push(ho);
            }
          }
        }
        if (toChange.length > 0) {
          if (!ambiguous)
            newShapeHoles = betterShapeHoles;
        }
      }
      let tmpHoles;
      for (let i = 0, il = newShapes.length; i < il; i++) {
        tmpShape = newShapes[i].s;
        shapes.push(tmpShape);
        tmpHoles = newShapeHoles[i];
        for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
          tmpShape.holes.push(tmpHoles[j].h);
        }
      }
      return shapes;
    }
  };
  var Font = class {
    constructor(data) {
      this.type = "Font";
      this.data = data;
    }
    generateShapes(text, size2 = 100) {
      const shapes = [];
      const paths = createPaths(text, size2, this.data);
      for (let p = 0, pl = paths.length; p < pl; p++) {
        Array.prototype.push.apply(shapes, paths[p].toShapes());
      }
      return shapes;
    }
  };
  function createPaths(text, size2, data) {
    const chars = Array.from(text);
    const scale = size2 / data.resolution;
    const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
    const paths = [];
    let offsetX = 0, offsetY = 0;
    for (let i = 0; i < chars.length; i++) {
      const char = chars[i];
      if (char === "\n") {
        offsetX = 0;
        offsetY -= line_height;
      } else {
        const ret = createPath(char, scale, offsetX, offsetY, data);
        offsetX += ret.offsetX;
        paths.push(ret.path);
      }
    }
    return paths;
  }
  function createPath(char, scale, offsetX, offsetY, data) {
    const glyph = data.glyphs[char] || data.glyphs["?"];
    if (!glyph) {
      console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + ".");
      return;
    }
    const path = new ShapePath();
    let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
    if (glyph.o) {
      const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
      for (let i = 0, l = outline.length; i < l; ) {
        const action = outline[i++];
        switch (action) {
          case "m":
            x = outline[i++] * scale + offsetX;
            y = outline[i++] * scale + offsetY;
            path.moveTo(x, y);
            break;
          case "l":
            x = outline[i++] * scale + offsetX;
            y = outline[i++] * scale + offsetY;
            path.lineTo(x, y);
            break;
          case "q":
            cpx = outline[i++] * scale + offsetX;
            cpy = outline[i++] * scale + offsetY;
            cpx1 = outline[i++] * scale + offsetX;
            cpy1 = outline[i++] * scale + offsetY;
            path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
            break;
          case "b":
            cpx = outline[i++] * scale + offsetX;
            cpy = outline[i++] * scale + offsetY;
            cpx1 = outline[i++] * scale + offsetX;
            cpy1 = outline[i++] * scale + offsetY;
            cpx2 = outline[i++] * scale + offsetX;
            cpy2 = outline[i++] * scale + offsetY;
            path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
            break;
        }
      }
    }
    return { offsetX: glyph.ha * scale, path };
  }
  Font.prototype.isFont = true;
  var _context;
  var AudioContext = {
    getContext: function() {
      if (_context === void 0) {
        _context = new (window.AudioContext || window.webkitAudioContext)();
      }
      return _context;
    },
    setContext: function(value) {
      _context = value;
    }
  };
  var AudioLoader = class extends Loader {
    constructor(manager) {
      super(manager);
    }
    load(url, onLoad, onProgress, onError) {
      const scope = this;
      const loader = new FileLoader(this.manager);
      loader.setResponseType("arraybuffer");
      loader.setPath(this.path);
      loader.setRequestHeader(this.requestHeader);
      loader.setWithCredentials(this.withCredentials);
      loader.load(url, function(buffer) {
        try {
          const bufferCopy = buffer.slice(0);
          const context = AudioContext.getContext();
          context.decodeAudioData(bufferCopy, function(audioBuffer) {
            onLoad(audioBuffer);
          });
        } catch (e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }
          scope.manager.itemError(url);
        }
      }, onProgress, onError);
    }
  };
  var HemisphereLightProbe = class extends LightProbe {
    constructor(skyColor, groundColor, intensity = 1) {
      super(void 0, intensity);
      const color1 = new Color().set(skyColor);
      const color2 = new Color().set(groundColor);
      const sky = new Vector3(color1.r, color1.g, color1.b);
      const ground = new Vector3(color2.r, color2.g, color2.b);
      const c0 = Math.sqrt(Math.PI);
      const c1 = c0 * Math.sqrt(0.75);
      this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
      this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
    }
  };
  HemisphereLightProbe.prototype.isHemisphereLightProbe = true;
  var AmbientLightProbe = class extends LightProbe {
    constructor(color, intensity = 1) {
      super(void 0, intensity);
      const color1 = new Color().set(color);
      this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
    }
  };
  AmbientLightProbe.prototype.isAmbientLightProbe = true;
  var _eyeRight = new Matrix4();
  var _eyeLeft = new Matrix4();
  var Clock = class {
    constructor(autoStart) {
      this.autoStart = autoStart !== void 0 ? autoStart : true;
      this.startTime = 0;
      this.oldTime = 0;
      this.elapsedTime = 0;
      this.running = false;
    }
    start() {
      this.startTime = now();
      this.oldTime = this.startTime;
      this.elapsedTime = 0;
      this.running = true;
    }
    stop() {
      this.getElapsedTime();
      this.running = false;
      this.autoStart = false;
    }
    getElapsedTime() {
      this.getDelta();
      return this.elapsedTime;
    }
    getDelta() {
      let diff = 0;
      if (this.autoStart && !this.running) {
        this.start();
        return 0;
      }
      if (this.running) {
        const newTime = now();
        diff = (newTime - this.oldTime) / 1e3;
        this.oldTime = newTime;
        this.elapsedTime += diff;
      }
      return diff;
    }
  };
  function now() {
    return (typeof performance === "undefined" ? Date : performance).now();
  }
  var Audio = class extends Object3D {
    constructor(listener) {
      super();
      this.type = "Audio";
      this.listener = listener;
      this.context = listener.context;
      this.gain = this.context.createGain();
      this.gain.connect(listener.getInput());
      this.autoplay = false;
      this.buffer = null;
      this.detune = 0;
      this.loop = false;
      this.loopStart = 0;
      this.loopEnd = 0;
      this.offset = 0;
      this.duration = void 0;
      this.playbackRate = 1;
      this.isPlaying = false;
      this.hasPlaybackControl = true;
      this.source = null;
      this.sourceType = "empty";
      this._startedAt = 0;
      this._progress = 0;
      this._connected = false;
      this.filters = [];
    }
    getOutput() {
      return this.gain;
    }
    setNodeSource(audioNode) {
      this.hasPlaybackControl = false;
      this.sourceType = "audioNode";
      this.source = audioNode;
      this.connect();
      return this;
    }
    setMediaElementSource(mediaElement) {
      this.hasPlaybackControl = false;
      this.sourceType = "mediaNode";
      this.source = this.context.createMediaElementSource(mediaElement);
      this.connect();
      return this;
    }
    setMediaStreamSource(mediaStream) {
      this.hasPlaybackControl = false;
      this.sourceType = "mediaStreamNode";
      this.source = this.context.createMediaStreamSource(mediaStream);
      this.connect();
      return this;
    }
    setBuffer(audioBuffer) {
      this.buffer = audioBuffer;
      this.sourceType = "buffer";
      if (this.autoplay)
        this.play();
      return this;
    }
    play(delay = 0) {
      if (this.isPlaying === true) {
        console.warn("THREE.Audio: Audio is already playing.");
        return;
      }
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      this._startedAt = this.context.currentTime + delay;
      const source = this.context.createBufferSource();
      source.buffer = this.buffer;
      source.loop = this.loop;
      source.loopStart = this.loopStart;
      source.loopEnd = this.loopEnd;
      source.onended = this.onEnded.bind(this);
      source.start(this._startedAt, this._progress + this.offset, this.duration);
      this.isPlaying = true;
      this.source = source;
      this.setDetune(this.detune);
      this.setPlaybackRate(this.playbackRate);
      return this.connect();
    }
    pause() {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      if (this.isPlaying === true) {
        this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
        if (this.loop === true) {
          this._progress = this._progress % (this.duration || this.buffer.duration);
        }
        this.source.stop();
        this.source.onended = null;
        this.isPlaying = false;
      }
      return this;
    }
    stop() {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      this._progress = 0;
      this.source.stop();
      this.source.onended = null;
      this.isPlaying = false;
      return this;
    }
    connect() {
      if (this.filters.length > 0) {
        this.source.connect(this.filters[0]);
        for (let i = 1, l = this.filters.length; i < l; i++) {
          this.filters[i - 1].connect(this.filters[i]);
        }
        this.filters[this.filters.length - 1].connect(this.getOutput());
      } else {
        this.source.connect(this.getOutput());
      }
      this._connected = true;
      return this;
    }
    disconnect() {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let i = 1, l = this.filters.length; i < l; i++) {
          this.filters[i - 1].disconnect(this.filters[i]);
        }
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else {
        this.source.disconnect(this.getOutput());
      }
      this._connected = false;
      return this;
    }
    getFilters() {
      return this.filters;
    }
    setFilters(value) {
      if (!value)
        value = [];
      if (this._connected === true) {
        this.disconnect();
        this.filters = value.slice();
        this.connect();
      } else {
        this.filters = value.slice();
      }
      return this;
    }
    setDetune(value) {
      this.detune = value;
      if (this.source.detune === void 0)
        return;
      if (this.isPlaying === true) {
        this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
      }
      return this;
    }
    getDetune() {
      return this.detune;
    }
    getFilter() {
      return this.getFilters()[0];
    }
    setFilter(filter) {
      return this.setFilters(filter ? [filter] : []);
    }
    setPlaybackRate(value) {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      this.playbackRate = value;
      if (this.isPlaying === true) {
        this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
      }
      return this;
    }
    getPlaybackRate() {
      return this.playbackRate;
    }
    onEnded() {
      this.isPlaying = false;
    }
    getLoop() {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return false;
      }
      return this.loop;
    }
    setLoop(value) {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      this.loop = value;
      if (this.isPlaying === true) {
        this.source.loop = this.loop;
      }
      return this;
    }
    setLoopStart(value) {
      this.loopStart = value;
      return this;
    }
    setLoopEnd(value) {
      this.loopEnd = value;
      return this;
    }
    getVolume() {
      return this.gain.gain.value;
    }
    setVolume(value) {
      this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
      return this;
    }
  };
  var AudioAnalyser = class {
    constructor(audio, fftSize = 2048) {
      this.analyser = audio.context.createAnalyser();
      this.analyser.fftSize = fftSize;
      this.data = new Uint8Array(this.analyser.frequencyBinCount);
      audio.getOutput().connect(this.analyser);
    }
    getFrequencyData() {
      this.analyser.getByteFrequencyData(this.data);
      return this.data;
    }
    getAverageFrequency() {
      let value = 0;
      const data = this.getFrequencyData();
      for (let i = 0; i < data.length; i++) {
        value += data[i];
      }
      return value / data.length;
    }
  };
  var PropertyMixer = class {
    constructor(binding, typeName, valueSize) {
      this.binding = binding;
      this.valueSize = valueSize;
      let mixFunction, mixFunctionAdditive, setIdentity;
      switch (typeName) {
        case "quaternion":
          mixFunction = this._slerp;
          mixFunctionAdditive = this._slerpAdditive;
          setIdentity = this._setAdditiveIdentityQuaternion;
          this.buffer = new Float64Array(valueSize * 6);
          this._workIndex = 5;
          break;
        case "string":
        case "bool":
          mixFunction = this._select;
          mixFunctionAdditive = this._select;
          setIdentity = this._setAdditiveIdentityOther;
          this.buffer = new Array(valueSize * 5);
          break;
        default:
          mixFunction = this._lerp;
          mixFunctionAdditive = this._lerpAdditive;
          setIdentity = this._setAdditiveIdentityNumeric;
          this.buffer = new Float64Array(valueSize * 5);
      }
      this._mixBufferRegion = mixFunction;
      this._mixBufferRegionAdditive = mixFunctionAdditive;
      this._setIdentity = setIdentity;
      this._origIndex = 3;
      this._addIndex = 4;
      this.cumulativeWeight = 0;
      this.cumulativeWeightAdditive = 0;
      this.useCount = 0;
      this.referenceCount = 0;
    }
    accumulate(accuIndex, weight) {
      const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
      let currentWeight = this.cumulativeWeight;
      if (currentWeight === 0) {
        for (let i = 0; i !== stride; ++i) {
          buffer[offset + i] = buffer[i];
        }
        currentWeight = weight;
      } else {
        currentWeight += weight;
        const mix = weight / currentWeight;
        this._mixBufferRegion(buffer, offset, 0, mix, stride);
      }
      this.cumulativeWeight = currentWeight;
    }
    accumulateAdditive(weight) {
      const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
      if (this.cumulativeWeightAdditive === 0) {
        this._setIdentity();
      }
      this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
      this.cumulativeWeightAdditive += weight;
    }
    apply(accuIndex) {
      const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
      this.cumulativeWeight = 0;
      this.cumulativeWeightAdditive = 0;
      if (weight < 1) {
        const originalValueOffset = stride * this._origIndex;
        this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
      }
      if (weightAdditive > 0) {
        this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
      }
      for (let i = stride, e = stride + stride; i !== e; ++i) {
        if (buffer[i] !== buffer[i + stride]) {
          binding.setValue(buffer, offset);
          break;
        }
      }
    }
    saveOriginalState() {
      const binding = this.binding;
      const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
      binding.getValue(buffer, originalValueOffset);
      for (let i = stride, e = originalValueOffset; i !== e; ++i) {
        buffer[i] = buffer[originalValueOffset + i % stride];
      }
      this._setIdentity();
      this.cumulativeWeight = 0;
      this.cumulativeWeightAdditive = 0;
    }
    restoreOriginalState() {
      const originalValueOffset = this.valueSize * 3;
      this.binding.setValue(this.buffer, originalValueOffset);
    }
    _setAdditiveIdentityNumeric() {
      const startIndex = this._addIndex * this.valueSize;
      const endIndex = startIndex + this.valueSize;
      for (let i = startIndex; i < endIndex; i++) {
        this.buffer[i] = 0;
      }
    }
    _setAdditiveIdentityQuaternion() {
      this._setAdditiveIdentityNumeric();
      this.buffer[this._addIndex * this.valueSize + 3] = 1;
    }
    _setAdditiveIdentityOther() {
      const startIndex = this._origIndex * this.valueSize;
      const targetIndex = this._addIndex * this.valueSize;
      for (let i = 0; i < this.valueSize; i++) {
        this.buffer[targetIndex + i] = this.buffer[startIndex + i];
      }
    }
    _select(buffer, dstOffset, srcOffset, t, stride) {
      if (t >= 0.5) {
        for (let i = 0; i !== stride; ++i) {
          buffer[dstOffset + i] = buffer[srcOffset + i];
        }
      }
    }
    _slerp(buffer, dstOffset, srcOffset, t) {
      Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
    }
    _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
      const workOffset = this._workIndex * stride;
      Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
      Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
    }
    _lerp(buffer, dstOffset, srcOffset, t, stride) {
      const s = 1 - t;
      for (let i = 0; i !== stride; ++i) {
        const j = dstOffset + i;
        buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
      }
    }
    _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
      for (let i = 0; i !== stride; ++i) {
        const j = dstOffset + i;
        buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
      }
    }
  };
  var _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
  var _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
  var _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
  var _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
  var _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
  var _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
  var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
  var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
  var _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$");
  var _supportedObjectNames = ["material", "materials", "bones"];
  function Composite(targetGroup, path, optionalParsedPath) {
    const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path, parsedPath);
  }
  Object.assign(Composite.prototype, {
    getValue: function(array, offset) {
      this.bind();
      const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
      if (binding !== void 0)
        binding.getValue(array, offset);
    },
    setValue: function(array, offset) {
      const bindings = this._bindings;
      for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
        bindings[i].setValue(array, offset);
      }
    },
    bind: function() {
      const bindings = this._bindings;
      for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
        bindings[i].bind();
      }
    },
    unbind: function() {
      const bindings = this._bindings;
      for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
        bindings[i].unbind();
      }
    }
  });
  function PropertyBinding(rootNode, path, parsedPath) {
    this.path = path;
    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
    this.rootNode = rootNode;
  }
  Object.assign(PropertyBinding, {
    Composite,
    create: function(root, path, parsedPath) {
      if (!(root && root.isAnimationObjectGroup)) {
        return new PropertyBinding(root, path, parsedPath);
      } else {
        return new PropertyBinding.Composite(root, path, parsedPath);
      }
    },
    sanitizeNodeName: function(name) {
      return name.replace(/\s/g, "_").replace(_reservedRe, "");
    },
    parseTrackName: function(trackName) {
      const matches = _trackRe.exec(trackName);
      if (!matches) {
        throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
      }
      const results = {
        nodeName: matches[2],
        objectName: matches[3],
        objectIndex: matches[4],
        propertyName: matches[5],
        propertyIndex: matches[6]
      };
      const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
      if (lastDot !== void 0 && lastDot !== -1) {
        const objectName = results.nodeName.substring(lastDot + 1);
        if (_supportedObjectNames.indexOf(objectName) !== -1) {
          results.nodeName = results.nodeName.substring(0, lastDot);
          results.objectName = objectName;
        }
      }
      if (results.propertyName === null || results.propertyName.length === 0) {
        throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
      }
      return results;
    },
    findNode: function(root, nodeName) {
      if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
        return root;
      }
      if (root.skeleton) {
        const bone = root.skeleton.getBoneByName(nodeName);
        if (bone !== void 0) {
          return bone;
        }
      }
      if (root.children) {
        const searchNodeSubtree = function(children) {
          for (let i = 0; i < children.length; i++) {
            const childNode = children[i];
            if (childNode.name === nodeName || childNode.uuid === nodeName) {
              return childNode;
            }
            const result = searchNodeSubtree(childNode.children);
            if (result)
              return result;
          }
          return null;
        };
        const subTreeNode = searchNodeSubtree(root.children);
        if (subTreeNode) {
          return subTreeNode;
        }
      }
      return null;
    }
  });
  Object.assign(PropertyBinding.prototype, {
    _getValue_unavailable: function() {
    },
    _setValue_unavailable: function() {
    },
    BindingType: {
      Direct: 0,
      EntireArray: 1,
      ArrayElement: 2,
      HasFromToArray: 3
    },
    Versioning: {
      None: 0,
      NeedsUpdate: 1,
      MatrixWorldNeedsUpdate: 2
    },
    GetterByBindingType: [
      function getValue_direct(buffer, offset) {
        buffer[offset] = this.node[this.propertyName];
      },
      function getValue_array(buffer, offset) {
        const source = this.resolvedProperty;
        for (let i = 0, n = source.length; i !== n; ++i) {
          buffer[offset++] = source[i];
        }
      },
      function getValue_arrayElement(buffer, offset) {
        buffer[offset] = this.resolvedProperty[this.propertyIndex];
      },
      function getValue_toArray(buffer, offset) {
        this.resolvedProperty.toArray(buffer, offset);
      }
    ],
    SetterByBindingTypeAndVersioning: [
      [
        function setValue_direct(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
        },
        function setValue_direct_setNeedsUpdate(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
          this.targetObject.needsUpdate = true;
        },
        function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
      ],
      [
        function setValue_array(buffer, offset) {
          const dest = this.resolvedProperty;
          for (let i = 0, n = dest.length; i !== n; ++i) {
            dest[i] = buffer[offset++];
          }
        },
        function setValue_array_setNeedsUpdate(buffer, offset) {
          const dest = this.resolvedProperty;
          for (let i = 0, n = dest.length; i !== n; ++i) {
            dest[i] = buffer[offset++];
          }
          this.targetObject.needsUpdate = true;
        },
        function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
          const dest = this.resolvedProperty;
          for (let i = 0, n = dest.length; i !== n; ++i) {
            dest[i] = buffer[offset++];
          }
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
      ],
      [
        function setValue_arrayElement(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
        },
        function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
          this.targetObject.needsUpdate = true;
        },
        function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
      ],
      [
        function setValue_fromArray(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
        },
        function setValue_fromArray_setNeedsUpdate(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
          this.targetObject.needsUpdate = true;
        },
        function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
      ]
    ],
    getValue: function getValue_unbound(targetArray, offset) {
      this.bind();
      this.getValue(targetArray, offset);
    },
    setValue: function getValue_unbound2(sourceArray, offset) {
      this.bind();
      this.setValue(sourceArray, offset);
    },
    bind: function() {
      let targetObject = this.node;
      const parsedPath = this.parsedPath;
      const objectName = parsedPath.objectName;
      const propertyName = parsedPath.propertyName;
      let propertyIndex = parsedPath.propertyIndex;
      if (!targetObject) {
        targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
        this.node = targetObject;
      }
      this.getValue = this._getValue_unavailable;
      this.setValue = this._setValue_unavailable;
      if (!targetObject) {
        console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
        return;
      }
      if (objectName) {
        let objectIndex = parsedPath.objectIndex;
        switch (objectName) {
          case "materials":
            if (!targetObject.material) {
              console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
              return;
            }
            if (!targetObject.material.materials) {
              console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
              return;
            }
            targetObject = targetObject.material.materials;
            break;
          case "bones":
            if (!targetObject.skeleton) {
              console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
              return;
            }
            targetObject = targetObject.skeleton.bones;
            for (let i = 0; i < targetObject.length; i++) {
              if (targetObject[i].name === objectIndex) {
                objectIndex = i;
                break;
              }
            }
            break;
          default:
            if (targetObject[objectName] === void 0) {
              console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
              return;
            }
            targetObject = targetObject[objectName];
        }
        if (objectIndex !== void 0) {
          if (targetObject[objectIndex] === void 0) {
            console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
            return;
          }
          targetObject = targetObject[objectIndex];
        }
      }
      const nodeProperty = targetObject[propertyName];
      if (nodeProperty === void 0) {
        const nodeName = parsedPath.nodeName;
        console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
        return;
      }
      let versioning = this.Versioning.None;
      this.targetObject = targetObject;
      if (targetObject.needsUpdate !== void 0) {
        versioning = this.Versioning.NeedsUpdate;
      } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
        versioning = this.Versioning.MatrixWorldNeedsUpdate;
      }
      let bindingType = this.BindingType.Direct;
      if (propertyIndex !== void 0) {
        if (propertyName === "morphTargetInfluences") {
          if (!targetObject.geometry) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
            return;
          }
          if (targetObject.geometry.isBufferGeometry) {
            if (!targetObject.geometry.morphAttributes) {
              console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
              return;
            }
            if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
              propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
            }
          } else {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
            return;
          }
        }
        bindingType = this.BindingType.ArrayElement;
        this.resolvedProperty = nodeProperty;
        this.propertyIndex = propertyIndex;
      } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
        bindingType = this.BindingType.HasFromToArray;
        this.resolvedProperty = nodeProperty;
      } else if (Array.isArray(nodeProperty)) {
        bindingType = this.BindingType.EntireArray;
        this.resolvedProperty = nodeProperty;
      } else {
        this.propertyName = propertyName;
      }
      this.getValue = this.GetterByBindingType[bindingType];
      this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
    },
    unbind: function() {
      this.node = null;
      this.getValue = this._getValue_unbound;
      this.setValue = this._setValue_unbound;
    }
  });
  Object.assign(PropertyBinding.prototype, {
    _getValue_unbound: PropertyBinding.prototype.getValue,
    _setValue_unbound: PropertyBinding.prototype.setValue
  });
  var AnimationObjectGroup = class {
    constructor() {
      this.uuid = MathUtils.generateUUID();
      this._objects = Array.prototype.slice.call(arguments);
      this.nCachedObjects_ = 0;
      const indices = {};
      this._indicesByUUID = indices;
      for (let i = 0, n = arguments.length; i !== n; ++i) {
        indices[arguments[i].uuid] = i;
      }
      this._paths = [];
      this._parsedPaths = [];
      this._bindings = [];
      this._bindingsIndicesByPath = {};
      const scope = this;
      this.stats = {
        objects: {
          get total() {
            return scope._objects.length;
          },
          get inUse() {
            return this.total - scope.nCachedObjects_;
          }
        },
        get bindingsPerObject() {
          return scope._bindings.length;
        }
      };
    }
    add() {
      const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
      let knownObject = void 0, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
      for (let i = 0, n = arguments.length; i !== n; ++i) {
        const object = arguments[i], uuid = object.uuid;
        let index = indicesByUUID[uuid];
        if (index === void 0) {
          index = nObjects++;
          indicesByUUID[uuid] = index;
          objects.push(object);
          for (let j = 0, m = nBindings; j !== m; ++j) {
            bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
          }
        } else if (index < nCachedObjects) {
          knownObject = objects[index];
          const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
          indicesByUUID[lastCachedObject.uuid] = index;
          objects[index] = lastCachedObject;
          indicesByUUID[uuid] = firstActiveIndex;
          objects[firstActiveIndex] = object;
          for (let j = 0, m = nBindings; j !== m; ++j) {
            const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex];
            let binding = bindingsForPath[index];
            bindingsForPath[index] = lastCached;
            if (binding === void 0) {
              binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
            }
            bindingsForPath[firstActiveIndex] = binding;
          }
        } else if (objects[index] !== knownObject) {
          console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
        }
      }
      this.nCachedObjects_ = nCachedObjects;
    }
    remove() {
      const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
      let nCachedObjects = this.nCachedObjects_;
      for (let i = 0, n = arguments.length; i !== n; ++i) {
        const object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
        if (index !== void 0 && index >= nCachedObjects) {
          const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
          indicesByUUID[firstActiveObject.uuid] = index;
          objects[index] = firstActiveObject;
          indicesByUUID[uuid] = lastCachedIndex;
          objects[lastCachedIndex] = object;
          for (let j = 0, m = nBindings; j !== m; ++j) {
            const bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
            bindingsForPath[index] = firstActive;
            bindingsForPath[lastCachedIndex] = binding;
          }
        }
      }
      this.nCachedObjects_ = nCachedObjects;
    }
    uncache() {
      const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
      let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
      for (let i = 0, n = arguments.length; i !== n; ++i) {
        const object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
        if (index !== void 0) {
          delete indicesByUUID[uuid];
          if (index < nCachedObjects) {
            const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
            indicesByUUID[lastCachedObject.uuid] = index;
            objects[index] = lastCachedObject;
            indicesByUUID[lastObject.uuid] = firstActiveIndex;
            objects[firstActiveIndex] = lastObject;
            objects.pop();
            for (let j = 0, m = nBindings; j !== m; ++j) {
              const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
              bindingsForPath[index] = lastCached;
              bindingsForPath[firstActiveIndex] = last;
              bindingsForPath.pop();
            }
          } else {
            const lastIndex = --nObjects, lastObject = objects[lastIndex];
            if (lastIndex > 0) {
              indicesByUUID[lastObject.uuid] = index;
            }
            objects[index] = lastObject;
            objects.pop();
            for (let j = 0, m = nBindings; j !== m; ++j) {
              const bindingsForPath = bindings[j];
              bindingsForPath[index] = bindingsForPath[lastIndex];
              bindingsForPath.pop();
            }
          }
        }
      }
      this.nCachedObjects_ = nCachedObjects;
    }
    subscribe_(path, parsedPath) {
      const indicesByPath = this._bindingsIndicesByPath;
      let index = indicesByPath[path];
      const bindings = this._bindings;
      if (index !== void 0)
        return bindings[index];
      const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
      index = bindings.length;
      indicesByPath[path] = index;
      paths.push(path);
      parsedPaths.push(parsedPath);
      bindings.push(bindingsForPath);
      for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {
        const object = objects[i];
        bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
      }
      return bindingsForPath;
    }
    unsubscribe_(path) {
      const indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
      if (index !== void 0) {
        const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
        indicesByPath[lastBindingsPath] = index;
        bindings[index] = lastBindings;
        bindings.pop();
        parsedPaths[index] = parsedPaths[lastBindingsIndex];
        parsedPaths.pop();
        paths[index] = paths[lastBindingsIndex];
        paths.pop();
      }
    }
  };
  AnimationObjectGroup.prototype.isAnimationObjectGroup = true;
  var AnimationAction = class {
    constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
      this._mixer = mixer;
      this._clip = clip;
      this._localRoot = localRoot;
      this.blendMode = blendMode;
      const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
      const interpolantSettings = {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding
      };
      for (let i = 0; i !== nTracks; ++i) {
        const interpolant = tracks[i].createInterpolant(null);
        interpolants[i] = interpolant;
        interpolant.settings = interpolantSettings;
      }
      this._interpolantSettings = interpolantSettings;
      this._interpolants = interpolants;
      this._propertyBindings = new Array(nTracks);
      this._cacheIndex = null;
      this._byClipCacheIndex = null;
      this._timeScaleInterpolant = null;
      this._weightInterpolant = null;
      this.loop = LoopRepeat;
      this._loopCount = -1;
      this._startTime = null;
      this.time = 0;
      this.timeScale = 1;
      this._effectiveTimeScale = 1;
      this.weight = 1;
      this._effectiveWeight = 1;
      this.repetitions = Infinity;
      this.paused = false;
      this.enabled = true;
      this.clampWhenFinished = false;
      this.zeroSlopeAtStart = true;
      this.zeroSlopeAtEnd = true;
    }
    play() {
      this._mixer._activateAction(this);
      return this;
    }
    stop() {
      this._mixer._deactivateAction(this);
      return this.reset();
    }
    reset() {
      this.paused = false;
      this.enabled = true;
      this.time = 0;
      this._loopCount = -1;
      this._startTime = null;
      return this.stopFading().stopWarping();
    }
    isRunning() {
      return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    }
    isScheduled() {
      return this._mixer._isActiveAction(this);
    }
    startAt(time) {
      this._startTime = time;
      return this;
    }
    setLoop(mode, repetitions) {
      this.loop = mode;
      this.repetitions = repetitions;
      return this;
    }
    setEffectiveWeight(weight) {
      this.weight = weight;
      this._effectiveWeight = this.enabled ? weight : 0;
      return this.stopFading();
    }
    getEffectiveWeight() {
      return this._effectiveWeight;
    }
    fadeIn(duration) {
      return this._scheduleFading(duration, 0, 1);
    }
    fadeOut(duration) {
      return this._scheduleFading(duration, 1, 0);
    }
    crossFadeFrom(fadeOutAction, duration, warp) {
      fadeOutAction.fadeOut(duration);
      this.fadeIn(duration);
      if (warp) {
        const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
        fadeOutAction.warp(1, startEndRatio, duration);
        this.warp(endStartRatio, 1, duration);
      }
      return this;
    }
    crossFadeTo(fadeInAction, duration, warp) {
      return fadeInAction.crossFadeFrom(this, duration, warp);
    }
    stopFading() {
      const weightInterpolant = this._weightInterpolant;
      if (weightInterpolant !== null) {
        this._weightInterpolant = null;
        this._mixer._takeBackControlInterpolant(weightInterpolant);
      }
      return this;
    }
    setEffectiveTimeScale(timeScale) {
      this.timeScale = timeScale;
      this._effectiveTimeScale = this.paused ? 0 : timeScale;
      return this.stopWarping();
    }
    getEffectiveTimeScale() {
      return this._effectiveTimeScale;
    }
    setDuration(duration) {
      this.timeScale = this._clip.duration / duration;
      return this.stopWarping();
    }
    syncWith(action) {
      this.time = action.time;
      this.timeScale = action.timeScale;
      return this.stopWarping();
    }
    halt(duration) {
      return this.warp(this._effectiveTimeScale, 0, duration);
    }
    warp(startTimeScale, endTimeScale, duration) {
      const mixer = this._mixer, now2 = mixer.time, timeScale = this.timeScale;
      let interpolant = this._timeScaleInterpolant;
      if (interpolant === null) {
        interpolant = mixer._lendControlInterpolant();
        this._timeScaleInterpolant = interpolant;
      }
      const times = interpolant.parameterPositions, values = interpolant.sampleValues;
      times[0] = now2;
      times[1] = now2 + duration;
      values[0] = startTimeScale / timeScale;
      values[1] = endTimeScale / timeScale;
      return this;
    }
    stopWarping() {
      const timeScaleInterpolant = this._timeScaleInterpolant;
      if (timeScaleInterpolant !== null) {
        this._timeScaleInterpolant = null;
        this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
      }
      return this;
    }
    getMixer() {
      return this._mixer;
    }
    getClip() {
      return this._clip;
    }
    getRoot() {
      return this._localRoot || this._mixer._root;
    }
    _update(time, deltaTime, timeDirection, accuIndex) {
      if (!this.enabled) {
        this._updateWeight(time);
        return;
      }
      const startTime = this._startTime;
      if (startTime !== null) {
        const timeRunning = (time - startTime) * timeDirection;
        if (timeRunning < 0 || timeDirection === 0) {
          return;
        }
        this._startTime = null;
        deltaTime = timeDirection * timeRunning;
      }
      deltaTime *= this._updateTimeScale(time);
      const clipTime = this._updateTime(deltaTime);
      const weight = this._updateWeight(time);
      if (weight > 0) {
        const interpolants = this._interpolants;
        const propertyMixers = this._propertyBindings;
        switch (this.blendMode) {
          case AdditiveAnimationBlendMode:
            for (let j = 0, m = interpolants.length; j !== m; ++j) {
              interpolants[j].evaluate(clipTime);
              propertyMixers[j].accumulateAdditive(weight);
            }
            break;
          case NormalAnimationBlendMode:
          default:
            for (let j = 0, m = interpolants.length; j !== m; ++j) {
              interpolants[j].evaluate(clipTime);
              propertyMixers[j].accumulate(accuIndex, weight);
            }
        }
      }
    }
    _updateWeight(time) {
      let weight = 0;
      if (this.enabled) {
        weight = this.weight;
        const interpolant = this._weightInterpolant;
        if (interpolant !== null) {
          const interpolantValue = interpolant.evaluate(time)[0];
          weight *= interpolantValue;
          if (time > interpolant.parameterPositions[1]) {
            this.stopFading();
            if (interpolantValue === 0) {
              this.enabled = false;
            }
          }
        }
      }
      this._effectiveWeight = weight;
      return weight;
    }
    _updateTimeScale(time) {
      let timeScale = 0;
      if (!this.paused) {
        timeScale = this.timeScale;
        const interpolant = this._timeScaleInterpolant;
        if (interpolant !== null) {
          const interpolantValue = interpolant.evaluate(time)[0];
          timeScale *= interpolantValue;
          if (time > interpolant.parameterPositions[1]) {
            this.stopWarping();
            if (timeScale === 0) {
              this.paused = true;
            } else {
              this.timeScale = timeScale;
            }
          }
        }
      }
      this._effectiveTimeScale = timeScale;
      return timeScale;
    }
    _updateTime(deltaTime) {
      const duration = this._clip.duration;
      const loop = this.loop;
      let time = this.time + deltaTime;
      let loopCount = this._loopCount;
      const pingPong = loop === LoopPingPong;
      if (deltaTime === 0) {
        if (loopCount === -1)
          return time;
        return pingPong && (loopCount & 1) === 1 ? duration - time : time;
      }
      if (loop === LoopOnce) {
        if (loopCount === -1) {
          this._loopCount = 0;
          this._setEndings(true, true, false);
        }
        handle_stop: {
          if (time >= duration) {
            time = duration;
          } else if (time < 0) {
            time = 0;
          } else {
            this.time = time;
            break handle_stop;
          }
          if (this.clampWhenFinished)
            this.paused = true;
          else
            this.enabled = false;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: deltaTime < 0 ? -1 : 1
          });
        }
      } else {
        if (loopCount === -1) {
          if (deltaTime >= 0) {
            loopCount = 0;
            this._setEndings(true, this.repetitions === 0, pingPong);
          } else {
            this._setEndings(this.repetitions === 0, true, pingPong);
          }
        }
        if (time >= duration || time < 0) {
          const loopDelta = Math.floor(time / duration);
          time -= duration * loopDelta;
          loopCount += Math.abs(loopDelta);
          const pending = this.repetitions - loopCount;
          if (pending <= 0) {
            if (this.clampWhenFinished)
              this.paused = true;
            else
              this.enabled = false;
            time = deltaTime > 0 ? duration : 0;
            this.time = time;
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: deltaTime > 0 ? 1 : -1
            });
          } else {
            if (pending === 1) {
              const atStart = deltaTime < 0;
              this._setEndings(atStart, !atStart, pingPong);
            } else {
              this._setEndings(false, false, pingPong);
            }
            this._loopCount = loopCount;
            this.time = time;
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta
            });
          }
        } else {
          this.time = time;
        }
        if (pingPong && (loopCount & 1) === 1) {
          return duration - time;
        }
      }
      return time;
    }
    _setEndings(atStart, atEnd, pingPong) {
      const settings = this._interpolantSettings;
      if (pingPong) {
        settings.endingStart = ZeroSlopeEnding;
        settings.endingEnd = ZeroSlopeEnding;
      } else {
        if (atStart) {
          settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
        } else {
          settings.endingStart = WrapAroundEnding;
        }
        if (atEnd) {
          settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
        } else {
          settings.endingEnd = WrapAroundEnding;
        }
      }
    }
    _scheduleFading(duration, weightNow, weightThen) {
      const mixer = this._mixer, now2 = mixer.time;
      let interpolant = this._weightInterpolant;
      if (interpolant === null) {
        interpolant = mixer._lendControlInterpolant();
        this._weightInterpolant = interpolant;
      }
      const times = interpolant.parameterPositions, values = interpolant.sampleValues;
      times[0] = now2;
      values[0] = weightNow;
      times[1] = now2 + duration;
      values[1] = weightThen;
      return this;
    }
  };
  var AnimationMixer = class extends EventDispatcher {
    constructor(root) {
      super();
      this._root = root;
      this._initMemoryManager();
      this._accuIndex = 0;
      this.time = 0;
      this.timeScale = 1;
    }
    _bindAction(action, prototypeAction) {
      const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
      let bindingsByName = bindingsByRoot[rootUuid];
      if (bindingsByName === void 0) {
        bindingsByName = {};
        bindingsByRoot[rootUuid] = bindingsByName;
      }
      for (let i = 0; i !== nTracks; ++i) {
        const track = tracks[i], trackName = track.name;
        let binding = bindingsByName[trackName];
        if (binding !== void 0) {
          bindings[i] = binding;
        } else {
          binding = bindings[i];
          if (binding !== void 0) {
            if (binding._cacheIndex === null) {
              ++binding.referenceCount;
              this._addInactiveBinding(binding, rootUuid, trackName);
            }
            continue;
          }
          const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
          binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
          ++binding.referenceCount;
          this._addInactiveBinding(binding, rootUuid, trackName);
          bindings[i] = binding;
        }
        interpolants[i].resultBuffer = binding.buffer;
      }
    }
    _activateAction(action) {
      if (!this._isActiveAction(action)) {
        if (action._cacheIndex === null) {
          const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
          this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
          this._addInactiveAction(action, clipUuid, rootUuid);
        }
        const bindings = action._propertyBindings;
        for (let i = 0, n = bindings.length; i !== n; ++i) {
          const binding = bindings[i];
          if (binding.useCount++ === 0) {
            this._lendBinding(binding);
            binding.saveOriginalState();
          }
        }
        this._lendAction(action);
      }
    }
    _deactivateAction(action) {
      if (this._isActiveAction(action)) {
        const bindings = action._propertyBindings;
        for (let i = 0, n = bindings.length; i !== n; ++i) {
          const binding = bindings[i];
          if (--binding.useCount === 0) {
            binding.restoreOriginalState();
            this._takeBackBinding(binding);
          }
        }
        this._takeBackAction(action);
      }
    }
    _initMemoryManager() {
      this._actions = [];
      this._nActiveActions = 0;
      this._actionsByClip = {};
      this._bindings = [];
      this._nActiveBindings = 0;
      this._bindingsByRootAndName = {};
      this._controlInterpolants = [];
      this._nActiveControlInterpolants = 0;
      const scope = this;
      this.stats = {
        actions: {
          get total() {
            return scope._actions.length;
          },
          get inUse() {
            return scope._nActiveActions;
          }
        },
        bindings: {
          get total() {
            return scope._bindings.length;
          },
          get inUse() {
            return scope._nActiveBindings;
          }
        },
        controlInterpolants: {
          get total() {
            return scope._controlInterpolants.length;
          },
          get inUse() {
            return scope._nActiveControlInterpolants;
          }
        }
      };
    }
    _isActiveAction(action) {
      const index = action._cacheIndex;
      return index !== null && index < this._nActiveActions;
    }
    _addInactiveAction(action, clipUuid, rootUuid) {
      const actions = this._actions, actionsByClip = this._actionsByClip;
      let actionsForClip = actionsByClip[clipUuid];
      if (actionsForClip === void 0) {
        actionsForClip = {
          knownActions: [action],
          actionByRoot: {}
        };
        action._byClipCacheIndex = 0;
        actionsByClip[clipUuid] = actionsForClip;
      } else {
        const knownActions = actionsForClip.knownActions;
        action._byClipCacheIndex = knownActions.length;
        knownActions.push(action);
      }
      action._cacheIndex = actions.length;
      actions.push(action);
      actionsForClip.actionByRoot[rootUuid] = action;
    }
    _removeInactiveAction(action) {
      const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
      lastInactiveAction._cacheIndex = cacheIndex;
      actions[cacheIndex] = lastInactiveAction;
      actions.pop();
      action._cacheIndex = null;
      const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
      lastKnownAction._byClipCacheIndex = byClipCacheIndex;
      knownActionsForClip[byClipCacheIndex] = lastKnownAction;
      knownActionsForClip.pop();
      action._byClipCacheIndex = null;
      const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
      delete actionByRoot[rootUuid];
      if (knownActionsForClip.length === 0) {
        delete actionsByClip[clipUuid];
      }
      this._removeInactiveBindingsForAction(action);
    }
    _removeInactiveBindingsForAction(action) {
      const bindings = action._propertyBindings;
      for (let i = 0, n = bindings.length; i !== n; ++i) {
        const binding = bindings[i];
        if (--binding.referenceCount === 0) {
          this._removeInactiveBinding(binding);
        }
      }
    }
    _lendAction(action) {
      const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
      action._cacheIndex = lastActiveIndex;
      actions[lastActiveIndex] = action;
      firstInactiveAction._cacheIndex = prevIndex;
      actions[prevIndex] = firstInactiveAction;
    }
    _takeBackAction(action) {
      const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
      action._cacheIndex = firstInactiveIndex;
      actions[firstInactiveIndex] = action;
      lastActiveAction._cacheIndex = prevIndex;
      actions[prevIndex] = lastActiveAction;
    }
    _addInactiveBinding(binding, rootUuid, trackName) {
      const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
      let bindingByName = bindingsByRoot[rootUuid];
      if (bindingByName === void 0) {
        bindingByName = {};
        bindingsByRoot[rootUuid] = bindingByName;
      }
      bindingByName[trackName] = binding;
      binding._cacheIndex = bindings.length;
      bindings.push(binding);
    }
    _removeInactiveBinding(binding) {
      const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
      lastInactiveBinding._cacheIndex = cacheIndex;
      bindings[cacheIndex] = lastInactiveBinding;
      bindings.pop();
      delete bindingByName[trackName];
      if (Object.keys(bindingByName).length === 0) {
        delete bindingsByRoot[rootUuid];
      }
    }
    _lendBinding(binding) {
      const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
      binding._cacheIndex = lastActiveIndex;
      bindings[lastActiveIndex] = binding;
      firstInactiveBinding._cacheIndex = prevIndex;
      bindings[prevIndex] = firstInactiveBinding;
    }
    _takeBackBinding(binding) {
      const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
      binding._cacheIndex = firstInactiveIndex;
      bindings[firstInactiveIndex] = binding;
      lastActiveBinding._cacheIndex = prevIndex;
      bindings[prevIndex] = lastActiveBinding;
    }
    _lendControlInterpolant() {
      const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
      let interpolant = interpolants[lastActiveIndex];
      if (interpolant === void 0) {
        interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
        interpolant.__cacheIndex = lastActiveIndex;
        interpolants[lastActiveIndex] = interpolant;
      }
      return interpolant;
    }
    _takeBackControlInterpolant(interpolant) {
      const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
      interpolant.__cacheIndex = firstInactiveIndex;
      interpolants[firstInactiveIndex] = interpolant;
      lastActiveInterpolant.__cacheIndex = prevIndex;
      interpolants[prevIndex] = lastActiveInterpolant;
    }
    clipAction(clip, optionalRoot, blendMode) {
      const root = optionalRoot || this._root, rootUuid = root.uuid;
      let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
      const clipUuid = clipObject !== null ? clipObject.uuid : clip;
      const actionsForClip = this._actionsByClip[clipUuid];
      let prototypeAction = null;
      if (blendMode === void 0) {
        if (clipObject !== null) {
          blendMode = clipObject.blendMode;
        } else {
          blendMode = NormalAnimationBlendMode;
        }
      }
      if (actionsForClip !== void 0) {
        const existingAction = actionsForClip.actionByRoot[rootUuid];
        if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
          return existingAction;
        }
        prototypeAction = actionsForClip.knownActions[0];
        if (clipObject === null)
          clipObject = prototypeAction._clip;
      }
      if (clipObject === null)
        return null;
      const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
      this._bindAction(newAction, prototypeAction);
      this._addInactiveAction(newAction, clipUuid, rootUuid);
      return newAction;
    }
    existingAction(clip, optionalRoot) {
      const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
      if (actionsForClip !== void 0) {
        return actionsForClip.actionByRoot[rootUuid] || null;
      }
      return null;
    }
    stopAllAction() {
      const actions = this._actions, nActions = this._nActiveActions;
      for (let i = nActions - 1; i >= 0; --i) {
        actions[i].stop();
      }
      return this;
    }
    update(deltaTime) {
      deltaTime *= this.timeScale;
      const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
      for (let i = 0; i !== nActions; ++i) {
        const action = actions[i];
        action._update(time, deltaTime, timeDirection, accuIndex);
      }
      const bindings = this._bindings, nBindings = this._nActiveBindings;
      for (let i = 0; i !== nBindings; ++i) {
        bindings[i].apply(accuIndex);
      }
      return this;
    }
    setTime(timeInSeconds) {
      this.time = 0;
      for (let i = 0; i < this._actions.length; i++) {
        this._actions[i].time = 0;
      }
      return this.update(timeInSeconds);
    }
    getRoot() {
      return this._root;
    }
    uncacheClip(clip) {
      const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
      if (actionsForClip !== void 0) {
        const actionsToRemove = actionsForClip.knownActions;
        for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
          const action = actionsToRemove[i];
          this._deactivateAction(action);
          const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
          action._cacheIndex = null;
          action._byClipCacheIndex = null;
          lastInactiveAction._cacheIndex = cacheIndex;
          actions[cacheIndex] = lastInactiveAction;
          actions.pop();
          this._removeInactiveBindingsForAction(action);
        }
        delete actionsByClip[clipUuid];
      }
    }
    uncacheRoot(root) {
      const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
      for (const clipUuid in actionsByClip) {
        const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
        if (action !== void 0) {
          this._deactivateAction(action);
          this._removeInactiveAction(action);
        }
      }
      const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
      if (bindingByName !== void 0) {
        for (const trackName in bindingByName) {
          const binding = bindingByName[trackName];
          binding.restoreOriginalState();
          this._removeInactiveBinding(binding);
        }
      }
    }
    uncacheAction(clip, optionalRoot) {
      const action = this.existingAction(clip, optionalRoot);
      if (action !== null) {
        this._deactivateAction(action);
        this._removeInactiveAction(action);
      }
    }
  };
  AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
  var Uniform = class {
    constructor(value) {
      if (typeof value === "string") {
        console.warn("THREE.Uniform: Type parameter is no longer needed.");
        value = arguments[1];
      }
      this.value = value;
    }
    clone() {
      return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
    }
  };
  function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
    InterleavedBuffer.call(this, array, stride);
    this.meshPerAttribute = meshPerAttribute || 1;
  }
  InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
    constructor: InstancedInterleavedBuffer,
    isInstancedInterleavedBuffer: true,
    copy: function(source) {
      InterleavedBuffer.prototype.copy.call(this, source);
      this.meshPerAttribute = source.meshPerAttribute;
      return this;
    },
    clone: function(data) {
      const ib = InterleavedBuffer.prototype.clone.call(this, data);
      ib.meshPerAttribute = this.meshPerAttribute;
      return ib;
    },
    toJSON: function(data) {
      const json = InterleavedBuffer.prototype.toJSON.call(this, data);
      json.isInstancedInterleavedBuffer = true;
      json.meshPerAttribute = this.meshPerAttribute;
      return json;
    }
  });
  function GLBufferAttribute(buffer, type, itemSize, elementSize, count) {
    this.buffer = buffer;
    this.type = type;
    this.itemSize = itemSize;
    this.elementSize = elementSize;
    this.count = count;
    this.version = 0;
  }
  Object.defineProperty(GLBufferAttribute.prototype, "needsUpdate", {
    set: function(value) {
      if (value === true)
        this.version++;
    }
  });
  Object.assign(GLBufferAttribute.prototype, {
    isGLBufferAttribute: true,
    setBuffer: function(buffer) {
      this.buffer = buffer;
      return this;
    },
    setType: function(type, elementSize) {
      this.type = type;
      this.elementSize = elementSize;
      return this;
    },
    setItemSize: function(itemSize) {
      this.itemSize = itemSize;
      return this;
    },
    setCount: function(count) {
      this.count = count;
      return this;
    }
  });
  function Raycaster(origin, direction, near = 0, far = Infinity) {
    this.ray = new Ray(origin, direction);
    this.near = near;
    this.far = far;
    this.camera = null;
    this.layers = new Layers();
    this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
    Object.defineProperties(this.params, {
      PointCloud: {
        get: function() {
          console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
          return this.Points;
        }
      }
    });
  }
  function ascSort(a, b2) {
    return a.distance - b2.distance;
  }
  function intersectObject(object, raycaster2, intersects2, recursive) {
    if (object.layers.test(raycaster2.layers)) {
      object.raycast(raycaster2, intersects2);
    }
    if (recursive === true) {
      const children = object.children;
      for (let i = 0, l = children.length; i < l; i++) {
        intersectObject(children[i], raycaster2, intersects2, true);
      }
    }
  }
  Object.assign(Raycaster.prototype, {
    set: function(origin, direction) {
      this.ray.set(origin, direction);
    },
    setFromCamera: function(coords, camera) {
      if (camera && camera.isPerspectiveCamera) {
        this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
        this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
        this.camera = camera;
      } else if (camera && camera.isOrthographicCamera) {
        this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
        this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
        this.camera = camera;
      } else {
        console.error("THREE.Raycaster: Unsupported camera type: " + camera.type);
      }
    },
    intersectObject: function(object, recursive = false, intersects2 = []) {
      intersectObject(object, this, intersects2, recursive);
      intersects2.sort(ascSort);
      return intersects2;
    },
    intersectObjects: function(objects, recursive = false, intersects2 = []) {
      for (let i = 0, l = objects.length; i < l; i++) {
        intersectObject(objects[i], this, intersects2, recursive);
      }
      intersects2.sort(ascSort);
      return intersects2;
    }
  });
  var Spherical = class {
    constructor(radius = 1, phi = 0, theta = 0) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      return this;
    }
    set(radius, phi, theta) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      return this;
    }
    copy(other) {
      this.radius = other.radius;
      this.phi = other.phi;
      this.theta = other.theta;
      return this;
    }
    makeSafe() {
      const EPS = 1e-6;
      this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
      return this;
    }
    setFromVector3(v) {
      return this.setFromCartesianCoords(v.x, v.y, v.z);
    }
    setFromCartesianCoords(x, y, z) {
      this.radius = Math.sqrt(x * x + y * y + z * z);
      if (this.radius === 0) {
        this.theta = 0;
        this.phi = 0;
      } else {
        this.theta = Math.atan2(x, z);
        this.phi = Math.acos(MathUtils.clamp(y / this.radius, -1, 1));
      }
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var _vector$4 = /* @__PURE__ */ new Vector2();
  var Box2 = class {
    constructor(min = new Vector2(Infinity, Infinity), max = new Vector2(-Infinity, -Infinity)) {
      this.min = min;
      this.max = max;
    }
    set(min, max) {
      this.min.copy(min);
      this.max.copy(max);
      return this;
    }
    setFromPoints(points) {
      this.makeEmpty();
      for (let i = 0, il = points.length; i < il; i++) {
        this.expandByPoint(points[i]);
      }
      return this;
    }
    setFromCenterAndSize(center, size2) {
      const halfSize = _vector$4.copy(size2).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(box) {
      this.min.copy(box.min);
      this.max.copy(box.max);
      return this;
    }
    makeEmpty() {
      this.min.x = this.min.y = Infinity;
      this.max.x = this.max.y = -Infinity;
      return this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y;
    }
    getCenter(target) {
      if (target === void 0) {
        console.warn("THREE.Box2: .getCenter() target is now required");
        target = new Vector2();
      }
      return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(target) {
      if (target === void 0) {
        console.warn("THREE.Box2: .getSize() target is now required");
        target = new Vector2();
      }
      return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
    }
    expandByPoint(point) {
      this.min.min(point);
      this.max.max(point);
      return this;
    }
    expandByVector(vector) {
      this.min.sub(vector);
      this.max.add(vector);
      return this;
    }
    expandByScalar(scalar) {
      this.min.addScalar(-scalar);
      this.max.addScalar(scalar);
      return this;
    }
    containsPoint(point) {
      return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
    }
    containsBox(box) {
      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
    }
    getParameter(point, target) {
      if (target === void 0) {
        console.warn("THREE.Box2: .getParameter() target is now required");
        target = new Vector2();
      }
      return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
    }
    intersectsBox(box) {
      return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
    }
    clampPoint(point, target) {
      if (target === void 0) {
        console.warn("THREE.Box2: .clampPoint() target is now required");
        target = new Vector2();
      }
      return target.copy(point).clamp(this.min, this.max);
    }
    distanceToPoint(point) {
      const clampedPoint = _vector$4.copy(point).clamp(this.min, this.max);
      return clampedPoint.sub(point).length();
    }
    intersect(box) {
      this.min.max(box.min);
      this.max.min(box.max);
      return this;
    }
    union(box) {
      this.min.min(box.min);
      this.max.max(box.max);
      return this;
    }
    translate(offset) {
      this.min.add(offset);
      this.max.add(offset);
      return this;
    }
    equals(box) {
      return box.min.equals(this.min) && box.max.equals(this.max);
    }
  };
  Box2.prototype.isBox2 = true;
  var _startP = /* @__PURE__ */ new Vector3();
  var _startEnd = /* @__PURE__ */ new Vector3();
  var Line3 = class {
    constructor(start = new Vector3(), end = new Vector3()) {
      this.start = start;
      this.end = end;
    }
    set(start, end) {
      this.start.copy(start);
      this.end.copy(end);
      return this;
    }
    copy(line) {
      this.start.copy(line.start);
      this.end.copy(line.end);
      return this;
    }
    getCenter(target) {
      if (target === void 0) {
        console.warn("THREE.Line3: .getCenter() target is now required");
        target = new Vector3();
      }
      return target.addVectors(this.start, this.end).multiplyScalar(0.5);
    }
    delta(target) {
      if (target === void 0) {
        console.warn("THREE.Line3: .delta() target is now required");
        target = new Vector3();
      }
      return target.subVectors(this.end, this.start);
    }
    distanceSq() {
      return this.start.distanceToSquared(this.end);
    }
    distance() {
      return this.start.distanceTo(this.end);
    }
    at(t, target) {
      if (target === void 0) {
        console.warn("THREE.Line3: .at() target is now required");
        target = new Vector3();
      }
      return this.delta(target).multiplyScalar(t).add(this.start);
    }
    closestPointToPointParameter(point, clampToLine) {
      _startP.subVectors(point, this.start);
      _startEnd.subVectors(this.end, this.start);
      const startEnd2 = _startEnd.dot(_startEnd);
      const startEnd_startP = _startEnd.dot(_startP);
      let t = startEnd_startP / startEnd2;
      if (clampToLine) {
        t = MathUtils.clamp(t, 0, 1);
      }
      return t;
    }
    closestPointToPoint(point, clampToLine, target) {
      const t = this.closestPointToPointParameter(point, clampToLine);
      if (target === void 0) {
        console.warn("THREE.Line3: .closestPointToPoint() target is now required");
        target = new Vector3();
      }
      return this.delta(target).multiplyScalar(t).add(this.start);
    }
    applyMatrix4(matrix) {
      this.start.applyMatrix4(matrix);
      this.end.applyMatrix4(matrix);
      return this;
    }
    equals(line) {
      return line.start.equals(this.start) && line.end.equals(this.end);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  function ImmediateRenderObject(material) {
    Object3D.call(this);
    this.material = material;
    this.render = function() {
    };
    this.hasPositions = false;
    this.hasNormals = false;
    this.hasColors = false;
    this.hasUvs = false;
    this.positionArray = null;
    this.normalArray = null;
    this.colorArray = null;
    this.uvArray = null;
    this.count = 0;
  }
  ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
  ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
  ImmediateRenderObject.prototype.isImmediateRenderObject = true;
  var _vector$3 = /* @__PURE__ */ new Vector3();
  var SpotLightHelper = class extends Object3D {
    constructor(light, color) {
      super();
      this.light = light;
      this.light.updateMatrixWorld();
      this.matrix = light.matrixWorld;
      this.matrixAutoUpdate = false;
      this.color = color;
      const geometry = new BufferGeometry();
      const positions = [
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        0,
        -1,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        1,
        0,
        0,
        0,
        0,
        -1,
        1
      ];
      for (let i = 0, j = 1, l = 32; i < l; i++, j++) {
        const p1 = i / l * Math.PI * 2;
        const p2 = j / l * Math.PI * 2;
        positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
      }
      geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
      const material = new LineBasicMaterial({ fog: false, toneMapped: false });
      this.cone = new LineSegments(geometry, material);
      this.add(this.cone);
      this.update();
    }
    dispose() {
      this.cone.geometry.dispose();
      this.cone.material.dispose();
    }
    update() {
      this.light.updateMatrixWorld();
      const coneLength = this.light.distance ? this.light.distance : 1e3;
      const coneWidth = coneLength * Math.tan(this.light.angle);
      this.cone.scale.set(coneWidth, coneWidth, coneLength);
      _vector$3.setFromMatrixPosition(this.light.target.matrixWorld);
      this.cone.lookAt(_vector$3);
      if (this.color !== void 0) {
        this.cone.material.color.set(this.color);
      } else {
        this.cone.material.color.copy(this.light.color);
      }
    }
  };
  var _vector$2 = /* @__PURE__ */ new Vector3();
  var _boneMatrix = /* @__PURE__ */ new Matrix4();
  var _matrixWorldInv = /* @__PURE__ */ new Matrix4();
  var SkeletonHelper = class extends LineSegments {
    constructor(object) {
      const bones = getBoneList(object);
      const geometry = new BufferGeometry();
      const vertices = [];
      const colors = [];
      const color1 = new Color(0, 0, 1);
      const color2 = new Color(0, 1, 0);
      for (let i = 0; i < bones.length; i++) {
        const bone = bones[i];
        if (bone.parent && bone.parent.isBone) {
          vertices.push(0, 0, 0);
          vertices.push(0, 0, 0);
          colors.push(color1.r, color1.g, color1.b);
          colors.push(color2.r, color2.g, color2.b);
        }
      }
      geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
      const material = new LineBasicMaterial({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true });
      super(geometry, material);
      this.type = "SkeletonHelper";
      this.isSkeletonHelper = true;
      this.root = object;
      this.bones = bones;
      this.matrix = object.matrixWorld;
      this.matrixAutoUpdate = false;
    }
    updateMatrixWorld(force) {
      const bones = this.bones;
      const geometry = this.geometry;
      const position = geometry.getAttribute("position");
      _matrixWorldInv.copy(this.root.matrixWorld).invert();
      for (let i = 0, j = 0; i < bones.length; i++) {
        const bone = bones[i];
        if (bone.parent && bone.parent.isBone) {
          _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
          _vector$2.setFromMatrixPosition(_boneMatrix);
          position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);
          _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
          _vector$2.setFromMatrixPosition(_boneMatrix);
          position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);
          j += 2;
        }
      }
      geometry.getAttribute("position").needsUpdate = true;
      super.updateMatrixWorld(force);
    }
  };
  function getBoneList(object) {
    const boneList = [];
    if (object && object.isBone) {
      boneList.push(object);
    }
    for (let i = 0; i < object.children.length; i++) {
      boneList.push.apply(boneList, getBoneList(object.children[i]));
    }
    return boneList;
  }
  var GridHelper = class extends LineSegments {
    constructor(size2 = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
      color1 = new Color(color1);
      color2 = new Color(color2);
      const center = divisions / 2;
      const step = size2 / divisions;
      const halfSize = size2 / 2;
      const vertices = [], colors = [];
      for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
        vertices.push(-halfSize, 0, k, halfSize, 0, k);
        vertices.push(k, 0, -halfSize, k, 0, halfSize);
        const color = i === center ? color1 : color2;
        color.toArray(colors, j);
        j += 3;
        color.toArray(colors, j);
        j += 3;
        color.toArray(colors, j);
        j += 3;
        color.toArray(colors, j);
        j += 3;
      }
      const geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
      const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
      super(geometry, material);
      this.type = "GridHelper";
    }
  };
  var _v1 = /* @__PURE__ */ new Vector3();
  var _v2 = /* @__PURE__ */ new Vector3();
  var _v3 = /* @__PURE__ */ new Vector3();
  var DirectionalLightHelper = class extends Object3D {
    constructor(light, size2, color) {
      super();
      this.light = light;
      this.light.updateMatrixWorld();
      this.matrix = light.matrixWorld;
      this.matrixAutoUpdate = false;
      this.color = color;
      if (size2 === void 0)
        size2 = 1;
      let geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute([
        -size2,
        size2,
        0,
        size2,
        size2,
        0,
        size2,
        -size2,
        0,
        -size2,
        -size2,
        0,
        -size2,
        size2,
        0
      ], 3));
      const material = new LineBasicMaterial({ fog: false, toneMapped: false });
      this.lightPlane = new Line(geometry, material);
      this.add(this.lightPlane);
      geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
      this.targetLine = new Line(geometry, material);
      this.add(this.targetLine);
      this.update();
    }
    dispose() {
      this.lightPlane.geometry.dispose();
      this.lightPlane.material.dispose();
      this.targetLine.geometry.dispose();
      this.targetLine.material.dispose();
    }
    update() {
      _v1.setFromMatrixPosition(this.light.matrixWorld);
      _v2.setFromMatrixPosition(this.light.target.matrixWorld);
      _v3.subVectors(_v2, _v1);
      this.lightPlane.lookAt(_v2);
      if (this.color !== void 0) {
        this.lightPlane.material.color.set(this.color);
        this.targetLine.material.color.set(this.color);
      } else {
        this.lightPlane.material.color.copy(this.light.color);
        this.targetLine.material.color.copy(this.light.color);
      }
      this.targetLine.lookAt(_v2);
      this.targetLine.scale.z = _v3.length();
    }
  };
  var _floatView = new Float32Array(1);
  var _int32View = new Int32Array(_floatView.buffer);
  var LOD_MIN = 4;
  var LOD_MAX = 8;
  var SIZE_MAX = Math.pow(2, LOD_MAX);
  var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
  var TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  var ENCODINGS = {
    [LinearEncoding]: 0,
    [sRGBEncoding]: 1,
    [RGBEEncoding]: 2,
    [RGBM7Encoding]: 3,
    [RGBM16Encoding]: 4,
    [RGBDEncoding]: 5,
    [GammaEncoding]: 6
  };
  var backgroundMaterial = new MeshBasicMaterial({
    side: BackSide,
    depthWrite: false,
    depthTest: false
  });
  var backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
  var PHI = (1 + Math.sqrt(5)) / 2;
  var INV_PHI = 1 / PHI;
  var _axisDirections = [
    /* @__PURE__ */ new Vector3(1, 1, 1),
    /* @__PURE__ */ new Vector3(-1, 1, 1),
    /* @__PURE__ */ new Vector3(1, 1, -1),
    /* @__PURE__ */ new Vector3(-1, 1, -1),
    /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
    /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
    /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
    /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
    /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
    /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0)
  ];
  Curve.create = function(construct, getPoint) {
    console.log("THREE.Curve.create() has been deprecated");
    construct.prototype = Object.create(Curve.prototype);
    construct.prototype.constructor = construct;
    construct.prototype.getPoint = getPoint;
    return construct;
  };
  Path.prototype.fromPoints = function(points) {
    console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
    return this.setFromPoints(points);
  };
  GridHelper.prototype.setColors = function() {
    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
  };
  SkeletonHelper.prototype.update = function() {
    console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
  };
  Loader.prototype.extractUrlBase = function(url) {
    console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
    return LoaderUtils.extractUrlBase(url);
  };
  Loader.Handlers = {
    add: function() {
      console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
    },
    get: function() {
      console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
    }
  };
  Box2.prototype.center = function(optionalTarget) {
    console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
    return this.getCenter(optionalTarget);
  };
  Box2.prototype.empty = function() {
    console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
    return this.isEmpty();
  };
  Box2.prototype.isIntersectionBox = function(box) {
    console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(box);
  };
  Box2.prototype.size = function(optionalTarget) {
    console.warn("THREE.Box2: .size() has been renamed to .getSize().");
    return this.getSize(optionalTarget);
  };
  Box3.prototype.center = function(optionalTarget) {
    console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
    return this.getCenter(optionalTarget);
  };
  Box3.prototype.empty = function() {
    console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
    return this.isEmpty();
  };
  Box3.prototype.isIntersectionBox = function(box) {
    console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(box);
  };
  Box3.prototype.isIntersectionSphere = function(sphere) {
    console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
    return this.intersectsSphere(sphere);
  };
  Box3.prototype.size = function(optionalTarget) {
    console.warn("THREE.Box3: .size() has been renamed to .getSize().");
    return this.getSize(optionalTarget);
  };
  Sphere.prototype.empty = function() {
    console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");
    return this.isEmpty();
  };
  Frustum.prototype.setFromMatrix = function(m) {
    console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
    return this.setFromProjectionMatrix(m);
  };
  Line3.prototype.center = function(optionalTarget) {
    console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
    return this.getCenter(optionalTarget);
  };
  MathUtils.random16 = function() {
    console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead.");
    return Math.random();
  };
  MathUtils.nearestPowerOfTwo = function(value) {
    console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().");
    return MathUtils.floorPowerOfTwo(value);
  };
  MathUtils.nextPowerOfTwo = function(value) {
    console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().");
    return MathUtils.ceilPowerOfTwo(value);
  };
  Matrix3.prototype.flattenToArrayOffset = function(array, offset) {
    console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
    return this.toArray(array, offset);
  };
  Matrix3.prototype.multiplyVector3 = function(vector) {
    console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
    return vector.applyMatrix3(this);
  };
  Matrix3.prototype.multiplyVector3Array = function() {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
  };
  Matrix3.prototype.applyToBufferAttribute = function(attribute) {
    console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
    return attribute.applyMatrix3(this);
  };
  Matrix3.prototype.applyToVector3Array = function() {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
  };
  Matrix3.prototype.getInverse = function(matrix) {
    console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
    return this.copy(matrix).invert();
  };
  Matrix4.prototype.extractPosition = function(m) {
    console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
    return this.copyPosition(m);
  };
  Matrix4.prototype.flattenToArrayOffset = function(array, offset) {
    console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
    return this.toArray(array, offset);
  };
  Matrix4.prototype.getPosition = function() {
    console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
    return new Vector3().setFromMatrixColumn(this, 3);
  };
  Matrix4.prototype.setRotationFromQuaternion = function(q) {
    console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
    return this.makeRotationFromQuaternion(q);
  };
  Matrix4.prototype.multiplyToArray = function() {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
  };
  Matrix4.prototype.multiplyVector3 = function(vector) {
    console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return vector.applyMatrix4(this);
  };
  Matrix4.prototype.multiplyVector4 = function(vector) {
    console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return vector.applyMatrix4(this);
  };
  Matrix4.prototype.multiplyVector3Array = function() {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
  };
  Matrix4.prototype.rotateAxis = function(v) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
    v.transformDirection(this);
  };
  Matrix4.prototype.crossVector = function(vector) {
    console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return vector.applyMatrix4(this);
  };
  Matrix4.prototype.translate = function() {
    console.error("THREE.Matrix4: .translate() has been removed.");
  };
  Matrix4.prototype.rotateX = function() {
    console.error("THREE.Matrix4: .rotateX() has been removed.");
  };
  Matrix4.prototype.rotateY = function() {
    console.error("THREE.Matrix4: .rotateY() has been removed.");
  };
  Matrix4.prototype.rotateZ = function() {
    console.error("THREE.Matrix4: .rotateZ() has been removed.");
  };
  Matrix4.prototype.rotateByAxis = function() {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
  };
  Matrix4.prototype.applyToBufferAttribute = function(attribute) {
    console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
    return attribute.applyMatrix4(this);
  };
  Matrix4.prototype.applyToVector3Array = function() {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
  };
  Matrix4.prototype.makeFrustum = function(left, right, bottom, top, near, far) {
    console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
    return this.makePerspective(left, right, top, bottom, near, far);
  };
  Matrix4.prototype.getInverse = function(matrix) {
    console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
    return this.copy(matrix).invert();
  };
  Plane.prototype.isIntersectionLine = function(line) {
    console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
    return this.intersectsLine(line);
  };
  Quaternion.prototype.multiplyVector3 = function(vector) {
    console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
    return vector.applyQuaternion(this);
  };
  Quaternion.prototype.inverse = function() {
    console.warn("THREE.Quaternion: .inverse() has been renamed to invert().");
    return this.invert();
  };
  Ray.prototype.isIntersectionBox = function(box) {
    console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(box);
  };
  Ray.prototype.isIntersectionPlane = function(plane) {
    console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
    return this.intersectsPlane(plane);
  };
  Ray.prototype.isIntersectionSphere = function(sphere) {
    console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
    return this.intersectsSphere(sphere);
  };
  Triangle.prototype.area = function() {
    console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
    return this.getArea();
  };
  Triangle.prototype.barycoordFromPoint = function(point, target) {
    console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
    return this.getBarycoord(point, target);
  };
  Triangle.prototype.midpoint = function(target) {
    console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
    return this.getMidpoint(target);
  };
  Triangle.prototypenormal = function(target) {
    console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
    return this.getNormal(target);
  };
  Triangle.prototype.plane = function(target) {
    console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
    return this.getPlane(target);
  };
  Triangle.barycoordFromPoint = function(point, a, b2, c, target) {
    console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
    return Triangle.getBarycoord(point, a, b2, c, target);
  };
  Triangle.normal = function(a, b2, c, target) {
    console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
    return Triangle.getNormal(a, b2, c, target);
  };
  Shape.prototype.extractAllPoints = function(divisions) {
    console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
    return this.extractPoints(divisions);
  };
  Shape.prototype.extrude = function(options) {
    console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
    return new ExtrudeGeometry(this, options);
  };
  Shape.prototype.makeGeometry = function(options) {
    console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
    return new ShapeGeometry(this, options);
  };
  Vector2.prototype.fromAttribute = function(attribute, index, offset) {
    console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
    return this.fromBufferAttribute(attribute, index, offset);
  };
  Vector2.prototype.distanceToManhattan = function(v) {
    console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
    return this.manhattanDistanceTo(v);
  };
  Vector2.prototype.lengthManhattan = function() {
    console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
    return this.manhattanLength();
  };
  Vector3.prototype.setEulerFromRotationMatrix = function() {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
  };
  Vector3.prototype.setEulerFromQuaternion = function() {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
  };
  Vector3.prototype.getPositionFromMatrix = function(m) {
    console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
    return this.setFromMatrixPosition(m);
  };
  Vector3.prototype.getScaleFromMatrix = function(m) {
    console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
    return this.setFromMatrixScale(m);
  };
  Vector3.prototype.getColumnFromMatrix = function(index, matrix) {
    console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
    return this.setFromMatrixColumn(matrix, index);
  };
  Vector3.prototype.applyProjection = function(m) {
    console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
    return this.applyMatrix4(m);
  };
  Vector3.prototype.fromAttribute = function(attribute, index, offset) {
    console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
    return this.fromBufferAttribute(attribute, index, offset);
  };
  Vector3.prototype.distanceToManhattan = function(v) {
    console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
    return this.manhattanDistanceTo(v);
  };
  Vector3.prototype.lengthManhattan = function() {
    console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
    return this.manhattanLength();
  };
  Vector4.prototype.fromAttribute = function(attribute, index, offset) {
    console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
    return this.fromBufferAttribute(attribute, index, offset);
  };
  Vector4.prototype.lengthManhattan = function() {
    console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
    return this.manhattanLength();
  };
  Object3D.prototype.getChildByName = function(name) {
    console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
    return this.getObjectByName(name);
  };
  Object3D.prototype.renderDepth = function() {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
  };
  Object3D.prototype.translate = function(distance, axis) {
    console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
    return this.translateOnAxis(axis, distance);
  };
  Object3D.prototype.getWorldRotation = function() {
    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
  };
  Object3D.prototype.applyMatrix = function(matrix) {
    console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
    return this.applyMatrix4(matrix);
  };
  Object.defineProperties(Object3D.prototype, {
    eulerOrder: {
      get: function() {
        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
        return this.rotation.order;
      },
      set: function(value) {
        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
        this.rotation.order = value;
      }
    },
    useQuaternion: {
      get: function() {
        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
      },
      set: function() {
        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
      }
    }
  });
  Mesh.prototype.setDrawMode = function() {
    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
  };
  Object.defineProperties(Mesh.prototype, {
    drawMode: {
      get: function() {
        console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
        return TrianglesDrawMode;
      },
      set: function() {
        console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
      }
    }
  });
  SkinnedMesh.prototype.initBones = function() {
    console.error("THREE.SkinnedMesh: initBones() has been removed.");
  };
  Object.defineProperty(Curve.prototype, "__arcLengthDivisions", {
    get: function() {
      console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
      return this.arcLengthDivisions;
    },
    set: function(value) {
      console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
      this.arcLengthDivisions = value;
    }
  });
  PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
    if (filmGauge !== void 0)
      this.filmGauge = filmGauge;
    this.setFocalLength(focalLength);
  };
  Object.defineProperties(Light.prototype, {
    onlyShadow: {
      set: function() {
        console.warn("THREE.Light: .onlyShadow has been removed.");
      }
    },
    shadowCameraFov: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
        this.shadow.camera.fov = value;
      }
    },
    shadowCameraLeft: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
        this.shadow.camera.left = value;
      }
    },
    shadowCameraRight: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
        this.shadow.camera.right = value;
      }
    },
    shadowCameraTop: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
        this.shadow.camera.top = value;
      }
    },
    shadowCameraBottom: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
        this.shadow.camera.bottom = value;
      }
    },
    shadowCameraNear: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
        this.shadow.camera.near = value;
      }
    },
    shadowCameraFar: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
        this.shadow.camera.far = value;
      }
    },
    shadowCameraVisible: {
      set: function() {
        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
      }
    },
    shadowBias: {
      set: function(value) {
        console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
        this.shadow.bias = value;
      }
    },
    shadowDarkness: {
      set: function() {
        console.warn("THREE.Light: .shadowDarkness has been removed.");
      }
    },
    shadowMapWidth: {
      set: function(value) {
        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
        this.shadow.mapSize.width = value;
      }
    },
    shadowMapHeight: {
      set: function(value) {
        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
        this.shadow.mapSize.height = value;
      }
    }
  });
  Object.defineProperties(BufferAttribute.prototype, {
    length: {
      get: function() {
        console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
        return this.array.length;
      }
    },
    dynamic: {
      get: function() {
        console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
        return this.usage === DynamicDrawUsage;
      },
      set: function() {
        console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
        this.setUsage(DynamicDrawUsage);
      }
    }
  });
  BufferAttribute.prototype.setDynamic = function(value) {
    console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
    this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
    return this;
  };
  BufferAttribute.prototype.copyIndicesArray = function() {
    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
  }, BufferAttribute.prototype.setArray = function() {
    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  };
  BufferGeometry.prototype.addIndex = function(index) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
    this.setIndex(index);
  };
  BufferGeometry.prototype.addAttribute = function(name, attribute) {
    console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
    if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
      console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
      return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
    }
    if (name === "index") {
      console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
      this.setIndex(attribute);
      return this;
    }
    return this.setAttribute(name, attribute);
  };
  BufferGeometry.prototype.addDrawCall = function(start, count, indexOffset) {
    if (indexOffset !== void 0) {
      console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
    }
    console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
    this.addGroup(start, count);
  };
  BufferGeometry.prototype.clearDrawCalls = function() {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
    this.clearGroups();
  };
  BufferGeometry.prototype.computeOffsets = function() {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
  };
  BufferGeometry.prototype.removeAttribute = function(name) {
    console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
    return this.deleteAttribute(name);
  };
  BufferGeometry.prototype.applyMatrix = function(matrix) {
    console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
    return this.applyMatrix4(matrix);
  };
  Object.defineProperties(BufferGeometry.prototype, {
    drawcalls: {
      get: function() {
        console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
        return this.groups;
      }
    },
    offsets: {
      get: function() {
        console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
        return this.groups;
      }
    }
  });
  Object.defineProperties(InstancedBufferGeometry.prototype, {
    maxInstancedCount: {
      get: function() {
        console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.");
        return this.instanceCount;
      },
      set: function(value) {
        console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.");
        this.instanceCount = value;
      }
    }
  });
  Object.defineProperties(Raycaster.prototype, {
    linePrecision: {
      get: function() {
        console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.");
        return this.params.Line.threshold;
      },
      set: function(value) {
        console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.");
        this.params.Line.threshold = value;
      }
    }
  });
  Object.defineProperties(InterleavedBuffer.prototype, {
    dynamic: {
      get: function() {
        console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
        return this.usage === DynamicDrawUsage;
      },
      set: function(value) {
        console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
        this.setUsage(value);
      }
    }
  });
  InterleavedBuffer.prototype.setDynamic = function(value) {
    console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
    this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
    return this;
  };
  InterleavedBuffer.prototype.setArray = function() {
    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  };
  ExtrudeGeometry.prototype.getArrays = function() {
    console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
  };
  ExtrudeGeometry.prototype.addShapeList = function() {
    console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
  };
  ExtrudeGeometry.prototype.addShape = function() {
    console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
  };
  Scene.prototype.dispose = function() {
    console.error("THREE.Scene: .dispose() has been removed.");
  };
  Uniform.prototype.onUpdate = function() {
    console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
    return this;
  };
  Object.defineProperties(Material.prototype, {
    wrapAround: {
      get: function() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      },
      set: function() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      }
    },
    overdraw: {
      get: function() {
        console.warn("THREE.Material: .overdraw has been removed.");
      },
      set: function() {
        console.warn("THREE.Material: .overdraw has been removed.");
      }
    },
    wrapRGB: {
      get: function() {
        console.warn("THREE.Material: .wrapRGB has been removed.");
        return new Color();
      }
    },
    shading: {
      get: function() {
        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
      },
      set: function(value) {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        this.flatShading = value === FlatShading;
      }
    },
    stencilMask: {
      get: function() {
        console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
        return this.stencilFuncMask;
      },
      set: function(value) {
        console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
        this.stencilFuncMask = value;
      }
    }
  });
  Object.defineProperties(MeshPhysicalMaterial.prototype, {
    transparency: {
      get: function() {
        console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.");
        return this.transmission;
      },
      set: function(value) {
        console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.");
        this.transmission = value;
      }
    }
  });
  Object.defineProperties(ShaderMaterial.prototype, {
    derivatives: {
      get: function() {
        console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
        return this.extensions.derivatives;
      },
      set: function(value) {
        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
        this.extensions.derivatives = value;
      }
    }
  });
  WebGLRenderer.prototype.clearTarget = function(renderTarget, color, depth, stencil) {
    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
    this.setRenderTarget(renderTarget);
    this.clear(color, depth, stencil);
  };
  WebGLRenderer.prototype.animate = function(callback) {
    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
    this.setAnimationLoop(callback);
  };
  WebGLRenderer.prototype.getCurrentRenderTarget = function() {
    console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
    return this.getRenderTarget();
  };
  WebGLRenderer.prototype.getMaxAnisotropy = function() {
    console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
    return this.capabilities.getMaxAnisotropy();
  };
  WebGLRenderer.prototype.getPrecision = function() {
    console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
    return this.capabilities.precision;
  };
  WebGLRenderer.prototype.resetGLState = function() {
    console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
    return this.state.reset();
  };
  WebGLRenderer.prototype.supportsFloatTextures = function() {
    console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
    return this.extensions.get("OES_texture_float");
  };
  WebGLRenderer.prototype.supportsHalfFloatTextures = function() {
    console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
    return this.extensions.get("OES_texture_half_float");
  };
  WebGLRenderer.prototype.supportsStandardDerivatives = function() {
    console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
    return this.extensions.get("OES_standard_derivatives");
  };
  WebGLRenderer.prototype.supportsCompressedTextureS3TC = function() {
    console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
    return this.extensions.get("WEBGL_compressed_texture_s3tc");
  };
  WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function() {
    console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
    return this.extensions.get("WEBGL_compressed_texture_pvrtc");
  };
  WebGLRenderer.prototype.supportsBlendMinMax = function() {
    console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
    return this.extensions.get("EXT_blend_minmax");
  };
  WebGLRenderer.prototype.supportsVertexTextures = function() {
    console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
    return this.capabilities.vertexTextures;
  };
  WebGLRenderer.prototype.supportsInstancedArrays = function() {
    console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
    return this.extensions.get("ANGLE_instanced_arrays");
  };
  WebGLRenderer.prototype.enableScissorTest = function(boolean) {
    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
    this.setScissorTest(boolean);
  };
  WebGLRenderer.prototype.initMaterial = function() {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
  };
  WebGLRenderer.prototype.addPrePlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
  };
  WebGLRenderer.prototype.addPostPlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
  };
  WebGLRenderer.prototype.updateShadowMap = function() {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
  };
  WebGLRenderer.prototype.setFaceCulling = function() {
    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
  };
  WebGLRenderer.prototype.allocTextureUnit = function() {
    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
  };
  WebGLRenderer.prototype.setTexture = function() {
    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
  };
  WebGLRenderer.prototype.setTexture2D = function() {
    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
  };
  WebGLRenderer.prototype.setTextureCube = function() {
    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
  };
  WebGLRenderer.prototype.getActiveMipMapLevel = function() {
    console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
    return this.getActiveMipmapLevel();
  };
  Object.defineProperties(WebGLRenderer.prototype, {
    shadowMapEnabled: {
      get: function() {
        return this.shadowMap.enabled;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
        this.shadowMap.enabled = value;
      }
    },
    shadowMapType: {
      get: function() {
        return this.shadowMap.type;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
        this.shadowMap.type = value;
      }
    },
    shadowMapCullFace: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
        return void 0;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      }
    },
    context: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
        return this.getContext();
      }
    },
    vr: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
        return this.xr;
      }
    },
    gammaInput: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
        return false;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
      }
    },
    gammaOutput: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
        return false;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
        this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
      }
    },
    toneMappingWhitePoint: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
        return 1;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
      }
    }
  });
  Object.defineProperties(WebGLShadowMap.prototype, {
    cullFace: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
        return void 0;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      }
    },
    renderReverseSided: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
        return void 0;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      }
    },
    renderSingleSided: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
        return void 0;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      }
    }
  });
  Object.defineProperties(WebGLRenderTarget.prototype, {
    wrapS: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
        return this.texture.wrapS;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
        this.texture.wrapS = value;
      }
    },
    wrapT: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
        return this.texture.wrapT;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
        this.texture.wrapT = value;
      }
    },
    magFilter: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
        return this.texture.magFilter;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
        this.texture.magFilter = value;
      }
    },
    minFilter: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
        return this.texture.minFilter;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
        this.texture.minFilter = value;
      }
    },
    anisotropy: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
        return this.texture.anisotropy;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
        this.texture.anisotropy = value;
      }
    },
    offset: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
        return this.texture.offset;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
        this.texture.offset = value;
      }
    },
    repeat: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
        return this.texture.repeat;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
        this.texture.repeat = value;
      }
    },
    format: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
        return this.texture.format;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
        this.texture.format = value;
      }
    },
    type: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
        return this.texture.type;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
        this.texture.type = value;
      }
    },
    generateMipmaps: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
        return this.texture.generateMipmaps;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
        this.texture.generateMipmaps = value;
      }
    }
  });
  Audio.prototype.load = function(file) {
    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
    const scope = this;
    const audioLoader = new AudioLoader();
    audioLoader.load(file, function(buffer) {
      scope.setBuffer(buffer);
    });
    return this;
  };
  AudioAnalyser.prototype.getData = function() {
    console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
    return this.getFrequencyData();
  };
  CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
    console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
    return this.update(renderer, scene);
  };
  CubeCamera.prototype.clear = function(renderer, color, depth, stencil) {
    console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear().");
    return this.renderTarget.clear(renderer, color, depth, stencil);
  };
  ImageUtils.crossOrigin = void 0;
  ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
    const loader = new TextureLoader();
    loader.setCrossOrigin(this.crossOrigin);
    const texture = loader.load(url, onLoad, void 0, onError);
    if (mapping)
      texture.mapping = mapping;
    return texture;
  };
  ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
    const loader = new CubeTextureLoader();
    loader.setCrossOrigin(this.crossOrigin);
    const texture = loader.load(urls, onLoad, void 0, onError);
    if (mapping)
      texture.mapping = mapping;
    return texture;
  };
  ImageUtils.loadCompressedTexture = function() {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
  };
  ImageUtils.loadCompressedTextureCube = function() {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
  };
  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
      revision: REVISION
    } }));
  }
  if (typeof window !== "undefined") {
    if (window.__THREE__) {
      console.warn("WARNING: Multiple instances of Three.js being imported.");
    } else {
      window.__THREE__ = REVISION;
    }
  }

  // node_modules/three/examples/jsm/postprocessing/Pass.js
  function Pass() {
    this.enabled = true;
    this.needsSwap = true;
    this.clear = false;
    this.renderToScreen = false;
  }
  Object.assign(Pass.prototype, {
    setSize: function() {
    },
    render: function() {
      console.error("THREE.Pass: .render() must be implemented in derived pass.");
    }
  });
  Pass.FullScreenQuad = function() {
    var camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
    var geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
    geometry.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
    var FullScreenQuad = function(material) {
      this._mesh = new Mesh(geometry, material);
    };
    Object.defineProperty(FullScreenQuad.prototype, "material", {
      get: function() {
        return this._mesh.material;
      },
      set: function(value) {
        this._mesh.material = value;
      }
    });
    Object.assign(FullScreenQuad.prototype, {
      dispose: function() {
        this._mesh.geometry.dispose();
      },
      render: function(renderer) {
        renderer.render(this._mesh, camera);
      }
    });
    return FullScreenQuad;
  }();

  // node_modules/three/examples/jsm/shaders/CopyShader.js
  var CopyShader = {
    uniforms: {
      "tDiffuse": { value: null },
      "opacity": { value: 1 }
    },
    vertexShader: [
      "varying vec2 vUv;",
      "void main() {",
      "	vUv = uv;",
      "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
      "}"
    ].join("\n"),
    fragmentShader: [
      "uniform float opacity;",
      "uniform sampler2D tDiffuse;",
      "varying vec2 vUv;",
      "void main() {",
      "	vec4 texel = texture2D( tDiffuse, vUv );",
      "	gl_FragColor = opacity * texel;",
      "}"
    ].join("\n")
  };

  // node_modules/three/examples/jsm/shaders/LuminosityHighPassShader.js
  var LuminosityHighPassShader = {
    shaderID: "luminosityHighPass",
    uniforms: {
      "tDiffuse": { value: null },
      "luminosityThreshold": { value: 1 },
      "smoothWidth": { value: 1 },
      "defaultColor": { value: new Color(0) },
      "defaultOpacity": { value: 0 }
    },
    vertexShader: [
      "varying vec2 vUv;",
      "void main() {",
      "	vUv = uv;",
      "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
      "}"
    ].join("\n"),
    fragmentShader: [
      "uniform sampler2D tDiffuse;",
      "uniform vec3 defaultColor;",
      "uniform float defaultOpacity;",
      "uniform float luminosityThreshold;",
      "uniform float smoothWidth;",
      "varying vec2 vUv;",
      "void main() {",
      "	vec4 texel = texture2D( tDiffuse, vUv );",
      "	vec3 luma = vec3( 0.299, 0.587, 0.114 );",
      "	float v = dot( texel.xyz, luma );",
      "	vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );",
      "	float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );",
      "	gl_FragColor = mix( outputColor, texel, alpha );",
      "}"
    ].join("\n")
  };

  // node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js
  var UnrealBloomPass = function(resolution, strength, radius, threshold) {
    Pass.call(this);
    this.strength = strength !== void 0 ? strength : 1;
    this.radius = radius;
    this.threshold = threshold;
    this.resolution = resolution !== void 0 ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);
    this.clearColor = new Color(0, 0, 0);
    var pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };
    this.renderTargetsHorizontal = [];
    this.renderTargetsVertical = [];
    this.nMips = 5;
    var resx = Math.round(this.resolution.x / 2);
    var resy = Math.round(this.resolution.y / 2);
    this.renderTargetBright = new WebGLRenderTarget(resx, resy, pars);
    this.renderTargetBright.texture.name = "UnrealBloomPass.bright";
    this.renderTargetBright.texture.generateMipmaps = false;
    for (var i = 0; i < this.nMips; i++) {
      var renderTargetHorizonal = new WebGLRenderTarget(resx, resy, pars);
      renderTargetHorizonal.texture.name = "UnrealBloomPass.h" + i;
      renderTargetHorizonal.texture.generateMipmaps = false;
      this.renderTargetsHorizontal.push(renderTargetHorizonal);
      var renderTargetVertical = new WebGLRenderTarget(resx, resy, pars);
      renderTargetVertical.texture.name = "UnrealBloomPass.v" + i;
      renderTargetVertical.texture.generateMipmaps = false;
      this.renderTargetsVertical.push(renderTargetVertical);
      resx = Math.round(resx / 2);
      resy = Math.round(resy / 2);
    }
    if (LuminosityHighPassShader === void 0)
      console.error("THREE.UnrealBloomPass relies on LuminosityHighPassShader");
    var highPassShader = LuminosityHighPassShader;
    this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms);
    this.highPassUniforms["luminosityThreshold"].value = threshold;
    this.highPassUniforms["smoothWidth"].value = 0.01;
    this.materialHighPassFilter = new ShaderMaterial({
      uniforms: this.highPassUniforms,
      vertexShader: highPassShader.vertexShader,
      fragmentShader: highPassShader.fragmentShader,
      defines: {}
    });
    this.separableBlurMaterials = [];
    var kernelSizeArray = [3, 5, 7, 9, 11];
    var resx = Math.round(this.resolution.x / 2);
    var resy = Math.round(this.resolution.y / 2);
    for (var i = 0; i < this.nMips; i++) {
      this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));
      this.separableBlurMaterials[i].uniforms["texSize"].value = new Vector2(resx, resy);
      resx = Math.round(resx / 2);
      resy = Math.round(resy / 2);
    }
    this.compositeMaterial = this.getCompositeMaterial(this.nMips);
    this.compositeMaterial.uniforms["blurTexture1"].value = this.renderTargetsVertical[0].texture;
    this.compositeMaterial.uniforms["blurTexture2"].value = this.renderTargetsVertical[1].texture;
    this.compositeMaterial.uniforms["blurTexture3"].value = this.renderTargetsVertical[2].texture;
    this.compositeMaterial.uniforms["blurTexture4"].value = this.renderTargetsVertical[3].texture;
    this.compositeMaterial.uniforms["blurTexture5"].value = this.renderTargetsVertical[4].texture;
    this.compositeMaterial.uniforms["bloomStrength"].value = strength;
    this.compositeMaterial.uniforms["bloomRadius"].value = 0.1;
    this.compositeMaterial.needsUpdate = true;
    var bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];
    this.compositeMaterial.uniforms["bloomFactors"].value = bloomFactors;
    this.bloomTintColors = [
      new Vector3(1, 1, 1),
      new Vector3(1, 1, 1),
      new Vector3(1, 1, 1),
      new Vector3(1, 1, 1),
      new Vector3(1, 1, 1)
    ];
    this.compositeMaterial.uniforms["bloomTintColors"].value = this.bloomTintColors;
    if (CopyShader === void 0) {
      console.error("THREE.UnrealBloomPass relies on CopyShader");
    }
    var copyShader = CopyShader;
    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);
    this.copyUniforms["opacity"].value = 1;
    this.materialCopy = new ShaderMaterial({
      uniforms: this.copyUniforms,
      vertexShader: copyShader.vertexShader,
      fragmentShader: copyShader.fragmentShader,
      blending: AdditiveBlending,
      depthTest: false,
      depthWrite: false,
      transparent: true
    });
    this.enabled = true;
    this.needsSwap = false;
    this._oldClearColor = new Color();
    this.oldClearAlpha = 1;
    this.basic = new MeshBasicMaterial();
    this.fsQuad = new Pass.FullScreenQuad(null);
  };
  UnrealBloomPass.prototype = Object.assign(Object.create(Pass.prototype), {
    constructor: UnrealBloomPass,
    dispose: function() {
      for (var i = 0; i < this.renderTargetsHorizontal.length; i++) {
        this.renderTargetsHorizontal[i].dispose();
      }
      for (var i = 0; i < this.renderTargetsVertical.length; i++) {
        this.renderTargetsVertical[i].dispose();
      }
      this.renderTargetBright.dispose();
    },
    setSize: function(width, height) {
      var resx = Math.round(width / 2);
      var resy = Math.round(height / 2);
      this.renderTargetBright.setSize(resx, resy);
      for (var i = 0; i < this.nMips; i++) {
        this.renderTargetsHorizontal[i].setSize(resx, resy);
        this.renderTargetsVertical[i].setSize(resx, resy);
        this.separableBlurMaterials[i].uniforms["texSize"].value = new Vector2(resx, resy);
        resx = Math.round(resx / 2);
        resy = Math.round(resy / 2);
      }
    },
    render: function(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
      renderer.getClearColor(this._oldClearColor);
      this.oldClearAlpha = renderer.getClearAlpha();
      var oldAutoClear = renderer.autoClear;
      renderer.autoClear = false;
      renderer.setClearColor(this.clearColor, 0);
      if (maskActive)
        renderer.state.buffers.stencil.setTest(false);
      if (this.renderToScreen) {
        this.fsQuad.material = this.basic;
        this.basic.map = readBuffer.texture;
        renderer.setRenderTarget(null);
        renderer.clear();
        this.fsQuad.render(renderer);
      }
      this.highPassUniforms["tDiffuse"].value = readBuffer.texture;
      this.highPassUniforms["luminosityThreshold"].value = this.threshold;
      this.fsQuad.material = this.materialHighPassFilter;
      renderer.setRenderTarget(this.renderTargetBright);
      renderer.clear();
      this.fsQuad.render(renderer);
      var inputRenderTarget = this.renderTargetBright;
      for (var i = 0; i < this.nMips; i++) {
        this.fsQuad.material = this.separableBlurMaterials[i];
        this.separableBlurMaterials[i].uniforms["colorTexture"].value = inputRenderTarget.texture;
        this.separableBlurMaterials[i].uniforms["direction"].value = UnrealBloomPass.BlurDirectionX;
        renderer.setRenderTarget(this.renderTargetsHorizontal[i]);
        renderer.clear();
        this.fsQuad.render(renderer);
        this.separableBlurMaterials[i].uniforms["colorTexture"].value = this.renderTargetsHorizontal[i].texture;
        this.separableBlurMaterials[i].uniforms["direction"].value = UnrealBloomPass.BlurDirectionY;
        renderer.setRenderTarget(this.renderTargetsVertical[i]);
        renderer.clear();
        this.fsQuad.render(renderer);
        inputRenderTarget = this.renderTargetsVertical[i];
      }
      this.fsQuad.material = this.compositeMaterial;
      this.compositeMaterial.uniforms["bloomStrength"].value = this.strength;
      this.compositeMaterial.uniforms["bloomRadius"].value = this.radius;
      this.compositeMaterial.uniforms["bloomTintColors"].value = this.bloomTintColors;
      renderer.setRenderTarget(this.renderTargetsHorizontal[0]);
      renderer.clear();
      this.fsQuad.render(renderer);
      this.fsQuad.material = this.materialCopy;
      this.copyUniforms["tDiffuse"].value = this.renderTargetsHorizontal[0].texture;
      if (maskActive)
        renderer.state.buffers.stencil.setTest(true);
      if (this.renderToScreen) {
        renderer.setRenderTarget(null);
        this.fsQuad.render(renderer);
      } else {
        renderer.setRenderTarget(readBuffer);
        this.fsQuad.render(renderer);
      }
      renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);
      renderer.autoClear = oldAutoClear;
    },
    getSeperableBlurMaterial: function(kernelRadius) {
      return new ShaderMaterial({
        defines: {
          "KERNEL_RADIUS": kernelRadius,
          "SIGMA": kernelRadius
        },
        uniforms: {
          "colorTexture": { value: null },
          "texSize": { value: new Vector2(0.5, 0.5) },
          "direction": { value: new Vector2(0.5, 0.5) }
        },
        vertexShader: "varying vec2 vUv;\n				void main() {\n					vUv = uv;\n					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n				}",
        fragmentShader: "#include <common>				varying vec2 vUv;\n				uniform sampler2D colorTexture;\n				uniform vec2 texSize;				uniform vec2 direction;								float gaussianPdf(in float x, in float sigma) {					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;				}				void main() {\n					vec2 invSize = 1.0 / texSize;					float fSigma = float(SIGMA);					float weightSum = gaussianPdf(0.0, fSigma);					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {						float x = float(i);						float w = gaussianPdf(x, fSigma);						vec2 uvOffset = direction * invSize * x;						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;						diffuseSum += (sample1 + sample2) * w;						weightSum += 2.0 * w;					}					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n				}"
      });
    },
    getCompositeMaterial: function(nMips) {
      return new ShaderMaterial({
        defines: {
          "NUM_MIPS": nMips
        },
        uniforms: {
          "blurTexture1": { value: null },
          "blurTexture2": { value: null },
          "blurTexture3": { value: null },
          "blurTexture4": { value: null },
          "blurTexture5": { value: null },
          "dirtTexture": { value: null },
          "bloomStrength": { value: 1 },
          "bloomFactors": { value: null },
          "bloomTintColors": { value: null },
          "bloomRadius": { value: 0 }
        },
        vertexShader: "varying vec2 vUv;\n				void main() {\n					vUv = uv;\n					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n				}",
        fragmentShader: "varying vec2 vUv;				uniform sampler2D blurTexture1;				uniform sampler2D blurTexture2;				uniform sampler2D blurTexture3;				uniform sampler2D blurTexture4;				uniform sampler2D blurTexture5;				uniform sampler2D dirtTexture;				uniform float bloomStrength;				uniform float bloomRadius;				uniform float bloomFactors[NUM_MIPS];				uniform vec3 bloomTintColors[NUM_MIPS];								float lerpBloomFactor(const in float factor) { 					float mirrorFactor = 1.2 - factor;					return mix(factor, mirrorFactor, bloomRadius);				}								void main() {					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + 													 lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + 													 lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + 													 lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + 													 lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );				}"
      });
    }
  });
  UnrealBloomPass.BlurDirectionX = new Vector2(1, 0);
  UnrealBloomPass.BlurDirectionY = new Vector2(0, 1);

  // node_modules/three/examples/jsm/shaders/FilmShader.js
  var FilmShader = {
    uniforms: {
      "tDiffuse": { value: null },
      "time": { value: 0 },
      "nIntensity": { value: 0.5 },
      "sIntensity": { value: 0.05 },
      "sCount": { value: 4096 },
      "grayscale": { value: 1 }
    },
    vertexShader: [
      "varying vec2 vUv;",
      "void main() {",
      "	vUv = uv;",
      "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
      "}"
    ].join("\n"),
    fragmentShader: [
      "#include <common>",
      "uniform float time;",
      "uniform bool grayscale;",
      "uniform float nIntensity;",
      "uniform float sIntensity;",
      "uniform float sCount;",
      "uniform sampler2D tDiffuse;",
      "varying vec2 vUv;",
      "void main() {",
      "	vec4 cTextureScreen = texture2D( tDiffuse, vUv );",
      "	float dx = rand( vUv + time );",
      "	vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );",
      "	vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );",
      "	cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;",
      "	cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );",
      "	if( grayscale ) {",
      "		cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );",
      "	}",
      "	gl_FragColor =  vec4( cResult, cTextureScreen.a );",
      "}"
    ].join("\n")
  };

  // node_modules/three/examples/jsm/postprocessing/FilmPass.js
  var FilmPass = function(noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale) {
    Pass.call(this);
    if (FilmShader === void 0)
      console.error("THREE.FilmPass relies on FilmShader");
    var shader = FilmShader;
    this.uniforms = UniformsUtils.clone(shader.uniforms);
    this.material = new ShaderMaterial({
      uniforms: this.uniforms,
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader
    });
    if (grayscale !== void 0)
      this.uniforms.grayscale.value = grayscale;
    if (noiseIntensity !== void 0)
      this.uniforms.nIntensity.value = noiseIntensity;
    if (scanlinesIntensity !== void 0)
      this.uniforms.sIntensity.value = scanlinesIntensity;
    if (scanlinesCount !== void 0)
      this.uniforms.sCount.value = scanlinesCount;
    this.fsQuad = new Pass.FullScreenQuad(this.material);
  };
  FilmPass.prototype = Object.assign(Object.create(Pass.prototype), {
    constructor: FilmPass,
    render: function(renderer, writeBuffer, readBuffer, deltaTime) {
      this.uniforms["tDiffuse"].value = readBuffer.texture;
      this.uniforms["time"].value += deltaTime;
      if (this.renderToScreen) {
        renderer.setRenderTarget(null);
        this.fsQuad.render(renderer);
      } else {
        renderer.setRenderTarget(writeBuffer);
        if (this.clear)
          renderer.clear();
        this.fsQuad.render(renderer);
      }
    }
  });

  // node_modules/three/examples/jsm/shaders/FXAAShader.js
  var FXAAShader = {
    uniforms: {
      "tDiffuse": { value: null },
      "resolution": { value: new Vector2(1 / 1024, 1 / 512) }
    },
    vertexShader: [
      "varying vec2 vUv;",
      "void main() {",
      "	vUv = uv;",
      "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
      "}"
    ].join("\n"),
    fragmentShader: [
      "precision highp float;",
      "",
      "uniform sampler2D tDiffuse;",
      "",
      "uniform vec2 resolution;",
      "",
      "varying vec2 vUv;",
      "",
      "// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)",
      "",
      "//----------------------------------------------------------------------------------",
      "// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag",
      "// SDK Version: v3.00",
      "// Email:       gameworks@nvidia.com",
      "// Site:        http://developer.nvidia.com/",
      "//",
      "// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.",
      "//",
      "// Redistribution and use in source and binary forms, with or without",
      "// modification, are permitted provided that the following conditions",
      "// are met:",
      "//  * Redistributions of source code must retain the above copyright",
      "//    notice, this list of conditions and the following disclaimer.",
      "//  * Redistributions in binary form must reproduce the above copyright",
      "//    notice, this list of conditions and the following disclaimer in the",
      "//    documentation and/or other materials provided with the distribution.",
      "//  * Neither the name of NVIDIA CORPORATION nor the names of its",
      "//    contributors may be used to endorse or promote products derived",
      "//    from this software without specific prior written permission.",
      "//",
      "// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY",
      "// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE",
      "// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR",
      "// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR",
      "// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,",
      "// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,",
      "// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR",
      "// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY",
      "// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT",
      "// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE",
      "// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",
      "//",
      "//----------------------------------------------------------------------------------",
      "",
      "#define FXAA_PC 1",
      "#define FXAA_GLSL_100 1",
      "#define FXAA_QUALITY_PRESET 12",
      "",
      "#define FXAA_GREEN_AS_LUMA 1",
      "",
      "/*--------------------------------------------------------------------------*/",
      "#ifndef FXAA_PC_CONSOLE",
      "    //",
      "    // The console algorithm for PC is included",
      "    // for developers targeting really low spec machines.",
      "    // Likely better to just run FXAA_PC, and use a really low preset.",
      "    //",
      "    #define FXAA_PC_CONSOLE 0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#ifndef FXAA_GLSL_120",
      "    #define FXAA_GLSL_120 0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#ifndef FXAA_GLSL_130",
      "    #define FXAA_GLSL_130 0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#ifndef FXAA_HLSL_3",
      "    #define FXAA_HLSL_3 0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#ifndef FXAA_HLSL_4",
      "    #define FXAA_HLSL_4 0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#ifndef FXAA_HLSL_5",
      "    #define FXAA_HLSL_5 0",
      "#endif",
      "/*==========================================================================*/",
      "#ifndef FXAA_GREEN_AS_LUMA",
      "    //",
      "    // For those using non-linear color,",
      "    // and either not able to get luma in alpha, or not wanting to,",
      "    // this enables FXAA to run using green as a proxy for luma.",
      "    // So with this enabled, no need to pack luma in alpha.",
      "    //",
      "    // This will turn off AA on anything which lacks some amount of green.",
      "    // Pure red and blue or combination of only R and B, will get no AA.",
      "    //",
      "    // Might want to lower the settings for both,",
      "    //    fxaaConsoleEdgeThresholdMin",
      "    //    fxaaQualityEdgeThresholdMin",
      "    // In order to insure AA does not get turned off on colors",
      "    // which contain a minor amount of green.",
      "    //",
      "    // 1 = On.",
      "    // 0 = Off.",
      "    //",
      "    #define FXAA_GREEN_AS_LUMA 0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#ifndef FXAA_EARLY_EXIT",
      "    //",
      "    // Controls algorithm's early exit path.",
      "    // On PS3 turning this ON adds 2 cycles to the shader.",
      "    // On 360 turning this OFF adds 10ths of a millisecond to the shader.",
      "    // Turning this off on console will result in a more blurry image.",
      "    // So this defaults to on.",
      "    //",
      "    // 1 = On.",
      "    // 0 = Off.",
      "    //",
      "    #define FXAA_EARLY_EXIT 1",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#ifndef FXAA_DISCARD",
      "    //",
      "    // Only valid for PC OpenGL currently.",
      "    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.",
      "    //",
      "    // 1 = Use discard on pixels which don't need AA.",
      "    //     For APIs which enable concurrent TEX+ROP from same surface.",
      "    // 0 = Return unchanged color on pixels which don't need AA.",
      "    //",
      "    #define FXAA_DISCARD 0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#ifndef FXAA_FAST_PIXEL_OFFSET",
      "    //",
      "    // Used for GLSL 120 only.",
      "    //",
      "    // 1 = GL API supports fast pixel offsets",
      "    // 0 = do not use fast pixel offsets",
      "    //",
      "    #ifdef GL_EXT_gpu_shader4",
      "        #define FXAA_FAST_PIXEL_OFFSET 1",
      "    #endif",
      "    #ifdef GL_NV_gpu_shader5",
      "        #define FXAA_FAST_PIXEL_OFFSET 1",
      "    #endif",
      "    #ifdef GL_ARB_gpu_shader5",
      "        #define FXAA_FAST_PIXEL_OFFSET 1",
      "    #endif",
      "    #ifndef FXAA_FAST_PIXEL_OFFSET",
      "        #define FXAA_FAST_PIXEL_OFFSET 0",
      "    #endif",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#ifndef FXAA_GATHER4_ALPHA",
      "    //",
      "    // 1 = API supports gather4 on alpha channel.",
      "    // 0 = API does not support gather4 on alpha channel.",
      "    //",
      "    #if (FXAA_HLSL_5 == 1)",
      "        #define FXAA_GATHER4_ALPHA 1",
      "    #endif",
      "    #ifdef GL_ARB_gpu_shader5",
      "        #define FXAA_GATHER4_ALPHA 1",
      "    #endif",
      "    #ifdef GL_NV_gpu_shader5",
      "        #define FXAA_GATHER4_ALPHA 1",
      "    #endif",
      "    #ifndef FXAA_GATHER4_ALPHA",
      "        #define FXAA_GATHER4_ALPHA 0",
      "    #endif",
      "#endif",
      "",
      "",
      "/*============================================================================",
      "                        FXAA QUALITY - TUNING KNOBS",
      "------------------------------------------------------------------------------",
      "NOTE the other tuning knobs are now in the shader function inputs!",
      "============================================================================*/",
      "#ifndef FXAA_QUALITY_PRESET",
      "    //",
      "    // Choose the quality preset.",
      "    // This needs to be compiled into the shader as it effects code.",
      "    // Best option to include multiple presets is to",
      "    // in each shader define the preset, then include this file.",
      "    //",
      "    // OPTIONS",
      "    // -----------------------------------------------------------------------",
      "    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)",
      "    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)",
      "    // 39       - no dither, very expensive",
      "    //",
      "    // NOTES",
      "    // -----------------------------------------------------------------------",
      "    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)",
      "    // 13 = about same speed as FXAA 3.9 and better than 12",
      "    // 23 = closest to FXAA 3.9 visually and performance wise",
      "    //  _ = the lowest digit is directly related to performance",
      "    // _  = the highest digit is directly related to style",
      "    //",
      "    #define FXAA_QUALITY_PRESET 12",
      "#endif",
      "",
      "",
      "/*============================================================================",
      "",
      "                           FXAA QUALITY - PRESETS",
      "",
      "============================================================================*/",
      "",
      "/*============================================================================",
      "                     FXAA QUALITY - MEDIUM DITHER PRESETS",
      "============================================================================*/",
      "#if (FXAA_QUALITY_PRESET == 10)",
      "    #define FXAA_QUALITY_PS 3",
      "    #define FXAA_QUALITY_P0 1.5",
      "    #define FXAA_QUALITY_P1 3.0",
      "    #define FXAA_QUALITY_P2 12.0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_QUALITY_PRESET == 11)",
      "    #define FXAA_QUALITY_PS 4",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.5",
      "    #define FXAA_QUALITY_P2 3.0",
      "    #define FXAA_QUALITY_P3 12.0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_QUALITY_PRESET == 12)",
      "    #define FXAA_QUALITY_PS 5",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.5",
      "    #define FXAA_QUALITY_P2 2.0",
      "    #define FXAA_QUALITY_P3 4.0",
      "    #define FXAA_QUALITY_P4 12.0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_QUALITY_PRESET == 13)",
      "    #define FXAA_QUALITY_PS 6",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.5",
      "    #define FXAA_QUALITY_P2 2.0",
      "    #define FXAA_QUALITY_P3 2.0",
      "    #define FXAA_QUALITY_P4 4.0",
      "    #define FXAA_QUALITY_P5 12.0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_QUALITY_PRESET == 14)",
      "    #define FXAA_QUALITY_PS 7",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.5",
      "    #define FXAA_QUALITY_P2 2.0",
      "    #define FXAA_QUALITY_P3 2.0",
      "    #define FXAA_QUALITY_P4 2.0",
      "    #define FXAA_QUALITY_P5 4.0",
      "    #define FXAA_QUALITY_P6 12.0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_QUALITY_PRESET == 15)",
      "    #define FXAA_QUALITY_PS 8",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.5",
      "    #define FXAA_QUALITY_P2 2.0",
      "    #define FXAA_QUALITY_P3 2.0",
      "    #define FXAA_QUALITY_P4 2.0",
      "    #define FXAA_QUALITY_P5 2.0",
      "    #define FXAA_QUALITY_P6 4.0",
      "    #define FXAA_QUALITY_P7 12.0",
      "#endif",
      "",
      "/*============================================================================",
      "                     FXAA QUALITY - LOW DITHER PRESETS",
      "============================================================================*/",
      "#if (FXAA_QUALITY_PRESET == 20)",
      "    #define FXAA_QUALITY_PS 3",
      "    #define FXAA_QUALITY_P0 1.5",
      "    #define FXAA_QUALITY_P1 2.0",
      "    #define FXAA_QUALITY_P2 8.0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_QUALITY_PRESET == 21)",
      "    #define FXAA_QUALITY_PS 4",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.5",
      "    #define FXAA_QUALITY_P2 2.0",
      "    #define FXAA_QUALITY_P3 8.0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_QUALITY_PRESET == 22)",
      "    #define FXAA_QUALITY_PS 5",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.5",
      "    #define FXAA_QUALITY_P2 2.0",
      "    #define FXAA_QUALITY_P3 2.0",
      "    #define FXAA_QUALITY_P4 8.0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_QUALITY_PRESET == 23)",
      "    #define FXAA_QUALITY_PS 6",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.5",
      "    #define FXAA_QUALITY_P2 2.0",
      "    #define FXAA_QUALITY_P3 2.0",
      "    #define FXAA_QUALITY_P4 2.0",
      "    #define FXAA_QUALITY_P5 8.0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_QUALITY_PRESET == 24)",
      "    #define FXAA_QUALITY_PS 7",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.5",
      "    #define FXAA_QUALITY_P2 2.0",
      "    #define FXAA_QUALITY_P3 2.0",
      "    #define FXAA_QUALITY_P4 2.0",
      "    #define FXAA_QUALITY_P5 3.0",
      "    #define FXAA_QUALITY_P6 8.0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_QUALITY_PRESET == 25)",
      "    #define FXAA_QUALITY_PS 8",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.5",
      "    #define FXAA_QUALITY_P2 2.0",
      "    #define FXAA_QUALITY_P3 2.0",
      "    #define FXAA_QUALITY_P4 2.0",
      "    #define FXAA_QUALITY_P5 2.0",
      "    #define FXAA_QUALITY_P6 4.0",
      "    #define FXAA_QUALITY_P7 8.0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_QUALITY_PRESET == 26)",
      "    #define FXAA_QUALITY_PS 9",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.5",
      "    #define FXAA_QUALITY_P2 2.0",
      "    #define FXAA_QUALITY_P3 2.0",
      "    #define FXAA_QUALITY_P4 2.0",
      "    #define FXAA_QUALITY_P5 2.0",
      "    #define FXAA_QUALITY_P6 2.0",
      "    #define FXAA_QUALITY_P7 4.0",
      "    #define FXAA_QUALITY_P8 8.0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_QUALITY_PRESET == 27)",
      "    #define FXAA_QUALITY_PS 10",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.5",
      "    #define FXAA_QUALITY_P2 2.0",
      "    #define FXAA_QUALITY_P3 2.0",
      "    #define FXAA_QUALITY_P4 2.0",
      "    #define FXAA_QUALITY_P5 2.0",
      "    #define FXAA_QUALITY_P6 2.0",
      "    #define FXAA_QUALITY_P7 2.0",
      "    #define FXAA_QUALITY_P8 4.0",
      "    #define FXAA_QUALITY_P9 8.0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_QUALITY_PRESET == 28)",
      "    #define FXAA_QUALITY_PS 11",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.5",
      "    #define FXAA_QUALITY_P2 2.0",
      "    #define FXAA_QUALITY_P3 2.0",
      "    #define FXAA_QUALITY_P4 2.0",
      "    #define FXAA_QUALITY_P5 2.0",
      "    #define FXAA_QUALITY_P6 2.0",
      "    #define FXAA_QUALITY_P7 2.0",
      "    #define FXAA_QUALITY_P8 2.0",
      "    #define FXAA_QUALITY_P9 4.0",
      "    #define FXAA_QUALITY_P10 8.0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_QUALITY_PRESET == 29)",
      "    #define FXAA_QUALITY_PS 12",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.5",
      "    #define FXAA_QUALITY_P2 2.0",
      "    #define FXAA_QUALITY_P3 2.0",
      "    #define FXAA_QUALITY_P4 2.0",
      "    #define FXAA_QUALITY_P5 2.0",
      "    #define FXAA_QUALITY_P6 2.0",
      "    #define FXAA_QUALITY_P7 2.0",
      "    #define FXAA_QUALITY_P8 2.0",
      "    #define FXAA_QUALITY_P9 2.0",
      "    #define FXAA_QUALITY_P10 4.0",
      "    #define FXAA_QUALITY_P11 8.0",
      "#endif",
      "",
      "/*============================================================================",
      "                     FXAA QUALITY - EXTREME QUALITY",
      "============================================================================*/",
      "#if (FXAA_QUALITY_PRESET == 39)",
      "    #define FXAA_QUALITY_PS 12",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.0",
      "    #define FXAA_QUALITY_P2 1.0",
      "    #define FXAA_QUALITY_P3 1.0",
      "    #define FXAA_QUALITY_P4 1.0",
      "    #define FXAA_QUALITY_P5 1.5",
      "    #define FXAA_QUALITY_P6 2.0",
      "    #define FXAA_QUALITY_P7 2.0",
      "    #define FXAA_QUALITY_P8 2.0",
      "    #define FXAA_QUALITY_P9 2.0",
      "    #define FXAA_QUALITY_P10 4.0",
      "    #define FXAA_QUALITY_P11 8.0",
      "#endif",
      "",
      "",
      "",
      "/*============================================================================",
      "",
      "                                API PORTING",
      "",
      "============================================================================*/",
      "#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)",
      "    #define FxaaBool bool",
      "    #define FxaaDiscard discard",
      "    #define FxaaFloat float",
      "    #define FxaaFloat2 vec2",
      "    #define FxaaFloat3 vec3",
      "    #define FxaaFloat4 vec4",
      "    #define FxaaHalf float",
      "    #define FxaaHalf2 vec2",
      "    #define FxaaHalf3 vec3",
      "    #define FxaaHalf4 vec4",
      "    #define FxaaInt2 ivec2",
      "    #define FxaaSat(x) clamp(x, 0.0, 1.0)",
      "    #define FxaaTex sampler2D",
      "#else",
      "    #define FxaaBool bool",
      "    #define FxaaDiscard clip(-1)",
      "    #define FxaaFloat float",
      "    #define FxaaFloat2 float2",
      "    #define FxaaFloat3 float3",
      "    #define FxaaFloat4 float4",
      "    #define FxaaHalf half",
      "    #define FxaaHalf2 half2",
      "    #define FxaaHalf3 half3",
      "    #define FxaaHalf4 half4",
      "    #define FxaaSat(x) saturate(x)",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_GLSL_100 == 1)",
      "  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)",
      "  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_GLSL_120 == 1)",
      "    // Requires,",
      "    //  #version 120",
      "    // And at least,",
      "    //  #extension GL_EXT_gpu_shader4 : enable",
      "    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)",
      "    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)",
      "    #if (FXAA_FAST_PIXEL_OFFSET == 1)",
      "        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)",
      "    #else",
      "        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)",
      "    #endif",
      "    #if (FXAA_GATHER4_ALPHA == 1)",
      "        // use #extension GL_ARB_gpu_shader5 : enable",
      "        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)",
      "        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)",
      "        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)",
      "        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)",
      "    #endif",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_GLSL_130 == 1)",
      '    // Requires "#version 130" or better',
      "    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)",
      "    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)",
      "    #if (FXAA_GATHER4_ALPHA == 1)",
      "        // use #extension GL_ARB_gpu_shader5 : enable",
      "        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)",
      "        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)",
      "        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)",
      "        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)",
      "    #endif",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_HLSL_3 == 1)",
      "    #define FxaaInt2 float2",
      "    #define FxaaTex sampler2D",
      "    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))",
      "    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_HLSL_4 == 1)",
      "    #define FxaaInt2 int2",
      "    struct FxaaTex { SamplerState smpl; Texture2D tex; };",
      "    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)",
      "    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_HLSL_5 == 1)",
      "    #define FxaaInt2 int2",
      "    struct FxaaTex { SamplerState smpl; Texture2D tex; };",
      "    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)",
      "    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)",
      "    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)",
      "    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)",
      "    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)",
      "    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)",
      "#endif",
      "",
      "",
      "/*============================================================================",
      "                   GREEN AS LUMA OPTION SUPPORT FUNCTION",
      "============================================================================*/",
      "#if (FXAA_GREEN_AS_LUMA == 0)",
      "    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }",
      "#else",
      "    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }",
      "#endif",
      "",
      "",
      "",
      "",
      "/*============================================================================",
      "",
      "                             FXAA3 QUALITY - PC",
      "",
      "============================================================================*/",
      "#if (FXAA_PC == 1)",
      "/*--------------------------------------------------------------------------*/",
      "FxaaFloat4 FxaaPixelShader(",
      "    //",
      "    // Use noperspective interpolation here (turn off perspective interpolation).",
      "    // {xy} = center of pixel",
      "    FxaaFloat2 pos,",
      "    //",
      "    // Used only for FXAA Console, and not used on the 360 version.",
      "    // Use noperspective interpolation here (turn off perspective interpolation).",
      "    // {xy_} = upper left of pixel",
      "    // {_zw} = lower right of pixel",
      "    FxaaFloat4 fxaaConsolePosPos,",
      "    //",
      "    // Input color texture.",
      "    // {rgb_} = color in linear or perceptual color space",
      "    // if (FXAA_GREEN_AS_LUMA == 0)",
      "    //     {__a} = luma in perceptual color space (not linear)",
      "    FxaaTex tex,",
      "    //",
      "    // Only used on the optimized 360 version of FXAA Console.",
      '    // For everything but 360, just use the same input here as for "tex".',
      "    // For 360, same texture, just alias with a 2nd sampler.",
      "    // This sampler needs to have an exponent bias of -1.",
      "    FxaaTex fxaaConsole360TexExpBiasNegOne,",
      "    //",
      "    // Only used on the optimized 360 version of FXAA Console.",
      '    // For everything but 360, just use the same input here as for "tex".',
      "    // For 360, same texture, just alias with a 3nd sampler.",
      "    // This sampler needs to have an exponent bias of -2.",
      "    FxaaTex fxaaConsole360TexExpBiasNegTwo,",
      "    //",
      "    // Only used on FXAA Quality.",
      "    // This must be from a constant/uniform.",
      "    // {x_} = 1.0/screenWidthInPixels",
      "    // {_y} = 1.0/screenHeightInPixels",
      "    FxaaFloat2 fxaaQualityRcpFrame,",
      "    //",
      "    // Only used on FXAA Console.",
      "    // This must be from a constant/uniform.",
      "    // This effects sub-pixel AA quality and inversely sharpness.",
      "    //   Where N ranges between,",
      "    //     N = 0.50 (default)",
      "    //     N = 0.33 (sharper)",
      "    // {x__} = -N/screenWidthInPixels",
      "    // {_y_} = -N/screenHeightInPixels",
      "    // {_z_} =  N/screenWidthInPixels",
      "    // {__w} =  N/screenHeightInPixels",
      "    FxaaFloat4 fxaaConsoleRcpFrameOpt,",
      "    //",
      "    // Only used on FXAA Console.",
      "    // Not used on 360, but used on PS3 and PC.",
      "    // This must be from a constant/uniform.",
      "    // {x__} = -2.0/screenWidthInPixels",
      "    // {_y_} = -2.0/screenHeightInPixels",
      "    // {_z_} =  2.0/screenWidthInPixels",
      "    // {__w} =  2.0/screenHeightInPixels",
      "    FxaaFloat4 fxaaConsoleRcpFrameOpt2,",
      "    //",
      "    // Only used on FXAA Console.",
      "    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.",
      "    // This must be from a constant/uniform.",
      "    // {x__} =  8.0/screenWidthInPixels",
      "    // {_y_} =  8.0/screenHeightInPixels",
      "    // {_z_} = -4.0/screenWidthInPixels",
      "    // {__w} = -4.0/screenHeightInPixels",
      "    FxaaFloat4 fxaaConsole360RcpFrameOpt2,",
      "    //",
      "    // Only used on FXAA Quality.",
      "    // This used to be the FXAA_QUALITY_SUBPIX define.",
      "    // It is here now to allow easier tuning.",
      "    // Choose the amount of sub-pixel aliasing removal.",
      "    // This can effect sharpness.",
      "    //   1.00 - upper limit (softer)",
      "    //   0.75 - default amount of filtering",
      "    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)",
      "    //   0.25 - almost off",
      "    //   0.00 - completely off",
      "    FxaaFloat fxaaQualitySubpix,",
      "    //",
      "    // Only used on FXAA Quality.",
      "    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.",
      "    // It is here now to allow easier tuning.",
      "    // The minimum amount of local contrast required to apply algorithm.",
      "    //   0.333 - too little (faster)",
      "    //   0.250 - low quality",
      "    //   0.166 - default",
      "    //   0.125 - high quality",
      "    //   0.063 - overkill (slower)",
      "    FxaaFloat fxaaQualityEdgeThreshold,",
      "    //",
      "    // Only used on FXAA Quality.",
      "    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.",
      "    // It is here now to allow easier tuning.",
      "    // Trims the algorithm from processing darks.",
      "    //   0.0833 - upper limit (default, the start of visible unfiltered edges)",
      "    //   0.0625 - high quality (faster)",
      "    //   0.0312 - visible limit (slower)",
      "    // Special notes when using FXAA_GREEN_AS_LUMA,",
      "    //   Likely want to set this to zero.",
      "    //   As colors that are mostly not-green",
      "    //   will appear very dark in the green channel!",
      "    //   Tune by looking at mostly non-green content,",
      "    //   then start at zero and increase until aliasing is a problem.",
      "    FxaaFloat fxaaQualityEdgeThresholdMin,",
      "    //",
      "    // Only used on FXAA Console.",
      "    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.",
      "    // It is here now to allow easier tuning.",
      "    // This does not effect PS3, as this needs to be compiled in.",
      "    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.",
      "    //   Due to the PS3 being ALU bound,",
      "    //   there are only three safe values here: 2 and 4 and 8.",
      "    //   These options use the shaders ability to a free *|/ by 2|4|8.",
      "    // For all other platforms can be a non-power of two.",
      "    //   8.0 is sharper (default!!!)",
      "    //   4.0 is softer",
      "    //   2.0 is really soft (good only for vector graphics inputs)",
      "    FxaaFloat fxaaConsoleEdgeSharpness,",
      "    //",
      "    // Only used on FXAA Console.",
      "    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.",
      "    // It is here now to allow easier tuning.",
      "    // This does not effect PS3, as this needs to be compiled in.",
      "    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.",
      "    //   Due to the PS3 being ALU bound,",
      "    //   there are only two safe values here: 1/4 and 1/8.",
      "    //   These options use the shaders ability to a free *|/ by 2|4|8.",
      "    // The console setting has a different mapping than the quality setting.",
      "    // Other platforms can use other values.",
      "    //   0.125 leaves less aliasing, but is softer (default!!!)",
      "    //   0.25 leaves more aliasing, and is sharper",
      "    FxaaFloat fxaaConsoleEdgeThreshold,",
      "    //",
      "    // Only used on FXAA Console.",
      "    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.",
      "    // It is here now to allow easier tuning.",
      "    // Trims the algorithm from processing darks.",
      "    // The console setting has a different mapping than the quality setting.",
      "    // This only applies when FXAA_EARLY_EXIT is 1.",
      "    // This does not apply to PS3,",
      "    // PS3 was simplified to avoid more shader instructions.",
      "    //   0.06 - faster but more aliasing in darks",
      "    //   0.05 - default",
      "    //   0.04 - slower and less aliasing in darks",
      "    // Special notes when using FXAA_GREEN_AS_LUMA,",
      "    //   Likely want to set this to zero.",
      "    //   As colors that are mostly not-green",
      "    //   will appear very dark in the green channel!",
      "    //   Tune by looking at mostly non-green content,",
      "    //   then start at zero and increase until aliasing is a problem.",
      "    FxaaFloat fxaaConsoleEdgeThresholdMin,",
      "    //",
      "    // Extra constants for 360 FXAA Console only.",
      "    // Use zeros or anything else for other platforms.",
      "    // These must be in physical constant registers and NOT immediates.",
      "    // Immediates will result in compiler un-optimizing.",
      "    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)",
      "    FxaaFloat4 fxaaConsole360ConstDir",
      ") {",
      "/*--------------------------------------------------------------------------*/",
      "    FxaaFloat2 posM;",
      "    posM.x = pos.x;",
      "    posM.y = pos.y;",
      "    #if (FXAA_GATHER4_ALPHA == 1)",
      "        #if (FXAA_DISCARD == 0)",
      "            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);",
      "            #if (FXAA_GREEN_AS_LUMA == 0)",
      "                #define lumaM rgbyM.w",
      "            #else",
      "                #define lumaM rgbyM.y",
      "            #endif",
      "        #endif",
      "        #if (FXAA_GREEN_AS_LUMA == 0)",
      "            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);",
      "            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));",
      "        #else",
      "            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);",
      "            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));",
      "        #endif",
      "        #if (FXAA_DISCARD == 1)",
      "            #define lumaM luma4A.w",
      "        #endif",
      "        #define lumaE luma4A.z",
      "        #define lumaS luma4A.x",
      "        #define lumaSE luma4A.y",
      "        #define lumaNW luma4B.w",
      "        #define lumaN luma4B.z",
      "        #define lumaW luma4B.x",
      "    #else",
      "        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);",
      "        #if (FXAA_GREEN_AS_LUMA == 0)",
      "            #define lumaM rgbyM.w",
      "        #else",
      "            #define lumaM rgbyM.y",
      "        #endif",
      "        #if (FXAA_GLSL_100 == 1)",
      "          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));",
      "          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));",
      "          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));",
      "          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));",
      "        #else",
      "          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));",
      "          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));",
      "          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));",
      "          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));",
      "        #endif",
      "    #endif",
      "/*--------------------------------------------------------------------------*/",
      "    FxaaFloat maxSM = max(lumaS, lumaM);",
      "    FxaaFloat minSM = min(lumaS, lumaM);",
      "    FxaaFloat maxESM = max(lumaE, maxSM);",
      "    FxaaFloat minESM = min(lumaE, minSM);",
      "    FxaaFloat maxWN = max(lumaN, lumaW);",
      "    FxaaFloat minWN = min(lumaN, lumaW);",
      "    FxaaFloat rangeMax = max(maxWN, maxESM);",
      "    FxaaFloat rangeMin = min(minWN, minESM);",
      "    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;",
      "    FxaaFloat range = rangeMax - rangeMin;",
      "    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);",
      "    FxaaBool earlyExit = range < rangeMaxClamped;",
      "/*--------------------------------------------------------------------------*/",
      "    if(earlyExit)",
      "        #if (FXAA_DISCARD == 1)",
      "            FxaaDiscard;",
      "        #else",
      "            return rgbyM;",
      "        #endif",
      "/*--------------------------------------------------------------------------*/",
      "    #if (FXAA_GATHER4_ALPHA == 0)",
      "        #if (FXAA_GLSL_100 == 1)",
      "          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));",
      "          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));",
      "          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));",
      "          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));",
      "        #else",
      "          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));",
      "          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));",
      "          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));",
      "          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));",
      "        #endif",
      "    #else",
      "        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));",
      "        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));",
      "    #endif",
      "/*--------------------------------------------------------------------------*/",
      "    FxaaFloat lumaNS = lumaN + lumaS;",
      "    FxaaFloat lumaWE = lumaW + lumaE;",
      "    FxaaFloat subpixRcpRange = 1.0/range;",
      "    FxaaFloat subpixNSWE = lumaNS + lumaWE;",
      "    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;",
      "    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;",
      "/*--------------------------------------------------------------------------*/",
      "    FxaaFloat lumaNESE = lumaNE + lumaSE;",
      "    FxaaFloat lumaNWNE = lumaNW + lumaNE;",
      "    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;",
      "    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;",
      "/*--------------------------------------------------------------------------*/",
      "    FxaaFloat lumaNWSW = lumaNW + lumaSW;",
      "    FxaaFloat lumaSWSE = lumaSW + lumaSE;",
      "    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);",
      "    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);",
      "    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;",
      "    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;",
      "    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;",
      "    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;",
      "/*--------------------------------------------------------------------------*/",
      "    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;",
      "    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;",
      "    FxaaBool horzSpan = edgeHorz >= edgeVert;",
      "    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;",
      "/*--------------------------------------------------------------------------*/",
      "    if(!horzSpan) lumaN = lumaW;",
      "    if(!horzSpan) lumaS = lumaE;",
      "    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;",
      "    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;",
      "/*--------------------------------------------------------------------------*/",
      "    FxaaFloat gradientN = lumaN - lumaM;",
      "    FxaaFloat gradientS = lumaS - lumaM;",
      "    FxaaFloat lumaNN = lumaN + lumaM;",
      "    FxaaFloat lumaSS = lumaS + lumaM;",
      "    FxaaBool pairN = abs(gradientN) >= abs(gradientS);",
      "    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));",
      "    if(pairN) lengthSign = -lengthSign;",
      "    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);",
      "/*--------------------------------------------------------------------------*/",
      "    FxaaFloat2 posB;",
      "    posB.x = posM.x;",
      "    posB.y = posM.y;",
      "    FxaaFloat2 offNP;",
      "    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;",
      "    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;",
      "    if(!horzSpan) posB.x += lengthSign * 0.5;",
      "    if( horzSpan) posB.y += lengthSign * 0.5;",
      "/*--------------------------------------------------------------------------*/",
      "    FxaaFloat2 posN;",
      "    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;",
      "    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;",
      "    FxaaFloat2 posP;",
      "    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;",
      "    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;",
      "    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;",
      "    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));",
      "    FxaaFloat subpixE = subpixC * subpixC;",
      "    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));",
      "/*--------------------------------------------------------------------------*/",
      "    if(!pairN) lumaNN = lumaSS;",
      "    FxaaFloat gradientScaled = gradient * 1.0/4.0;",
      "    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;",
      "    FxaaFloat subpixF = subpixD * subpixE;",
      "    FxaaBool lumaMLTZero = lumaMM < 0.0;",
      "/*--------------------------------------------------------------------------*/",
      "    lumaEndN -= lumaNN * 0.5;",
      "    lumaEndP -= lumaNN * 0.5;",
      "    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;",
      "    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;",
      "    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;",
      "    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;",
      "    FxaaBool doneNP = (!doneN) || (!doneP);",
      "    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;",
      "    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;",
      "/*--------------------------------------------------------------------------*/",
      "    if(doneNP) {",
      "        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
      "        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
      "        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
      "        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
      "        doneN = abs(lumaEndN) >= gradientScaled;",
      "        doneP = abs(lumaEndP) >= gradientScaled;",
      "        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;",
      "        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;",
      "        doneNP = (!doneN) || (!doneP);",
      "        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;",
      "        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;",
      "/*--------------------------------------------------------------------------*/",
      "        #if (FXAA_QUALITY_PS > 3)",
      "        if(doneNP) {",
      "            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
      "            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
      "            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
      "            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
      "            doneN = abs(lumaEndN) >= gradientScaled;",
      "            doneP = abs(lumaEndP) >= gradientScaled;",
      "            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;",
      "            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;",
      "            doneNP = (!doneN) || (!doneP);",
      "            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;",
      "            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;",
      "/*--------------------------------------------------------------------------*/",
      "            #if (FXAA_QUALITY_PS > 4)",
      "            if(doneNP) {",
      "                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
      "                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
      "                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
      "                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
      "                doneN = abs(lumaEndN) >= gradientScaled;",
      "                doneP = abs(lumaEndP) >= gradientScaled;",
      "                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;",
      "                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;",
      "                doneNP = (!doneN) || (!doneP);",
      "                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;",
      "                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;",
      "/*--------------------------------------------------------------------------*/",
      "                #if (FXAA_QUALITY_PS > 5)",
      "                if(doneNP) {",
      "                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
      "                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
      "                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
      "                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
      "                    doneN = abs(lumaEndN) >= gradientScaled;",
      "                    doneP = abs(lumaEndP) >= gradientScaled;",
      "                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;",
      "                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;",
      "                    doneNP = (!doneN) || (!doneP);",
      "                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;",
      "                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;",
      "/*--------------------------------------------------------------------------*/",
      "                    #if (FXAA_QUALITY_PS > 6)",
      "                    if(doneNP) {",
      "                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
      "                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
      "                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
      "                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
      "                        doneN = abs(lumaEndN) >= gradientScaled;",
      "                        doneP = abs(lumaEndP) >= gradientScaled;",
      "                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;",
      "                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;",
      "                        doneNP = (!doneN) || (!doneP);",
      "                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;",
      "                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;",
      "/*--------------------------------------------------------------------------*/",
      "                        #if (FXAA_QUALITY_PS > 7)",
      "                        if(doneNP) {",
      "                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
      "                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
      "                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
      "                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
      "                            doneN = abs(lumaEndN) >= gradientScaled;",
      "                            doneP = abs(lumaEndP) >= gradientScaled;",
      "                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;",
      "                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;",
      "                            doneNP = (!doneN) || (!doneP);",
      "                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;",
      "                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;",
      "/*--------------------------------------------------------------------------*/",
      "    #if (FXAA_QUALITY_PS > 8)",
      "    if(doneNP) {",
      "        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
      "        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
      "        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
      "        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
      "        doneN = abs(lumaEndN) >= gradientScaled;",
      "        doneP = abs(lumaEndP) >= gradientScaled;",
      "        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;",
      "        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;",
      "        doneNP = (!doneN) || (!doneP);",
      "        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;",
      "        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;",
      "/*--------------------------------------------------------------------------*/",
      "        #if (FXAA_QUALITY_PS > 9)",
      "        if(doneNP) {",
      "            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
      "            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
      "            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
      "            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
      "            doneN = abs(lumaEndN) >= gradientScaled;",
      "            doneP = abs(lumaEndP) >= gradientScaled;",
      "            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;",
      "            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;",
      "            doneNP = (!doneN) || (!doneP);",
      "            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;",
      "            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;",
      "/*--------------------------------------------------------------------------*/",
      "            #if (FXAA_QUALITY_PS > 10)",
      "            if(doneNP) {",
      "                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
      "                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
      "                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
      "                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
      "                doneN = abs(lumaEndN) >= gradientScaled;",
      "                doneP = abs(lumaEndP) >= gradientScaled;",
      "                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;",
      "                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;",
      "                doneNP = (!doneN) || (!doneP);",
      "                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;",
      "                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;",
      "/*--------------------------------------------------------------------------*/",
      "                #if (FXAA_QUALITY_PS > 11)",
      "                if(doneNP) {",
      "                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
      "                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
      "                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
      "                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
      "                    doneN = abs(lumaEndN) >= gradientScaled;",
      "                    doneP = abs(lumaEndP) >= gradientScaled;",
      "                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;",
      "                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;",
      "                    doneNP = (!doneN) || (!doneP);",
      "                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;",
      "                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;",
      "/*--------------------------------------------------------------------------*/",
      "                    #if (FXAA_QUALITY_PS > 12)",
      "                    if(doneNP) {",
      "                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
      "                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
      "                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
      "                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
      "                        doneN = abs(lumaEndN) >= gradientScaled;",
      "                        doneP = abs(lumaEndP) >= gradientScaled;",
      "                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;",
      "                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;",
      "                        doneNP = (!doneN) || (!doneP);",
      "                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;",
      "                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;",
      "/*--------------------------------------------------------------------------*/",
      "                    }",
      "                    #endif",
      "/*--------------------------------------------------------------------------*/",
      "                }",
      "                #endif",
      "/*--------------------------------------------------------------------------*/",
      "            }",
      "            #endif",
      "/*--------------------------------------------------------------------------*/",
      "        }",
      "        #endif",
      "/*--------------------------------------------------------------------------*/",
      "    }",
      "    #endif",
      "/*--------------------------------------------------------------------------*/",
      "                        }",
      "                        #endif",
      "/*--------------------------------------------------------------------------*/",
      "                    }",
      "                    #endif",
      "/*--------------------------------------------------------------------------*/",
      "                }",
      "                #endif",
      "/*--------------------------------------------------------------------------*/",
      "            }",
      "            #endif",
      "/*--------------------------------------------------------------------------*/",
      "        }",
      "        #endif",
      "/*--------------------------------------------------------------------------*/",
      "    }",
      "/*--------------------------------------------------------------------------*/",
      "    FxaaFloat dstN = posM.x - posN.x;",
      "    FxaaFloat dstP = posP.x - posM.x;",
      "    if(!horzSpan) dstN = posM.y - posN.y;",
      "    if(!horzSpan) dstP = posP.y - posM.y;",
      "/*--------------------------------------------------------------------------*/",
      "    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;",
      "    FxaaFloat spanLength = (dstP + dstN);",
      "    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;",
      "    FxaaFloat spanLengthRcp = 1.0/spanLength;",
      "/*--------------------------------------------------------------------------*/",
      "    FxaaBool directionN = dstN < dstP;",
      "    FxaaFloat dst = min(dstN, dstP);",
      "    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;",
      "    FxaaFloat subpixG = subpixF * subpixF;",
      "    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;",
      "    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;",
      "/*--------------------------------------------------------------------------*/",
      "    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;",
      "    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);",
      "    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;",
      "    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;",
      "    #if (FXAA_DISCARD == 1)",
      "        return FxaaTexTop(tex, posM);",
      "    #else",
      "        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);",
      "    #endif",
      "}",
      "/*==========================================================================*/",
      "#endif",
      "",
      "void main() {",
      "  gl_FragColor = FxaaPixelShader(",
      "    vUv,",
      "    vec4(0.0),",
      "    tDiffuse,",
      "    tDiffuse,",
      "    tDiffuse,",
      "    resolution,",
      "    vec4(0.0),",
      "    vec4(0.0),",
      "    vec4(0.0),",
      "    0.75,",
      "    0.166,",
      "    0.0833,",
      "    0.0,",
      "    0.0,",
      "    0.0,",
      "    vec4(0.0)",
      "  );",
      "",
      "  // TODO avoid querying texture twice for same texel",
      "  gl_FragColor.a = texture2D(tDiffuse, vUv).a;",
      "}"
    ].join("\n")
  };

  // node_modules/three/examples/jsm/lines/LineMaterial.js
  UniformsLib.line = {
    linewidth: { value: 1 },
    resolution: { value: new Vector2(1, 1) },
    dashScale: { value: 1 },
    dashSize: { value: 1 },
    dashOffset: { value: 0 },
    gapSize: { value: 1 },
    opacity: { value: 1 }
  };
  ShaderLib["line"] = {
    uniforms: UniformsUtils.merge([
      UniformsLib.common,
      UniformsLib.fog,
      UniformsLib.line
    ]),
    vertexShader: `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		varying vec2 vUv;

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;

			#endif

			float aspect = resolution.x / resolution.y;

			vUv = uv;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec2 ndcStart = clipStart.xy / clipStart.w;
			vec2 ndcEnd = clipEnd.xy / clipEnd.w;

			// direction
			vec2 dir = ndcEnd - ndcStart;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			// perpendicular to dir
			vec2 offset = vec2( dir.y, - dir.x );

			// undo aspect ratio adjustment
			dir.x /= aspect;
			offset.x /= aspect;

			// sign flip
			if ( position.x < 0.0 ) offset *= - 1.0;

			// endcaps
			if ( position.y < 0.0 ) {

				offset += - dir;

			} else if ( position.y > 1.0 ) {

				offset += dir;

			}

			// adjust for linewidth
			offset *= linewidth;

			// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
			offset /= resolution.y;

			// select end
			vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

			// back to clip space
			offset *= clip.w;

			clip.xy += offset;

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,
    fragmentShader: `
		uniform vec3 diffuse;
		uniform float opacity;

		#ifdef USE_DASH

			uniform float dashSize;
			uniform float dashOffset;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		varying vec2 vUv;

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef ALPHA_TO_COVERAGE

			// artifacts appear on some hardware if a derivative is taken within a conditional
			float a = vUv.x;
			float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
			float len2 = a * a + b * b;
			float dlen = fwidth( len2 );

			if ( abs( vUv.y ) > 1.0 ) {

				alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

			}

			#else

			if ( abs( vUv.y ) > 1.0 ) {

				float a = vUv.x;
				float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
				float len2 = a * a + b * b;

				if ( len2 > 1.0 ) discard;

			}

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  };
  var LineMaterial = function(parameters) {
    ShaderMaterial.call(this, {
      type: "LineMaterial",
      uniforms: UniformsUtils.clone(ShaderLib["line"].uniforms),
      vertexShader: ShaderLib["line"].vertexShader,
      fragmentShader: ShaderLib["line"].fragmentShader,
      clipping: true
    });
    this.dashed = false;
    Object.defineProperties(this, {
      color: {
        enumerable: true,
        get: function() {
          return this.uniforms.diffuse.value;
        },
        set: function(value) {
          this.uniforms.diffuse.value = value;
        }
      },
      linewidth: {
        enumerable: true,
        get: function() {
          return this.uniforms.linewidth.value;
        },
        set: function(value) {
          this.uniforms.linewidth.value = value;
        }
      },
      dashScale: {
        enumerable: true,
        get: function() {
          return this.uniforms.dashScale.value;
        },
        set: function(value) {
          this.uniforms.dashScale.value = value;
        }
      },
      dashSize: {
        enumerable: true,
        get: function() {
          return this.uniforms.dashSize.value;
        },
        set: function(value) {
          this.uniforms.dashSize.value = value;
        }
      },
      dashOffset: {
        enumerable: true,
        get: function() {
          return this.uniforms.dashOffset.value;
        },
        set: function(value) {
          this.uniforms.dashOffset.value = value;
        }
      },
      gapSize: {
        enumerable: true,
        get: function() {
          return this.uniforms.gapSize.value;
        },
        set: function(value) {
          this.uniforms.gapSize.value = value;
        }
      },
      opacity: {
        enumerable: true,
        get: function() {
          return this.uniforms.opacity.value;
        },
        set: function(value) {
          this.uniforms.opacity.value = value;
        }
      },
      resolution: {
        enumerable: true,
        get: function() {
          return this.uniforms.resolution.value;
        },
        set: function(value) {
          this.uniforms.resolution.value.copy(value);
        }
      },
      alphaToCoverage: {
        enumerable: true,
        get: function() {
          return Boolean("ALPHA_TO_COVERAGE" in this.defines);
        },
        set: function(value) {
          if (Boolean(value) !== Boolean("ALPHA_TO_COVERAGE" in this.defines)) {
            this.needsUpdate = true;
          }
          if (value) {
            this.defines.ALPHA_TO_COVERAGE = "";
            this.extensions.derivatives = true;
          } else {
            delete this.defines.ALPHA_TO_COVERAGE;
            this.extensions.derivatives = false;
          }
        }
      }
    });
    this.setValues(parameters);
  };
  LineMaterial.prototype = Object.create(ShaderMaterial.prototype);
  LineMaterial.prototype.constructor = LineMaterial;
  LineMaterial.prototype.isLineMaterial = true;

  // node_modules/three/examples/jsm/lines/LineSegmentsGeometry.js
  var LineSegmentsGeometry = function() {
    InstancedBufferGeometry.call(this);
    this.type = "LineSegmentsGeometry";
    var positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];
    var uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];
    var index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(index);
    this.setAttribute("position", new Float32BufferAttribute(positions, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  };
  LineSegmentsGeometry.prototype = Object.assign(Object.create(InstancedBufferGeometry.prototype), {
    constructor: LineSegmentsGeometry,
    isLineSegmentsGeometry: true,
    applyMatrix4: function(matrix) {
      var start = this.attributes.instanceStart;
      var end = this.attributes.instanceEnd;
      if (start !== void 0) {
        start.applyMatrix4(matrix);
        end.applyMatrix4(matrix);
        start.needsUpdate = true;
      }
      if (this.boundingBox !== null) {
        this.computeBoundingBox();
      }
      if (this.boundingSphere !== null) {
        this.computeBoundingSphere();
      }
      return this;
    },
    setPositions: function(array) {
      var lineSegments;
      if (array instanceof Float32Array) {
        lineSegments = array;
      } else if (Array.isArray(array)) {
        lineSegments = new Float32Array(array);
      }
      var instanceBuffer = new InstancedInterleavedBuffer(lineSegments, 6, 1);
      this.setAttribute("instanceStart", new InterleavedBufferAttribute(instanceBuffer, 3, 0));
      this.setAttribute("instanceEnd", new InterleavedBufferAttribute(instanceBuffer, 3, 3));
      this.computeBoundingBox();
      this.computeBoundingSphere();
      return this;
    },
    setColors: function(array) {
      var colors;
      if (array instanceof Float32Array) {
        colors = array;
      } else if (Array.isArray(array)) {
        colors = new Float32Array(array);
      }
      var instanceColorBuffer = new InstancedInterleavedBuffer(colors, 6, 1);
      this.setAttribute("instanceColorStart", new InterleavedBufferAttribute(instanceColorBuffer, 3, 0));
      this.setAttribute("instanceColorEnd", new InterleavedBufferAttribute(instanceColorBuffer, 3, 3));
      return this;
    },
    fromWireframeGeometry: function(geometry) {
      this.setPositions(geometry.attributes.position.array);
      return this;
    },
    fromEdgesGeometry: function(geometry) {
      this.setPositions(geometry.attributes.position.array);
      return this;
    },
    fromMesh: function(mesh) {
      this.fromWireframeGeometry(new WireframeGeometry(mesh.geometry));
      return this;
    },
    fromLineSegments: function(lineSegments) {
      var geometry = lineSegments.geometry;
      if (geometry.isGeometry) {
        console.error("THREE.LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.");
        return;
      } else if (geometry.isBufferGeometry) {
        this.setPositions(geometry.attributes.position.array);
      }
      return this;
    },
    computeBoundingBox: function() {
      var box = new Box3();
      return function computeBoundingBox() {
        if (this.boundingBox === null) {
          this.boundingBox = new Box3();
        }
        var start = this.attributes.instanceStart;
        var end = this.attributes.instanceEnd;
        if (start !== void 0 && end !== void 0) {
          this.boundingBox.setFromBufferAttribute(start);
          box.setFromBufferAttribute(end);
          this.boundingBox.union(box);
        }
      };
    }(),
    computeBoundingSphere: function() {
      var vector = new Vector3();
      return function computeBoundingSphere() {
        if (this.boundingSphere === null) {
          this.boundingSphere = new Sphere();
        }
        if (this.boundingBox === null) {
          this.computeBoundingBox();
        }
        var start = this.attributes.instanceStart;
        var end = this.attributes.instanceEnd;
        if (start !== void 0 && end !== void 0) {
          var center = this.boundingSphere.center;
          this.boundingBox.getCenter(center);
          var maxRadiusSq = 0;
          for (var i = 0, il = start.count; i < il; i++) {
            vector.fromBufferAttribute(start, i);
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
            vector.fromBufferAttribute(end, i);
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
          }
          this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
          if (isNaN(this.boundingSphere.radius)) {
            console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
          }
        }
      };
    }(),
    toJSON: function() {
    },
    applyMatrix: function(matrix) {
      console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().");
      return this.applyMatrix4(matrix);
    }
  });

  // node_modules/three/examples/jsm/lines/Wireframe.js
  var Wireframe = function(geometry, material) {
    Mesh.call(this);
    this.type = "Wireframe";
    this.geometry = geometry !== void 0 ? geometry : new LineSegmentsGeometry();
    this.material = material !== void 0 ? material : new LineMaterial({ color: Math.random() * 16777215 });
  };
  Wireframe.prototype = Object.assign(Object.create(Mesh.prototype), {
    constructor: Wireframe,
    isWireframe: true,
    computeLineDistances: function() {
      var start = new Vector3();
      var end = new Vector3();
      return function computeLineDistances() {
        var geometry = this.geometry;
        var instanceStart = geometry.attributes.instanceStart;
        var instanceEnd = geometry.attributes.instanceEnd;
        var lineDistances = new Float32Array(2 * instanceStart.count);
        for (var i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {
          start.fromBufferAttribute(instanceStart, i);
          end.fromBufferAttribute(instanceEnd, i);
          lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];
          lineDistances[j + 1] = lineDistances[j] + start.distanceTo(end);
        }
        var instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1);
        geometry.setAttribute("instanceDistanceStart", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0));
        geometry.setAttribute("instanceDistanceEnd", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1));
        return this;
      };
    }()
  });

  // node_modules/three/examples/jsm/lines/WireframeGeometry2.js
  var WireframeGeometry2 = function(geometry) {
    LineSegmentsGeometry.call(this);
    this.type = "WireframeGeometry2";
    this.fromWireframeGeometry(new WireframeGeometry(geometry));
  };
  WireframeGeometry2.prototype = Object.assign(Object.create(LineSegmentsGeometry.prototype), {
    constructor: WireframeGeometry2,
    isWireframeGeometry2: true
  });

  // node_modules/three/examples/jsm/deprecated/Geometry.js
  var _m12 = new Matrix4();
  var _obj2 = new Object3D();
  var _offset2 = new Vector3();
  function Geometry() {
    this.uuid = MathUtils.generateUUID();
    this.name = "";
    this.type = "Geometry";
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.elementsNeedUpdate = false;
    this.verticesNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.lineDistancesNeedUpdate = false;
    this.groupsNeedUpdate = false;
  }
  Geometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Geometry,
    isGeometry: true,
    applyMatrix4: function(matrix) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      for (let i = 0, il = this.vertices.length; i < il; i++) {
        const vertex = this.vertices[i];
        vertex.applyMatrix4(matrix);
      }
      for (let i = 0, il = this.faces.length; i < il; i++) {
        const face = this.faces[i];
        face.normal.applyMatrix3(normalMatrix).normalize();
        for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {
          face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
        }
      }
      if (this.boundingBox !== null) {
        this.computeBoundingBox();
      }
      if (this.boundingSphere !== null) {
        this.computeBoundingSphere();
      }
      this.verticesNeedUpdate = true;
      this.normalsNeedUpdate = true;
      return this;
    },
    rotateX: function(angle) {
      _m12.makeRotationX(angle);
      this.applyMatrix4(_m12);
      return this;
    },
    rotateY: function(angle) {
      _m12.makeRotationY(angle);
      this.applyMatrix4(_m12);
      return this;
    },
    rotateZ: function(angle) {
      _m12.makeRotationZ(angle);
      this.applyMatrix4(_m12);
      return this;
    },
    translate: function(x, y, z) {
      _m12.makeTranslation(x, y, z);
      this.applyMatrix4(_m12);
      return this;
    },
    scale: function(x, y, z) {
      _m12.makeScale(x, y, z);
      this.applyMatrix4(_m12);
      return this;
    },
    lookAt: function(vector) {
      _obj2.lookAt(vector);
      _obj2.updateMatrix();
      this.applyMatrix4(_obj2.matrix);
      return this;
    },
    fromBufferGeometry: function(geometry) {
      const scope = this;
      const index = geometry.index !== null ? geometry.index : void 0;
      const attributes = geometry.attributes;
      if (attributes.position === void 0) {
        console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.");
        return this;
      }
      const position = attributes.position;
      const normal = attributes.normal;
      const color = attributes.color;
      const uv = attributes.uv;
      const uv2 = attributes.uv2;
      if (uv2 !== void 0)
        this.faceVertexUvs[1] = [];
      for (let i = 0; i < position.count; i++) {
        scope.vertices.push(new Vector3().fromBufferAttribute(position, i));
        if (color !== void 0) {
          scope.colors.push(new Color().fromBufferAttribute(color, i));
        }
      }
      function addFace(a, b2, c, materialIndex) {
        const vertexColors = color === void 0 ? [] : [
          scope.colors[a].clone(),
          scope.colors[b2].clone(),
          scope.colors[c].clone()
        ];
        const vertexNormals = normal === void 0 ? [] : [
          new Vector3().fromBufferAttribute(normal, a),
          new Vector3().fromBufferAttribute(normal, b2),
          new Vector3().fromBufferAttribute(normal, c)
        ];
        const face = new Face3(a, b2, c, vertexNormals, vertexColors, materialIndex);
        scope.faces.push(face);
        if (uv !== void 0) {
          scope.faceVertexUvs[0].push([
            new Vector2().fromBufferAttribute(uv, a),
            new Vector2().fromBufferAttribute(uv, b2),
            new Vector2().fromBufferAttribute(uv, c)
          ]);
        }
        if (uv2 !== void 0) {
          scope.faceVertexUvs[1].push([
            new Vector2().fromBufferAttribute(uv2, a),
            new Vector2().fromBufferAttribute(uv2, b2),
            new Vector2().fromBufferAttribute(uv2, c)
          ]);
        }
      }
      const groups = geometry.groups;
      if (groups.length > 0) {
        for (let i = 0; i < groups.length; i++) {
          const group = groups[i];
          const start = group.start;
          const count = group.count;
          for (let j = start, jl = start + count; j < jl; j += 3) {
            if (index !== void 0) {
              addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);
            } else {
              addFace(j, j + 1, j + 2, group.materialIndex);
            }
          }
        }
      } else {
        if (index !== void 0) {
          for (let i = 0; i < index.count; i += 3) {
            addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2));
          }
        } else {
          for (let i = 0; i < position.count; i += 3) {
            addFace(i, i + 1, i + 2);
          }
        }
      }
      this.computeFaceNormals();
      if (geometry.boundingBox !== null) {
        this.boundingBox = geometry.boundingBox.clone();
      }
      if (geometry.boundingSphere !== null) {
        this.boundingSphere = geometry.boundingSphere.clone();
      }
      return this;
    },
    center: function() {
      this.computeBoundingBox();
      this.boundingBox.getCenter(_offset2).negate();
      this.translate(_offset2.x, _offset2.y, _offset2.z);
      return this;
    },
    normalize: function() {
      this.computeBoundingSphere();
      const center = this.boundingSphere.center;
      const radius = this.boundingSphere.radius;
      const s = radius === 0 ? 1 : 1 / radius;
      const matrix = new Matrix4();
      matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
      this.applyMatrix4(matrix);
      return this;
    },
    computeFaceNormals: function() {
      const cb = new Vector3(), ab = new Vector3();
      for (let f = 0, fl = this.faces.length; f < fl; f++) {
        const face = this.faces[f];
        const vA = this.vertices[face.a];
        const vB = this.vertices[face.b];
        const vC = this.vertices[face.c];
        cb.subVectors(vC, vB);
        ab.subVectors(vA, vB);
        cb.cross(ab);
        cb.normalize();
        face.normal.copy(cb);
      }
    },
    computeVertexNormals: function(areaWeighted = true) {
      const vertices = new Array(this.vertices.length);
      for (let v = 0, vl = this.vertices.length; v < vl; v++) {
        vertices[v] = new Vector3();
      }
      if (areaWeighted) {
        const cb = new Vector3(), ab = new Vector3();
        for (let f = 0, fl = this.faces.length; f < fl; f++) {
          const face = this.faces[f];
          const vA = this.vertices[face.a];
          const vB = this.vertices[face.b];
          const vC = this.vertices[face.c];
          cb.subVectors(vC, vB);
          ab.subVectors(vA, vB);
          cb.cross(ab);
          vertices[face.a].add(cb);
          vertices[face.b].add(cb);
          vertices[face.c].add(cb);
        }
      } else {
        this.computeFaceNormals();
        for (let f = 0, fl = this.faces.length; f < fl; f++) {
          const face = this.faces[f];
          vertices[face.a].add(face.normal);
          vertices[face.b].add(face.normal);
          vertices[face.c].add(face.normal);
        }
      }
      for (let v = 0, vl = this.vertices.length; v < vl; v++) {
        vertices[v].normalize();
      }
      for (let f = 0, fl = this.faces.length; f < fl; f++) {
        const face = this.faces[f];
        const vertexNormals = face.vertexNormals;
        if (vertexNormals.length === 3) {
          vertexNormals[0].copy(vertices[face.a]);
          vertexNormals[1].copy(vertices[face.b]);
          vertexNormals[2].copy(vertices[face.c]);
        } else {
          vertexNormals[0] = vertices[face.a].clone();
          vertexNormals[1] = vertices[face.b].clone();
          vertexNormals[2] = vertices[face.c].clone();
        }
      }
      if (this.faces.length > 0) {
        this.normalsNeedUpdate = true;
      }
    },
    computeFlatVertexNormals: function() {
      this.computeFaceNormals();
      for (let f = 0, fl = this.faces.length; f < fl; f++) {
        const face = this.faces[f];
        const vertexNormals = face.vertexNormals;
        if (vertexNormals.length === 3) {
          vertexNormals[0].copy(face.normal);
          vertexNormals[1].copy(face.normal);
          vertexNormals[2].copy(face.normal);
        } else {
          vertexNormals[0] = face.normal.clone();
          vertexNormals[1] = face.normal.clone();
          vertexNormals[2] = face.normal.clone();
        }
      }
      if (this.faces.length > 0) {
        this.normalsNeedUpdate = true;
      }
    },
    computeMorphNormals: function() {
      for (let f = 0, fl = this.faces.length; f < fl; f++) {
        const face = this.faces[f];
        if (!face.__originalFaceNormal) {
          face.__originalFaceNormal = face.normal.clone();
        } else {
          face.__originalFaceNormal.copy(face.normal);
        }
        if (!face.__originalVertexNormals)
          face.__originalVertexNormals = [];
        for (let i = 0, il = face.vertexNormals.length; i < il; i++) {
          if (!face.__originalVertexNormals[i]) {
            face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
          } else {
            face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
          }
        }
      }
      const tmpGeo = new Geometry();
      tmpGeo.faces = this.faces;
      for (let i = 0, il = this.morphTargets.length; i < il; i++) {
        if (!this.morphNormals[i]) {
          this.morphNormals[i] = {};
          this.morphNormals[i].faceNormals = [];
          this.morphNormals[i].vertexNormals = [];
          const dstNormalsFace = this.morphNormals[i].faceNormals;
          const dstNormalsVertex = this.morphNormals[i].vertexNormals;
          for (let f = 0, fl = this.faces.length; f < fl; f++) {
            const faceNormal = new Vector3();
            const vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };
            dstNormalsFace.push(faceNormal);
            dstNormalsVertex.push(vertexNormals);
          }
        }
        const morphNormals = this.morphNormals[i];
        tmpGeo.vertices = this.morphTargets[i].vertices;
        tmpGeo.computeFaceNormals();
        tmpGeo.computeVertexNormals();
        for (let f = 0, fl = this.faces.length; f < fl; f++) {
          const face = this.faces[f];
          const faceNormal = morphNormals.faceNormals[f];
          const vertexNormals = morphNormals.vertexNormals[f];
          faceNormal.copy(face.normal);
          vertexNormals.a.copy(face.vertexNormals[0]);
          vertexNormals.b.copy(face.vertexNormals[1]);
          vertexNormals.c.copy(face.vertexNormals[2]);
        }
      }
      for (let f = 0, fl = this.faces.length; f < fl; f++) {
        const face = this.faces[f];
        face.normal = face.__originalFaceNormal;
        face.vertexNormals = face.__originalVertexNormals;
      }
    },
    computeBoundingBox: function() {
      if (this.boundingBox === null) {
        this.boundingBox = new Box3();
      }
      this.boundingBox.setFromPoints(this.vertices);
    },
    computeBoundingSphere: function() {
      if (this.boundingSphere === null) {
        this.boundingSphere = new Sphere();
      }
      this.boundingSphere.setFromPoints(this.vertices);
    },
    merge: function(geometry, matrix, materialIndexOffset = 0) {
      if (!(geometry && geometry.isGeometry)) {
        console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", geometry);
        return;
      }
      let normalMatrix;
      const vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, colors1 = this.colors, colors2 = geometry.colors;
      if (matrix !== void 0) {
        normalMatrix = new Matrix3().getNormalMatrix(matrix);
      }
      for (let i = 0, il = vertices2.length; i < il; i++) {
        const vertex = vertices2[i];
        const vertexCopy = vertex.clone();
        if (matrix !== void 0)
          vertexCopy.applyMatrix4(matrix);
        vertices1.push(vertexCopy);
      }
      for (let i = 0, il = colors2.length; i < il; i++) {
        colors1.push(colors2[i].clone());
      }
      for (let i = 0, il = faces2.length; i < il; i++) {
        const face = faces2[i];
        let normal, color;
        const faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
        const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
        faceCopy.normal.copy(face.normal);
        if (normalMatrix !== void 0) {
          faceCopy.normal.applyMatrix3(normalMatrix).normalize();
        }
        for (let j = 0, jl = faceVertexNormals.length; j < jl; j++) {
          normal = faceVertexNormals[j].clone();
          if (normalMatrix !== void 0) {
            normal.applyMatrix3(normalMatrix).normalize();
          }
          faceCopy.vertexNormals.push(normal);
        }
        faceCopy.color.copy(face.color);
        for (let j = 0, jl = faceVertexColors.length; j < jl; j++) {
          color = faceVertexColors[j];
          faceCopy.vertexColors.push(color.clone());
        }
        faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
        faces1.push(faceCopy);
      }
      for (let i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {
        const faceVertexUvs2 = geometry.faceVertexUvs[i];
        if (this.faceVertexUvs[i] === void 0)
          this.faceVertexUvs[i] = [];
        for (let j = 0, jl = faceVertexUvs2.length; j < jl; j++) {
          const uvs2 = faceVertexUvs2[j], uvsCopy = [];
          for (let k = 0, kl = uvs2.length; k < kl; k++) {
            uvsCopy.push(uvs2[k].clone());
          }
          this.faceVertexUvs[i].push(uvsCopy);
        }
      }
    },
    mergeMesh: function(mesh) {
      if (!(mesh && mesh.isMesh)) {
        console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", mesh);
        return;
      }
      if (mesh.matrixAutoUpdate)
        mesh.updateMatrix();
      this.merge(mesh.geometry, mesh.matrix);
    },
    mergeVertices: function(precisionPoints = 4) {
      const verticesMap = {};
      const unique = [], changes = [];
      const precision = Math.pow(10, precisionPoints);
      for (let i = 0, il = this.vertices.length; i < il; i++) {
        const v = this.vertices[i];
        const key = Math.round(v.x * precision) + "_" + Math.round(v.y * precision) + "_" + Math.round(v.z * precision);
        if (verticesMap[key] === void 0) {
          verticesMap[key] = i;
          unique.push(this.vertices[i]);
          changes[i] = unique.length - 1;
        } else {
          changes[i] = changes[verticesMap[key]];
        }
      }
      const faceIndicesToRemove = [];
      for (let i = 0, il = this.faces.length; i < il; i++) {
        const face = this.faces[i];
        face.a = changes[face.a];
        face.b = changes[face.b];
        face.c = changes[face.c];
        const indices = [face.a, face.b, face.c];
        for (let n = 0; n < 3; n++) {
          if (indices[n] === indices[(n + 1) % 3]) {
            faceIndicesToRemove.push(i);
            break;
          }
        }
      }
      for (let i = faceIndicesToRemove.length - 1; i >= 0; i--) {
        const idx = faceIndicesToRemove[i];
        this.faces.splice(idx, 1);
        for (let j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
          this.faceVertexUvs[j].splice(idx, 1);
        }
      }
      const diff = this.vertices.length - unique.length;
      this.vertices = unique;
      return diff;
    },
    setFromPoints: function(points) {
      this.vertices = [];
      for (let i = 0, l = points.length; i < l; i++) {
        const point = points[i];
        this.vertices.push(new Vector3(point.x, point.y, point.z || 0));
      }
      return this;
    },
    sortFacesByMaterialIndex: function() {
      const faces = this.faces;
      const length = faces.length;
      for (let i = 0; i < length; i++) {
        faces[i]._id = i;
      }
      function materialIndexSort(a, b2) {
        return a.materialIndex - b2.materialIndex;
      }
      faces.sort(materialIndexSort);
      const uvs1 = this.faceVertexUvs[0];
      const uvs2 = this.faceVertexUvs[1];
      let newUvs1, newUvs2;
      if (uvs1 && uvs1.length === length)
        newUvs1 = [];
      if (uvs2 && uvs2.length === length)
        newUvs2 = [];
      for (let i = 0; i < length; i++) {
        const id = faces[i]._id;
        if (newUvs1)
          newUvs1.push(uvs1[id]);
        if (newUvs2)
          newUvs2.push(uvs2[id]);
      }
      if (newUvs1)
        this.faceVertexUvs[0] = newUvs1;
      if (newUvs2)
        this.faceVertexUvs[1] = newUvs2;
    },
    toJSON: function() {
      const data = {
        metadata: {
          version: 4.5,
          type: "Geometry",
          generator: "Geometry.toJSON"
        }
      };
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== "")
        data.name = this.name;
      if (this.parameters !== void 0) {
        const parameters = this.parameters;
        for (const key in parameters) {
          if (parameters[key] !== void 0)
            data[key] = parameters[key];
        }
        return data;
      }
      const vertices = [];
      for (let i = 0; i < this.vertices.length; i++) {
        const vertex = this.vertices[i];
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
      const faces = [];
      const normals = [];
      const normalsHash = {};
      const colors = [];
      const colorsHash = {};
      const uvs = [];
      const uvsHash = {};
      for (let i = 0; i < this.faces.length; i++) {
        const face = this.faces[i];
        const hasMaterial = true;
        const hasFaceUv = false;
        const hasFaceVertexUv = this.faceVertexUvs[0][i] !== void 0;
        const hasFaceNormal = face.normal.length() > 0;
        const hasFaceVertexNormal = face.vertexNormals.length > 0;
        const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
        const hasFaceVertexColor = face.vertexColors.length > 0;
        let faceType = 0;
        faceType = setBit(faceType, 0, 0);
        faceType = setBit(faceType, 1, hasMaterial);
        faceType = setBit(faceType, 2, hasFaceUv);
        faceType = setBit(faceType, 3, hasFaceVertexUv);
        faceType = setBit(faceType, 4, hasFaceNormal);
        faceType = setBit(faceType, 5, hasFaceVertexNormal);
        faceType = setBit(faceType, 6, hasFaceColor);
        faceType = setBit(faceType, 7, hasFaceVertexColor);
        faces.push(faceType);
        faces.push(face.a, face.b, face.c);
        faces.push(face.materialIndex);
        if (hasFaceVertexUv) {
          const faceVertexUvs = this.faceVertexUvs[0][i];
          faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
        }
        if (hasFaceNormal) {
          faces.push(getNormalIndex(face.normal));
        }
        if (hasFaceVertexNormal) {
          const vertexNormals = face.vertexNormals;
          faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
        }
        if (hasFaceColor) {
          faces.push(getColorIndex(face.color));
        }
        if (hasFaceVertexColor) {
          const vertexColors = face.vertexColors;
          faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
        }
      }
      function setBit(value, position, enabled) {
        return enabled ? value | 1 << position : value & ~(1 << position);
      }
      function getNormalIndex(normal) {
        const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
        if (normalsHash[hash] !== void 0) {
          return normalsHash[hash];
        }
        normalsHash[hash] = normals.length / 3;
        normals.push(normal.x, normal.y, normal.z);
        return normalsHash[hash];
      }
      function getColorIndex(color) {
        const hash = color.r.toString() + color.g.toString() + color.b.toString();
        if (colorsHash[hash] !== void 0) {
          return colorsHash[hash];
        }
        colorsHash[hash] = colors.length;
        colors.push(color.getHex());
        return colorsHash[hash];
      }
      function getUvIndex(uv) {
        const hash = uv.x.toString() + uv.y.toString();
        if (uvsHash[hash] !== void 0) {
          return uvsHash[hash];
        }
        uvsHash[hash] = uvs.length / 2;
        uvs.push(uv.x, uv.y);
        return uvsHash[hash];
      }
      data.data = {};
      data.data.vertices = vertices;
      data.data.normals = normals;
      if (colors.length > 0)
        data.data.colors = colors;
      if (uvs.length > 0)
        data.data.uvs = [uvs];
      data.data.faces = faces;
      return data;
    },
    clone: function() {
      return new Geometry().copy(this);
    },
    copy: function(source) {
      this.vertices = [];
      this.colors = [];
      this.faces = [];
      this.faceVertexUvs = [[]];
      this.morphTargets = [];
      this.morphNormals = [];
      this.skinWeights = [];
      this.skinIndices = [];
      this.lineDistances = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      this.name = source.name;
      const vertices = source.vertices;
      for (let i = 0, il = vertices.length; i < il; i++) {
        this.vertices.push(vertices[i].clone());
      }
      const colors = source.colors;
      for (let i = 0, il = colors.length; i < il; i++) {
        this.colors.push(colors[i].clone());
      }
      const faces = source.faces;
      for (let i = 0, il = faces.length; i < il; i++) {
        this.faces.push(faces[i].clone());
      }
      for (let i = 0, il = source.faceVertexUvs.length; i < il; i++) {
        const faceVertexUvs = source.faceVertexUvs[i];
        if (this.faceVertexUvs[i] === void 0) {
          this.faceVertexUvs[i] = [];
        }
        for (let j = 0, jl = faceVertexUvs.length; j < jl; j++) {
          const uvs = faceVertexUvs[j], uvsCopy = [];
          for (let k = 0, kl = uvs.length; k < kl; k++) {
            const uv = uvs[k];
            uvsCopy.push(uv.clone());
          }
          this.faceVertexUvs[i].push(uvsCopy);
        }
      }
      const morphTargets = source.morphTargets;
      for (let i = 0, il = morphTargets.length; i < il; i++) {
        const morphTarget = {};
        morphTarget.name = morphTargets[i].name;
        if (morphTargets[i].vertices !== void 0) {
          morphTarget.vertices = [];
          for (let j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {
            morphTarget.vertices.push(morphTargets[i].vertices[j].clone());
          }
        }
        if (morphTargets[i].normals !== void 0) {
          morphTarget.normals = [];
          for (let j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {
            morphTarget.normals.push(morphTargets[i].normals[j].clone());
          }
        }
        this.morphTargets.push(morphTarget);
      }
      const morphNormals = source.morphNormals;
      for (let i = 0, il = morphNormals.length; i < il; i++) {
        const morphNormal = {};
        if (morphNormals[i].vertexNormals !== void 0) {
          morphNormal.vertexNormals = [];
          for (let j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {
            const srcVertexNormal = morphNormals[i].vertexNormals[j];
            const destVertexNormal = {};
            destVertexNormal.a = srcVertexNormal.a.clone();
            destVertexNormal.b = srcVertexNormal.b.clone();
            destVertexNormal.c = srcVertexNormal.c.clone();
            morphNormal.vertexNormals.push(destVertexNormal);
          }
        }
        if (morphNormals[i].faceNormals !== void 0) {
          morphNormal.faceNormals = [];
          for (let j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {
            morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());
          }
        }
        this.morphNormals.push(morphNormal);
      }
      const skinWeights = source.skinWeights;
      for (let i = 0, il = skinWeights.length; i < il; i++) {
        this.skinWeights.push(skinWeights[i].clone());
      }
      const skinIndices = source.skinIndices;
      for (let i = 0, il = skinIndices.length; i < il; i++) {
        this.skinIndices.push(skinIndices[i].clone());
      }
      const lineDistances = source.lineDistances;
      for (let i = 0, il = lineDistances.length; i < il; i++) {
        this.lineDistances.push(lineDistances[i]);
      }
      const boundingBox = source.boundingBox;
      if (boundingBox !== null) {
        this.boundingBox = boundingBox.clone();
      }
      const boundingSphere = source.boundingSphere;
      if (boundingSphere !== null) {
        this.boundingSphere = boundingSphere.clone();
      }
      this.elementsNeedUpdate = source.elementsNeedUpdate;
      this.verticesNeedUpdate = source.verticesNeedUpdate;
      this.uvsNeedUpdate = source.uvsNeedUpdate;
      this.normalsNeedUpdate = source.normalsNeedUpdate;
      this.colorsNeedUpdate = source.colorsNeedUpdate;
      this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
      this.groupsNeedUpdate = source.groupsNeedUpdate;
      return this;
    },
    toBufferGeometry: function() {
      const geometry = new DirectGeometry().fromGeometry(this);
      const buffergeometry = new BufferGeometry();
      const positions = new Float32Array(geometry.vertices.length * 3);
      buffergeometry.setAttribute("position", new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));
      if (geometry.normals.length > 0) {
        const normals = new Float32Array(geometry.normals.length * 3);
        buffergeometry.setAttribute("normal", new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
      }
      if (geometry.colors.length > 0) {
        const colors = new Float32Array(geometry.colors.length * 3);
        buffergeometry.setAttribute("color", new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
      }
      if (geometry.uvs.length > 0) {
        const uvs = new Float32Array(geometry.uvs.length * 2);
        buffergeometry.setAttribute("uv", new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
      }
      if (geometry.uvs2.length > 0) {
        const uvs2 = new Float32Array(geometry.uvs2.length * 2);
        buffergeometry.setAttribute("uv2", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
      }
      buffergeometry.groups = geometry.groups;
      for (const name in geometry.morphTargets) {
        const array = [];
        const morphTargets = geometry.morphTargets[name];
        for (let i = 0, l = morphTargets.length; i < l; i++) {
          const morphTarget = morphTargets[i];
          const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);
          attribute.name = morphTarget.name;
          array.push(attribute.copyVector3sArray(morphTarget.data));
        }
        buffergeometry.morphAttributes[name] = array;
      }
      if (geometry.skinIndices.length > 0) {
        const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);
        buffergeometry.setAttribute("skinIndex", skinIndices.copyVector4sArray(geometry.skinIndices));
      }
      if (geometry.skinWeights.length > 0) {
        const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);
        buffergeometry.setAttribute("skinWeight", skinWeights.copyVector4sArray(geometry.skinWeights));
      }
      if (geometry.boundingSphere !== null) {
        buffergeometry.boundingSphere = geometry.boundingSphere.clone();
      }
      if (geometry.boundingBox !== null) {
        buffergeometry.boundingBox = geometry.boundingBox.clone();
      }
      return buffergeometry;
    },
    computeTangents: function() {
      console.error("THREE.Geometry: .computeTangents() has been removed.");
    },
    computeLineDistances: function() {
      console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
    },
    applyMatrix: function(matrix) {
      console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().");
      return this.applyMatrix4(matrix);
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  });
  Geometry.createBufferGeometryFromObject = function(object) {
    let buffergeometry = new BufferGeometry();
    const geometry = object.geometry;
    if (object.isPoints || object.isLine) {
      const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);
      const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);
      buffergeometry.setAttribute("position", positions.copyVector3sArray(geometry.vertices));
      buffergeometry.setAttribute("color", colors.copyColorsArray(geometry.colors));
      if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
        const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);
        buffergeometry.setAttribute("lineDistance", lineDistances.copyArray(geometry.lineDistances));
      }
      if (geometry.boundingSphere !== null) {
        buffergeometry.boundingSphere = geometry.boundingSphere.clone();
      }
      if (geometry.boundingBox !== null) {
        buffergeometry.boundingBox = geometry.boundingBox.clone();
      }
    } else if (object.isMesh) {
      buffergeometry = geometry.toBufferGeometry();
    }
    return buffergeometry;
  };
  var DirectGeometry = class {
    constructor() {
      this.vertices = [];
      this.normals = [];
      this.colors = [];
      this.uvs = [];
      this.uvs2 = [];
      this.groups = [];
      this.morphTargets = {};
      this.skinWeights = [];
      this.skinIndices = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      this.verticesNeedUpdate = false;
      this.normalsNeedUpdate = false;
      this.colorsNeedUpdate = false;
      this.uvsNeedUpdate = false;
      this.groupsNeedUpdate = false;
    }
    computeGroups(geometry) {
      const groups = [];
      let group, i;
      let materialIndex = void 0;
      const faces = geometry.faces;
      for (i = 0; i < faces.length; i++) {
        const face = faces[i];
        if (face.materialIndex !== materialIndex) {
          materialIndex = face.materialIndex;
          if (group !== void 0) {
            group.count = i * 3 - group.start;
            groups.push(group);
          }
          group = {
            start: i * 3,
            materialIndex
          };
        }
      }
      if (group !== void 0) {
        group.count = i * 3 - group.start;
        groups.push(group);
      }
      this.groups = groups;
    }
    fromGeometry(geometry) {
      const faces = geometry.faces;
      const vertices = geometry.vertices;
      const faceVertexUvs = geometry.faceVertexUvs;
      const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
      const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
      const morphTargets = geometry.morphTargets;
      const morphTargetsLength = morphTargets.length;
      let morphTargetsPosition;
      if (morphTargetsLength > 0) {
        morphTargetsPosition = [];
        for (let i = 0; i < morphTargetsLength; i++) {
          morphTargetsPosition[i] = {
            name: morphTargets[i].name,
            data: []
          };
        }
        this.morphTargets.position = morphTargetsPosition;
      }
      const morphNormals = geometry.morphNormals;
      const morphNormalsLength = morphNormals.length;
      let morphTargetsNormal;
      if (morphNormalsLength > 0) {
        morphTargetsNormal = [];
        for (let i = 0; i < morphNormalsLength; i++) {
          morphTargetsNormal[i] = {
            name: morphNormals[i].name,
            data: []
          };
        }
        this.morphTargets.normal = morphTargetsNormal;
      }
      const skinIndices = geometry.skinIndices;
      const skinWeights = geometry.skinWeights;
      const hasSkinIndices = skinIndices.length === vertices.length;
      const hasSkinWeights = skinWeights.length === vertices.length;
      if (vertices.length > 0 && faces.length === 0) {
        console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
      }
      for (let i = 0; i < faces.length; i++) {
        const face = faces[i];
        this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
        const vertexNormals = face.vertexNormals;
        if (vertexNormals.length === 3) {
          this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
        } else {
          const normal = face.normal;
          this.normals.push(normal, normal, normal);
        }
        const vertexColors = face.vertexColors;
        if (vertexColors.length === 3) {
          this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
        } else {
          const color = face.color;
          this.colors.push(color, color, color);
        }
        if (hasFaceVertexUv === true) {
          const vertexUvs = faceVertexUvs[0][i];
          if (vertexUvs !== void 0) {
            this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
          } else {
            console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", i);
            this.uvs.push(new Vector2(), new Vector2(), new Vector2());
          }
        }
        if (hasFaceVertexUv2 === true) {
          const vertexUvs = faceVertexUvs[1][i];
          if (vertexUvs !== void 0) {
            this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
          } else {
            console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", i);
            this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
          }
        }
        for (let j = 0; j < morphTargetsLength; j++) {
          const morphTarget = morphTargets[j].vertices;
          morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
        }
        for (let j = 0; j < morphNormalsLength; j++) {
          const morphNormal = morphNormals[j].vertexNormals[i];
          morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);
        }
        if (hasSkinIndices) {
          this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
        }
        if (hasSkinWeights) {
          this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
        }
      }
      this.computeGroups(geometry);
      this.verticesNeedUpdate = geometry.verticesNeedUpdate;
      this.normalsNeedUpdate = geometry.normalsNeedUpdate;
      this.colorsNeedUpdate = geometry.colorsNeedUpdate;
      this.uvsNeedUpdate = geometry.uvsNeedUpdate;
      this.groupsNeedUpdate = geometry.groupsNeedUpdate;
      if (geometry.boundingSphere !== null) {
        this.boundingSphere = geometry.boundingSphere.clone();
      }
      if (geometry.boundingBox !== null) {
        this.boundingBox = geometry.boundingBox.clone();
      }
      return this;
    }
  };
  var Face3 = class {
    constructor(a, b2, c, normal, color, materialIndex = 0) {
      this.a = a;
      this.b = b2;
      this.c = c;
      this.normal = normal && normal.isVector3 ? normal : new Vector3();
      this.vertexNormals = Array.isArray(normal) ? normal : [];
      this.color = color && color.isColor ? color : new Color();
      this.vertexColors = Array.isArray(color) ? color : [];
      this.materialIndex = materialIndex;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.a = source.a;
      this.b = source.b;
      this.c = source.c;
      this.normal.copy(source.normal);
      this.color.copy(source.color);
      this.materialIndex = source.materialIndex;
      for (let i = 0, il = source.vertexNormals.length; i < il; i++) {
        this.vertexNormals[i] = source.vertexNormals[i].clone();
      }
      for (let i = 0, il = source.vertexColors.length; i < il; i++) {
        this.vertexColors[i] = source.vertexColors[i].clone();
      }
      return this;
    }
  };

  // node_modules/@enable3d/three-wrapper/dist/deprecated/face3.js
  var Face32 = class {
    constructor(a, b2, c, normal, color, materialIndex = 0) {
      this.a = a;
      this.b = b2;
      this.c = c;
      this.normal = normal && normal.isVector3 ? normal : new Vector3();
      this.vertexNormals = Array.isArray(normal) ? normal : [];
      this.color = color && color.isColor ? color : new Color();
      this.vertexColors = Array.isArray(color) ? color : [];
      this.materialIndex = materialIndex;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.a = source.a;
      this.b = source.b;
      this.c = source.c;
      this.normal.copy(source.normal);
      this.color.copy(source.color);
      this.materialIndex = source.materialIndex;
      for (let i = 0, il = source.vertexNormals.length; i < il; i++) {
        this.vertexNormals[i] = source.vertexNormals[i].clone();
      }
      for (let i = 0, il = source.vertexColors.length; i < il; i++) {
        this.vertexColors[i] = source.vertexColors[i].clone();
      }
      return this;
    }
  };

  // node_modules/three/examples/jsm/loaders/SVGLoader.js
  var SVGLoader = function(manager) {
    Loader.call(this, manager);
    this.defaultDPI = 90;
    this.defaultUnit = "px";
  };
  SVGLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: SVGLoader,
    load: function(url, onLoad, onProgress, onError) {
      var scope = this;
      var loader = new FileLoader(scope.manager);
      loader.setPath(scope.path);
      loader.setRequestHeader(scope.requestHeader);
      loader.setWithCredentials(scope.withCredentials);
      loader.load(url, function(text) {
        try {
          onLoad(scope.parse(text));
        } catch (e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }
          scope.manager.itemError(url);
        }
      }, onProgress, onError);
    },
    parse: function(text) {
      var scope = this;
      function parseNode(node, style) {
        if (node.nodeType !== 1)
          return;
        var transform = getNodeTransform(node);
        var traverseChildNodes = true;
        var path = null;
        switch (node.nodeName) {
          case "svg":
            break;
          case "style":
            parseCSSStylesheet(node);
            break;
          case "g":
            style = parseStyle(node, style);
            break;
          case "path":
            style = parseStyle(node, style);
            if (node.hasAttribute("d"))
              path = parsePathNode(node);
            break;
          case "rect":
            style = parseStyle(node, style);
            path = parseRectNode(node);
            break;
          case "polygon":
            style = parseStyle(node, style);
            path = parsePolygonNode(node);
            break;
          case "polyline":
            style = parseStyle(node, style);
            path = parsePolylineNode(node);
            break;
          case "circle":
            style = parseStyle(node, style);
            path = parseCircleNode(node);
            break;
          case "ellipse":
            style = parseStyle(node, style);
            path = parseEllipseNode(node);
            break;
          case "line":
            style = parseStyle(node, style);
            path = parseLineNode(node);
            break;
          case "defs":
            traverseChildNodes = false;
            break;
          case "use":
            style = parseStyle(node, style);
            var usedNodeId = node.href.baseVal.substring(1);
            var usedNode = node.viewportElement.getElementById(usedNodeId);
            if (usedNode) {
              parseNode(usedNode, style);
            } else {
              console.warn("SVGLoader: 'use node' references non-existent node id: " + usedNodeId);
            }
            break;
          default:
        }
        if (path) {
          if (style.fill !== void 0 && style.fill !== "none") {
            path.color.setStyle(style.fill);
          }
          transformPath(path, currentTransform);
          paths.push(path);
          path.userData = { node, style };
        }
        if (traverseChildNodes) {
          var nodes = node.childNodes;
          for (var i = 0; i < nodes.length; i++) {
            parseNode(nodes[i], style);
          }
        }
        if (transform) {
          transformStack.pop();
          if (transformStack.length > 0) {
            currentTransform.copy(transformStack[transformStack.length - 1]);
          } else {
            currentTransform.identity();
          }
        }
      }
      function parsePathNode(node) {
        var path = new ShapePath();
        var point = new Vector2();
        var control = new Vector2();
        var firstPoint = new Vector2();
        var isFirstPoint = true;
        var doSetFirstPoint = false;
        var d = node.getAttribute("d");
        var commands = d.match(/[a-df-z][^a-df-z]*/ig);
        for (var i = 0, l = commands.length; i < l; i++) {
          var command = commands[i];
          var type = command.charAt(0);
          var data2 = command.substr(1).trim();
          if (isFirstPoint === true) {
            doSetFirstPoint = true;
            isFirstPoint = false;
          }
          switch (type) {
            case "M":
              var numbers = parseFloats(data2);
              for (var j = 0, jl = numbers.length; j < jl; j += 2) {
                point.x = numbers[j + 0];
                point.y = numbers[j + 1];
                control.x = point.x;
                control.y = point.y;
                if (j === 0) {
                  path.moveTo(point.x, point.y);
                } else {
                  path.lineTo(point.x, point.y);
                }
                if (j === 0 && doSetFirstPoint === true)
                  firstPoint.copy(point);
              }
              break;
            case "H":
              var numbers = parseFloats(data2);
              for (var j = 0, jl = numbers.length; j < jl; j++) {
                point.x = numbers[j];
                control.x = point.x;
                control.y = point.y;
                path.lineTo(point.x, point.y);
                if (j === 0 && doSetFirstPoint === true)
                  firstPoint.copy(point);
              }
              break;
            case "V":
              var numbers = parseFloats(data2);
              for (var j = 0, jl = numbers.length; j < jl; j++) {
                point.y = numbers[j];
                control.x = point.x;
                control.y = point.y;
                path.lineTo(point.x, point.y);
                if (j === 0 && doSetFirstPoint === true)
                  firstPoint.copy(point);
              }
              break;
            case "L":
              var numbers = parseFloats(data2);
              for (var j = 0, jl = numbers.length; j < jl; j += 2) {
                point.x = numbers[j + 0];
                point.y = numbers[j + 1];
                control.x = point.x;
                control.y = point.y;
                path.lineTo(point.x, point.y);
                if (j === 0 && doSetFirstPoint === true)
                  firstPoint.copy(point);
              }
              break;
            case "C":
              var numbers = parseFloats(data2);
              for (var j = 0, jl = numbers.length; j < jl; j += 6) {
                path.bezierCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], numbers[j + 5]);
                control.x = numbers[j + 2];
                control.y = numbers[j + 3];
                point.x = numbers[j + 4];
                point.y = numbers[j + 5];
                if (j === 0 && doSetFirstPoint === true)
                  firstPoint.copy(point);
              }
              break;
            case "S":
              var numbers = parseFloats(data2);
              for (var j = 0, jl = numbers.length; j < jl; j += 4) {
                path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);
                control.x = numbers[j + 0];
                control.y = numbers[j + 1];
                point.x = numbers[j + 2];
                point.y = numbers[j + 3];
                if (j === 0 && doSetFirstPoint === true)
                  firstPoint.copy(point);
              }
              break;
            case "Q":
              var numbers = parseFloats(data2);
              for (var j = 0, jl = numbers.length; j < jl; j += 4) {
                path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);
                control.x = numbers[j + 0];
                control.y = numbers[j + 1];
                point.x = numbers[j + 2];
                point.y = numbers[j + 3];
                if (j === 0 && doSetFirstPoint === true)
                  firstPoint.copy(point);
              }
              break;
            case "T":
              var numbers = parseFloats(data2);
              for (var j = 0, jl = numbers.length; j < jl; j += 2) {
                var rx = getReflection(point.x, control.x);
                var ry = getReflection(point.y, control.y);
                path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1]);
                control.x = rx;
                control.y = ry;
                point.x = numbers[j + 0];
                point.y = numbers[j + 1];
                if (j === 0 && doSetFirstPoint === true)
                  firstPoint.copy(point);
              }
              break;
            case "A":
              var numbers = parseFloats(data2, [3, 4], 7);
              for (var j = 0, jl = numbers.length; j < jl; j += 7) {
                if (numbers[j + 5] == point.x && numbers[j + 6] == point.y)
                  continue;
                var start = point.clone();
                point.x = numbers[j + 5];
                point.y = numbers[j + 6];
                control.x = point.x;
                control.y = point.y;
                parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);
                if (j === 0 && doSetFirstPoint === true)
                  firstPoint.copy(point);
              }
              break;
            case "m":
              var numbers = parseFloats(data2);
              for (var j = 0, jl = numbers.length; j < jl; j += 2) {
                point.x += numbers[j + 0];
                point.y += numbers[j + 1];
                control.x = point.x;
                control.y = point.y;
                if (j === 0) {
                  path.moveTo(point.x, point.y);
                } else {
                  path.lineTo(point.x, point.y);
                }
                if (j === 0 && doSetFirstPoint === true)
                  firstPoint.copy(point);
              }
              break;
            case "h":
              var numbers = parseFloats(data2);
              for (var j = 0, jl = numbers.length; j < jl; j++) {
                point.x += numbers[j];
                control.x = point.x;
                control.y = point.y;
                path.lineTo(point.x, point.y);
                if (j === 0 && doSetFirstPoint === true)
                  firstPoint.copy(point);
              }
              break;
            case "v":
              var numbers = parseFloats(data2);
              for (var j = 0, jl = numbers.length; j < jl; j++) {
                point.y += numbers[j];
                control.x = point.x;
                control.y = point.y;
                path.lineTo(point.x, point.y);
                if (j === 0 && doSetFirstPoint === true)
                  firstPoint.copy(point);
              }
              break;
            case "l":
              var numbers = parseFloats(data2);
              for (var j = 0, jl = numbers.length; j < jl; j += 2) {
                point.x += numbers[j + 0];
                point.y += numbers[j + 1];
                control.x = point.x;
                control.y = point.y;
                path.lineTo(point.x, point.y);
                if (j === 0 && doSetFirstPoint === true)
                  firstPoint.copy(point);
              }
              break;
            case "c":
              var numbers = parseFloats(data2);
              for (var j = 0, jl = numbers.length; j < jl; j += 6) {
                path.bezierCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3], point.x + numbers[j + 4], point.y + numbers[j + 5]);
                control.x = point.x + numbers[j + 2];
                control.y = point.y + numbers[j + 3];
                point.x += numbers[j + 4];
                point.y += numbers[j + 5];
                if (j === 0 && doSetFirstPoint === true)
                  firstPoint.copy(point);
              }
              break;
            case "s":
              var numbers = parseFloats(data2);
              for (var j = 0, jl = numbers.length; j < jl; j += 4) {
                path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3]);
                control.x = point.x + numbers[j + 0];
                control.y = point.y + numbers[j + 1];
                point.x += numbers[j + 2];
                point.y += numbers[j + 3];
                if (j === 0 && doSetFirstPoint === true)
                  firstPoint.copy(point);
              }
              break;
            case "q":
              var numbers = parseFloats(data2);
              for (var j = 0, jl = numbers.length; j < jl; j += 4) {
                path.quadraticCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3]);
                control.x = point.x + numbers[j + 0];
                control.y = point.y + numbers[j + 1];
                point.x += numbers[j + 2];
                point.y += numbers[j + 3];
                if (j === 0 && doSetFirstPoint === true)
                  firstPoint.copy(point);
              }
              break;
            case "t":
              var numbers = parseFloats(data2);
              for (var j = 0, jl = numbers.length; j < jl; j += 2) {
                var rx = getReflection(point.x, control.x);
                var ry = getReflection(point.y, control.y);
                path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1]);
                control.x = rx;
                control.y = ry;
                point.x = point.x + numbers[j + 0];
                point.y = point.y + numbers[j + 1];
                if (j === 0 && doSetFirstPoint === true)
                  firstPoint.copy(point);
              }
              break;
            case "a":
              var numbers = parseFloats(data2, [3, 4], 7);
              for (var j = 0, jl = numbers.length; j < jl; j += 7) {
                if (numbers[j + 5] == 0 && numbers[j + 6] == 0)
                  continue;
                var start = point.clone();
                point.x += numbers[j + 5];
                point.y += numbers[j + 6];
                control.x = point.x;
                control.y = point.y;
                parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);
                if (j === 0 && doSetFirstPoint === true)
                  firstPoint.copy(point);
              }
              break;
            case "Z":
            case "z":
              path.currentPath.autoClose = true;
              if (path.currentPath.curves.length > 0) {
                point.copy(firstPoint);
                path.currentPath.currentPoint.copy(point);
                isFirstPoint = true;
              }
              break;
            default:
              console.warn(command);
          }
          doSetFirstPoint = false;
        }
        return path;
      }
      function parseCSSStylesheet(node) {
        if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length)
          return;
        for (var i = 0; i < node.sheet.cssRules.length; i++) {
          var stylesheet = node.sheet.cssRules[i];
          if (stylesheet.type !== 1)
            continue;
          var selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map((i2) => i2.trim());
          for (var j = 0; j < selectorList.length; j++) {
            stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, stylesheet.style);
          }
        }
      }
      function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {
        if (rx == 0 || ry == 0) {
          path.lineTo(end.x, end.y);
          return;
        }
        x_axis_rotation = x_axis_rotation * Math.PI / 180;
        rx = Math.abs(rx);
        ry = Math.abs(ry);
        var dx2 = (start.x - end.x) / 2;
        var dy2 = (start.y - end.y) / 2;
        var x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;
        var y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2;
        var rxs = rx * rx;
        var rys = ry * ry;
        var x1ps = x1p * x1p;
        var y1ps = y1p * y1p;
        var cr2 = x1ps / rxs + y1ps / rys;
        if (cr2 > 1) {
          var s = Math.sqrt(cr2);
          rx = s * rx;
          ry = s * ry;
          rxs = rx * rx;
          rys = ry * ry;
        }
        var dq = rxs * y1ps + rys * x1ps;
        var pq = (rxs * rys - dq) / dq;
        var q = Math.sqrt(Math.max(0, pq));
        if (large_arc_flag === sweep_flag)
          q = -q;
        var cxp = q * rx * y1p / ry;
        var cyp = -q * ry * x1p / rx;
        var cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;
        var cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2;
        var theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);
        var delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);
        path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);
      }
      function svgAngle(ux, uy, vx, vy) {
        var dot = ux * vx + uy * vy;
        var len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);
        var ang = Math.acos(Math.max(-1, Math.min(1, dot / len)));
        if (ux * vy - uy * vx < 0)
          ang = -ang;
        return ang;
      }
      function parseRectNode(node) {
        var x = parseFloatWithUnits(node.getAttribute("x") || 0);
        var y = parseFloatWithUnits(node.getAttribute("y") || 0);
        var rx = parseFloatWithUnits(node.getAttribute("rx") || 0);
        var ry = parseFloatWithUnits(node.getAttribute("ry") || 0);
        var w = parseFloatWithUnits(node.getAttribute("width"));
        var h = parseFloatWithUnits(node.getAttribute("height"));
        var path = new ShapePath();
        path.moveTo(x + 2 * rx, y);
        path.lineTo(x + w - 2 * rx, y);
        if (rx !== 0 || ry !== 0)
          path.bezierCurveTo(x + w, y, x + w, y, x + w, y + 2 * ry);
        path.lineTo(x + w, y + h - 2 * ry);
        if (rx !== 0 || ry !== 0)
          path.bezierCurveTo(x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h);
        path.lineTo(x + 2 * rx, y + h);
        if (rx !== 0 || ry !== 0) {
          path.bezierCurveTo(x, y + h, x, y + h, x, y + h - 2 * ry);
        }
        path.lineTo(x, y + 2 * ry);
        if (rx !== 0 || ry !== 0) {
          path.bezierCurveTo(x, y, x, y, x + 2 * rx, y);
        }
        return path;
      }
      function parsePolygonNode(node) {
        function iterator(match, a, b2) {
          var x = parseFloatWithUnits(a);
          var y = parseFloatWithUnits(b2);
          if (index === 0) {
            path.moveTo(x, y);
          } else {
            path.lineTo(x, y);
          }
          index++;
        }
        var regex = /(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g;
        var path = new ShapePath();
        var index = 0;
        node.getAttribute("points").replace(regex, iterator);
        path.currentPath.autoClose = true;
        return path;
      }
      function parsePolylineNode(node) {
        function iterator(match, a, b2) {
          var x = parseFloatWithUnits(a);
          var y = parseFloatWithUnits(b2);
          if (index === 0) {
            path.moveTo(x, y);
          } else {
            path.lineTo(x, y);
          }
          index++;
        }
        var regex = /(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g;
        var path = new ShapePath();
        var index = 0;
        node.getAttribute("points").replace(regex, iterator);
        path.currentPath.autoClose = false;
        return path;
      }
      function parseCircleNode(node) {
        var x = parseFloatWithUnits(node.getAttribute("cx") || 0);
        var y = parseFloatWithUnits(node.getAttribute("cy") || 0);
        var r = parseFloatWithUnits(node.getAttribute("r") || 0);
        var subpath = new Path();
        subpath.absarc(x, y, r, 0, Math.PI * 2);
        var path = new ShapePath();
        path.subPaths.push(subpath);
        return path;
      }
      function parseEllipseNode(node) {
        var x = parseFloatWithUnits(node.getAttribute("cx") || 0);
        var y = parseFloatWithUnits(node.getAttribute("cy") || 0);
        var rx = parseFloatWithUnits(node.getAttribute("rx") || 0);
        var ry = parseFloatWithUnits(node.getAttribute("ry") || 0);
        var subpath = new Path();
        subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);
        var path = new ShapePath();
        path.subPaths.push(subpath);
        return path;
      }
      function parseLineNode(node) {
        var x1 = parseFloatWithUnits(node.getAttribute("x1") || 0);
        var y1 = parseFloatWithUnits(node.getAttribute("y1") || 0);
        var x2 = parseFloatWithUnits(node.getAttribute("x2") || 0);
        var y2 = parseFloatWithUnits(node.getAttribute("y2") || 0);
        var path = new ShapePath();
        path.moveTo(x1, y1);
        path.lineTo(x2, y2);
        path.currentPath.autoClose = false;
        return path;
      }
      function parseStyle(node, style) {
        style = Object.assign({}, style);
        var stylesheetStyles = {};
        if (node.hasAttribute("class")) {
          var classSelectors = node.getAttribute("class").split(/\s/).filter(Boolean).map((i2) => i2.trim());
          for (var i = 0; i < classSelectors.length; i++) {
            stylesheetStyles = Object.assign(stylesheetStyles, stylesheets["." + classSelectors[i]]);
          }
        }
        if (node.hasAttribute("id")) {
          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets["#" + node.getAttribute("id")]);
        }
        function addStyle(svgName, jsName, adjustFunction) {
          if (adjustFunction === void 0)
            adjustFunction = function copy(v) {
              if (v.startsWith("url"))
                console.warn("SVGLoader: url access in attributes is not implemented.");
              return v;
            };
          if (node.hasAttribute(svgName))
            style[jsName] = adjustFunction(node.getAttribute(svgName));
          if (stylesheetStyles[svgName])
            style[jsName] = adjustFunction(stylesheetStyles[svgName]);
          if (node.style && node.style[svgName] !== "")
            style[jsName] = adjustFunction(node.style[svgName]);
        }
        function clamp(v) {
          return Math.max(0, Math.min(1, parseFloatWithUnits(v)));
        }
        function positive(v) {
          return Math.max(0, parseFloatWithUnits(v));
        }
        addStyle("fill", "fill");
        addStyle("fill-opacity", "fillOpacity", clamp);
        addStyle("opacity", "opacity", clamp);
        addStyle("stroke", "stroke");
        addStyle("stroke-opacity", "strokeOpacity", clamp);
        addStyle("stroke-width", "strokeWidth", positive);
        addStyle("stroke-linejoin", "strokeLineJoin");
        addStyle("stroke-linecap", "strokeLineCap");
        addStyle("stroke-miterlimit", "strokeMiterLimit", positive);
        addStyle("visibility", "visibility");
        return style;
      }
      function getReflection(a, b2) {
        return a - (b2 - a);
      }
      function parseFloats(input, flags, stride) {
        if (typeof input !== "string") {
          throw new TypeError("Invalid input: " + typeof input);
        }
        var RE = {
          SEPARATOR: /[ \t\r\n\,.\-+]/,
          WHITESPACE: /[ \t\r\n]/,
          DIGIT: /[\d]/,
          SIGN: /[-+]/,
          POINT: /\./,
          COMMA: /,/,
          EXP: /e/i,
          FLAGS: /[01]/
        };
        var SEP = 0;
        var INT = 1;
        var FLOAT = 2;
        var EXP = 3;
        var state = SEP;
        var seenComma = true;
        var result = [], number = "", exponent = "";
        function throwSyntaxError(current2, i2, partial) {
          var error = new SyntaxError('Unexpected character "' + current2 + '" at index ' + i2 + ".");
          error.partial = partial;
          throw error;
        }
        function newNumber() {
          if (number !== "") {
            if (exponent === "")
              result.push(Number(number));
            else
              result.push(Number(number) * Math.pow(10, Number(exponent)));
          }
          number = "";
          exponent = "";
        }
        var current, i = 0, length = input.length;
        for (i = 0; i < length; i++) {
          current = input[i];
          if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {
            state = INT;
            number = current;
            newNumber();
            continue;
          }
          if (state === SEP) {
            if (RE.WHITESPACE.test(current)) {
              continue;
            }
            if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {
              state = INT;
              number = current;
              continue;
            }
            if (RE.POINT.test(current)) {
              state = FLOAT;
              number = current;
              continue;
            }
            if (RE.COMMA.test(current)) {
              if (seenComma) {
                throwSyntaxError(current, i, result);
              }
              seenComma = true;
            }
          }
          if (state === INT) {
            if (RE.DIGIT.test(current)) {
              number += current;
              continue;
            }
            if (RE.POINT.test(current)) {
              number += current;
              state = FLOAT;
              continue;
            }
            if (RE.EXP.test(current)) {
              state = EXP;
              continue;
            }
            if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {
              throwSyntaxError(current, i, result);
            }
          }
          if (state === FLOAT) {
            if (RE.DIGIT.test(current)) {
              number += current;
              continue;
            }
            if (RE.EXP.test(current)) {
              state = EXP;
              continue;
            }
            if (RE.POINT.test(current) && number[number.length - 1] === ".") {
              throwSyntaxError(current, i, result);
            }
          }
          if (state === EXP) {
            if (RE.DIGIT.test(current)) {
              exponent += current;
              continue;
            }
            if (RE.SIGN.test(current)) {
              if (exponent === "") {
                exponent += current;
                continue;
              }
              if (exponent.length === 1 && RE.SIGN.test(exponent)) {
                throwSyntaxError(current, i, result);
              }
            }
          }
          if (RE.WHITESPACE.test(current)) {
            newNumber();
            state = SEP;
            seenComma = false;
          } else if (RE.COMMA.test(current)) {
            newNumber();
            state = SEP;
            seenComma = true;
          } else if (RE.SIGN.test(current)) {
            newNumber();
            state = INT;
            number = current;
          } else if (RE.POINT.test(current)) {
            newNumber();
            state = FLOAT;
            number = current;
          } else {
            throwSyntaxError(current, i, result);
          }
        }
        newNumber();
        return result;
      }
      var units = ["mm", "cm", "in", "pt", "pc", "px"];
      var unitConversion = {
        "mm": {
          "mm": 1,
          "cm": 0.1,
          "in": 1 / 25.4,
          "pt": 72 / 25.4,
          "pc": 6 / 25.4,
          "px": -1
        },
        "cm": {
          "mm": 10,
          "cm": 1,
          "in": 1 / 2.54,
          "pt": 72 / 2.54,
          "pc": 6 / 2.54,
          "px": -1
        },
        "in": {
          "mm": 25.4,
          "cm": 2.54,
          "in": 1,
          "pt": 72,
          "pc": 6,
          "px": -1
        },
        "pt": {
          "mm": 25.4 / 72,
          "cm": 2.54 / 72,
          "in": 1 / 72,
          "pt": 1,
          "pc": 6 / 72,
          "px": -1
        },
        "pc": {
          "mm": 25.4 / 6,
          "cm": 2.54 / 6,
          "in": 1 / 6,
          "pt": 72 / 6,
          "pc": 1,
          "px": -1
        },
        "px": {
          "px": 1
        }
      };
      function parseFloatWithUnits(string) {
        var theUnit = "px";
        if (typeof string === "string" || string instanceof String) {
          for (var i = 0, n = units.length; i < n; i++) {
            var u = units[i];
            if (string.endsWith(u)) {
              theUnit = u;
              string = string.substring(0, string.length - u.length);
              break;
            }
          }
        }
        var scale = void 0;
        if (theUnit === "px" && scope.defaultUnit !== "px") {
          scale = unitConversion["in"][scope.defaultUnit] / scope.defaultDPI;
        } else {
          scale = unitConversion[theUnit][scope.defaultUnit];
          if (scale < 0) {
            scale = unitConversion[theUnit]["in"] * scope.defaultDPI;
          }
        }
        return scale * parseFloat(string);
      }
      function getNodeTransform(node) {
        if (!(node.hasAttribute("transform") || node.nodeName === "use" && (node.hasAttribute("x") || node.hasAttribute("y")))) {
          return null;
        }
        var transform = parseNodeTransform(node);
        if (transformStack.length > 0) {
          transform.premultiply(transformStack[transformStack.length - 1]);
        }
        currentTransform.copy(transform);
        transformStack.push(transform);
        return transform;
      }
      function parseNodeTransform(node) {
        var transform = new Matrix3();
        var currentTransform2 = tempTransform0;
        if (node.nodeName === "use" && (node.hasAttribute("x") || node.hasAttribute("y"))) {
          var tx = parseFloatWithUnits(node.getAttribute("x"));
          var ty = parseFloatWithUnits(node.getAttribute("y"));
          transform.translate(tx, ty);
        }
        if (node.hasAttribute("transform")) {
          var transformsTexts = node.getAttribute("transform").split(")");
          for (var tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {
            var transformText = transformsTexts[tIndex].trim();
            if (transformText === "")
              continue;
            var openParPos = transformText.indexOf("(");
            var closeParPos = transformText.length;
            if (openParPos > 0 && openParPos < closeParPos) {
              var transformType = transformText.substr(0, openParPos);
              var array = parseFloats(transformText.substr(openParPos + 1, closeParPos - openParPos - 1));
              currentTransform2.identity();
              switch (transformType) {
                case "translate":
                  if (array.length >= 1) {
                    var tx = array[0];
                    var ty = tx;
                    if (array.length >= 2) {
                      ty = array[1];
                    }
                    currentTransform2.translate(tx, ty);
                  }
                  break;
                case "rotate":
                  if (array.length >= 1) {
                    var angle = 0;
                    var cx = 0;
                    var cy = 0;
                    angle = -array[0] * Math.PI / 180;
                    if (array.length >= 3) {
                      cx = array[1];
                      cy = array[2];
                    }
                    tempTransform1.identity().translate(-cx, -cy);
                    tempTransform2.identity().rotate(angle);
                    tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);
                    tempTransform1.identity().translate(cx, cy);
                    currentTransform2.multiplyMatrices(tempTransform1, tempTransform3);
                  }
                  break;
                case "scale":
                  if (array.length >= 1) {
                    var scaleX = array[0];
                    var scaleY = scaleX;
                    if (array.length >= 2) {
                      scaleY = array[1];
                    }
                    currentTransform2.scale(scaleX, scaleY);
                  }
                  break;
                case "skewX":
                  if (array.length === 1) {
                    currentTransform2.set(1, Math.tan(array[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);
                  }
                  break;
                case "skewY":
                  if (array.length === 1) {
                    currentTransform2.set(1, 0, 0, Math.tan(array[0] * Math.PI / 180), 1, 0, 0, 0, 1);
                  }
                  break;
                case "matrix":
                  if (array.length === 6) {
                    currentTransform2.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1);
                  }
                  break;
              }
            }
            transform.premultiply(currentTransform2);
          }
        }
        return transform;
      }
      function transformPath(path, m) {
        function transfVec2(v2) {
          tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);
          v2.set(tempV3.x, tempV3.y);
        }
        var isRotated = isTransformRotated(m);
        var subPaths = path.subPaths;
        for (var i = 0, n = subPaths.length; i < n; i++) {
          var subPath = subPaths[i];
          var curves = subPath.curves;
          for (var j = 0; j < curves.length; j++) {
            var curve = curves[j];
            if (curve.isLineCurve) {
              transfVec2(curve.v1);
              transfVec2(curve.v2);
            } else if (curve.isCubicBezierCurve) {
              transfVec2(curve.v0);
              transfVec2(curve.v1);
              transfVec2(curve.v2);
              transfVec2(curve.v3);
            } else if (curve.isQuadraticBezierCurve) {
              transfVec2(curve.v0);
              transfVec2(curve.v1);
              transfVec2(curve.v2);
            } else if (curve.isEllipseCurve) {
              if (isRotated) {
                console.warn("SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.");
              }
              tempV2.set(curve.aX, curve.aY);
              transfVec2(tempV2);
              curve.aX = tempV2.x;
              curve.aY = tempV2.y;
              curve.xRadius *= getTransformScaleX(m);
              curve.yRadius *= getTransformScaleY(m);
            }
          }
        }
      }
      function isTransformRotated(m) {
        return m.elements[1] !== 0 || m.elements[3] !== 0;
      }
      function getTransformScaleX(m) {
        var te = m.elements;
        return Math.sqrt(te[0] * te[0] + te[1] * te[1]);
      }
      function getTransformScaleY(m) {
        var te = m.elements;
        return Math.sqrt(te[3] * te[3] + te[4] * te[4]);
      }
      var paths = [];
      var stylesheets = {};
      var transformStack = [];
      var tempTransform0 = new Matrix3();
      var tempTransform1 = new Matrix3();
      var tempTransform2 = new Matrix3();
      var tempTransform3 = new Matrix3();
      var tempV2 = new Vector2();
      var tempV3 = new Vector3();
      var currentTransform = new Matrix3();
      var xml = new DOMParser().parseFromString(text, "image/svg+xml");
      parseNode(xml.documentElement, {
        fill: "#000",
        fillOpacity: 1,
        strokeOpacity: 1,
        strokeWidth: 1,
        strokeLineJoin: "miter",
        strokeLineCap: "butt",
        strokeMiterLimit: 4
      });
      var data = { paths, xml: xml.documentElement };
      return data;
    }
  });
  SVGLoader.createShapes = function(shapePath) {
    const BIGNUMBER = 999999999;
    const IntersectionLocationType = {
      ORIGIN: 0,
      DESTINATION: 1,
      BETWEEN: 2,
      LEFT: 3,
      RIGHT: 4,
      BEHIND: 5,
      BEYOND: 6
    };
    const classifyResult = {
      loc: IntersectionLocationType.ORIGIN,
      t: 0
    };
    function findEdgeIntersection(a0, a1, b0, b1) {
      var x1 = a0.x;
      var x2 = a1.x;
      var x3 = b0.x;
      var x4 = b1.x;
      var y1 = a0.y;
      var y2 = a1.y;
      var y3 = b0.y;
      var y4 = b1.y;
      var nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
      var nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
      var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
      var t1 = nom1 / denom;
      var t2 = nom2 / denom;
      if (denom === 0 && nom1 !== 0 || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {
        return null;
      } else if (nom1 === 0 && denom === 0) {
        for (var i = 0; i < 2; i++) {
          classifyPoint(i === 0 ? b0 : b1, a0, a1);
          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {
            var point = i === 0 ? b0 : b1;
            return { x: point.x, y: point.y, t: classifyResult.t };
          } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {
            var x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10);
            var y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10);
            return { x, y, t: classifyResult.t };
          }
        }
        return null;
      } else {
        for (var i = 0; i < 2; i++) {
          classifyPoint(i === 0 ? b0 : b1, a0, a1);
          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {
            var point = i === 0 ? b0 : b1;
            return { x: point.x, y: point.y, t: classifyResult.t };
          }
        }
        var x = +(x1 + t1 * (x2 - x1)).toPrecision(10);
        var y = +(y1 + t1 * (y2 - y1)).toPrecision(10);
        return { x, y, t: t1 };
      }
    }
    function classifyPoint(p, edgeStart, edgeEnd) {
      var ax = edgeEnd.x - edgeStart.x;
      var ay = edgeEnd.y - edgeStart.y;
      var bx = p.x - edgeStart.x;
      var by = p.y - edgeStart.y;
      var sa = ax * by - bx * ay;
      if (p.x === edgeStart.x && p.y === edgeStart.y) {
        classifyResult.loc = IntersectionLocationType.ORIGIN;
        classifyResult.t = 0;
        return;
      }
      if (p.x === edgeEnd.x && p.y === edgeEnd.y) {
        classifyResult.loc = IntersectionLocationType.DESTINATION;
        classifyResult.t = 1;
        return;
      }
      if (sa < -Number.EPSILON) {
        classifyResult.loc = IntersectionLocationType.LEFT;
        return;
      }
      if (sa > Number.EPSILON) {
        classifyResult.loc = IntersectionLocationType.RIGHT;
        return;
      }
      if (ax * bx < 0 || ay * by < 0) {
        classifyResult.loc = IntersectionLocationType.BEHIND;
        return;
      }
      if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {
        classifyResult.loc = IntersectionLocationType.BEYOND;
        return;
      }
      var t;
      if (ax !== 0) {
        t = bx / ax;
      } else {
        t = by / ay;
      }
      classifyResult.loc = IntersectionLocationType.BETWEEN;
      classifyResult.t = t;
    }
    function getIntersections(path1, path2) {
      const intersectionsRaw = [];
      const intersections = [];
      for (let index = 1; index < path1.length; index++) {
        const path1EdgeStart = path1[index - 1];
        const path1EdgeEnd = path1[index];
        for (let index2 = 1; index2 < path2.length; index2++) {
          const path2EdgeStart = path2[index2 - 1];
          const path2EdgeEnd = path2[index2];
          const intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd);
          if (intersection !== null && intersectionsRaw.find((i) => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON) === void 0) {
            intersectionsRaw.push(intersection);
            intersections.push(new Vector2(intersection.x, intersection.y));
          }
        }
      }
      return intersections;
    }
    function getScanlineIntersections(scanline, boundingBox, paths) {
      const center = new Vector2();
      boundingBox.getCenter(center);
      const allIntersections = [];
      paths.forEach((path) => {
        if (path.boundingBox.containsPoint(center)) {
          const intersections = getIntersections(scanline, path.points);
          intersections.forEach((p) => {
            allIntersections.push({ identifier: path.identifier, isCW: path.isCW, point: p });
          });
        }
      });
      allIntersections.sort((i1, i2) => {
        return i1.point.x - i2.point.x;
      });
      return allIntersections;
    }
    function isHoleTo(simplePath, allPaths, scanlineMinX2, scanlineMaxX2, _fillRule) {
      if (_fillRule === null || _fillRule === void 0 || _fillRule === "") {
        _fillRule = "nonzero";
      }
      const centerBoundingBox = new Vector2();
      simplePath.boundingBox.getCenter(centerBoundingBox);
      const scanline = [new Vector2(scanlineMinX2, centerBoundingBox.y), new Vector2(scanlineMaxX2, centerBoundingBox.y)];
      const scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths);
      scanlineIntersections.sort((i1, i2) => {
        return i1.point.x - i2.point.x;
      });
      const baseIntersections = [];
      const otherIntersections = [];
      scanlineIntersections.forEach((i2) => {
        if (i2.identifier === simplePath.identifier) {
          baseIntersections.push(i2);
        } else {
          otherIntersections.push(i2);
        }
      });
      const firstXOfPath = baseIntersections[0].point.x;
      const stack = [];
      let i = 0;
      while (i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath) {
        if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {
          stack.pop();
        } else {
          stack.push(otherIntersections[i].identifier);
        }
        i++;
      }
      stack.push(simplePath.identifier);
      if (_fillRule === "evenodd") {
        const isHole = stack.length % 2 === 0 ? true : false;
        const isHoleFor = stack[stack.length - 2];
        return { identifier: simplePath.identifier, isHole, for: isHoleFor };
      } else if (_fillRule === "nonzero") {
        let isHole = true;
        let isHoleFor = null;
        let lastCWValue = null;
        for (let i2 = 0; i2 < stack.length; i2++) {
          const identifier2 = stack[i2];
          if (isHole) {
            lastCWValue = allPaths[identifier2].isCW;
            isHole = false;
            isHoleFor = identifier2;
          } else if (lastCWValue !== allPaths[identifier2].isCW) {
            lastCWValue = allPaths[identifier2].isCW;
            isHole = true;
          }
        }
        return { identifier: simplePath.identifier, isHole, for: isHoleFor };
      } else {
        console.warn('fill-rule: "' + _fillRule + '" is currently not implemented.');
      }
    }
    let identifier = 0;
    let scanlineMinX = BIGNUMBER;
    let scanlineMaxX = -BIGNUMBER;
    let simplePaths = shapePath.subPaths.map((p) => {
      const points = p.getPoints();
      let maxY = -BIGNUMBER;
      let minY = BIGNUMBER;
      let maxX = -BIGNUMBER;
      let minX = BIGNUMBER;
      for (let i = 0; i < points.length; i++) {
        const p2 = points[i];
        if (p2.y > maxY) {
          maxY = p2.y;
        }
        if (p2.y < minY) {
          minY = p2.y;
        }
        if (p2.x > maxX) {
          maxX = p2.x;
        }
        if (p2.x < minX) {
          minX = p2.x;
        }
      }
      if (scanlineMaxX <= maxX) {
        scanlineMaxX = maxX + 1;
      }
      if (scanlineMinX >= minX) {
        scanlineMinX = minX - 1;
      }
      return { points, isCW: ShapeUtils.isClockWise(points), identifier: identifier++, boundingBox: new Box2(new Vector2(minX, minY), new Vector2(maxX, maxY)) };
    });
    simplePaths = simplePaths.filter((sp) => sp.points.length > 0);
    const isAHole = simplePaths.map((p) => isHoleTo(p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData.style.fillRule));
    const shapesToReturn = [];
    simplePaths.forEach((p) => {
      const amIAHole = isAHole[p.identifier];
      if (!amIAHole.isHole) {
        const shape = new Shape(p.points);
        const holes = isAHole.filter((h) => h.isHole && h.for === p.identifier);
        holes.forEach((h) => {
          const path = simplePaths[h.identifier];
          shape.holes.push(new Path(path.points));
        });
        shapesToReturn.push(shape);
      }
    });
    return shapesToReturn;
  };
  SVGLoader.getStrokeStyle = function(width, color, lineJoin, lineCap, miterLimit) {
    width = width !== void 0 ? width : 1;
    color = color !== void 0 ? color : "#000";
    lineJoin = lineJoin !== void 0 ? lineJoin : "miter";
    lineCap = lineCap !== void 0 ? lineCap : "butt";
    miterLimit = miterLimit !== void 0 ? miterLimit : 4;
    return {
      strokeColor: color,
      strokeWidth: width,
      strokeLineJoin: lineJoin,
      strokeLineCap: lineCap,
      strokeMiterLimit: miterLimit
    };
  };
  SVGLoader.pointsToStroke = function(points, style, arcDivisions, minDistance) {
    var vertices = [];
    var normals = [];
    var uvs = [];
    if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {
      return null;
    }
    var geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    geometry.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    return geometry;
  };
  SVGLoader.pointsToStrokeWithBuffers = function() {
    var tempV2_1 = new Vector2();
    var tempV2_2 = new Vector2();
    var tempV2_3 = new Vector2();
    var tempV2_4 = new Vector2();
    var tempV2_5 = new Vector2();
    var tempV2_6 = new Vector2();
    var tempV2_7 = new Vector2();
    var lastPointL = new Vector2();
    var lastPointR = new Vector2();
    var point0L = new Vector2();
    var point0R = new Vector2();
    var currentPointL = new Vector2();
    var currentPointR = new Vector2();
    var nextPointL = new Vector2();
    var nextPointR = new Vector2();
    var innerPoint = new Vector2();
    var outerPoint = new Vector2();
    return function(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {
      arcDivisions = arcDivisions !== void 0 ? arcDivisions : 12;
      minDistance = minDistance !== void 0 ? minDistance : 1e-3;
      vertexOffset = vertexOffset !== void 0 ? vertexOffset : 0;
      points = removeDuplicatedPoints(points);
      var numPoints = points.length;
      if (numPoints < 2)
        return 0;
      var isClosed = points[0].equals(points[numPoints - 1]);
      var currentPoint;
      var previousPoint = points[0];
      var nextPoint;
      var strokeWidth2 = style.strokeWidth / 2;
      var deltaU = 1 / (numPoints - 1);
      var u0 = 0;
      var innerSideModified;
      var joinIsOnLeftSide;
      var isMiter;
      var initialJoinIsOnLeftSide = false;
      var numVertices = 0;
      var currentCoordinate = vertexOffset * 3;
      var currentCoordinateUV = vertexOffset * 2;
      getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);
      lastPointL.copy(points[0]).sub(tempV2_1);
      lastPointR.copy(points[0]).add(tempV2_1);
      point0L.copy(lastPointL);
      point0R.copy(lastPointR);
      for (var iPoint = 1; iPoint < numPoints; iPoint++) {
        currentPoint = points[iPoint];
        if (iPoint === numPoints - 1) {
          if (isClosed) {
            nextPoint = points[1];
          } else
            nextPoint = void 0;
        } else {
          nextPoint = points[iPoint + 1];
        }
        var normal1 = tempV2_1;
        getNormal(previousPoint, currentPoint, normal1);
        tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);
        currentPointL.copy(currentPoint).sub(tempV2_3);
        currentPointR.copy(currentPoint).add(tempV2_3);
        var u1 = u0 + deltaU;
        innerSideModified = false;
        if (nextPoint !== void 0) {
          getNormal(currentPoint, nextPoint, tempV2_2);
          tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);
          nextPointL.copy(currentPoint).sub(tempV2_3);
          nextPointR.copy(currentPoint).add(tempV2_3);
          joinIsOnLeftSide = true;
          tempV2_3.subVectors(nextPoint, previousPoint);
          if (normal1.dot(tempV2_3) < 0) {
            joinIsOnLeftSide = false;
          }
          if (iPoint === 1)
            initialJoinIsOnLeftSide = joinIsOnLeftSide;
          tempV2_3.subVectors(nextPoint, currentPoint);
          tempV2_3.normalize();
          var dot = Math.abs(normal1.dot(tempV2_3));
          if (dot !== 0) {
            var miterSide = strokeWidth2 / dot;
            tempV2_3.multiplyScalar(-miterSide);
            tempV2_4.subVectors(currentPoint, previousPoint);
            tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);
            innerPoint.copy(tempV2_5).negate();
            var miterLength2 = tempV2_5.length();
            var segmentLengthPrev = tempV2_4.length();
            tempV2_4.divideScalar(segmentLengthPrev);
            tempV2_6.subVectors(nextPoint, currentPoint);
            var segmentLengthNext = tempV2_6.length();
            tempV2_6.divideScalar(segmentLengthNext);
            if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {
              innerSideModified = true;
            }
            outerPoint.copy(tempV2_5).add(currentPoint);
            innerPoint.add(currentPoint);
            isMiter = false;
            if (innerSideModified) {
              if (joinIsOnLeftSide) {
                nextPointR.copy(innerPoint);
                currentPointR.copy(innerPoint);
              } else {
                nextPointL.copy(innerPoint);
                currentPointL.copy(innerPoint);
              }
            } else {
              makeSegmentTriangles();
            }
            switch (style.strokeLineJoin) {
              case "bevel":
                makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);
                break;
              case "round":
                createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);
                if (joinIsOnLeftSide) {
                  makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);
                } else {
                  makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);
                }
                break;
              case "miter":
              case "miter-clip":
              default:
                var miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;
                if (miterFraction < 1) {
                  if (style.strokeLineJoin !== "miter-clip") {
                    makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);
                    break;
                  } else {
                    createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);
                    if (joinIsOnLeftSide) {
                      tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);
                      tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);
                      addVertex(currentPointL, u1, 0);
                      addVertex(tempV2_6, u1, 0);
                      addVertex(currentPoint, u1, 0.5);
                      addVertex(currentPoint, u1, 0.5);
                      addVertex(tempV2_6, u1, 0);
                      addVertex(tempV2_7, u1, 0);
                      addVertex(currentPoint, u1, 0.5);
                      addVertex(tempV2_7, u1, 0);
                      addVertex(nextPointL, u1, 0);
                    } else {
                      tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);
                      tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);
                      addVertex(currentPointR, u1, 1);
                      addVertex(tempV2_6, u1, 1);
                      addVertex(currentPoint, u1, 0.5);
                      addVertex(currentPoint, u1, 0.5);
                      addVertex(tempV2_6, u1, 1);
                      addVertex(tempV2_7, u1, 1);
                      addVertex(currentPoint, u1, 0.5);
                      addVertex(tempV2_7, u1, 1);
                      addVertex(nextPointR, u1, 1);
                    }
                  }
                } else {
                  if (innerSideModified) {
                    if (joinIsOnLeftSide) {
                      addVertex(lastPointR, u0, 1);
                      addVertex(lastPointL, u0, 0);
                      addVertex(outerPoint, u1, 0);
                      addVertex(lastPointR, u0, 1);
                      addVertex(outerPoint, u1, 0);
                      addVertex(innerPoint, u1, 1);
                    } else {
                      addVertex(lastPointR, u0, 1);
                      addVertex(lastPointL, u0, 0);
                      addVertex(outerPoint, u1, 1);
                      addVertex(lastPointL, u0, 0);
                      addVertex(innerPoint, u1, 0);
                      addVertex(outerPoint, u1, 1);
                    }
                    if (joinIsOnLeftSide) {
                      nextPointL.copy(outerPoint);
                    } else {
                      nextPointR.copy(outerPoint);
                    }
                  } else {
                    if (joinIsOnLeftSide) {
                      addVertex(currentPointL, u1, 0);
                      addVertex(outerPoint, u1, 0);
                      addVertex(currentPoint, u1, 0.5);
                      addVertex(currentPoint, u1, 0.5);
                      addVertex(outerPoint, u1, 0);
                      addVertex(nextPointL, u1, 0);
                    } else {
                      addVertex(currentPointR, u1, 1);
                      addVertex(outerPoint, u1, 1);
                      addVertex(currentPoint, u1, 0.5);
                      addVertex(currentPoint, u1, 0.5);
                      addVertex(outerPoint, u1, 1);
                      addVertex(nextPointR, u1, 1);
                    }
                  }
                  isMiter = true;
                }
                break;
            }
          } else {
            makeSegmentTriangles();
          }
        } else {
          makeSegmentTriangles();
        }
        if (!isClosed && iPoint === numPoints - 1) {
          addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);
        }
        u0 = u1;
        previousPoint = currentPoint;
        lastPointL.copy(nextPointL);
        lastPointR.copy(nextPointR);
      }
      if (!isClosed) {
        addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);
      } else if (innerSideModified && vertices) {
        var lastOuter = outerPoint;
        var lastInner = innerPoint;
        if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {
          lastOuter = innerPoint;
          lastInner = outerPoint;
        }
        if (joinIsOnLeftSide) {
          if (isMiter || initialJoinIsOnLeftSide) {
            lastInner.toArray(vertices, 0 * 3);
            lastInner.toArray(vertices, 3 * 3);
            if (isMiter) {
              lastOuter.toArray(vertices, 1 * 3);
            }
          }
        } else {
          if (isMiter || !initialJoinIsOnLeftSide) {
            lastInner.toArray(vertices, 1 * 3);
            lastInner.toArray(vertices, 3 * 3);
            if (isMiter) {
              lastOuter.toArray(vertices, 0 * 3);
            }
          }
        }
      }
      return numVertices;
      function getNormal(p1, p2, result) {
        result.subVectors(p2, p1);
        return result.set(-result.y, result.x).normalize();
      }
      function addVertex(position, u, v) {
        if (vertices) {
          vertices[currentCoordinate] = position.x;
          vertices[currentCoordinate + 1] = position.y;
          vertices[currentCoordinate + 2] = 0;
          if (normals) {
            normals[currentCoordinate] = 0;
            normals[currentCoordinate + 1] = 0;
            normals[currentCoordinate + 2] = 1;
          }
          currentCoordinate += 3;
          if (uvs) {
            uvs[currentCoordinateUV] = u;
            uvs[currentCoordinateUV + 1] = v;
            currentCoordinateUV += 2;
          }
        }
        numVertices += 3;
      }
      function makeCircularSector(center, p1, p2, u, v) {
        tempV2_1.copy(p1).sub(center).normalize();
        tempV2_2.copy(p2).sub(center).normalize();
        var angle = Math.PI;
        var dot2 = tempV2_1.dot(tempV2_2);
        if (Math.abs(dot2) < 1)
          angle = Math.abs(Math.acos(dot2));
        angle /= arcDivisions;
        tempV2_3.copy(p1);
        for (var i = 0, il = arcDivisions - 1; i < il; i++) {
          tempV2_4.copy(tempV2_3).rotateAround(center, angle);
          addVertex(tempV2_3, u, v);
          addVertex(tempV2_4, u, v);
          addVertex(center, u, 0.5);
          tempV2_3.copy(tempV2_4);
        }
        addVertex(tempV2_4, u, v);
        addVertex(p2, u, v);
        addVertex(center, u, 0.5);
      }
      function makeSegmentTriangles() {
        addVertex(lastPointR, u0, 1);
        addVertex(lastPointL, u0, 0);
        addVertex(currentPointL, u1, 0);
        addVertex(lastPointR, u0, 1);
        addVertex(currentPointL, u1, 1);
        addVertex(currentPointR, u1, 0);
      }
      function makeSegmentWithBevelJoin(joinIsOnLeftSide2, innerSideModified2, u) {
        if (innerSideModified2) {
          if (joinIsOnLeftSide2) {
            addVertex(lastPointR, u0, 1);
            addVertex(lastPointL, u0, 0);
            addVertex(currentPointL, u1, 0);
            addVertex(lastPointR, u0, 1);
            addVertex(currentPointL, u1, 0);
            addVertex(innerPoint, u1, 1);
            addVertex(currentPointL, u, 0);
            addVertex(nextPointL, u, 0);
            addVertex(innerPoint, u, 0.5);
          } else {
            addVertex(lastPointR, u0, 1);
            addVertex(lastPointL, u0, 0);
            addVertex(currentPointR, u1, 1);
            addVertex(lastPointL, u0, 0);
            addVertex(innerPoint, u1, 0);
            addVertex(currentPointR, u1, 1);
            addVertex(currentPointR, u, 1);
            addVertex(nextPointR, u, 0);
            addVertex(innerPoint, u, 0.5);
          }
        } else {
          if (joinIsOnLeftSide2) {
            addVertex(currentPointL, u, 0);
            addVertex(nextPointL, u, 0);
            addVertex(currentPoint, u, 0.5);
          } else {
            addVertex(currentPointR, u, 1);
            addVertex(nextPointR, u, 0);
            addVertex(currentPoint, u, 0.5);
          }
        }
      }
      function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide2, innerSideModified2) {
        if (innerSideModified2) {
          if (joinIsOnLeftSide2) {
            addVertex(lastPointR, u0, 1);
            addVertex(lastPointL, u0, 0);
            addVertex(currentPointL, u1, 0);
            addVertex(lastPointR, u0, 1);
            addVertex(currentPointL, u1, 0);
            addVertex(innerPoint, u1, 1);
            addVertex(currentPointL, u0, 0);
            addVertex(currentPoint, u1, 0.5);
            addVertex(innerPoint, u1, 1);
            addVertex(currentPoint, u1, 0.5);
            addVertex(nextPointL, u0, 0);
            addVertex(innerPoint, u1, 1);
          } else {
            addVertex(lastPointR, u0, 1);
            addVertex(lastPointL, u0, 0);
            addVertex(currentPointR, u1, 1);
            addVertex(lastPointL, u0, 0);
            addVertex(innerPoint, u1, 0);
            addVertex(currentPointR, u1, 1);
            addVertex(currentPointR, u0, 1);
            addVertex(innerPoint, u1, 0);
            addVertex(currentPoint, u1, 0.5);
            addVertex(currentPoint, u1, 0.5);
            addVertex(innerPoint, u1, 0);
            addVertex(nextPointR, u0, 1);
          }
        }
      }
      function addCapGeometry(center, p1, p2, joinIsOnLeftSide2, start, u) {
        switch (style.strokeLineCap) {
          case "round":
            if (start) {
              makeCircularSector(center, p2, p1, u, 0.5);
            } else {
              makeCircularSector(center, p1, p2, u, 0.5);
            }
            break;
          case "square":
            if (start) {
              tempV2_1.subVectors(p1, center);
              tempV2_2.set(tempV2_1.y, -tempV2_1.x);
              tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);
              tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);
              if (joinIsOnLeftSide2) {
                tempV2_3.toArray(vertices, 1 * 3);
                tempV2_4.toArray(vertices, 0 * 3);
                tempV2_4.toArray(vertices, 3 * 3);
              } else {
                tempV2_3.toArray(vertices, 1 * 3);
                tempV2_3.toArray(vertices, 3 * 3);
                tempV2_4.toArray(vertices, 0 * 3);
              }
            } else {
              tempV2_1.subVectors(p2, center);
              tempV2_2.set(tempV2_1.y, -tempV2_1.x);
              tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);
              tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);
              var vl = vertices.length;
              if (joinIsOnLeftSide2) {
                tempV2_3.toArray(vertices, vl - 1 * 3);
                tempV2_4.toArray(vertices, vl - 2 * 3);
                tempV2_4.toArray(vertices, vl - 4 * 3);
              } else {
                tempV2_3.toArray(vertices, vl - 2 * 3);
                tempV2_4.toArray(vertices, vl - 1 * 3);
                tempV2_4.toArray(vertices, vl - 4 * 3);
              }
            }
            break;
          case "butt":
          default:
            break;
        }
      }
      function removeDuplicatedPoints(points2) {
        var dupPoints = false;
        for (var i = 1, n = points2.length - 1; i < n; i++) {
          if (points2[i].distanceTo(points2[i + 1]) < minDistance) {
            dupPoints = true;
            break;
          }
        }
        if (!dupPoints)
          return points2;
        var newPoints = [];
        newPoints.push(points2[0]);
        for (var i = 1, n = points2.length - 1; i < n; i++) {
          if (points2[i].distanceTo(points2[i + 1]) >= minDistance) {
            newPoints.push(points2[i]);
          }
        }
        newPoints.push(points2[points2.length - 1]);
        return newPoints;
      }
    };
  }();

  // node_modules/@enable3d/three-graphics/jsm/csg/_directGeometry.js
  var DirectGeometry2 = class {
    constructor() {
      this.vertices = [];
      this.normals = [];
      this.colors = [];
      this.uvs = [];
      this.uvs2 = [];
      this.groups = [];
      this.morphTargets = {};
      this.skinWeights = [];
      this.skinIndices = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      this.verticesNeedUpdate = false;
      this.normalsNeedUpdate = false;
      this.colorsNeedUpdate = false;
      this.uvsNeedUpdate = false;
      this.groupsNeedUpdate = false;
    }
    computeGroups(geometry) {
      const groups = [];
      let group, i;
      let materialIndex = void 0;
      const faces = geometry.faces;
      for (i = 0; i < faces.length; i++) {
        const face = faces[i];
        if (face.materialIndex !== materialIndex) {
          materialIndex = face.materialIndex;
          if (group !== void 0) {
            group.count = i * 3 - group.start;
            groups.push(group);
          }
          group = {
            start: i * 3,
            materialIndex
          };
        }
      }
      if (group !== void 0) {
        group.count = i * 3 - group.start;
        groups.push(group);
      }
      this.groups = groups;
    }
    fromGeometry(geometry) {
      const faces = geometry.faces;
      const vertices = geometry.vertices;
      const faceVertexUvs = geometry.faceVertexUvs;
      const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
      const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
      const morphTargets = geometry.morphTargets;
      const morphTargetsLength = morphTargets.length;
      let morphTargetsPosition;
      if (morphTargetsLength > 0) {
        morphTargetsPosition = [];
        for (let i = 0; i < morphTargetsLength; i++) {
          morphTargetsPosition[i] = {
            name: morphTargets[i].name,
            data: []
          };
        }
        this.morphTargets.position = morphTargetsPosition;
      }
      const morphNormals = geometry.morphNormals;
      const morphNormalsLength = morphNormals.length;
      let morphTargetsNormal;
      if (morphNormalsLength > 0) {
        morphTargetsNormal = [];
        for (let i = 0; i < morphNormalsLength; i++) {
          morphTargetsNormal[i] = {
            name: morphNormals[i].name,
            data: []
          };
        }
        this.morphTargets.normal = morphTargetsNormal;
      }
      const skinIndices = geometry.skinIndices;
      const skinWeights = geometry.skinWeights;
      const hasSkinIndices = skinIndices.length === vertices.length;
      const hasSkinWeights = skinWeights.length === vertices.length;
      if (vertices.length > 0 && faces.length === 0) {
        console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
      }
      for (let i = 0; i < faces.length; i++) {
        const face = faces[i];
        this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
        const vertexNormals = face.vertexNormals;
        if (vertexNormals.length === 3) {
          this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
        } else {
          const normal = face.normal;
          this.normals.push(normal, normal, normal);
        }
        const vertexColors = face.vertexColors;
        if (vertexColors.length === 3) {
          this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
        } else {
          const color = face.color;
          this.colors.push(color, color, color);
        }
        if (hasFaceVertexUv === true) {
          const vertexUvs = faceVertexUvs[0][i];
          if (vertexUvs !== void 0) {
            this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
          } else {
            console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", i);
            this.uvs.push(new Vector2(), new Vector2(), new Vector2());
          }
        }
        if (hasFaceVertexUv2 === true) {
          const vertexUvs = faceVertexUvs[1][i];
          if (vertexUvs !== void 0) {
            this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
          } else {
            console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", i);
            this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
          }
        }
        for (let j = 0; j < morphTargetsLength; j++) {
          const morphTarget = morphTargets[j].vertices;
          morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
        }
        for (let j = 0; j < morphNormalsLength; j++) {
          const morphNormal = morphNormals[j].vertexNormals[i];
          morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);
        }
        if (hasSkinIndices) {
          this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
        }
        if (hasSkinWeights) {
          this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
        }
      }
      this.computeGroups(geometry);
      this.verticesNeedUpdate = geometry.verticesNeedUpdate;
      this.normalsNeedUpdate = geometry.normalsNeedUpdate;
      this.colorsNeedUpdate = geometry.colorsNeedUpdate;
      this.uvsNeedUpdate = geometry.uvsNeedUpdate;
      this.groupsNeedUpdate = geometry.groupsNeedUpdate;
      if (geometry.boundingSphere !== null) {
        this.boundingSphere = geometry.boundingSphere.clone();
      }
      if (geometry.boundingBox !== null) {
        this.boundingBox = geometry.boundingBox.clone();
      }
      return this;
    }
  };

  // node_modules/@enable3d/three-graphics/jsm/csg/_fromGeometry.js
  var fromGeometry = (buffer, geometry) => {
    const directGeometry = new DirectGeometry2().fromGeometry(geometry);
    return fromDirectGeometry(buffer, directGeometry);
  };
  var fromDirectGeometry = (buffer, geometry) => {
    var _a, _b;
    const positions = new Float32Array(geometry.vertices.length * 3);
    buffer.setAttribute("position", new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));
    if (geometry.normals.length > 0) {
      const normals = new Float32Array(geometry.normals.length * 3);
      buffer.setAttribute("normal", new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
    }
    if (geometry.colors.length > 0) {
      const colors = new Float32Array(geometry.colors.length * 3);
      buffer.setAttribute("color", new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
    }
    if (geometry.uvs.length > 0) {
      const uvs = new Float32Array(geometry.uvs.length * 2);
      buffer.setAttribute("uv", new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
    }
    if (geometry.uvs2.length > 0) {
      const uvs2 = new Float32Array(geometry.uvs2.length * 2);
      buffer.setAttribute("uv2", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
    }
    buffer.groups = geometry.groups;
    for (const name in geometry.morphTargets) {
      const array = [];
      const morphTargets = geometry.morphTargets[name];
      for (let i = 0, l = morphTargets.length; i < l; i++) {
        const morphTarget = morphTargets[i];
        const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);
        attribute.name = morphTarget.name;
        array.push(attribute.copyVector3sArray(morphTarget.data));
      }
      buffer.morphAttributes[name] = array;
    }
    if (geometry.skinIndices.length > 0) {
      const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);
      buffer.setAttribute("skinIndex", skinIndices.copyVector4sArray(geometry.skinIndices));
    }
    if (geometry.skinWeights.length > 0) {
      const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);
      buffer.setAttribute("skinWeight", skinWeights.copyVector4sArray(geometry.skinWeights));
    }
    if (geometry.boundingSphere !== null) {
      buffer.boundingSphere = (_a = geometry.boundingSphere) === null || _a === void 0 ? void 0 : _a.clone();
    }
    if (geometry.boundingBox !== null) {
      buffer.boundingBox = (_b = geometry.boundingBox) === null || _b === void 0 ? void 0 : _b.clone();
    }
    return buffer;
  };

  // node_modules/@enable3d/three-graphics/jsm/plugins/transform.js
  var Transform = class {
    constructor(camera, renderer) {
      this.camera = camera;
      this.renderer = renderer;
    }
    static geometryToBufferGeometry(geometry) {
      if (geometry.isGeometry)
        return fromGeometry(new BufferGeometry(), geometry);
      else
        return geometry;
    }
    static bufferGeometryToGeometry(bufferGeometry) {
      if (bufferGeometry.isBufferGeometry)
        return new Geometry().fromBufferGeometry(bufferGeometry);
      else
        return bufferGeometry;
    }
    fromSVGtoShape(svg, isCCW = false, noHoles) {
      if (svg) {
        const svgLoader = new SVGLoader();
        const shapes = [];
        svgLoader.parse(svg).paths.forEach((path) => {
          path.toShapes(isCCW, noHoles).forEach((shape) => {
            shapes.push(shape);
          });
        });
        return shapes;
      }
      return [];
    }
    from3dto2d(position) {
      const vector3 = new Vector3(position.x, position.y, position.z);
      const canvas2 = this.renderer.domElement;
      this.camera.updateMatrixWorld();
      vector3.project(this.camera);
      const x = Math.round((vector3.x + 1) * (canvas2.width / 2));
      const y = Math.round((-vector3.y + 1) * (canvas2.height / 2));
      return new Vector2(x, y);
    }
    from2dto3d(x, y, distanceFromCamera) {
      var _a;
      if (!this.tmpPlane) {
        const geo = new PlaneGeometry(1e4, 1e4);
        const mat = new MeshBasicMaterial({ transparent: true, opacity: 0.25 });
        this.tmpPlane = new Mesh(geo, mat);
        this.tmpPlane.name = "_tmp_raycast_plane";
      }
      if (!this.tmpRaycaster)
        this.tmpRaycaster = new Raycaster();
      if (!this.tmpVector3)
        this.tmpVector3 = new Vector3();
      let position;
      this.tmpPlane.setRotationFromEuler(this.camera.rotation);
      const p = this.camera.position;
      this.tmpPlane.position.set(p.x, p.y, p.z);
      this.camera.getWorldDirection(this.tmpVector3);
      this.tmpPlane.position.add(this.tmpVector3.clone().multiplyScalar(distanceFromCamera));
      this.tmpPlane.updateMatrix();
      this.tmpPlane.updateMatrixWorld(true);
      this.tmpRaycaster.setFromCamera({ x, y }, this.camera);
      const intersects2 = this.tmpRaycaster.intersectObjects([this.tmpPlane]);
      if (((_a = intersects2[0]) === null || _a === void 0 ? void 0 : _a.object.name) === "_tmp_raycast_plane")
        position = intersects2[0].point;
      return position;
    }
  };

  // node_modules/@enable3d/three-graphics/jsm/csg/index.js
  var CSGWrapper = class {
    static toGeometry(meshA, meshB) {
      meshA.geometry = Transform.bufferGeometryToGeometry(meshA.geometry);
      meshB.geometry = Transform.bufferGeometryToGeometry(meshB.geometry);
    }
    static toBufferGeometry(meshC) {
      meshC.geometry = Transform.geometryToBufferGeometry(meshC.geometry);
    }
    static union(meshA, meshB) {
      this.toGeometry(meshA, meshB);
      const meshC = this.doCSG(meshA, meshB, "union");
      this.toBufferGeometry(meshC);
      return meshC;
    }
    static subtract(meshA, meshB) {
      this.toGeometry(meshA, meshB);
      const meshC = this.doCSG(meshA, meshB, "subtract");
      this.toBufferGeometry(meshC);
      return meshC;
    }
    static intersect(meshA, meshB) {
      this.toGeometry(meshA, meshB);
      const meshC = this.doCSG(meshA, meshB, "intersect");
      this.toBufferGeometry(meshC);
      return meshC;
    }
    static doCSG(meshA, meshB, operation) {
      meshA.updateMatrix();
      meshB.updateMatrix();
      const bspA = CSG.fromMesh(meshA);
      const bspB = CSG.fromMesh(meshB);
      const bspC = bspA[operation](bspB);
      const result = CSG.toMesh(bspC, meshA.matrix);
      return result;
    }
  };
  var CSG = class {
    constructor() {
      this.polygons = [];
    }
    static fromPolygons(polygons) {
      const csg = new CSG();
      csg.polygons = polygons;
      return csg;
    }
    static fromGeometry(geom) {
      if (geom.isBufferGeometry) {
        geom = new Geometry().fromBufferGeometry(geom);
      }
      const fs = geom.faces;
      const vs = geom.vertices;
      const polys = [];
      const fm = ["a", "b", "c"];
      for (let i = 0; i < fs.length; i++) {
        const f = fs[i];
        const vertices = [];
        for (let j = 0; j < 3; j++) {
          const uvs = geom.faceVertexUvs[0][i] !== void 0 && geom.faceVertexUvs[0][i][j] !== void 0 ? geom.faceVertexUvs[0][i][j] : void 0;
          vertices.push(new Vertex(vs[f[fm[j]]], f.vertexNormals[j], uvs));
        }
        polys.push(new Polygon(vertices));
      }
      return CSG.fromPolygons(polys);
    }
    static fromMesh(mesh) {
      const csg = CSG.fromGeometry(mesh.geometry);
      CSG._tmpm3.getNormalMatrix(mesh.matrix);
      for (const p of csg.polygons) {
        for (const v of p.vertices) {
          v.pos.applyMatrix4(mesh.matrix);
          v.normal.applyMatrix3(CSG._tmpm3);
        }
      }
      return csg;
    }
    static toMesh(csg, toMatrix) {
      const geom = new Geometry();
      const ps = csg.polygons;
      const vs = geom.vertices;
      const fvuv = geom.faceVertexUvs[0];
      for (const p of ps) {
        const pvs = p.vertices;
        const v0 = vs.length;
        const pvlen = pvs.length;
        for (const pv of pvs) {
          vs.push(new Vector3().copy(pv.pos));
        }
        for (let j = 3; j <= pvlen; j++) {
          const fc = new Face32(v0, v0 + j - 2, v0 + j - 1);
          const fuv = [];
          fvuv.push(fuv);
          const fnml = fc.vertexNormals;
          fnml.push(new Vector3().copy(pvs[0].normal));
          fnml.push(new Vector3().copy(pvs[j - 2].normal));
          fnml.push(new Vector3().copy(pvs[j - 1].normal));
          if (pvs[0].uv && pvs[j - 2].uv && pvs[j - 1].uv) {
            fuv.push(new Vector3().copy(pvs[0].uv));
            fuv.push(new Vector3().copy(pvs[j - 2].uv));
            fuv.push(new Vector3().copy(pvs[j - 1].uv));
          }
          fc.normal = new Vector3().copy(p.plane.normal);
          geom.faces.push(fc);
        }
      }
      const inv = parseInt(REVISION) >= 123 ? new Matrix4().copy(toMatrix).invert() : new Matrix4().getInverse(toMatrix);
      geom.applyMatrix4(inv);
      geom.verticesNeedUpdate = geom.elementsNeedUpdate = geom.normalsNeedUpdate = true;
      geom.computeBoundingSphere();
      geom.computeBoundingBox();
      const m = new Mesh(geom);
      m.matrix.copy(toMatrix);
      m.matrix.decompose(m.position, m.rotation, m.scale);
      m.updateMatrixWorld();
      return m;
    }
    static iEval(tokens, _index = 0) {
      var _a;
      if (typeof tokens === "string") {
        CSG.currentOp = tokens;
      } else if (tokens instanceof Array) {
        for (const token of tokens) {
          CSG.iEval(token, 0);
        }
      } else if (typeof tokens === "object") {
        const op = CSG.currentOp;
        tokens.updateMatrix();
        tokens.updateMatrixWorld();
        if (!CSG.sourceMesh) {
          CSG.currentPrim = CSG.fromMesh(CSG.sourceMesh = tokens);
        } else {
          CSG.nextPrim = CSG.fromMesh(tokens);
          CSG.currentPrim = CSG.currentPrim[op](CSG.nextPrim);
        }
        if (CSG.doRemove)
          (_a = tokens === null || tokens === void 0 ? void 0 : tokens.parent) === null || _a === void 0 ? void 0 : _a.remove(tokens);
      }
    }
    static eval(tokens, doRemove) {
      delete CSG.currentOp;
      delete CSG.sourceMesh;
      CSG.doRemove = doRemove;
      CSG.iEval(tokens);
      const result = CSG.toMesh(CSG.currentPrim, CSG.sourceMesh.matrix);
      result.material = CSG.sourceMesh.material;
      result.castShadow = result.receiveShadow = true;
      return result;
    }
    clone() {
      const csg = new CSG();
      csg.polygons = this.polygons.map((p) => {
        return p.clone();
      });
      return csg;
    }
    toPolygons() {
      return this.polygons;
    }
    union(csg) {
      const a = new Node2(this.clone().polygons);
      const b2 = new Node2(csg.clone().polygons);
      a.clipTo(b2);
      b2.clipTo(a);
      b2.invert();
      b2.clipTo(a);
      b2.invert();
      a.build(b2.allPolygons());
      return CSG.fromPolygons(a.allPolygons());
    }
    subtract(csg) {
      const a = new Node2(this.clone().polygons);
      const b2 = new Node2(csg.clone().polygons);
      a.invert();
      a.clipTo(b2);
      b2.clipTo(a);
      b2.invert();
      b2.clipTo(a);
      b2.invert();
      a.build(b2.allPolygons());
      a.invert();
      return CSG.fromPolygons(a.allPolygons());
    }
    intersect(csg) {
      const a = new Node2(this.clone().polygons);
      const b2 = new Node2(csg.clone().polygons);
      a.invert();
      b2.clipTo(a);
      b2.invert();
      a.clipTo(b2);
      b2.clipTo(a);
      a.build(b2.allPolygons());
      a.invert();
      return CSG.fromPolygons(a.allPolygons());
    }
    inverse() {
      const csg = this.clone();
      csg.polygons.map((p) => {
        p.flip();
      });
      return csg;
    }
  };
  CSG._tmpm3 = new Matrix3();
  var Vector = class extends Vector3 {
    constructor(x, y, z) {
      if (arguments.length === 3) {
        super(x, y, z);
      } else if (Array.isArray(x)) {
        super(x[0], x[1], x[2]);
      } else if (typeof x === "object") {
        this.copy(x);
      } else {
        throw new Error("Invalid constructor to vector");
      }
    }
    clone() {
      return new Vector(this.x, this.y, this.z);
    }
    negated() {
      return this.clone().multiplyScalar(-1);
    }
    plus(a) {
      return this.clone().add(a);
    }
    minus(a) {
      return this.clone().sub(a);
    }
    times(a) {
      return this.clone().multiplyScalar(a);
    }
    dividedBy(a) {
      return this.clone().divideScalar(a);
    }
    lerp(a, t) {
      return this.plus(a.minus(this).times(t));
    }
    unit() {
      return this.dividedBy(this.length());
    }
    cross(a, w) {
      return Vector3.prototype.cross.call(this.clone(), a);
    }
  };
  var Vertex = class {
    constructor(pos2, normal, uv) {
      this.pos = new Vector(pos2.x, pos2.y, pos2.z);
      this.normal = new Vector(normal.x, normal.y, normal.z);
      if (uv)
        this.uv = new Vector(uv.x, uv.y, uv.z);
    }
    clone() {
      return new Vertex(this.pos.clone(), this.normal.clone(), this.uv ? this.uv.clone() : void 0);
    }
    flip() {
      this.normal = this.normal.negated();
    }
    interpolate(other, t) {
      return new Vertex(this.pos.lerp(other.pos, t), this.normal.lerp(other.normal, t), this.uv ? this.uv.lerp(other.uv, t) : void 0);
    }
  };
  var Plane2 = class {
    constructor(normal, w) {
      this.normal = normal;
      this.w = w;
    }
    static fromPoints(a, b2, c) {
      const n = b2.minus(a).cross(c.minus(a)).unit();
      return new Plane2(n, n.dot(a));
    }
    clone() {
      return new Plane2(this.normal.clone(), this.w);
    }
    flip() {
      this.normal = this.normal.negated();
      this.w = -this.w;
    }
    splitPolygon(polygon, coplanarFront, coplanarBack, front, back) {
      const COPLANAR = 0;
      const FRONT = 1;
      const BACK = 2;
      const SPANNING = 3;
      let polygonType = 0;
      const types = [];
      for (const vertex of polygon.vertices) {
        const t = this.normal.dot(vertex.pos) - this.w;
        const type = t < -Plane2.EPSILON ? BACK : t > Plane2.EPSILON ? FRONT : COPLANAR;
        polygonType |= type;
        types.push(type);
      }
      switch (polygonType) {
        case COPLANAR:
          if (this.normal.dot(polygon.plane.normal) > 0)
            coplanarFront.push(polygon);
          else
            coplanarBack.push(polygon);
          break;
        case FRONT:
          front.push(polygon);
          break;
        case BACK:
          back.push(polygon);
          break;
        case SPANNING:
          const f = [];
          const b2 = [];
          for (let i = 0; i < polygon.vertices.length; i++) {
            const j = (i + 1) % polygon.vertices.length;
            const ti = types[i];
            const tj = types[j];
            const vi = polygon.vertices[i];
            const vj = polygon.vertices[j];
            if (ti !== BACK) {
              f.push(vi);
            }
            if (ti !== FRONT) {
              b2.push(ti !== BACK ? vi.clone() : vi);
            }
            if ((ti | tj) === SPANNING) {
              const t = (this.w - this.normal.dot(vi.pos)) / this.normal.dot(vj.pos.minus(vi.pos));
              const v = vi.interpolate(vj, t);
              f.push(v);
              b2.push(v.clone());
            }
          }
          if (f.length >= 3) {
            front.push(new Polygon(f, polygon.shared));
          }
          if (b2.length >= 3) {
            back.push(new Polygon(b2, polygon.shared));
          }
          break;
      }
    }
  };
  Plane2.EPSILON = 1e-5;
  var Polygon = class {
    constructor(vertices, shared = null) {
      this.vertices = vertices;
      this.shared = shared;
      this.plane = Plane2.fromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);
    }
    clone() {
      const vertices = this.vertices.map((v) => {
        return v.clone();
      });
      return new Polygon(vertices, this.shared);
    }
    flip() {
      this.vertices.reverse().map((v) => {
        v.flip();
      });
      this.plane.flip();
    }
  };
  var Node2 = class {
    constructor(polygons) {
      delete this.plane;
      delete this.front;
      delete this.back;
      this.polygons = [];
      if (polygons) {
        this.build(polygons);
      }
    }
    clone() {
      const node = new Node2();
      node.plane = this.plane && this.plane.clone();
      node.front = this.front && this.front.clone();
      node.back = this.back && this.back.clone();
      node.polygons = this.polygons.map((p) => {
        return p.clone();
      });
      return node;
    }
    invert() {
      for (const polygon of this.polygons) {
        polygon.flip();
      }
      this.plane.flip();
      if (this.front) {
        this.front.invert();
      }
      if (this.back) {
        this.back.invert();
      }
      const temp = this.front;
      this.front = this.back;
      this.back = temp;
    }
    clipPolygons(polygons) {
      if (!this.plane) {
        return polygons.slice();
      }
      let front = [];
      let back = [];
      for (const polygon of polygons) {
        this.plane.splitPolygon(polygon, front, back, front, back);
      }
      if (this.front) {
        front = this.front.clipPolygons(front);
      }
      back = this.back ? this.back.clipPolygons(back) : [];
      return front.concat(back);
    }
    clipTo(bsp) {
      this.polygons = bsp.clipPolygons(this.polygons);
      if (this.front) {
        this.front.clipTo(bsp);
      }
      if (this.back) {
        this.back.clipTo(bsp);
      }
    }
    allPolygons() {
      let polygons = this.polygons.slice();
      if (this.front) {
        polygons = polygons.concat(this.front.allPolygons());
      }
      if (this.back) {
        polygons = polygons.concat(this.back.allPolygons());
      }
      return polygons;
    }
    build(polygons) {
      if (!polygons.length) {
        return;
      }
      if (!this.plane) {
        this.plane = polygons[0].plane.clone();
      }
      const front = [];
      const back = [];
      for (const polygon of polygons) {
        this.plane.splitPolygon(polygon, this.polygons, this.polygons, front, back);
      }
      if (front.length) {
        if (!this.front) {
          this.front = new Node2();
        }
        this.front.build(front);
      }
      if (back.length) {
        if (!this.back) {
          this.back = new Node2();
        }
        this.back.build(back);
      }
    }
  };

  // node_modules/three/examples/jsm/libs/fflate.module.min.js
  var fflate_module_min_exports = {};
  __export(fflate_module_min_exports, {
    AsyncCompress: () => Rn,
    AsyncDecompress: () => et,
    AsyncDeflate: () => En,
    AsyncGunzip: () => Hn,
    AsyncGzip: () => Rn,
    AsyncInflate: () => en,
    AsyncUnzipInflate: () => pt,
    AsyncUnzlib: () => Yn,
    AsyncZipDeflate: () => ht,
    AsyncZlib: () => nt,
    Compress: () => qr,
    DecodeUTF8: () => ot,
    Decompress: () => Jn,
    Deflate: () => rr,
    EncodeUTF8: () => ft,
    Gunzip: () => Wr,
    Gzip: () => qr,
    Inflate: () => J,
    Unzip: () => gt,
    UnzipInflate: () => ct,
    UnzipPassThrough: () => dn,
    Unzlib: () => jr,
    Zip: () => ut,
    ZipDeflate: () => st,
    ZipPassThrough: () => Br,
    Zlib: () => on,
    compress: () => qn,
    compressSync: () => Hr,
    decompress: () => it,
    decompressSync: () => at,
    default: () => fflate_module_min_default,
    deflate: () => Pn,
    deflateSync: () => kr,
    gunzip: () => Wn,
    gunzipSync: () => Yr,
    gzip: () => qn,
    gzipSync: () => Hr,
    inflate: () => an,
    inflateSync: () => xr,
    strFromU8: () => un,
    strToU8: () => or,
    unzip: () => wt,
    unzipSync: () => yt,
    unzlib: () => jn,
    unzlibSync: () => Jr,
    zip: () => lt,
    zipSync: () => vt,
    zlib: () => tt,
    zlibSync: () => fn
  });
  var gn = {};
  var bn = function(n, r, t, e, i) {
    var a = gn[r] || (gn[r] = URL.createObjectURL(new Blob([n], { type: "text/javascript" }))), o = new Worker(a);
    return o.onerror = function(f) {
      return i(f.error, null);
    }, o.onmessage = function(f) {
      return i(null, f.data);
    }, o.postMessage(t, e), o;
  };
  var A = Uint8Array;
  var R = Uint16Array;
  var nr = Uint32Array;
  var ur = new A([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]);
  var lr = new A([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]);
  var Mr = new A([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  var wn = function(n, r) {
    for (var t = new R(31), e = 0; e < 31; ++e)
      t[e] = r += 1 << n[e - 1];
    for (var i = new nr(t[30]), e = 1; e < 30; ++e)
      for (var a = t[e]; a < t[e + 1]; ++a)
        i[a] = a - t[e] << 5 | e;
    return [t, i];
  };
  var yn = wn(ur, 2);
  var Nr = yn[0];
  var Ir = yn[1];
  Nr[28] = 258, Ir[258] = 28;
  for (var mn = wn(lr, 0), zn = mn[0], Qr = mn[1], Ur = new R(32768), T = 0; T < 32768; ++T) {
    ir = (T & 43690) >>> 1 | (T & 21845) << 1;
    ir = (ir & 52428) >>> 2 | (ir & 13107) << 2, ir = (ir & 61680) >>> 4 | (ir & 3855) << 4, Ur[T] = ((ir & 65280) >>> 8 | (ir & 255) << 8) >>> 1;
  }
  var ir;
  for (var V = function(n, r, t) {
    for (var e = n.length, i = 0, a = new R(r); i < e; ++i)
      ++a[n[i] - 1];
    var o = new R(r);
    for (i = 0; i < r; ++i)
      o[i] = o[i - 1] + a[i - 1] << 1;
    var f;
    if (t) {
      f = new R(1 << r);
      var h = 15 - r;
      for (i = 0; i < e; ++i)
        if (n[i])
          for (var s = i << 4 | n[i], u = r - n[i], l = o[n[i] - 1]++ << u, p = l | (1 << u) - 1; l <= p; ++l)
            f[Ur[l] >>> h] = s;
    } else
      for (f = new R(e), i = 0; i < e; ++i)
        n[i] && (f[i] = Ur[o[n[i] - 1]++] >>> 15 - n[i]);
    return f;
  }, tr = new A(288), T = 0; T < 144; ++T)
    tr[T] = 8;
  for (var T = 144; T < 256; ++T)
    tr[T] = 9;
  for (var T = 256; T < 280; ++T)
    tr[T] = 7;
  for (var T = 280; T < 288; ++T)
    tr[T] = 8;
  for (var vr = new A(32), T = 0; T < 32; ++T)
    vr[T] = 5;
  var xn = V(tr, 9, 0);
  var An = V(tr, 9, 1);
  var Dn = V(vr, 5, 0);
  var Mn = V(vr, 5, 1);
  var Gr = function(n) {
    for (var r = n[0], t = 1; t < n.length; ++t)
      n[t] > r && (r = n[t]);
    return r;
  };
  var X = function(n, r, t) {
    var e = r / 8 | 0;
    return (n[e] | n[e + 1] << 8) >> (r & 7) & t;
  };
  var Or = function(n, r) {
    var t = r / 8 | 0;
    return (n[t] | n[t + 1] << 8 | n[t + 2] << 16) >> (r & 7);
  };
  var Cr = function(n) {
    return (n / 8 | 0) + (n & 7 && 1);
  };
  var $ = function(n, r, t) {
    (r == null || r < 0) && (r = 0), (t == null || t > n.length) && (t = n.length);
    var e = new (n instanceof R ? R : n instanceof nr ? nr : A)(t - r);
    return e.set(n.subarray(r, t)), e;
  };
  var Fr = function(n, r, t) {
    var e = n.length;
    if (!e || t && !t.l && e < 5)
      return r || new A(0);
    var i = !r || t, a = !t || t.i;
    t || (t = {}), r || (r = new A(e * 3));
    var o = function(Tr) {
      var Dr = r.length;
      if (Tr > Dr) {
        var hr = new A(Math.max(Dr * 2, Tr));
        hr.set(r), r = hr;
      }
    }, f = t.f || 0, h = t.p || 0, s = t.b || 0, u = t.l, l = t.d, p = t.m, y = t.n, c = e * 8;
    do {
      if (!u) {
        t.f = f = X(n, h, 1);
        var g = X(n, h + 1, 3);
        if (h += 3, g)
          if (g == 1)
            u = An, l = Mn, p = 9, y = 5;
          else if (g == 2) {
            var m = X(n, h, 31) + 257, D = X(n, h + 10, 15) + 4, C = m + X(n, h + 5, 31) + 1;
            h += 14;
            for (var U = new A(C), x = new A(19), v = 0; v < D; ++v)
              x[Mr[v]] = X(n, h + v * 3, 7);
            h += D * 3;
            var E = Gr(x), S = (1 << E) - 1;
            if (!a && h + C * (E + 7) > c)
              break;
            for (var K = V(x, E, 1), v = 0; v < C; ) {
              var I = K[X(n, h, S)];
              h += I & 15;
              var w = I >>> 4;
              if (w < 16)
                U[v++] = w;
              else {
                var Z = 0, B = 0;
                for (w == 16 ? (B = 3 + X(n, h, 3), h += 2, Z = U[v - 1]) : w == 17 ? (B = 3 + X(n, h, 7), h += 3) : w == 18 && (B = 11 + X(n, h, 127), h += 7); B--; )
                  U[v++] = Z;
              }
            }
            var G = U.subarray(0, m), k = U.subarray(m);
            p = Gr(G), y = Gr(k), u = V(G, p, 1), l = V(k, y, 1);
          } else
            throw "invalid block type";
        else {
          var w = Cr(h) + 4, M = n[w - 4] | n[w - 3] << 8, z = w + M;
          if (z > e) {
            if (a)
              throw "unexpected EOF";
            break;
          }
          i && o(s + M), r.set(n.subarray(w, z), s), t.b = s += M, t.p = h = z * 8;
          continue;
        }
        if (h > c)
          throw "unexpected EOF";
      }
      i && o(s + 131072);
      for (var O = (1 << p) - 1, H = (1 << y) - 1, N = p + y + 18; a || h + N < c; ) {
        var Z = u[Or(n, h) & O], Q = Z >>> 4;
        if (h += Z & 15, h > c)
          throw "unexpected EOF";
        if (!Z)
          throw "invalid length/literal";
        if (Q < 256)
          r[s++] = Q;
        else if (Q == 256) {
          u = null;
          break;
        } else {
          var W = Q - 254;
          if (Q > 264) {
            var v = Q - 257, d = ur[v];
            W = X(n, h, (1 << d) - 1) + Nr[v], h += d;
          }
          var _ = l[Or(n, h) & H], j = _ >>> 4;
          if (!_)
            throw "invalid distance";
          h += _ & 15;
          var k = zn[j];
          if (j > 3) {
            var d = lr[j];
            k += Or(n, h) & (1 << d) - 1, h += d;
          }
          if (h > c)
            throw "unexpected EOF";
          i && o(s + 131072);
          for (var q = s + W; s < q; s += 4)
            r[s] = r[s - k], r[s + 1] = r[s + 1 - k], r[s + 2] = r[s + 2 - k], r[s + 3] = r[s + 3 - k];
          s = q;
        }
      }
      t.l = u, t.p = h, t.b = s, u && (f = 1, t.m = p, t.d = l, t.n = y);
    } while (!f);
    return s == r.length ? r : $(r, 0, s);
  };
  var b = function(n, r, t) {
    t <<= r & 7;
    var e = r / 8 | 0;
    n[e] |= t, n[e + 1] |= t >>> 8;
  };
  var cr = function(n, r, t) {
    t <<= r & 7;
    var e = r / 8 | 0;
    n[e] |= t, n[e + 1] |= t >>> 8, n[e + 2] |= t >>> 16;
  };
  var Er = function(n, r) {
    for (var t = [], e = 0; e < n.length; ++e)
      n[e] && t.push({ s: e, f: n[e] });
    var i = t.length, a = t.slice();
    if (!i)
      return [er, 0];
    if (i == 1) {
      var o = new A(t[0].s + 1);
      return o[t[0].s] = 1, [o, 1];
    }
    t.sort(function(C, U) {
      return C.f - U.f;
    }), t.push({ s: -1, f: 25001 });
    var f = t[0], h = t[1], s = 0, u = 1, l = 2;
    for (t[0] = { s: -1, f: f.f + h.f, l: f, r: h }; u != i - 1; )
      f = t[t[s].f < t[l].f ? s++ : l++], h = t[s != u && t[s].f < t[l].f ? s++ : l++], t[u++] = { s: -1, f: f.f + h.f, l: f, r: h };
    for (var p = a[0].s, e = 1; e < i; ++e)
      a[e].s > p && (p = a[e].s);
    var y = new R(p + 1), c = Pr(t[u - 1], y, 0);
    if (c > r) {
      var e = 0, g = 0, w = c - r, M = 1 << w;
      for (a.sort(function(U, x) {
        return y[x.s] - y[U.s] || U.f - x.f;
      }); e < i; ++e) {
        var z = a[e].s;
        if (y[z] > r)
          g += M - (1 << c - y[z]), y[z] = r;
        else
          break;
      }
      for (g >>>= w; g > 0; ) {
        var m = a[e].s;
        y[m] < r ? g -= 1 << r - y[m]++ - 1 : ++e;
      }
      for (; e >= 0 && g; --e) {
        var D = a[e].s;
        y[D] == r && (--y[D], ++g);
      }
      c = r;
    }
    return [new A(y), c];
  };
  var Pr = function(n, r, t) {
    return n.s == -1 ? Math.max(Pr(n.l, r, t + 1), Pr(n.r, r, t + 1)) : r[n.s] = t;
  };
  var Vr = function(n) {
    for (var r = n.length; r && !n[--r]; )
      ;
    for (var t = new R(++r), e = 0, i = n[0], a = 1, o = function(h) {
      t[e++] = h;
    }, f = 1; f <= r; ++f)
      if (n[f] == i && f != r)
        ++a;
      else {
        if (!i && a > 2) {
          for (; a > 138; a -= 138)
            o(32754);
          a > 2 && (o(a > 10 ? a - 11 << 5 | 28690 : a - 3 << 5 | 12305), a = 0);
        } else if (a > 3) {
          for (o(i), --a; a > 6; a -= 6)
            o(8304);
          a > 2 && (o(a - 3 << 5 | 8208), a = 0);
        }
        for (; a--; )
          o(i);
        a = 1, i = n[f];
      }
    return [t.subarray(0, e), r];
  };
  var pr = function(n, r) {
    for (var t = 0, e = 0; e < r.length; ++e)
      t += n[e] * r[e];
    return t;
  };
  var Sr = function(n, r, t) {
    var e = t.length, i = Cr(r + 2);
    n[i] = e & 255, n[i + 1] = e >>> 8, n[i + 2] = n[i] ^ 255, n[i + 3] = n[i + 1] ^ 255;
    for (var a = 0; a < e; ++a)
      n[i + a + 4] = t[a];
    return (i + 4 + e) * 8;
  };
  var Xr = function(n, r, t, e, i, a, o, f, h, s, u) {
    b(r, u++, t), ++i[256];
    for (var l = Er(i, 15), p = l[0], y = l[1], c = Er(a, 15), g = c[0], w = c[1], M = Vr(p), z = M[0], m = M[1], D = Vr(g), C = D[0], U = D[1], x = new R(19), v = 0; v < z.length; ++v)
      x[z[v] & 31]++;
    for (var v = 0; v < C.length; ++v)
      x[C[v] & 31]++;
    for (var E = Er(x, 7), S = E[0], K = E[1], I = 19; I > 4 && !S[Mr[I - 1]]; --I)
      ;
    var Z = s + 5 << 3, B = pr(i, tr) + pr(a, vr) + o, G = pr(i, p) + pr(a, g) + o + 14 + 3 * I + pr(x, S) + (2 * x[16] + 3 * x[17] + 7 * x[18]);
    if (Z <= B && Z <= G)
      return Sr(r, u, n.subarray(h, h + s));
    var k, O, H, N;
    if (b(r, u, 1 + (G < B)), u += 2, G < B) {
      k = V(p, y, 0), O = p, H = V(g, w, 0), N = g;
      var Q = V(S, K, 0);
      b(r, u, m - 257), b(r, u + 5, U - 1), b(r, u + 10, I - 4), u += 14;
      for (var v = 0; v < I; ++v)
        b(r, u + 3 * v, S[Mr[v]]);
      u += 3 * I;
      for (var W = [z, C], d = 0; d < 2; ++d)
        for (var _ = W[d], v = 0; v < _.length; ++v) {
          var j = _[v] & 31;
          b(r, u, Q[j]), u += S[j], j > 15 && (b(r, u, _[v] >>> 5 & 127), u += _[v] >>> 12);
        }
    } else
      k = xn, O = tr, H = Dn, N = vr;
    for (var v = 0; v < f; ++v)
      if (e[v] > 255) {
        var j = e[v] >>> 18 & 31;
        cr(r, u, k[j + 257]), u += O[j + 257], j > 7 && (b(r, u, e[v] >>> 23 & 31), u += ur[j]);
        var q = e[v] & 31;
        cr(r, u, H[q]), u += N[q], q > 3 && (cr(r, u, e[v] >>> 5 & 8191), u += lr[q]);
      } else
        cr(r, u, k[e[v]]), u += O[e[v]];
    return cr(r, u, k[256]), u + O[256];
  };
  var Un = new nr([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
  var er = new A(0);
  var Cn = function(n, r, t, e, i, a) {
    var o = n.length, f = new A(e + o + 5 * (1 + Math.ceil(o / 7e3)) + i), h = f.subarray(e, f.length - i), s = 0;
    if (!r || o < 8)
      for (var u = 0; u <= o; u += 65535) {
        var l = u + 65535;
        l < o ? s = Sr(h, s, n.subarray(u, l)) : (h[u] = a, s = Sr(h, s, n.subarray(u, o)));
      }
    else {
      for (var p = Un[r - 1], y = p >>> 13, c = p & 8191, g = (1 << t) - 1, w = new R(32768), M = new R(g + 1), z = Math.ceil(t / 3), m = 2 * z, D = function(Kr) {
        return (n[Kr] ^ n[Kr + 1] << z ^ n[Kr + 2] << m) & g;
      }, C = new nr(25e3), U = new R(288), x = new R(32), v = 0, E = 0, u = 0, S = 0, K = 0, I = 0; u < o; ++u) {
        var Z = D(u), B = u & 32767, G = M[Z];
        if (w[B] = G, M[Z] = B, K <= u) {
          var k = o - u;
          if ((v > 7e3 || S > 24576) && k > 423) {
            s = Xr(n, h, 0, C, U, x, E, S, I, u - I, s), S = v = E = 0, I = u;
            for (var O = 0; O < 286; ++O)
              U[O] = 0;
            for (var O = 0; O < 30; ++O)
              x[O] = 0;
          }
          var H = 2, N = 0, Q = c, W = B - G & 32767;
          if (k > 2 && Z == D(u - W))
            for (var d = Math.min(y, k) - 1, _ = Math.min(32767, u), j = Math.min(258, k); W <= _ && --Q && B != G; ) {
              if (n[u + H] == n[u + H - W]) {
                for (var q = 0; q < j && n[u + q] == n[u + q - W]; ++q)
                  ;
                if (q > H) {
                  if (H = q, N = W, q > d)
                    break;
                  for (var Tr = Math.min(W, q - 2), Dr = 0, O = 0; O < Tr; ++O) {
                    var hr = u - W + O + 32768 & 32767, _n = w[hr], vn = hr - _n + 32768 & 32767;
                    vn > Dr && (Dr = vn, G = hr);
                  }
                }
              }
              B = G, G = w[B], W += B - G + 32768 & 32767;
            }
          if (N) {
            C[S++] = 268435456 | Ir[H] << 18 | Qr[N];
            var cn = Ir[H] & 31, pn = Qr[N] & 31;
            E += ur[cn] + lr[pn], ++U[257 + cn], ++x[pn], K = u + H, ++v;
          } else
            C[S++] = n[u], ++U[n[u]];
        }
      }
      s = Xr(n, h, a, C, U, x, E, S, I, u - I, s), !a && s & 7 && (s = Sr(h, s + 1, er));
    }
    return $(f, 0, e + Cr(s) + i);
  };
  var Fn = function() {
    for (var n = new nr(256), r = 0; r < 256; ++r) {
      for (var t = r, e = 9; --e; )
        t = (t & 1 && 3988292384) ^ t >>> 1;
      n[r] = t;
    }
    return n;
  }();
  var gr = function() {
    var n = -1;
    return { p: function(r) {
      for (var t = n, e = 0; e < r.length; ++e)
        t = Fn[t & 255 ^ r[e]] ^ t >>> 8;
      n = t;
    }, d: function() {
      return ~n;
    } };
  };
  var $r = function() {
    var n = 1, r = 0;
    return { p: function(t) {
      for (var e = n, i = r, a = t.length, o = 0; o != a; ) {
        for (var f = Math.min(o + 2655, a); o < f; ++o)
          i += e += t[o];
        e = (e & 65535) + 15 * (e >> 16), i = (i & 65535) + 15 * (i >> 16);
      }
      n = e, r = i;
    }, d: function() {
      return n %= 65521, r %= 65521, (n >>> 8 << 16 | (r & 255) << 8 | r >>> 8) + ((n & 255) << 23) * 2;
    } };
  };
  var sr = function(n, r, t, e, i) {
    return Cn(n, r.level == null ? 6 : r.level, r.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(n.length))) * 1.5) : 12 + r.mem, t, e, !i);
  };
  var Zr = function(n, r) {
    var t = {};
    for (var e in n)
      t[e] = n[e];
    for (var e in r)
      t[e] = r[e];
    return t;
  };
  var Sn = function(n, r, t) {
    for (var e = n(), i = n.toString(), a = i.slice(i.indexOf("[") + 1, i.lastIndexOf("]")).replace(/ /g, "").split(","), o = 0; o < e.length; ++o) {
      var f = e[o], h = a[o];
      if (typeof f == "function") {
        r += ";" + h + "=";
        var s = f.toString();
        if (f.prototype)
          if (s.indexOf("[native code]") != -1) {
            var u = s.indexOf(" ", 8) + 1;
            r += s.slice(u, s.indexOf("(", u));
          } else {
            r += s;
            for (var l in f.prototype)
              r += ";" + h + ".prototype." + l + "=" + f.prototype[l].toString();
          }
        else
          r += s;
      } else
        t[h] = f;
    }
    return [r, t];
  };
  var Rr = [];
  var rt = function(n) {
    var r = [];
    for (var t in n)
      (n[t] instanceof A || n[t] instanceof R || n[t] instanceof nr) && r.push((n[t] = new n[t].constructor(n[t])).buffer);
    return r;
  };
  var Zn = function(n, r, t, e) {
    var i;
    if (!Rr[t]) {
      for (var a = "", o = {}, f = n.length - 1, h = 0; h < f; ++h)
        i = Sn(n[h], a, o), a = i[0], o = i[1];
      Rr[t] = Sn(n[f], a, o);
    }
    var s = Zr({}, Rr[t][1]);
    return bn(Rr[t][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + r.toString() + "}", t, s, rt(s), e);
  };
  var wr = function() {
    return [A, R, nr, ur, lr, Mr, Nr, zn, An, Mn, Ur, V, Gr, X, Or, Cr, $, Fr, xr, ar, Lr];
  };
  var yr = function() {
    return [A, R, nr, ur, lr, Mr, Ir, Qr, xn, tr, Dn, vr, Ur, Un, er, V, b, cr, Er, Pr, Vr, pr, Sr, Xr, Cr, $, Cn, sr, kr, ar];
  };
  var kn = function() {
    return [_r, rn, F, gr, Fn];
  };
  var Bn = function() {
    return [br, Gn];
  };
  var Tn = function() {
    return [nn, F, $r];
  };
  var In = function() {
    return [On];
  };
  var ar = function(n) {
    return postMessage(n, [n.buffer]);
  };
  var Lr = function(n) {
    return n && n.size && new A(n.size);
  };
  var mr = function(n, r, t, e, i, a) {
    var o = Zn(t, e, i, function(f, h) {
      o.terminate(), a(f, h);
    });
    return o.postMessage([n, r], r.consume ? [n.buffer] : []), function() {
      o.terminate();
    };
  };
  var L = function(n) {
    return n.ondata = function(r, t) {
      return postMessage([r, t], [r.buffer]);
    }, function(r) {
      return n.push(r.data[0], r.data[1]);
    };
  };
  var zr = function(n, r, t, e, i) {
    var a, o = Zn(n, e, i, function(f, h) {
      f ? (o.terminate(), r.ondata.call(r, f)) : (h[1] && o.terminate(), r.ondata.call(r, f, h[0], h[1]));
    });
    o.postMessage(t), r.push = function(f, h) {
      if (a)
        throw "stream finished";
      if (!r.ondata)
        throw "no stream handler";
      o.postMessage([f, a = h], [f.buffer]);
    }, r.terminate = function() {
      o.terminate();
    };
  };
  var Y = function(n, r) {
    return n[r] | n[r + 1] << 8;
  };
  var P = function(n, r) {
    return (n[r] | n[r + 1] << 8 | n[r + 2] << 16) + (n[r + 3] << 23) * 2;
  };
  var dr = function(n, r) {
    return P(n, r) | P(n, r) * 4294967296;
  };
  var F = function(n, r, t) {
    for (; t; ++r)
      n[r] = t, t >>>= 8;
  };
  var _r = function(n, r) {
    var t = r.filename;
    if (n[0] = 31, n[1] = 139, n[2] = 8, n[8] = r.level < 2 ? 4 : r.level == 9 ? 2 : 0, n[9] = 3, r.mtime != 0 && F(n, 4, Math.floor(new Date(r.mtime || Date.now()) / 1e3)), t) {
      n[3] = 8;
      for (var e = 0; e <= t.length; ++e)
        n[e + 10] = t.charCodeAt(e);
    }
  };
  var br = function(n) {
    if (n[0] != 31 || n[1] != 139 || n[2] != 8)
      throw "invalid gzip data";
    var r = n[3], t = 10;
    r & 4 && (t += n[10] | (n[11] << 8) + 2);
    for (var e = (r >> 3 & 1) + (r >> 4 & 1); e > 0; e -= !n[t++])
      ;
    return t + (r & 2);
  };
  var Gn = function(n) {
    var r = n.length;
    return (n[r - 4] | n[r - 3] << 8 | n[r - 2] << 16) + 2 * (n[r - 1] << 23);
  };
  var rn = function(n) {
    return 10 + (n.filename && n.filename.length + 1 || 0);
  };
  var nn = function(n, r) {
    var t = r.level, e = t == 0 ? 0 : t < 6 ? 1 : t == 9 ? 3 : 2;
    n[0] = 120, n[1] = e << 6 | (e ? 32 - 2 * e : 1);
  };
  var On = function(n) {
    if ((n[0] & 15) != 8 || n[0] >>> 4 > 7 || (n[0] << 8 | n[1]) % 31)
      throw "invalid zlib data";
    if (n[1] & 32)
      throw "invalid zlib data: preset dictionaries not supported";
  };
  function tn(n, r) {
    return !r && typeof n == "function" && (r = n, n = {}), this.ondata = r, n;
  }
  var rr = function() {
    function n(r, t) {
      !t && typeof r == "function" && (t = r, r = {}), this.ondata = t, this.o = r || {};
    }
    return n.prototype.p = function(r, t) {
      this.ondata(sr(r, this.o, 0, 0, !t), t);
    }, n.prototype.push = function(r, t) {
      if (this.d)
        throw "stream finished";
      if (!this.ondata)
        throw "no stream handler";
      this.d = t, this.p(r, t || false);
    }, n;
  }();
  var En = function() {
    function n(r, t) {
      zr([yr, function() {
        return [L, rr];
      }], this, tn.call(this, r, t), function(e) {
        var i = new rr(e.data);
        onmessage = L(i);
      }, 6);
    }
    return n;
  }();
  function Pn(n, r, t) {
    if (t || (t = r, r = {}), typeof t != "function")
      throw "no callback";
    return mr(n, r, [yr], function(e) {
      return ar(kr(e.data[0], e.data[1]));
    }, 0, t);
  }
  function kr(n, r) {
    return sr(n, r || {}, 0, 0);
  }
  var J = function() {
    function n(r) {
      this.s = {}, this.p = new A(0), this.ondata = r;
    }
    return n.prototype.e = function(r) {
      if (this.d)
        throw "stream finished";
      if (!this.ondata)
        throw "no stream handler";
      var t = this.p.length, e = new A(t + r.length);
      e.set(this.p), e.set(r, t), this.p = e;
    }, n.prototype.c = function(r) {
      this.d = this.s.i = r || false;
      var t = this.s.b, e = Fr(this.p, this.o, this.s);
      this.ondata($(e, t, this.s.b), this.d), this.o = $(e, this.s.b - 32768), this.s.b = this.o.length, this.p = $(this.p, this.s.p / 8 | 0), this.s.p &= 7;
    }, n.prototype.push = function(r, t) {
      this.e(r), this.c(t);
    }, n;
  }();
  var en = function() {
    function n(r) {
      this.ondata = r, zr([wr, function() {
        return [L, J];
      }], this, 0, function() {
        var t = new J();
        onmessage = L(t);
      }, 7);
    }
    return n;
  }();
  function an(n, r, t) {
    if (t || (t = r, r = {}), typeof t != "function")
      throw "no callback";
    return mr(n, r, [wr], function(e) {
      return ar(xr(e.data[0], Lr(e.data[1])));
    }, 1, t);
  }
  function xr(n, r) {
    return Fr(n, r);
  }
  var qr = function() {
    function n(r, t) {
      this.c = gr(), this.l = 0, this.v = 1, rr.call(this, r, t);
    }
    return n.prototype.push = function(r, t) {
      rr.prototype.push.call(this, r, t);
    }, n.prototype.p = function(r, t) {
      this.c.p(r), this.l += r.length;
      var e = sr(r, this.o, this.v && rn(this.o), t && 8, !t);
      this.v && (_r(e, this.o), this.v = 0), t && (F(e, e.length - 8, this.c.d()), F(e, e.length - 4, this.l)), this.ondata(e, t);
    }, n;
  }();
  var Rn = function() {
    function n(r, t) {
      zr([yr, kn, function() {
        return [L, rr, qr];
      }], this, tn.call(this, r, t), function(e) {
        var i = new qr(e.data);
        onmessage = L(i);
      }, 8);
    }
    return n;
  }();
  function qn(n, r, t) {
    if (t || (t = r, r = {}), typeof t != "function")
      throw "no callback";
    return mr(n, r, [yr, kn, function() {
      return [Hr];
    }], function(e) {
      return ar(Hr(e.data[0], e.data[1]));
    }, 2, t);
  }
  function Hr(n, r) {
    r || (r = {});
    var t = gr(), e = n.length;
    t.p(n);
    var i = sr(n, r, rn(r), 8), a = i.length;
    return _r(i, r), F(i, a - 8, t.d()), F(i, a - 4, e), i;
  }
  var Wr = function() {
    function n(r) {
      this.v = 1, J.call(this, r);
    }
    return n.prototype.push = function(r, t) {
      if (J.prototype.e.call(this, r), this.v) {
        var e = this.p.length > 3 ? br(this.p) : 4;
        if (e >= this.p.length && !t)
          return;
        this.p = this.p.subarray(e), this.v = 0;
      }
      if (t) {
        if (this.p.length < 8)
          throw "invalid gzip stream";
        this.p = this.p.subarray(0, -8);
      }
      J.prototype.c.call(this, t);
    }, n;
  }();
  var Hn = function() {
    function n(r) {
      this.ondata = r, zr([wr, Bn, function() {
        return [L, J, Wr];
      }], this, 0, function() {
        var t = new Wr();
        onmessage = L(t);
      }, 9);
    }
    return n;
  }();
  function Wn(n, r, t) {
    if (t || (t = r, r = {}), typeof t != "function")
      throw "no callback";
    return mr(n, r, [wr, Bn, function() {
      return [Yr];
    }], function(e) {
      return ar(Yr(e.data[0]));
    }, 3, t);
  }
  function Yr(n, r) {
    return Fr(n.subarray(br(n), -8), r || new A(Gn(n)));
  }
  var on = function() {
    function n(r, t) {
      this.c = $r(), this.v = 1, rr.call(this, r, t);
    }
    return n.prototype.push = function(r, t) {
      rr.prototype.push.call(this, r, t);
    }, n.prototype.p = function(r, t) {
      this.c.p(r);
      var e = sr(r, this.o, this.v && 2, t && 4, !t);
      this.v && (nn(e, this.o), this.v = 0), t && F(e, e.length - 4, this.c.d()), this.ondata(e, t);
    }, n;
  }();
  var nt = function() {
    function n(r, t) {
      zr([yr, Tn, function() {
        return [L, rr, on];
      }], this, tn.call(this, r, t), function(e) {
        var i = new on(e.data);
        onmessage = L(i);
      }, 10);
    }
    return n;
  }();
  function tt(n, r, t) {
    if (t || (t = r, r = {}), typeof t != "function")
      throw "no callback";
    return mr(n, r, [yr, Tn, function() {
      return [fn];
    }], function(e) {
      return ar(fn(e.data[0], e.data[1]));
    }, 4, t);
  }
  function fn(n, r) {
    r || (r = {});
    var t = $r();
    t.p(n);
    var e = sr(n, r, 2, 4);
    return nn(e, r), F(e, e.length - 4, t.d()), e;
  }
  var jr = function() {
    function n(r) {
      this.v = 1, J.call(this, r);
    }
    return n.prototype.push = function(r, t) {
      if (J.prototype.e.call(this, r), this.v) {
        if (this.p.length < 2 && !t)
          return;
        this.p = this.p.subarray(2), this.v = 0;
      }
      if (t) {
        if (this.p.length < 4)
          throw "invalid zlib stream";
        this.p = this.p.subarray(0, -4);
      }
      J.prototype.c.call(this, t);
    }, n;
  }();
  var Yn = function() {
    function n(r) {
      this.ondata = r, zr([wr, In, function() {
        return [L, J, jr];
      }], this, 0, function() {
        var t = new jr();
        onmessage = L(t);
      }, 11);
    }
    return n;
  }();
  function jn(n, r, t) {
    if (t || (t = r, r = {}), typeof t != "function")
      throw "no callback";
    return mr(n, r, [wr, In, function() {
      return [Jr];
    }], function(e) {
      return ar(Jr(e.data[0], Lr(e.data[1])));
    }, 5, t);
  }
  function Jr(n, r) {
    return Fr((On(n), n.subarray(2, -4)), r);
  }
  var Jn = function() {
    function n(r) {
      this.G = Wr, this.I = J, this.Z = jr, this.ondata = r;
    }
    return n.prototype.push = function(r, t) {
      if (!this.ondata)
        throw "no stream handler";
      if (this.s)
        this.s.push(r, t);
      else {
        if (this.p && this.p.length) {
          var e = new A(this.p.length + r.length);
          e.set(this.p), e.set(r, this.p.length);
        } else
          this.p = r;
        if (this.p.length > 2) {
          var i = this, a = function() {
            i.ondata.apply(i, arguments);
          };
          this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(a) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(a) : new this.Z(a), this.s.push(this.p, t), this.p = null;
        }
      }
    }, n;
  }();
  var et = function() {
    function n(r) {
      this.G = Hn, this.I = en, this.Z = Yn, this.ondata = r;
    }
    return n.prototype.push = function(r, t) {
      Jn.prototype.push.call(this, r, t);
    }, n;
  }();
  function it(n, r, t) {
    if (t || (t = r, r = {}), typeof t != "function")
      throw "no callback";
    return n[0] == 31 && n[1] == 139 && n[2] == 8 ? Wn(n, r, t) : (n[0] & 15) != 8 || n[0] >> 4 > 7 || (n[0] << 8 | n[1]) % 31 ? an(n, r, t) : jn(n, r, t);
  }
  function at(n, r) {
    return n[0] == 31 && n[1] == 139 && n[2] == 8 ? Yr(n, r) : (n[0] & 15) != 8 || n[0] >> 4 > 7 || (n[0] << 8 | n[1]) % 31 ? xr(n, r) : Jr(n, r);
  }
  var sn = function(n, r, t, e) {
    for (var i in n) {
      var a = n[i], o = r + i;
      a instanceof A ? t[o] = [a, e] : Array.isArray(a) ? t[o] = [a[0], Zr(e, a[1])] : sn(a, o + "/", t, e);
    }
  };
  var Kn = typeof TextEncoder != "undefined" && new TextEncoder();
  var hn = typeof TextDecoder != "undefined" && new TextDecoder();
  var Nn = 0;
  try {
    hn.decode(er, { stream: true }), Nn = 1;
  } catch (n) {
  }
  var Qn = function(n) {
    for (var r = "", t = 0; ; ) {
      var e = n[t++], i = (e > 127) + (e > 223) + (e > 239);
      if (t + i > n.length)
        return [r, $(n, t - 1)];
      i ? i == 3 ? (e = ((e & 15) << 18 | (n[t++] & 63) << 12 | (n[t++] & 63) << 6 | n[t++] & 63) - 65536, r += String.fromCharCode(55296 | e >> 10, 56320 | e & 1023)) : i & 1 ? r += String.fromCharCode((e & 31) << 6 | n[t++] & 63) : r += String.fromCharCode((e & 15) << 12 | (n[t++] & 63) << 6 | n[t++] & 63) : r += String.fromCharCode(e);
    }
  };
  var ot = function() {
    function n(r) {
      this.ondata = r, Nn ? this.t = new TextDecoder() : this.p = er;
    }
    return n.prototype.push = function(r, t) {
      if (!this.ondata)
        throw "no callback";
      if (t || (t = false), this.t)
        return this.ondata(this.t.decode(r, { stream: !t }), t);
      var e = new A(this.p.length + r.length);
      e.set(this.p), e.set(r, this.p.length);
      var i = Qn(e), a = i[0], o = i[1];
      if (t && o.length)
        throw "invalid utf-8 data";
      this.p = o, this.ondata(a, t);
    }, n;
  }();
  var ft = function() {
    function n(r) {
      this.ondata = r;
    }
    return n.prototype.push = function(r, t) {
      if (!this.ondata)
        throw "no callback";
      this.ondata(or(r), t || false);
    }, n;
  }();
  function or(n, r) {
    if (r) {
      for (var t = new A(n.length), e = 0; e < n.length; ++e)
        t[e] = n.charCodeAt(e);
      return t;
    }
    if (Kn)
      return Kn.encode(n);
    for (var i = n.length, a = new A(n.length + (n.length >> 1)), o = 0, f = function(u) {
      a[o++] = u;
    }, e = 0; e < i; ++e) {
      if (o + 5 > a.length) {
        var h = new A(o + 8 + (i - e << 1));
        h.set(a), a = h;
      }
      var s = n.charCodeAt(e);
      s < 128 || r ? f(s) : s < 2048 ? (f(192 | s >>> 6), f(128 | s & 63)) : s > 55295 && s < 57344 ? (s = 65536 + (s & 1023 << 10) | n.charCodeAt(++e) & 1023, f(240 | s >>> 18), f(128 | s >>> 12 & 63), f(128 | s >>> 6 & 63), f(128 | s & 63)) : (f(224 | s >>> 12), f(128 | s >>> 6 & 63), f(128 | s & 63));
    }
    return $(a, 0, o);
  }
  function un(n, r) {
    if (r) {
      for (var t = "", e = 0; e < n.length; e += 16384)
        t += String.fromCharCode.apply(null, n.subarray(e, e + 16384));
      return t;
    } else {
      if (hn)
        return hn.decode(n);
      var i = Qn(n), a = i[0], o = i[1];
      if (o.length)
        throw "invalid utf-8 data";
      return a;
    }
  }
  var Vn = function(n) {
    return n == 1 ? 3 : n < 6 ? 2 : n == 9 ? 1 : 0;
  };
  var Xn = function(n, r) {
    return r + 30 + Y(n, r + 26) + Y(n, r + 28);
  };
  var $n = function(n, r, t) {
    var e = Y(n, r + 28), i = un(n.subarray(r + 46, r + 46 + e), !(Y(n, r + 8) & 2048)), a = r + 46 + e, o = P(n, r + 20), f = t && o == 4294967295 ? Ln(n, a) : [o, P(n, r + 24), P(n, r + 42)], h = f[0], s = f[1], u = f[2];
    return [Y(n, r + 10), h, s, i, a + Y(n, r + 30) + Y(n, r + 32), u];
  };
  var Ln = function(n, r) {
    for (; Y(n, r) != 1; r += 4 + Y(n, r + 2))
      ;
    return [dr(n, r + 12), dr(n, r + 4), dr(n, r + 20)];
  };
  var fr = function(n) {
    var r = 0;
    if (n)
      for (var t in n) {
        var e = n[t].length;
        if (e > 65535)
          throw "extra field too long";
        r += e + 4;
      }
    return r;
  };
  var Ar = function(n, r, t, e, i, a, o, f) {
    var h = e.length, s = t.extra, u = f && f.length, l = fr(s);
    F(n, r, o != null ? 33639248 : 67324752), r += 4, o != null && (n[r++] = 20, n[r++] = t.os), n[r] = 20, r += 2, n[r++] = t.flag << 1 | (a == null && 8), n[r++] = i && 8, n[r++] = t.compression & 255, n[r++] = t.compression >> 8;
    var p = new Date(t.mtime == null ? Date.now() : t.mtime), y = p.getFullYear() - 1980;
    if (y < 0 || y > 119)
      throw "date not in range 1980-2099";
    if (F(n, r, (y << 24) * 2 | p.getMonth() + 1 << 21 | p.getDate() << 16 | p.getHours() << 11 | p.getMinutes() << 5 | p.getSeconds() >>> 1), r += 4, a != null && (F(n, r, t.crc), F(n, r + 4, a), F(n, r + 8, t.size)), F(n, r + 12, h), F(n, r + 14, l), r += 16, o != null && (F(n, r, u), F(n, r + 6, t.attrs), F(n, r + 10, o), r += 14), n.set(e, r), r += h, l)
      for (var c in s) {
        var g = s[c], w = g.length;
        F(n, r, +c), F(n, r + 2, w), n.set(g, r + 4), r += 4 + w;
      }
    return u && (n.set(f, r), r += u), r;
  };
  var ln = function(n, r, t, e, i) {
    F(n, r, 101010256), F(n, r + 8, t), F(n, r + 10, t), F(n, r + 12, e), F(n, r + 16, i);
  };
  var Br = function() {
    function n(r) {
      this.filename = r, this.c = gr(), this.size = 0, this.compression = 0;
    }
    return n.prototype.process = function(r, t) {
      this.ondata(null, r, t);
    }, n.prototype.push = function(r, t) {
      if (!this.ondata)
        throw "no callback - add to ZIP archive before pushing";
      this.c.p(r), this.size += r.length, t && (this.crc = this.c.d()), this.process(r, t || false);
    }, n;
  }();
  var st = function() {
    function n(r, t) {
      var e = this;
      t || (t = {}), Br.call(this, r), this.d = new rr(t, function(i, a) {
        e.ondata(null, i, a);
      }), this.compression = 8, this.flag = Vn(t.level);
    }
    return n.prototype.process = function(r, t) {
      try {
        this.d.push(r, t);
      } catch (e) {
        this.ondata(e, null, t);
      }
    }, n.prototype.push = function(r, t) {
      Br.prototype.push.call(this, r, t);
    }, n;
  }();
  var ht = function() {
    function n(r, t) {
      var e = this;
      t || (t = {}), Br.call(this, r), this.d = new En(t, function(i, a, o) {
        e.ondata(i, a, o);
      }), this.compression = 8, this.flag = Vn(t.level), this.terminate = this.d.terminate;
    }
    return n.prototype.process = function(r, t) {
      this.d.push(r, t);
    }, n.prototype.push = function(r, t) {
      Br.prototype.push.call(this, r, t);
    }, n;
  }();
  var ut = function() {
    function n(r) {
      this.ondata = r, this.u = [], this.d = 1;
    }
    return n.prototype.add = function(r) {
      var t = this;
      if (this.d & 2)
        throw "stream finished";
      var e = or(r.filename), i = e.length, a = r.comment, o = a && or(a), f = i != r.filename.length || o && a.length != o.length, h = i + fr(r.extra) + 30;
      if (i > 65535)
        throw "filename too long";
      var s = new A(h);
      Ar(s, 0, r, e, f);
      var u = [s], l = function() {
        for (var w = 0, M = u; w < M.length; w++) {
          var z = M[w];
          t.ondata(null, z, false);
        }
        u = [];
      }, p = this.d;
      this.d = 0;
      var y = this.u.length, c = Zr(r, { f: e, u: f, o, t: function() {
        r.terminate && r.terminate();
      }, r: function() {
        if (l(), p) {
          var w = t.u[y + 1];
          w ? w.r() : t.d = 1;
        }
        p = 1;
      } }), g = 0;
      r.ondata = function(w, M, z) {
        if (w)
          t.ondata(w, M, z), t.terminate();
        else if (g += M.length, u.push(M), z) {
          var m = new A(16);
          F(m, 0, 134695760), F(m, 4, r.crc), F(m, 8, g), F(m, 12, r.size), u.push(m), c.c = g, c.b = h + g + 16, c.crc = r.crc, c.size = r.size, p && c.r(), p = 1;
        } else
          p && l();
      }, this.u.push(c);
    }, n.prototype.end = function() {
      var r = this;
      if (this.d & 2)
        throw this.d & 1 ? "stream finishing" : "stream finished";
      this.d ? this.e() : this.u.push({ r: function() {
        if (!(r.d & 1))
          return;
        r.u.splice(-1, 1), r.e();
      }, t: function() {
      } }), this.d = 3;
    }, n.prototype.e = function() {
      for (var r = 0, t = 0, e = 0, i = 0, a = this.u; i < a.length; i++) {
        var o = a[i];
        e += 46 + o.f.length + fr(o.extra) + (o.o ? o.o.length : 0);
      }
      for (var f = new A(e + 22), h = 0, s = this.u; h < s.length; h++) {
        var o = s[h];
        Ar(f, r, o, o.f, o.u, o.c, t, o.o), r += 46 + o.f.length + fr(o.extra) + (o.o ? o.o.length : 0), t += o.b;
      }
      ln(f, r, this.u.length, e, t), this.ondata(null, f, true), this.d = 2;
    }, n.prototype.terminate = function() {
      for (var r = 0, t = this.u; r < t.length; r++) {
        var e = t[r];
        e.t();
      }
      this.d = 2;
    }, n;
  }();
  function lt(n, r, t) {
    if (t || (t = r, r = {}), typeof t != "function")
      throw "no callback";
    var e = {};
    sn(n, "", e, r);
    var i = Object.keys(e), a = i.length, o = 0, f = 0, h = a, s = new Array(a), u = [], l = function() {
      for (var g = 0; g < u.length; ++g)
        u[g]();
    }, p = function() {
      var g = new A(f + 22), w = o, M = f - o;
      f = 0;
      for (var z = 0; z < h; ++z) {
        var m = s[z];
        try {
          var D = m.c.length;
          Ar(g, f, m, m.f, m.u, D);
          var C = 30 + m.f.length + fr(m.extra), U = f + C;
          g.set(m.c, U), Ar(g, o, m, m.f, m.u, D, f, m.m), o += 16 + C + (m.m ? m.m.length : 0), f = U + D;
        } catch (x) {
          return t(x, null);
        }
      }
      ln(g, o, s.length, M, w), t(null, g);
    };
    a || p();
    for (var y = function(g) {
      var w = i[g], M = e[w], z = M[0], m = M[1], D = gr(), C = z.length;
      D.p(z);
      var U = or(w), x = U.length, v = m.comment, E = v && or(v), S = E && E.length, K = fr(m.extra), I = m.level == 0 ? 0 : 8, Z = function(B, G) {
        if (B)
          l(), t(B, null);
        else {
          var k = G.length;
          s[g] = Zr(m, { size: C, crc: D.d(), c: G, f: U, m: E, u: x != w.length || E && v.length != S, compression: I }), o += 30 + x + K + k, f += 76 + 2 * (x + K) + (S || 0) + k, --a || p();
        }
      };
      if (x > 65535 && Z("filename too long", null), !I)
        Z(null, z);
      else if (C < 16e4)
        try {
          Z(null, kr(z, m));
        } catch (B) {
          Z(B, null);
        }
      else
        u.push(Pn(z, m, Z));
    }, c = 0; c < h; ++c)
      y(c);
    return l;
  }
  function vt(n, r) {
    r || (r = {});
    var t = {}, e = [];
    sn(n, "", t, r);
    var i = 0, a = 0;
    for (var o in t) {
      var f = t[o], h = f[0], s = f[1], u = s.level == 0 ? 0 : 8, l = or(o), p = l.length, y = s.comment, c = y && or(y), g = c && c.length, w = fr(s.extra);
      if (p > 65535)
        throw "filename too long";
      var M = u ? kr(h, s) : h, z = M.length, m = gr();
      m.p(h), e.push(Zr(s, { size: h.length, crc: m.d(), c: M, f: l, m: c, u: p != o.length || c && y.length != g, o: i, compression: u })), i += 30 + p + w + z, a += 76 + 2 * (p + w) + (g || 0) + z;
    }
    for (var D = new A(a + 22), C = i, U = a - i, x = 0; x < e.length; ++x) {
      var l = e[x];
      Ar(D, l.o, l, l.f, l.u, l.c.length);
      var v = 30 + l.f.length + fr(l.extra);
      D.set(l.c, l.o + v), Ar(D, i, l, l.f, l.u, l.c.length, l.o, l.m), i += 16 + v + (l.m ? l.m.length : 0);
    }
    return ln(D, i, e.length, U, C), D;
  }
  var dn = function() {
    function n() {
    }
    return n.prototype.push = function(r, t) {
      this.ondata(null, r, t);
    }, n.compression = 0, n;
  }();
  var ct = function() {
    function n() {
      var r = this;
      this.i = new J(function(t, e) {
        r.ondata(null, t, e);
      });
    }
    return n.prototype.push = function(r, t) {
      try {
        this.i.push(r, t);
      } catch (e) {
        this.ondata(e, r, t);
      }
    }, n.compression = 8, n;
  }();
  var pt = function() {
    function n(r, t) {
      var e = this;
      t < 32e4 ? this.i = new J(function(i, a) {
        e.ondata(null, i, a);
      }) : (this.i = new en(function(i, a, o) {
        e.ondata(i, a, o);
      }), this.terminate = this.i.terminate);
    }
    return n.prototype.push = function(r, t) {
      this.i.terminate && (r = $(r, 0)), this.i.push(r, t);
    }, n.compression = 8, n;
  }();
  var gt = function() {
    function n(r) {
      this.onfile = r, this.k = [], this.o = { 0: dn }, this.p = er;
    }
    return n.prototype.push = function(r, t) {
      var e = this;
      if (!this.onfile)
        throw "no callback";
      if (this.c > 0) {
        var i = Math.min(this.c, r.length), a = r.subarray(0, i);
        if (this.c -= i, this.d ? this.d.push(a, !this.c) : this.k[0].push(a), r = r.subarray(i), r.length)
          return this.push(r, t);
      } else {
        var o = 0, f = 0, h = void 0, s = void 0;
        this.p.length ? r.length ? (s = new A(this.p.length + r.length), s.set(this.p), s.set(r, this.p.length)) : s = this.p : s = r;
        for (var u = s.length, l = this.c, p = l && this.d, y = function() {
          var M, z = P(s, f);
          if (z == 67324752) {
            o = 1, h = f, c.d = null, c.c = 0;
            var m = Y(s, f + 6), D = Y(s, f + 8), C = m & 2048, U = m & 8, x = Y(s, f + 26), v = Y(s, f + 28);
            if (u > f + 30 + x + v) {
              var E = [];
              c.k.unshift(E), o = 2;
              var S = P(s, f + 18), K = P(s, f + 22), I = un(s.subarray(f + 30, f += 30 + x), !C);
              S == 4294967295 ? (M = U ? [-2] : Ln(s, f), S = M[0], K = M[1]) : U && (S = -1), f += v, c.c = S;
              var Z = { name: I, compression: D, start: function() {
                if (!Z.ondata)
                  throw "no callback";
                if (!S)
                  Z.ondata(null, er, true);
                else {
                  var B = e.o[D];
                  if (!B)
                    throw "unknown compression type " + D;
                  var G = S < 0 ? new B(I) : new B(I, S, K);
                  G.ondata = function(N, Q, W) {
                    Z.ondata(N, Q, W);
                  };
                  for (var k = 0, O = E; k < O.length; k++) {
                    var H = O[k];
                    G.push(H, false);
                  }
                  e.k[0] == E ? e.d = G : G.push(er, true);
                }
              }, terminate: function() {
                e.k[0] == E && e.d.terminate && e.d.terminate();
              } };
              S >= 0 && (Z.size = S, Z.originalSize = K), c.onfile(Z);
            }
            return "break";
          } else if (l) {
            if (z == 134695760)
              return h = f += 12 + (l == -2 && 8), o = 2, c.c = 0, "break";
            if (z == 33639248)
              return h = f -= 4, o = 2, c.c = 0, "break";
          }
        }, c = this; f < u - 4; ++f) {
          var g = y();
          if (g === "break")
            break;
        }
        if (this.p = er, l < 0) {
          var w = o ? s.subarray(0, h - 12 - (l == -2 && 8) - (P(s, h - 16) == 134695760 && 4)) : s.subarray(0, f);
          p ? p.push(w, !!o) : this.k[+(o == 2)].push(w);
        }
        if (o & 2)
          return this.push(s.subarray(f), t);
        this.p = s.subarray(f);
      }
      if (t && this.c)
        throw "invalid zip file";
    }, n.prototype.register = function(r) {
      this.o[r.compression] = r;
    }, n;
  }();
  function wt(n, r) {
    if (typeof r != "function")
      throw "no callback";
    for (var t = [], e = function() {
      for (var p = 0; p < t.length; ++p)
        t[p]();
    }, i = {}, a = n.length - 22; P(n, a) != 101010256; --a)
      if (!a || n.length - a > 65558) {
        r("invalid zip file", null);
        return;
      }
    var o = Y(n, a + 8);
    o || r(null, {});
    var f = o, h = P(n, a + 16), s = h == 4294967295;
    if (s) {
      if (a = P(n, a - 12), P(n, a) != 101075792) {
        r("invalid zip file", null);
        return;
      }
      f = o = P(n, a + 32), h = P(n, a + 48);
    }
    for (var u = function(p) {
      var y = $n(n, h, s), c = y[0], g = y[1], w = y[2], M = y[3], z = y[4], m = y[5], D = Xn(n, m);
      h = z;
      var C = function(x, v) {
        x ? (e(), r(x, null)) : (i[M] = v, --o || r(null, i));
      };
      if (!c)
        C(null, $(n, D, D + g));
      else if (c == 8) {
        var U = n.subarray(D, D + g);
        if (g < 32e4)
          try {
            C(null, xr(U, new A(w)));
          } catch (x) {
            C(x, null);
          }
        else
          t.push(an(U, { size: w }, C));
      } else
        C("unknown compression type " + c, null);
    }, l = 0; l < f; ++l)
      u();
    return e;
  }
  function yt(n) {
    for (var r = {}, t = n.length - 22; P(n, t) != 101010256; --t)
      if (!t || n.length - t > 65558)
        throw "invalid zip file";
    var e = Y(n, t + 8);
    if (!e)
      return {};
    var i = P(n, t + 16), a = i == 4294967295;
    if (a) {
      if (t = P(n, t - 12), P(n, t) != 101075792)
        throw "invalid zip file";
      e = P(n, t + 32), i = P(n, t + 48);
    }
    for (var o = 0; o < e; ++o) {
      var f = $n(n, i, a), h = f[0], s = f[1], u = f[2], l = f[3], p = f[4], y = f[5], c = Xn(n, y);
      if (i = p, !h)
        r[l] = $(n, c, c + s);
      else if (h == 8)
        r[l] = xr(n.subarray(c, c + s), new A(u));
      else
        throw "unknown compression type " + h;
    }
    return r;
  }
  var fflate_module_min_default = null;

  // node_modules/three/examples/jsm/curves/NURBSUtils.js
  var NURBSUtils = {
    findSpan: function(p, u, U) {
      var n = U.length - p - 1;
      if (u >= U[n]) {
        return n - 1;
      }
      if (u <= U[p]) {
        return p;
      }
      var low = p;
      var high = n;
      var mid = Math.floor((low + high) / 2);
      while (u < U[mid] || u >= U[mid + 1]) {
        if (u < U[mid]) {
          high = mid;
        } else {
          low = mid;
        }
        mid = Math.floor((low + high) / 2);
      }
      return mid;
    },
    calcBasisFunctions: function(span, u, p, U) {
      var N = [];
      var left = [];
      var right = [];
      N[0] = 1;
      for (var j = 1; j <= p; ++j) {
        left[j] = u - U[span + 1 - j];
        right[j] = U[span + j] - u;
        var saved = 0;
        for (var r = 0; r < j; ++r) {
          var rv = right[r + 1];
          var lv = left[j - r];
          var temp = N[r] / (rv + lv);
          N[r] = saved + rv * temp;
          saved = lv * temp;
        }
        N[j] = saved;
      }
      return N;
    },
    calcBSplinePoint: function(p, U, P2, u) {
      var span = this.findSpan(p, u, U);
      var N = this.calcBasisFunctions(span, u, p, U);
      var C = new Vector4(0, 0, 0, 0);
      for (var j = 0; j <= p; ++j) {
        var point = P2[span - p + j];
        var Nj = N[j];
        var wNj = point.w * Nj;
        C.x += point.x * wNj;
        C.y += point.y * wNj;
        C.z += point.z * wNj;
        C.w += point.w * Nj;
      }
      return C;
    },
    calcBasisFunctionDerivatives: function(span, u, p, n, U) {
      var zeroArr = [];
      for (var i = 0; i <= p; ++i)
        zeroArr[i] = 0;
      var ders = [];
      for (var i = 0; i <= n; ++i)
        ders[i] = zeroArr.slice(0);
      var ndu = [];
      for (var i = 0; i <= p; ++i)
        ndu[i] = zeroArr.slice(0);
      ndu[0][0] = 1;
      var left = zeroArr.slice(0);
      var right = zeroArr.slice(0);
      for (var j = 1; j <= p; ++j) {
        left[j] = u - U[span + 1 - j];
        right[j] = U[span + j] - u;
        var saved = 0;
        for (var r = 0; r < j; ++r) {
          var rv = right[r + 1];
          var lv = left[j - r];
          ndu[j][r] = rv + lv;
          var temp = ndu[r][j - 1] / ndu[j][r];
          ndu[r][j] = saved + rv * temp;
          saved = lv * temp;
        }
        ndu[j][j] = saved;
      }
      for (var j = 0; j <= p; ++j) {
        ders[0][j] = ndu[j][p];
      }
      for (var r = 0; r <= p; ++r) {
        var s1 = 0;
        var s2 = 1;
        var a = [];
        for (var i = 0; i <= p; ++i) {
          a[i] = zeroArr.slice(0);
        }
        a[0][0] = 1;
        for (var k = 1; k <= n; ++k) {
          var d = 0;
          var rk = r - k;
          var pk = p - k;
          if (r >= k) {
            a[s2][0] = a[s1][0] / ndu[pk + 1][rk];
            d = a[s2][0] * ndu[rk][pk];
          }
          var j1 = rk >= -1 ? 1 : -rk;
          var j2 = r - 1 <= pk ? k - 1 : p - r;
          for (var j = j1; j <= j2; ++j) {
            a[s2][j] = (a[s1][j] - a[s1][j - 1]) / ndu[pk + 1][rk + j];
            d += a[s2][j] * ndu[rk + j][pk];
          }
          if (r <= pk) {
            a[s2][k] = -a[s1][k - 1] / ndu[pk + 1][r];
            d += a[s2][k] * ndu[r][pk];
          }
          ders[k][r] = d;
          var j = s1;
          s1 = s2;
          s2 = j;
        }
      }
      var r = p;
      for (var k = 1; k <= n; ++k) {
        for (var j = 0; j <= p; ++j) {
          ders[k][j] *= r;
        }
        r *= p - k;
      }
      return ders;
    },
    calcBSplineDerivatives: function(p, U, P2, u, nd) {
      var du = nd < p ? nd : p;
      var CK = [];
      var span = this.findSpan(p, u, U);
      var nders = this.calcBasisFunctionDerivatives(span, u, p, du, U);
      var Pw = [];
      for (var i = 0; i < P2.length; ++i) {
        var point = P2[i].clone();
        var w = point.w;
        point.x *= w;
        point.y *= w;
        point.z *= w;
        Pw[i] = point;
      }
      for (var k = 0; k <= du; ++k) {
        var point = Pw[span - p].clone().multiplyScalar(nders[k][0]);
        for (var j = 1; j <= p; ++j) {
          point.add(Pw[span - p + j].clone().multiplyScalar(nders[k][j]));
        }
        CK[k] = point;
      }
      for (var k = du + 1; k <= nd + 1; ++k) {
        CK[k] = new Vector4(0, 0, 0);
      }
      return CK;
    },
    calcKoverI: function(k, i) {
      var nom = 1;
      for (var j = 2; j <= k; ++j) {
        nom *= j;
      }
      var denom = 1;
      for (var j = 2; j <= i; ++j) {
        denom *= j;
      }
      for (var j = 2; j <= k - i; ++j) {
        denom *= j;
      }
      return nom / denom;
    },
    calcRationalCurveDerivatives: function(Pders) {
      var nd = Pders.length;
      var Aders = [];
      var wders = [];
      for (var i = 0; i < nd; ++i) {
        var point = Pders[i];
        Aders[i] = new Vector3(point.x, point.y, point.z);
        wders[i] = point.w;
      }
      var CK = [];
      for (var k = 0; k < nd; ++k) {
        var v = Aders[k].clone();
        for (var i = 1; i <= k; ++i) {
          v.sub(CK[k - i].clone().multiplyScalar(this.calcKoverI(k, i) * wders[i]));
        }
        CK[k] = v.divideScalar(wders[0]);
      }
      return CK;
    },
    calcNURBSDerivatives: function(p, U, P2, u, nd) {
      var Pders = this.calcBSplineDerivatives(p, U, P2, u, nd);
      return this.calcRationalCurveDerivatives(Pders);
    },
    calcSurfacePoint: function(p, q, U, V, P2, u, v, target) {
      var uspan = this.findSpan(p, u, U);
      var vspan = this.findSpan(q, v, V);
      var Nu = this.calcBasisFunctions(uspan, u, p, U);
      var Nv = this.calcBasisFunctions(vspan, v, q, V);
      var temp = [];
      for (var l = 0; l <= q; ++l) {
        temp[l] = new Vector4(0, 0, 0, 0);
        for (var k = 0; k <= p; ++k) {
          var point = P2[uspan - p + k][vspan - q + l].clone();
          var w = point.w;
          point.x *= w;
          point.y *= w;
          point.z *= w;
          temp[l].add(point.multiplyScalar(Nu[k]));
        }
      }
      var Sw = new Vector4(0, 0, 0, 0);
      for (var l = 0; l <= q; ++l) {
        Sw.add(temp[l].multiplyScalar(Nv[l]));
      }
      Sw.divideScalar(Sw.w);
      target.set(Sw.x, Sw.y, Sw.z);
    }
  };

  // node_modules/three/examples/jsm/curves/NURBSCurve.js
  var NURBSCurve = function(degree, knots, controlPoints, startKnot, endKnot) {
    Curve.call(this);
    this.degree = degree;
    this.knots = knots;
    this.controlPoints = [];
    this.startKnot = startKnot || 0;
    this.endKnot = endKnot || this.knots.length - 1;
    for (var i = 0; i < controlPoints.length; ++i) {
      var point = controlPoints[i];
      this.controlPoints[i] = new Vector4(point.x, point.y, point.z, point.w);
    }
  };
  NURBSCurve.prototype = Object.create(Curve.prototype);
  NURBSCurve.prototype.constructor = NURBSCurve;
  NURBSCurve.prototype.getPoint = function(t, optionalTarget) {
    var point = optionalTarget || new Vector3();
    var u = this.knots[this.startKnot] + t * (this.knots[this.endKnot] - this.knots[this.startKnot]);
    var hpoint = NURBSUtils.calcBSplinePoint(this.degree, this.knots, this.controlPoints, u);
    if (hpoint.w != 1) {
      hpoint.divideScalar(hpoint.w);
    }
    return point.set(hpoint.x, hpoint.y, hpoint.z);
  };
  NURBSCurve.prototype.getTangent = function(t, optionalTarget) {
    var tangent = optionalTarget || new Vector3();
    var u = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0]);
    var ders = NURBSUtils.calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, u, 1);
    tangent.copy(ders[1]).normalize();
    return tangent;
  };

  // node_modules/three/examples/jsm/loaders/FBXLoader.js
  var FBXLoader = function() {
    var fbxTree;
    var connections;
    var sceneGraph;
    function FBXLoader2(manager) {
      Loader.call(this, manager);
    }
    FBXLoader2.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: FBXLoader2,
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var path = scope.path === "" ? LoaderUtils.extractUrlBase(url) : scope.path;
        var loader = new FileLoader(this.manager);
        loader.setPath(scope.path);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(buffer) {
          try {
            onLoad(scope.parse(buffer, path));
          } catch (e) {
            if (onError) {
              onError(e);
            } else {
              console.error(e);
            }
            scope.manager.itemError(url);
          }
        }, onProgress, onError);
      },
      parse: function(FBXBuffer, path) {
        if (isFbxFormatBinary(FBXBuffer)) {
          fbxTree = new BinaryParser().parse(FBXBuffer);
        } else {
          var FBXText = convertArrayBufferToString(FBXBuffer);
          if (!isFbxFormatASCII(FBXText)) {
            throw new Error("THREE.FBXLoader: Unknown format.");
          }
          if (getFbxVersion(FBXText) < 7e3) {
            throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + getFbxVersion(FBXText));
          }
          fbxTree = new TextParser().parse(FBXText);
        }
        var textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
        return new FBXTreeParser(textureLoader, this.manager).parse(fbxTree);
      }
    });
    function FBXTreeParser(textureLoader, manager) {
      this.textureLoader = textureLoader;
      this.manager = manager;
    }
    FBXTreeParser.prototype = {
      constructor: FBXTreeParser,
      parse: function() {
        connections = this.parseConnections();
        var images = this.parseImages();
        var textures = this.parseTextures(images);
        var materials = this.parseMaterials(textures);
        var deformers = this.parseDeformers();
        var geometryMap = new GeometryParser().parse(deformers);
        this.parseScene(deformers, geometryMap, materials);
        return sceneGraph;
      },
      parseConnections: function() {
        var connectionMap = new Map();
        if ("Connections" in fbxTree) {
          var rawConnections = fbxTree.Connections.connections;
          rawConnections.forEach(function(rawConnection) {
            var fromID = rawConnection[0];
            var toID = rawConnection[1];
            var relationship = rawConnection[2];
            if (!connectionMap.has(fromID)) {
              connectionMap.set(fromID, {
                parents: [],
                children: []
              });
            }
            var parentRelationship = { ID: toID, relationship };
            connectionMap.get(fromID).parents.push(parentRelationship);
            if (!connectionMap.has(toID)) {
              connectionMap.set(toID, {
                parents: [],
                children: []
              });
            }
            var childRelationship = { ID: fromID, relationship };
            connectionMap.get(toID).children.push(childRelationship);
          });
        }
        return connectionMap;
      },
      parseImages: function() {
        var images = {};
        var blobs = {};
        if ("Video" in fbxTree.Objects) {
          var videoNodes = fbxTree.Objects.Video;
          for (var nodeID in videoNodes) {
            var videoNode = videoNodes[nodeID];
            var id = parseInt(nodeID);
            images[id] = videoNode.RelativeFilename || videoNode.Filename;
            if ("Content" in videoNode) {
              var arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;
              var base64Content = typeof videoNode.Content === "string" && videoNode.Content !== "";
              if (arrayBufferContent || base64Content) {
                var image = this.parseImage(videoNodes[nodeID]);
                blobs[videoNode.RelativeFilename || videoNode.Filename] = image;
              }
            }
          }
        }
        for (var id in images) {
          var filename = images[id];
          if (blobs[filename] !== void 0)
            images[id] = blobs[filename];
          else
            images[id] = images[id].split("\\").pop();
        }
        return images;
      },
      parseImage: function(videoNode) {
        var content = videoNode.Content;
        var fileName = videoNode.RelativeFilename || videoNode.Filename;
        var extension = fileName.slice(fileName.lastIndexOf(".") + 1).toLowerCase();
        var type;
        switch (extension) {
          case "bmp":
            type = "image/bmp";
            break;
          case "jpg":
          case "jpeg":
            type = "image/jpeg";
            break;
          case "png":
            type = "image/png";
            break;
          case "tif":
            type = "image/tiff";
            break;
          case "tga":
            if (this.manager.getHandler(".tga") === null) {
              console.warn("FBXLoader: TGA loader not found, skipping ", fileName);
            }
            type = "image/tga";
            break;
          default:
            console.warn('FBXLoader: Image type "' + extension + '" is not supported.');
            return;
        }
        if (typeof content === "string") {
          return "data:" + type + ";base64," + content;
        } else {
          var array = new Uint8Array(content);
          return window.URL.createObjectURL(new Blob([array], { type }));
        }
      },
      parseTextures: function(images) {
        var textureMap = new Map();
        if ("Texture" in fbxTree.Objects) {
          var textureNodes = fbxTree.Objects.Texture;
          for (var nodeID in textureNodes) {
            var texture = this.parseTexture(textureNodes[nodeID], images);
            textureMap.set(parseInt(nodeID), texture);
          }
        }
        return textureMap;
      },
      parseTexture: function(textureNode, images) {
        var texture = this.loadTexture(textureNode, images);
        texture.ID = textureNode.id;
        texture.name = textureNode.attrName;
        var wrapModeU = textureNode.WrapModeU;
        var wrapModeV = textureNode.WrapModeV;
        var valueU = wrapModeU !== void 0 ? wrapModeU.value : 0;
        var valueV = wrapModeV !== void 0 ? wrapModeV.value : 0;
        texture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping;
        texture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping;
        if ("Scaling" in textureNode) {
          var values = textureNode.Scaling.value;
          texture.repeat.x = values[0];
          texture.repeat.y = values[1];
        }
        return texture;
      },
      loadTexture: function(textureNode, images) {
        var fileName;
        var currentPath = this.textureLoader.path;
        var children = connections.get(textureNode.id).children;
        if (children !== void 0 && children.length > 0 && images[children[0].ID] !== void 0) {
          fileName = images[children[0].ID];
          if (fileName.indexOf("blob:") === 0 || fileName.indexOf("data:") === 0) {
            this.textureLoader.setPath(void 0);
          }
        }
        var texture;
        var extension = textureNode.FileName.slice(-3).toLowerCase();
        if (extension === "tga") {
          var loader = this.manager.getHandler(".tga");
          if (loader === null) {
            console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", textureNode.RelativeFilename);
            texture = new Texture();
          } else {
            texture = loader.load(fileName);
          }
        } else if (extension === "psd") {
          console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", textureNode.RelativeFilename);
          texture = new Texture();
        } else {
          texture = this.textureLoader.load(fileName);
        }
        this.textureLoader.setPath(currentPath);
        return texture;
      },
      parseMaterials: function(textureMap) {
        var materialMap = new Map();
        if ("Material" in fbxTree.Objects) {
          var materialNodes = fbxTree.Objects.Material;
          for (var nodeID in materialNodes) {
            var material = this.parseMaterial(materialNodes[nodeID], textureMap);
            if (material !== null)
              materialMap.set(parseInt(nodeID), material);
          }
        }
        return materialMap;
      },
      parseMaterial: function(materialNode, textureMap) {
        var ID = materialNode.id;
        var name = materialNode.attrName;
        var type = materialNode.ShadingModel;
        if (typeof type === "object") {
          type = type.value;
        }
        if (!connections.has(ID))
          return null;
        var parameters = this.parseParameters(materialNode, textureMap, ID);
        var material;
        switch (type.toLowerCase()) {
          case "phong":
            material = new MeshPhongMaterial();
            break;
          case "lambert":
            material = new MeshLambertMaterial();
            break;
          default:
            console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', type);
            material = new MeshPhongMaterial();
            break;
        }
        material.setValues(parameters);
        material.name = name;
        return material;
      },
      parseParameters: function(materialNode, textureMap, ID) {
        var parameters = {};
        if (materialNode.BumpFactor) {
          parameters.bumpScale = materialNode.BumpFactor.value;
        }
        if (materialNode.Diffuse) {
          parameters.color = new Color().fromArray(materialNode.Diffuse.value);
        } else if (materialNode.DiffuseColor && (materialNode.DiffuseColor.type === "Color" || materialNode.DiffuseColor.type === "ColorRGB")) {
          parameters.color = new Color().fromArray(materialNode.DiffuseColor.value);
        }
        if (materialNode.DisplacementFactor) {
          parameters.displacementScale = materialNode.DisplacementFactor.value;
        }
        if (materialNode.Emissive) {
          parameters.emissive = new Color().fromArray(materialNode.Emissive.value);
        } else if (materialNode.EmissiveColor && (materialNode.EmissiveColor.type === "Color" || materialNode.EmissiveColor.type === "ColorRGB")) {
          parameters.emissive = new Color().fromArray(materialNode.EmissiveColor.value);
        }
        if (materialNode.EmissiveFactor) {
          parameters.emissiveIntensity = parseFloat(materialNode.EmissiveFactor.value);
        }
        if (materialNode.Opacity) {
          parameters.opacity = parseFloat(materialNode.Opacity.value);
        }
        if (parameters.opacity < 1) {
          parameters.transparent = true;
        }
        if (materialNode.ReflectionFactor) {
          parameters.reflectivity = materialNode.ReflectionFactor.value;
        }
        if (materialNode.Shininess) {
          parameters.shininess = materialNode.Shininess.value;
        }
        if (materialNode.Specular) {
          parameters.specular = new Color().fromArray(materialNode.Specular.value);
        } else if (materialNode.SpecularColor && materialNode.SpecularColor.type === "Color") {
          parameters.specular = new Color().fromArray(materialNode.SpecularColor.value);
        }
        var scope = this;
        connections.get(ID).children.forEach(function(child) {
          var type = child.relationship;
          switch (type) {
            case "Bump":
              parameters.bumpMap = scope.getTexture(textureMap, child.ID);
              break;
            case "Maya|TEX_ao_map":
              parameters.aoMap = scope.getTexture(textureMap, child.ID);
              break;
            case "DiffuseColor":
            case "Maya|TEX_color_map":
              parameters.map = scope.getTexture(textureMap, child.ID);
              parameters.map.encoding = sRGBEncoding;
              break;
            case "DisplacementColor":
              parameters.displacementMap = scope.getTexture(textureMap, child.ID);
              break;
            case "EmissiveColor":
              parameters.emissiveMap = scope.getTexture(textureMap, child.ID);
              parameters.emissiveMap.encoding = sRGBEncoding;
              break;
            case "NormalMap":
            case "Maya|TEX_normal_map":
              parameters.normalMap = scope.getTexture(textureMap, child.ID);
              break;
            case "ReflectionColor":
              parameters.envMap = scope.getTexture(textureMap, child.ID);
              parameters.envMap.mapping = EquirectangularReflectionMapping;
              parameters.envMap.encoding = sRGBEncoding;
              break;
            case "SpecularColor":
              parameters.specularMap = scope.getTexture(textureMap, child.ID);
              parameters.specularMap.encoding = sRGBEncoding;
              break;
            case "TransparentColor":
            case "TransparencyFactor":
              parameters.alphaMap = scope.getTexture(textureMap, child.ID);
              parameters.transparent = true;
              break;
            case "AmbientColor":
            case "ShininessExponent":
            case "SpecularFactor":
            case "VectorDisplacementColor":
            default:
              console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", type);
              break;
          }
        });
        return parameters;
      },
      getTexture: function(textureMap, id) {
        if ("LayeredTexture" in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture) {
          console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.");
          id = connections.get(id).children[0].ID;
        }
        return textureMap.get(id);
      },
      parseDeformers: function() {
        var skeletons = {};
        var morphTargets = {};
        if ("Deformer" in fbxTree.Objects) {
          var DeformerNodes = fbxTree.Objects.Deformer;
          for (var nodeID in DeformerNodes) {
            var deformerNode = DeformerNodes[nodeID];
            var relationships = connections.get(parseInt(nodeID));
            if (deformerNode.attrType === "Skin") {
              var skeleton = this.parseSkeleton(relationships, DeformerNodes);
              skeleton.ID = nodeID;
              if (relationships.parents.length > 1)
                console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported.");
              skeleton.geometryID = relationships.parents[0].ID;
              skeletons[nodeID] = skeleton;
            } else if (deformerNode.attrType === "BlendShape") {
              var morphTarget = {
                id: nodeID
              };
              morphTarget.rawTargets = this.parseMorphTargets(relationships, DeformerNodes);
              morphTarget.id = nodeID;
              if (relationships.parents.length > 1)
                console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported.");
              morphTargets[nodeID] = morphTarget;
            }
          }
        }
        return {
          skeletons,
          morphTargets
        };
      },
      parseSkeleton: function(relationships, deformerNodes) {
        var rawBones = [];
        relationships.children.forEach(function(child) {
          var boneNode = deformerNodes[child.ID];
          if (boneNode.attrType !== "Cluster")
            return;
          var rawBone = {
            ID: child.ID,
            indices: [],
            weights: [],
            transformLink: new Matrix4().fromArray(boneNode.TransformLink.a)
          };
          if ("Indexes" in boneNode) {
            rawBone.indices = boneNode.Indexes.a;
            rawBone.weights = boneNode.Weights.a;
          }
          rawBones.push(rawBone);
        });
        return {
          rawBones,
          bones: []
        };
      },
      parseMorphTargets: function(relationships, deformerNodes) {
        var rawMorphTargets = [];
        for (var i = 0; i < relationships.children.length; i++) {
          var child = relationships.children[i];
          var morphTargetNode = deformerNodes[child.ID];
          var rawMorphTarget = {
            name: morphTargetNode.attrName,
            initialWeight: morphTargetNode.DeformPercent,
            id: morphTargetNode.id,
            fullWeights: morphTargetNode.FullWeights.a
          };
          if (morphTargetNode.attrType !== "BlendShapeChannel")
            return;
          rawMorphTarget.geoID = connections.get(parseInt(child.ID)).children.filter(function(child2) {
            return child2.relationship === void 0;
          })[0].ID;
          rawMorphTargets.push(rawMorphTarget);
        }
        return rawMorphTargets;
      },
      parseScene: function(deformers, geometryMap, materialMap) {
        sceneGraph = new Group();
        var modelMap = this.parseModels(deformers.skeletons, geometryMap, materialMap);
        var modelNodes = fbxTree.Objects.Model;
        var scope = this;
        modelMap.forEach(function(model) {
          var modelNode = modelNodes[model.ID];
          scope.setLookAtProperties(model, modelNode);
          var parentConnections = connections.get(model.ID).parents;
          parentConnections.forEach(function(connection) {
            var parent = modelMap.get(connection.ID);
            if (parent !== void 0)
              parent.add(model);
          });
          if (model.parent === null) {
            sceneGraph.add(model);
          }
        });
        this.bindSkeleton(deformers.skeletons, geometryMap, modelMap);
        this.createAmbientLight();
        this.setupMorphMaterials();
        sceneGraph.traverse(function(node) {
          if (node.userData.transformData) {
            if (node.parent) {
              node.userData.transformData.parentMatrix = node.parent.matrix;
              node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;
            }
            var transform = generateTransform(node.userData.transformData);
            node.applyMatrix4(transform);
            node.updateWorldMatrix();
          }
        });
        var animations = new AnimationParser().parse();
        if (sceneGraph.children.length === 1 && sceneGraph.children[0].isGroup) {
          sceneGraph.children[0].animations = animations;
          sceneGraph = sceneGraph.children[0];
        }
        sceneGraph.animations = animations;
      },
      parseModels: function(skeletons, geometryMap, materialMap) {
        var modelMap = new Map();
        var modelNodes = fbxTree.Objects.Model;
        for (var nodeID in modelNodes) {
          var id = parseInt(nodeID);
          var node = modelNodes[nodeID];
          var relationships = connections.get(id);
          var model = this.buildSkeleton(relationships, skeletons, id, node.attrName);
          if (!model) {
            switch (node.attrType) {
              case "Camera":
                model = this.createCamera(relationships);
                break;
              case "Light":
                model = this.createLight(relationships);
                break;
              case "Mesh":
                model = this.createMesh(relationships, geometryMap, materialMap);
                break;
              case "NurbsCurve":
                model = this.createCurve(relationships, geometryMap);
                break;
              case "LimbNode":
              case "Root":
                model = new Bone();
                break;
              case "Null":
              default:
                model = new Group();
                break;
            }
            model.name = node.attrName ? PropertyBinding.sanitizeNodeName(node.attrName) : "";
            model.ID = id;
          }
          this.getTransformData(model, node);
          modelMap.set(id, model);
        }
        return modelMap;
      },
      buildSkeleton: function(relationships, skeletons, id, name) {
        var bone = null;
        relationships.parents.forEach(function(parent) {
          for (var ID in skeletons) {
            var skeleton = skeletons[ID];
            skeleton.rawBones.forEach(function(rawBone, i) {
              if (rawBone.ID === parent.ID) {
                var subBone = bone;
                bone = new Bone();
                bone.matrixWorld.copy(rawBone.transformLink);
                bone.name = name ? PropertyBinding.sanitizeNodeName(name) : "";
                bone.ID = id;
                skeleton.bones[i] = bone;
                if (subBone !== null) {
                  bone.add(subBone);
                }
              }
            });
          }
        });
        return bone;
      },
      createCamera: function(relationships) {
        var model;
        var cameraAttribute;
        relationships.children.forEach(function(child) {
          var attr = fbxTree.Objects.NodeAttribute[child.ID];
          if (attr !== void 0) {
            cameraAttribute = attr;
          }
        });
        if (cameraAttribute === void 0) {
          model = new Object3D();
        } else {
          var type = 0;
          if (cameraAttribute.CameraProjectionType !== void 0 && cameraAttribute.CameraProjectionType.value === 1) {
            type = 1;
          }
          var nearClippingPlane = 1;
          if (cameraAttribute.NearPlane !== void 0) {
            nearClippingPlane = cameraAttribute.NearPlane.value / 1e3;
          }
          var farClippingPlane = 1e3;
          if (cameraAttribute.FarPlane !== void 0) {
            farClippingPlane = cameraAttribute.FarPlane.value / 1e3;
          }
          var width = window.innerWidth;
          var height = window.innerHeight;
          if (cameraAttribute.AspectWidth !== void 0 && cameraAttribute.AspectHeight !== void 0) {
            width = cameraAttribute.AspectWidth.value;
            height = cameraAttribute.AspectHeight.value;
          }
          var aspect2 = width / height;
          var fov2 = 45;
          if (cameraAttribute.FieldOfView !== void 0) {
            fov2 = cameraAttribute.FieldOfView.value;
          }
          var focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;
          switch (type) {
            case 0:
              model = new PerspectiveCamera(fov2, aspect2, nearClippingPlane, farClippingPlane);
              if (focalLength !== null)
                model.setFocalLength(focalLength);
              break;
            case 1:
              model = new OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, nearClippingPlane, farClippingPlane);
              break;
            default:
              console.warn("THREE.FBXLoader: Unknown camera type " + type + ".");
              model = new Object3D();
              break;
          }
        }
        return model;
      },
      createLight: function(relationships) {
        var model;
        var lightAttribute;
        relationships.children.forEach(function(child) {
          var attr = fbxTree.Objects.NodeAttribute[child.ID];
          if (attr !== void 0) {
            lightAttribute = attr;
          }
        });
        if (lightAttribute === void 0) {
          model = new Object3D();
        } else {
          var type;
          if (lightAttribute.LightType === void 0) {
            type = 0;
          } else {
            type = lightAttribute.LightType.value;
          }
          var color = 16777215;
          if (lightAttribute.Color !== void 0) {
            color = new Color().fromArray(lightAttribute.Color.value);
          }
          var intensity = lightAttribute.Intensity === void 0 ? 1 : lightAttribute.Intensity.value / 100;
          if (lightAttribute.CastLightOnObject !== void 0 && lightAttribute.CastLightOnObject.value === 0) {
            intensity = 0;
          }
          var distance = 0;
          if (lightAttribute.FarAttenuationEnd !== void 0) {
            if (lightAttribute.EnableFarAttenuation !== void 0 && lightAttribute.EnableFarAttenuation.value === 0) {
              distance = 0;
            } else {
              distance = lightAttribute.FarAttenuationEnd.value;
            }
          }
          var decay = 1;
          switch (type) {
            case 0:
              model = new PointLight(color, intensity, distance, decay);
              break;
            case 1:
              model = new DirectionalLight(color, intensity);
              break;
            case 2:
              var angle = Math.PI / 3;
              if (lightAttribute.InnerAngle !== void 0) {
                angle = MathUtils.degToRad(lightAttribute.InnerAngle.value);
              }
              var penumbra = 0;
              if (lightAttribute.OuterAngle !== void 0) {
                penumbra = MathUtils.degToRad(lightAttribute.OuterAngle.value);
                penumbra = Math.max(penumbra, 1);
              }
              model = new SpotLight(color, intensity, distance, angle, penumbra, decay);
              break;
            default:
              console.warn("THREE.FBXLoader: Unknown light type " + lightAttribute.LightType.value + ", defaulting to a PointLight.");
              model = new PointLight(color, intensity);
              break;
          }
          if (lightAttribute.CastShadows !== void 0 && lightAttribute.CastShadows.value === 1) {
            model.castShadow = true;
          }
        }
        return model;
      },
      createMesh: function(relationships, geometryMap, materialMap) {
        var model;
        var geometry = null;
        var material = null;
        var materials = [];
        relationships.children.forEach(function(child) {
          if (geometryMap.has(child.ID)) {
            geometry = geometryMap.get(child.ID);
          }
          if (materialMap.has(child.ID)) {
            materials.push(materialMap.get(child.ID));
          }
        });
        if (materials.length > 1) {
          material = materials;
        } else if (materials.length > 0) {
          material = materials[0];
        } else {
          material = new MeshPhongMaterial({ color: 13421772 });
          materials.push(material);
        }
        if ("color" in geometry.attributes) {
          materials.forEach(function(material2) {
            material2.vertexColors = true;
          });
        }
        if (geometry.FBX_Deformer) {
          materials.forEach(function(material2) {
            material2.skinning = true;
          });
          model = new SkinnedMesh(geometry, material);
          model.normalizeSkinWeights();
        } else {
          model = new Mesh(geometry, material);
        }
        return model;
      },
      createCurve: function(relationships, geometryMap) {
        var geometry = relationships.children.reduce(function(geo, child) {
          if (geometryMap.has(child.ID))
            geo = geometryMap.get(child.ID);
          return geo;
        }, null);
        var material = new LineBasicMaterial({ color: 3342591, linewidth: 1 });
        return new Line(geometry, material);
      },
      getTransformData: function(model, modelNode) {
        var transformData = {};
        if ("InheritType" in modelNode)
          transformData.inheritType = parseInt(modelNode.InheritType.value);
        if ("RotationOrder" in modelNode)
          transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);
        else
          transformData.eulerOrder = "ZYX";
        if ("Lcl_Translation" in modelNode)
          transformData.translation = modelNode.Lcl_Translation.value;
        if ("PreRotation" in modelNode)
          transformData.preRotation = modelNode.PreRotation.value;
        if ("Lcl_Rotation" in modelNode)
          transformData.rotation = modelNode.Lcl_Rotation.value;
        if ("PostRotation" in modelNode)
          transformData.postRotation = modelNode.PostRotation.value;
        if ("Lcl_Scaling" in modelNode)
          transformData.scale = modelNode.Lcl_Scaling.value;
        if ("ScalingOffset" in modelNode)
          transformData.scalingOffset = modelNode.ScalingOffset.value;
        if ("ScalingPivot" in modelNode)
          transformData.scalingPivot = modelNode.ScalingPivot.value;
        if ("RotationOffset" in modelNode)
          transformData.rotationOffset = modelNode.RotationOffset.value;
        if ("RotationPivot" in modelNode)
          transformData.rotationPivot = modelNode.RotationPivot.value;
        model.userData.transformData = transformData;
      },
      setLookAtProperties: function(model, modelNode) {
        if ("LookAtProperty" in modelNode) {
          var children = connections.get(model.ID).children;
          children.forEach(function(child) {
            if (child.relationship === "LookAtProperty") {
              var lookAtTarget = fbxTree.Objects.Model[child.ID];
              if ("Lcl_Translation" in lookAtTarget) {
                var pos2 = lookAtTarget.Lcl_Translation.value;
                if (model.target !== void 0) {
                  model.target.position.fromArray(pos2);
                  sceneGraph.add(model.target);
                } else {
                  model.lookAt(new Vector3().fromArray(pos2));
                }
              }
            }
          });
        }
      },
      bindSkeleton: function(skeletons, geometryMap, modelMap) {
        var bindMatrices = this.parsePoseNodes();
        for (var ID in skeletons) {
          var skeleton = skeletons[ID];
          var parents = connections.get(parseInt(skeleton.ID)).parents;
          parents.forEach(function(parent) {
            if (geometryMap.has(parent.ID)) {
              var geoID = parent.ID;
              var geoRelationships = connections.get(geoID);
              geoRelationships.parents.forEach(function(geoConnParent) {
                if (modelMap.has(geoConnParent.ID)) {
                  var model = modelMap.get(geoConnParent.ID);
                  model.bind(new Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID]);
                }
              });
            }
          });
        }
      },
      parsePoseNodes: function() {
        var bindMatrices = {};
        if ("Pose" in fbxTree.Objects) {
          var BindPoseNode = fbxTree.Objects.Pose;
          for (var nodeID in BindPoseNode) {
            if (BindPoseNode[nodeID].attrType === "BindPose") {
              var poseNodes = BindPoseNode[nodeID].PoseNode;
              if (Array.isArray(poseNodes)) {
                poseNodes.forEach(function(poseNode) {
                  bindMatrices[poseNode.Node] = new Matrix4().fromArray(poseNode.Matrix.a);
                });
              } else {
                bindMatrices[poseNodes.Node] = new Matrix4().fromArray(poseNodes.Matrix.a);
              }
            }
          }
        }
        return bindMatrices;
      },
      createAmbientLight: function() {
        if ("GlobalSettings" in fbxTree && "AmbientColor" in fbxTree.GlobalSettings) {
          var ambientColor = fbxTree.GlobalSettings.AmbientColor.value;
          var r = ambientColor[0];
          var g = ambientColor[1];
          var b2 = ambientColor[2];
          if (r !== 0 || g !== 0 || b2 !== 0) {
            var color = new Color(r, g, b2);
            sceneGraph.add(new AmbientLight(color, 1));
          }
        }
      },
      setupMorphMaterials: function() {
        var scope = this;
        sceneGraph.traverse(function(child) {
          if (child.isMesh) {
            if (child.geometry.morphAttributes.position && child.geometry.morphAttributes.position.length) {
              if (Array.isArray(child.material)) {
                child.material.forEach(function(material, i) {
                  scope.setupMorphMaterial(child, material, i);
                });
              } else {
                scope.setupMorphMaterial(child, child.material);
              }
            }
          }
        });
      },
      setupMorphMaterial: function(child, material, index) {
        var uuid = child.uuid;
        var matUuid = material.uuid;
        var sharedMat = false;
        sceneGraph.traverse(function(node) {
          if (node.isMesh) {
            if (Array.isArray(node.material)) {
              node.material.forEach(function(mat) {
                if (mat.uuid === matUuid && node.uuid !== uuid)
                  sharedMat = true;
              });
            } else if (node.material.uuid === matUuid && node.uuid !== uuid)
              sharedMat = true;
          }
        });
        if (sharedMat === true) {
          var clonedMat = material.clone();
          clonedMat.morphTargets = true;
          if (index === void 0)
            child.material = clonedMat;
          else
            child.material[index] = clonedMat;
        } else
          material.morphTargets = true;
      }
    };
    function GeometryParser() {
    }
    GeometryParser.prototype = {
      constructor: GeometryParser,
      parse: function(deformers) {
        var geometryMap = new Map();
        if ("Geometry" in fbxTree.Objects) {
          var geoNodes = fbxTree.Objects.Geometry;
          for (var nodeID in geoNodes) {
            var relationships = connections.get(parseInt(nodeID));
            var geo = this.parseGeometry(relationships, geoNodes[nodeID], deformers);
            geometryMap.set(parseInt(nodeID), geo);
          }
        }
        return geometryMap;
      },
      parseGeometry: function(relationships, geoNode, deformers) {
        switch (geoNode.attrType) {
          case "Mesh":
            return this.parseMeshGeometry(relationships, geoNode, deformers);
            break;
          case "NurbsCurve":
            return this.parseNurbsGeometry(geoNode);
            break;
        }
      },
      parseMeshGeometry: function(relationships, geoNode, deformers) {
        var skeletons = deformers.skeletons;
        var morphTargets = [];
        var modelNodes = relationships.parents.map(function(parent) {
          return fbxTree.Objects.Model[parent.ID];
        });
        if (modelNodes.length === 0)
          return;
        var skeleton = relationships.children.reduce(function(skeleton2, child) {
          if (skeletons[child.ID] !== void 0)
            skeleton2 = skeletons[child.ID];
          return skeleton2;
        }, null);
        relationships.children.forEach(function(child) {
          if (deformers.morphTargets[child.ID] !== void 0) {
            morphTargets.push(deformers.morphTargets[child.ID]);
          }
        });
        var modelNode = modelNodes[0];
        var transformData = {};
        if ("RotationOrder" in modelNode)
          transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);
        if ("InheritType" in modelNode)
          transformData.inheritType = parseInt(modelNode.InheritType.value);
        if ("GeometricTranslation" in modelNode)
          transformData.translation = modelNode.GeometricTranslation.value;
        if ("GeometricRotation" in modelNode)
          transformData.rotation = modelNode.GeometricRotation.value;
        if ("GeometricScaling" in modelNode)
          transformData.scale = modelNode.GeometricScaling.value;
        var transform = generateTransform(transformData);
        return this.genGeometry(geoNode, skeleton, morphTargets, transform);
      },
      genGeometry: function(geoNode, skeleton, morphTargets, preTransform) {
        var geo = new BufferGeometry();
        if (geoNode.attrName)
          geo.name = geoNode.attrName;
        var geoInfo = this.parseGeoNode(geoNode, skeleton);
        var buffers = this.genBuffers(geoInfo);
        var positionAttribute = new Float32BufferAttribute(buffers.vertex, 3);
        positionAttribute.applyMatrix4(preTransform);
        geo.setAttribute("position", positionAttribute);
        if (buffers.colors.length > 0) {
          geo.setAttribute("color", new Float32BufferAttribute(buffers.colors, 3));
        }
        if (skeleton) {
          geo.setAttribute("skinIndex", new Uint16BufferAttribute(buffers.weightsIndices, 4));
          geo.setAttribute("skinWeight", new Float32BufferAttribute(buffers.vertexWeights, 4));
          geo.FBX_Deformer = skeleton;
        }
        if (buffers.normal.length > 0) {
          var normalMatrix = new Matrix3().getNormalMatrix(preTransform);
          var normalAttribute = new Float32BufferAttribute(buffers.normal, 3);
          normalAttribute.applyNormalMatrix(normalMatrix);
          geo.setAttribute("normal", normalAttribute);
        }
        buffers.uvs.forEach(function(uvBuffer, i) {
          var name = "uv" + (i + 1).toString();
          if (i === 0) {
            name = "uv";
          }
          geo.setAttribute(name, new Float32BufferAttribute(buffers.uvs[i], 2));
        });
        if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
          var prevMaterialIndex = buffers.materialIndex[0];
          var startIndex = 0;
          buffers.materialIndex.forEach(function(currentIndex, i) {
            if (currentIndex !== prevMaterialIndex) {
              geo.addGroup(startIndex, i - startIndex, prevMaterialIndex);
              prevMaterialIndex = currentIndex;
              startIndex = i;
            }
          });
          if (geo.groups.length > 0) {
            var lastGroup = geo.groups[geo.groups.length - 1];
            var lastIndex = lastGroup.start + lastGroup.count;
            if (lastIndex !== buffers.materialIndex.length) {
              geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);
            }
          }
          if (geo.groups.length === 0) {
            geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);
          }
        }
        this.addMorphTargets(geo, geoNode, morphTargets, preTransform);
        return geo;
      },
      parseGeoNode: function(geoNode, skeleton) {
        var geoInfo = {};
        geoInfo.vertexPositions = geoNode.Vertices !== void 0 ? geoNode.Vertices.a : [];
        geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== void 0 ? geoNode.PolygonVertexIndex.a : [];
        if (geoNode.LayerElementColor) {
          geoInfo.color = this.parseVertexColors(geoNode.LayerElementColor[0]);
        }
        if (geoNode.LayerElementMaterial) {
          geoInfo.material = this.parseMaterialIndices(geoNode.LayerElementMaterial[0]);
        }
        if (geoNode.LayerElementNormal) {
          geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0]);
        }
        if (geoNode.LayerElementUV) {
          geoInfo.uv = [];
          var i = 0;
          while (geoNode.LayerElementUV[i]) {
            if (geoNode.LayerElementUV[i].UV) {
              geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i]));
            }
            i++;
          }
        }
        geoInfo.weightTable = {};
        if (skeleton !== null) {
          geoInfo.skeleton = skeleton;
          skeleton.rawBones.forEach(function(rawBone, i2) {
            rawBone.indices.forEach(function(index, j) {
              if (geoInfo.weightTable[index] === void 0)
                geoInfo.weightTable[index] = [];
              geoInfo.weightTable[index].push({
                id: i2,
                weight: rawBone.weights[j]
              });
            });
          });
        }
        return geoInfo;
      },
      genBuffers: function(geoInfo) {
        var buffers = {
          vertex: [],
          normal: [],
          colors: [],
          uvs: [],
          materialIndex: [],
          vertexWeights: [],
          weightsIndices: []
        };
        var polygonIndex = 0;
        var faceLength = 0;
        var displayedWeightsWarning = false;
        var facePositionIndexes = [];
        var faceNormals = [];
        var faceColors = [];
        var faceUVs = [];
        var faceWeights = [];
        var faceWeightIndices = [];
        var scope = this;
        geoInfo.vertexIndices.forEach(function(vertexIndex, polygonVertexIndex) {
          var endOfFace = false;
          if (vertexIndex < 0) {
            vertexIndex = vertexIndex ^ -1;
            endOfFace = true;
          }
          var weightIndices = [];
          var weights = [];
          facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);
          if (geoInfo.color) {
            var data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color);
            faceColors.push(data[0], data[1], data[2]);
          }
          if (geoInfo.skeleton) {
            if (geoInfo.weightTable[vertexIndex] !== void 0) {
              geoInfo.weightTable[vertexIndex].forEach(function(wt2) {
                weights.push(wt2.weight);
                weightIndices.push(wt2.id);
              });
            }
            if (weights.length > 4) {
              if (!displayedWeightsWarning) {
                console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.");
                displayedWeightsWarning = true;
              }
              var wIndex = [0, 0, 0, 0];
              var Weight = [0, 0, 0, 0];
              weights.forEach(function(weight, weightIndex) {
                var currentWeight = weight;
                var currentIndex = weightIndices[weightIndex];
                Weight.forEach(function(comparedWeight, comparedWeightIndex, comparedWeightArray) {
                  if (currentWeight > comparedWeight) {
                    comparedWeightArray[comparedWeightIndex] = currentWeight;
                    currentWeight = comparedWeight;
                    var tmp2 = wIndex[comparedWeightIndex];
                    wIndex[comparedWeightIndex] = currentIndex;
                    currentIndex = tmp2;
                  }
                });
              });
              weightIndices = wIndex;
              weights = Weight;
            }
            while (weights.length < 4) {
              weights.push(0);
              weightIndices.push(0);
            }
            for (var i = 0; i < 4; ++i) {
              faceWeights.push(weights[i]);
              faceWeightIndices.push(weightIndices[i]);
            }
          }
          if (geoInfo.normal) {
            var data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal);
            faceNormals.push(data[0], data[1], data[2]);
          }
          if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
            var materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0];
          }
          if (geoInfo.uv) {
            geoInfo.uv.forEach(function(uv, i2) {
              var data2 = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv);
              if (faceUVs[i2] === void 0) {
                faceUVs[i2] = [];
              }
              faceUVs[i2].push(data2[0]);
              faceUVs[i2].push(data2[1]);
            });
          }
          faceLength++;
          if (endOfFace) {
            scope.genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength);
            polygonIndex++;
            faceLength = 0;
            facePositionIndexes = [];
            faceNormals = [];
            faceColors = [];
            faceUVs = [];
            faceWeights = [];
            faceWeightIndices = [];
          }
        });
        return buffers;
      },
      genFace: function(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {
        for (var i = 2; i < faceLength; i++) {
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 1]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 2]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 1]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 2]]);
          if (geoInfo.skeleton) {
            buffers.vertexWeights.push(faceWeights[0]);
            buffers.vertexWeights.push(faceWeights[1]);
            buffers.vertexWeights.push(faceWeights[2]);
            buffers.vertexWeights.push(faceWeights[3]);
            buffers.vertexWeights.push(faceWeights[(i - 1) * 4]);
            buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 1]);
            buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 2]);
            buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 3]);
            buffers.vertexWeights.push(faceWeights[i * 4]);
            buffers.vertexWeights.push(faceWeights[i * 4 + 1]);
            buffers.vertexWeights.push(faceWeights[i * 4 + 2]);
            buffers.vertexWeights.push(faceWeights[i * 4 + 3]);
            buffers.weightsIndices.push(faceWeightIndices[0]);
            buffers.weightsIndices.push(faceWeightIndices[1]);
            buffers.weightsIndices.push(faceWeightIndices[2]);
            buffers.weightsIndices.push(faceWeightIndices[3]);
            buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4]);
            buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 1]);
            buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 2]);
            buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 3]);
            buffers.weightsIndices.push(faceWeightIndices[i * 4]);
            buffers.weightsIndices.push(faceWeightIndices[i * 4 + 1]);
            buffers.weightsIndices.push(faceWeightIndices[i * 4 + 2]);
            buffers.weightsIndices.push(faceWeightIndices[i * 4 + 3]);
          }
          if (geoInfo.color) {
            buffers.colors.push(faceColors[0]);
            buffers.colors.push(faceColors[1]);
            buffers.colors.push(faceColors[2]);
            buffers.colors.push(faceColors[(i - 1) * 3]);
            buffers.colors.push(faceColors[(i - 1) * 3 + 1]);
            buffers.colors.push(faceColors[(i - 1) * 3 + 2]);
            buffers.colors.push(faceColors[i * 3]);
            buffers.colors.push(faceColors[i * 3 + 1]);
            buffers.colors.push(faceColors[i * 3 + 2]);
          }
          if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
            buffers.materialIndex.push(materialIndex);
            buffers.materialIndex.push(materialIndex);
            buffers.materialIndex.push(materialIndex);
          }
          if (geoInfo.normal) {
            buffers.normal.push(faceNormals[0]);
            buffers.normal.push(faceNormals[1]);
            buffers.normal.push(faceNormals[2]);
            buffers.normal.push(faceNormals[(i - 1) * 3]);
            buffers.normal.push(faceNormals[(i - 1) * 3 + 1]);
            buffers.normal.push(faceNormals[(i - 1) * 3 + 2]);
            buffers.normal.push(faceNormals[i * 3]);
            buffers.normal.push(faceNormals[i * 3 + 1]);
            buffers.normal.push(faceNormals[i * 3 + 2]);
          }
          if (geoInfo.uv) {
            geoInfo.uv.forEach(function(uv, j) {
              if (buffers.uvs[j] === void 0)
                buffers.uvs[j] = [];
              buffers.uvs[j].push(faceUVs[j][0]);
              buffers.uvs[j].push(faceUVs[j][1]);
              buffers.uvs[j].push(faceUVs[j][(i - 1) * 2]);
              buffers.uvs[j].push(faceUVs[j][(i - 1) * 2 + 1]);
              buffers.uvs[j].push(faceUVs[j][i * 2]);
              buffers.uvs[j].push(faceUVs[j][i * 2 + 1]);
            });
          }
        }
      },
      addMorphTargets: function(parentGeo, parentGeoNode, morphTargets, preTransform) {
        if (morphTargets.length === 0)
          return;
        parentGeo.morphTargetsRelative = true;
        parentGeo.morphAttributes.position = [];
        var scope = this;
        morphTargets.forEach(function(morphTarget) {
          morphTarget.rawTargets.forEach(function(rawTarget) {
            var morphGeoNode = fbxTree.Objects.Geometry[rawTarget.geoID];
            if (morphGeoNode !== void 0) {
              scope.genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name);
            }
          });
        });
      },
      genMorphGeometry: function(parentGeo, parentGeoNode, morphGeoNode, preTransform, name) {
        var vertexIndices = parentGeoNode.PolygonVertexIndex !== void 0 ? parentGeoNode.PolygonVertexIndex.a : [];
        var morphPositionsSparse = morphGeoNode.Vertices !== void 0 ? morphGeoNode.Vertices.a : [];
        var indices = morphGeoNode.Indexes !== void 0 ? morphGeoNode.Indexes.a : [];
        var length = parentGeo.attributes.position.count * 3;
        var morphPositions = new Float32Array(length);
        for (var i = 0; i < indices.length; i++) {
          var morphIndex = indices[i] * 3;
          morphPositions[morphIndex] = morphPositionsSparse[i * 3];
          morphPositions[morphIndex + 1] = morphPositionsSparse[i * 3 + 1];
          morphPositions[morphIndex + 2] = morphPositionsSparse[i * 3 + 2];
        }
        var morphGeoInfo = {
          vertexIndices,
          vertexPositions: morphPositions
        };
        var morphBuffers = this.genBuffers(morphGeoInfo);
        var positionAttribute = new Float32BufferAttribute(morphBuffers.vertex, 3);
        positionAttribute.name = name || morphGeoNode.attrName;
        positionAttribute.applyMatrix4(preTransform);
        parentGeo.morphAttributes.position.push(positionAttribute);
      },
      parseNormals: function(NormalNode) {
        var mappingType = NormalNode.MappingInformationType;
        var referenceType = NormalNode.ReferenceInformationType;
        var buffer = NormalNode.Normals.a;
        var indexBuffer = [];
        if (referenceType === "IndexToDirect") {
          if ("NormalIndex" in NormalNode) {
            indexBuffer = NormalNode.NormalIndex.a;
          } else if ("NormalsIndex" in NormalNode) {
            indexBuffer = NormalNode.NormalsIndex.a;
          }
        }
        return {
          dataSize: 3,
          buffer,
          indices: indexBuffer,
          mappingType,
          referenceType
        };
      },
      parseUVs: function(UVNode) {
        var mappingType = UVNode.MappingInformationType;
        var referenceType = UVNode.ReferenceInformationType;
        var buffer = UVNode.UV.a;
        var indexBuffer = [];
        if (referenceType === "IndexToDirect") {
          indexBuffer = UVNode.UVIndex.a;
        }
        return {
          dataSize: 2,
          buffer,
          indices: indexBuffer,
          mappingType,
          referenceType
        };
      },
      parseVertexColors: function(ColorNode) {
        var mappingType = ColorNode.MappingInformationType;
        var referenceType = ColorNode.ReferenceInformationType;
        var buffer = ColorNode.Colors.a;
        var indexBuffer = [];
        if (referenceType === "IndexToDirect") {
          indexBuffer = ColorNode.ColorIndex.a;
        }
        return {
          dataSize: 4,
          buffer,
          indices: indexBuffer,
          mappingType,
          referenceType
        };
      },
      parseMaterialIndices: function(MaterialNode) {
        var mappingType = MaterialNode.MappingInformationType;
        var referenceType = MaterialNode.ReferenceInformationType;
        if (mappingType === "NoMappingInformation") {
          return {
            dataSize: 1,
            buffer: [0],
            indices: [0],
            mappingType: "AllSame",
            referenceType
          };
        }
        var materialIndexBuffer = MaterialNode.Materials.a;
        var materialIndices = [];
        for (var i = 0; i < materialIndexBuffer.length; ++i) {
          materialIndices.push(i);
        }
        return {
          dataSize: 1,
          buffer: materialIndexBuffer,
          indices: materialIndices,
          mappingType,
          referenceType
        };
      },
      parseNurbsGeometry: function(geoNode) {
        if (NURBSCurve === void 0) {
          console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.");
          return new BufferGeometry();
        }
        var order = parseInt(geoNode.Order);
        if (isNaN(order)) {
          console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", geoNode.Order, geoNode.id);
          return new BufferGeometry();
        }
        var degree = order - 1;
        var knots = geoNode.KnotVector.a;
        var controlPoints = [];
        var pointsValues = geoNode.Points.a;
        for (var i = 0, l = pointsValues.length; i < l; i += 4) {
          controlPoints.push(new Vector4().fromArray(pointsValues, i));
        }
        var startKnot, endKnot;
        if (geoNode.Form === "Closed") {
          controlPoints.push(controlPoints[0]);
        } else if (geoNode.Form === "Periodic") {
          startKnot = degree;
          endKnot = knots.length - 1 - startKnot;
          for (var i = 0; i < degree; ++i) {
            controlPoints.push(controlPoints[i]);
          }
        }
        var curve = new NURBSCurve(degree, knots, controlPoints, startKnot, endKnot);
        var vertices = curve.getPoints(controlPoints.length * 7);
        var positions = new Float32Array(vertices.length * 3);
        vertices.forEach(function(vertex, i2) {
          vertex.toArray(positions, i2 * 3);
        });
        var geometry = new BufferGeometry();
        geometry.setAttribute("position", new BufferAttribute(positions, 3));
        return geometry;
      }
    };
    function AnimationParser() {
    }
    AnimationParser.prototype = {
      constructor: AnimationParser,
      parse: function() {
        var animationClips = [];
        var rawClips = this.parseClips();
        if (rawClips !== void 0) {
          for (var key in rawClips) {
            var rawClip = rawClips[key];
            var clip = this.addClip(rawClip);
            animationClips.push(clip);
          }
        }
        return animationClips;
      },
      parseClips: function() {
        if (fbxTree.Objects.AnimationCurve === void 0)
          return void 0;
        var curveNodesMap = this.parseAnimationCurveNodes();
        this.parseAnimationCurves(curveNodesMap);
        var layersMap = this.parseAnimationLayers(curveNodesMap);
        var rawClips = this.parseAnimStacks(layersMap);
        return rawClips;
      },
      parseAnimationCurveNodes: function() {
        var rawCurveNodes = fbxTree.Objects.AnimationCurveNode;
        var curveNodesMap = new Map();
        for (var nodeID in rawCurveNodes) {
          var rawCurveNode = rawCurveNodes[nodeID];
          if (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {
            var curveNode = {
              id: rawCurveNode.id,
              attr: rawCurveNode.attrName,
              curves: {}
            };
            curveNodesMap.set(curveNode.id, curveNode);
          }
        }
        return curveNodesMap;
      },
      parseAnimationCurves: function(curveNodesMap) {
        var rawCurves = fbxTree.Objects.AnimationCurve;
        for (var nodeID in rawCurves) {
          var animationCurve = {
            id: rawCurves[nodeID].id,
            times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),
            values: rawCurves[nodeID].KeyValueFloat.a
          };
          var relationships = connections.get(animationCurve.id);
          if (relationships !== void 0) {
            var animationCurveID = relationships.parents[0].ID;
            var animationCurveRelationship = relationships.parents[0].relationship;
            if (animationCurveRelationship.match(/X/)) {
              curveNodesMap.get(animationCurveID).curves["x"] = animationCurve;
            } else if (animationCurveRelationship.match(/Y/)) {
              curveNodesMap.get(animationCurveID).curves["y"] = animationCurve;
            } else if (animationCurveRelationship.match(/Z/)) {
              curveNodesMap.get(animationCurveID).curves["z"] = animationCurve;
            } else if (animationCurveRelationship.match(/d|DeformPercent/) && curveNodesMap.has(animationCurveID)) {
              curveNodesMap.get(animationCurveID).curves["morph"] = animationCurve;
            }
          }
        }
      },
      parseAnimationLayers: function(curveNodesMap) {
        var rawLayers = fbxTree.Objects.AnimationLayer;
        var layersMap = new Map();
        for (var nodeID in rawLayers) {
          var layerCurveNodes = [];
          var connection = connections.get(parseInt(nodeID));
          if (connection !== void 0) {
            var children = connection.children;
            children.forEach(function(child, i) {
              if (curveNodesMap.has(child.ID)) {
                var curveNode = curveNodesMap.get(child.ID);
                if (curveNode.curves.x !== void 0 || curveNode.curves.y !== void 0 || curveNode.curves.z !== void 0) {
                  if (layerCurveNodes[i] === void 0) {
                    var modelID = connections.get(child.ID).parents.filter(function(parent) {
                      return parent.relationship !== void 0;
                    })[0].ID;
                    if (modelID !== void 0) {
                      var rawModel = fbxTree.Objects.Model[modelID.toString()];
                      if (rawModel === void 0) {
                        console.warn("THREE.FBXLoader: Encountered a unused curve.", child);
                        return;
                      }
                      var node = {
                        modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : "",
                        ID: rawModel.id,
                        initialPosition: [0, 0, 0],
                        initialRotation: [0, 0, 0],
                        initialScale: [1, 1, 1]
                      };
                      sceneGraph.traverse(function(child2) {
                        if (child2.ID === rawModel.id) {
                          node.transform = child2.matrix;
                          if (child2.userData.transformData)
                            node.eulerOrder = child2.userData.transformData.eulerOrder;
                        }
                      });
                      if (!node.transform)
                        node.transform = new Matrix4();
                      if ("PreRotation" in rawModel)
                        node.preRotation = rawModel.PreRotation.value;
                      if ("PostRotation" in rawModel)
                        node.postRotation = rawModel.PostRotation.value;
                      layerCurveNodes[i] = node;
                    }
                  }
                  if (layerCurveNodes[i])
                    layerCurveNodes[i][curveNode.attr] = curveNode;
                } else if (curveNode.curves.morph !== void 0) {
                  if (layerCurveNodes[i] === void 0) {
                    var deformerID = connections.get(child.ID).parents.filter(function(parent) {
                      return parent.relationship !== void 0;
                    })[0].ID;
                    var morpherID = connections.get(deformerID).parents[0].ID;
                    var geoID = connections.get(morpherID).parents[0].ID;
                    var modelID = connections.get(geoID).parents[0].ID;
                    var rawModel = fbxTree.Objects.Model[modelID];
                    var node = {
                      modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : "",
                      morphName: fbxTree.Objects.Deformer[deformerID].attrName
                    };
                    layerCurveNodes[i] = node;
                  }
                  layerCurveNodes[i][curveNode.attr] = curveNode;
                }
              }
            });
            layersMap.set(parseInt(nodeID), layerCurveNodes);
          }
        }
        return layersMap;
      },
      parseAnimStacks: function(layersMap) {
        var rawStacks = fbxTree.Objects.AnimationStack;
        var rawClips = {};
        for (var nodeID in rawStacks) {
          var children = connections.get(parseInt(nodeID)).children;
          if (children.length > 1) {
            console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
          }
          var layer = layersMap.get(children[0].ID);
          rawClips[nodeID] = {
            name: rawStacks[nodeID].attrName,
            layer
          };
        }
        return rawClips;
      },
      addClip: function(rawClip) {
        var tracks = [];
        var scope = this;
        rawClip.layer.forEach(function(rawTracks) {
          tracks = tracks.concat(scope.generateTracks(rawTracks));
        });
        return new AnimationClip(rawClip.name, -1, tracks);
      },
      generateTracks: function(rawTracks) {
        var tracks = [];
        var initialPosition = new Vector3();
        var initialRotation = new Quaternion();
        var initialScale = new Vector3();
        if (rawTracks.transform)
          rawTracks.transform.decompose(initialPosition, initialRotation, initialScale);
        initialPosition = initialPosition.toArray();
        initialRotation = new Euler().setFromQuaternion(initialRotation, rawTracks.eulerOrder).toArray();
        initialScale = initialScale.toArray();
        if (rawTracks.T !== void 0 && Object.keys(rawTracks.T.curves).length > 0) {
          var positionTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.T.curves, initialPosition, "position");
          if (positionTrack !== void 0)
            tracks.push(positionTrack);
        }
        if (rawTracks.R !== void 0 && Object.keys(rawTracks.R.curves).length > 0) {
          var rotationTrack = this.generateRotationTrack(rawTracks.modelName, rawTracks.R.curves, initialRotation, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder);
          if (rotationTrack !== void 0)
            tracks.push(rotationTrack);
        }
        if (rawTracks.S !== void 0 && Object.keys(rawTracks.S.curves).length > 0) {
          var scaleTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, initialScale, "scale");
          if (scaleTrack !== void 0)
            tracks.push(scaleTrack);
        }
        if (rawTracks.DeformPercent !== void 0) {
          var morphTrack = this.generateMorphTrack(rawTracks);
          if (morphTrack !== void 0)
            tracks.push(morphTrack);
        }
        return tracks;
      },
      generateVectorTrack: function(modelName, curves, initialValue, type) {
        var times = this.getTimesForAllAxes(curves);
        var values = this.getKeyframeTrackValues(times, curves, initialValue);
        return new VectorKeyframeTrack(modelName + "." + type, times, values);
      },
      generateRotationTrack: function(modelName, curves, initialValue, preRotation, postRotation, eulerOrder) {
        if (curves.x !== void 0) {
          this.interpolateRotations(curves.x);
          curves.x.values = curves.x.values.map(MathUtils.degToRad);
        }
        if (curves.y !== void 0) {
          this.interpolateRotations(curves.y);
          curves.y.values = curves.y.values.map(MathUtils.degToRad);
        }
        if (curves.z !== void 0) {
          this.interpolateRotations(curves.z);
          curves.z.values = curves.z.values.map(MathUtils.degToRad);
        }
        var times = this.getTimesForAllAxes(curves);
        var values = this.getKeyframeTrackValues(times, curves, initialValue);
        if (preRotation !== void 0) {
          preRotation = preRotation.map(MathUtils.degToRad);
          preRotation.push(eulerOrder);
          preRotation = new Euler().fromArray(preRotation);
          preRotation = new Quaternion().setFromEuler(preRotation);
        }
        if (postRotation !== void 0) {
          postRotation = postRotation.map(MathUtils.degToRad);
          postRotation.push(eulerOrder);
          postRotation = new Euler().fromArray(postRotation);
          postRotation = new Quaternion().setFromEuler(postRotation).invert();
        }
        var quaternion = new Quaternion();
        var euler = new Euler();
        var quaternionValues = [];
        for (var i = 0; i < values.length; i += 3) {
          euler.set(values[i], values[i + 1], values[i + 2], eulerOrder);
          quaternion.setFromEuler(euler);
          if (preRotation !== void 0)
            quaternion.premultiply(preRotation);
          if (postRotation !== void 0)
            quaternion.multiply(postRotation);
          quaternion.toArray(quaternionValues, i / 3 * 4);
        }
        return new QuaternionKeyframeTrack(modelName + ".quaternion", times, quaternionValues);
      },
      generateMorphTrack: function(rawTracks) {
        var curves = rawTracks.DeformPercent.curves.morph;
        var values = curves.values.map(function(val) {
          return val / 100;
        });
        var morphNum = sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName];
        return new NumberKeyframeTrack(rawTracks.modelName + ".morphTargetInfluences[" + morphNum + "]", curves.times, values);
      },
      getTimesForAllAxes: function(curves) {
        var times = [];
        if (curves.x !== void 0)
          times = times.concat(curves.x.times);
        if (curves.y !== void 0)
          times = times.concat(curves.y.times);
        if (curves.z !== void 0)
          times = times.concat(curves.z.times);
        times = times.sort(function(a, b2) {
          return a - b2;
        });
        if (times.length > 1) {
          var targetIndex = 1;
          var lastValue = times[0];
          for (var i = 1; i < times.length; i++) {
            var currentValue = times[i];
            if (currentValue !== lastValue) {
              times[targetIndex] = currentValue;
              lastValue = currentValue;
              targetIndex++;
            }
          }
          times = times.slice(0, targetIndex);
        }
        return times;
      },
      getKeyframeTrackValues: function(times, curves, initialValue) {
        var prevValue = initialValue;
        var values = [];
        var xIndex = -1;
        var yIndex = -1;
        var zIndex = -1;
        times.forEach(function(time) {
          if (curves.x)
            xIndex = curves.x.times.indexOf(time);
          if (curves.y)
            yIndex = curves.y.times.indexOf(time);
          if (curves.z)
            zIndex = curves.z.times.indexOf(time);
          if (xIndex !== -1) {
            var xValue = curves.x.values[xIndex];
            values.push(xValue);
            prevValue[0] = xValue;
          } else {
            values.push(prevValue[0]);
          }
          if (yIndex !== -1) {
            var yValue = curves.y.values[yIndex];
            values.push(yValue);
            prevValue[1] = yValue;
          } else {
            values.push(prevValue[1]);
          }
          if (zIndex !== -1) {
            var zValue = curves.z.values[zIndex];
            values.push(zValue);
            prevValue[2] = zValue;
          } else {
            values.push(prevValue[2]);
          }
        });
        return values;
      },
      interpolateRotations: function(curve) {
        for (var i = 1; i < curve.values.length; i++) {
          var initialValue = curve.values[i - 1];
          var valuesSpan = curve.values[i] - initialValue;
          var absoluteSpan = Math.abs(valuesSpan);
          if (absoluteSpan >= 180) {
            var numSubIntervals = absoluteSpan / 180;
            var step = valuesSpan / numSubIntervals;
            var nextValue = initialValue + step;
            var initialTime = curve.times[i - 1];
            var timeSpan = curve.times[i] - initialTime;
            var interval = timeSpan / numSubIntervals;
            var nextTime = initialTime + interval;
            var interpolatedTimes = [];
            var interpolatedValues = [];
            while (nextTime < curve.times[i]) {
              interpolatedTimes.push(nextTime);
              nextTime += interval;
              interpolatedValues.push(nextValue);
              nextValue += step;
            }
            curve.times = inject(curve.times, i, interpolatedTimes);
            curve.values = inject(curve.values, i, interpolatedValues);
          }
        }
      }
    };
    function TextParser() {
    }
    TextParser.prototype = {
      constructor: TextParser,
      getPrevNode: function() {
        return this.nodeStack[this.currentIndent - 2];
      },
      getCurrentNode: function() {
        return this.nodeStack[this.currentIndent - 1];
      },
      getCurrentProp: function() {
        return this.currentProp;
      },
      pushStack: function(node) {
        this.nodeStack.push(node);
        this.currentIndent += 1;
      },
      popStack: function() {
        this.nodeStack.pop();
        this.currentIndent -= 1;
      },
      setCurrentProp: function(val, name) {
        this.currentProp = val;
        this.currentPropName = name;
      },
      parse: function(text) {
        this.currentIndent = 0;
        this.allNodes = new FBXTree();
        this.nodeStack = [];
        this.currentProp = [];
        this.currentPropName = "";
        var scope = this;
        var split = text.split(/[\r\n]+/);
        split.forEach(function(line, i) {
          var matchComment = line.match(/^[\s\t]*;/);
          var matchEmpty = line.match(/^[\s\t]*$/);
          if (matchComment || matchEmpty)
            return;
          var matchBeginning = line.match("^\\t{" + scope.currentIndent + "}(\\w+):(.*){", "");
          var matchProperty = line.match("^\\t{" + scope.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)");
          var matchEnd = line.match("^\\t{" + (scope.currentIndent - 1) + "}}");
          if (matchBeginning) {
            scope.parseNodeBegin(line, matchBeginning);
          } else if (matchProperty) {
            scope.parseNodeProperty(line, matchProperty, split[++i]);
          } else if (matchEnd) {
            scope.popStack();
          } else if (line.match(/^[^\s\t}]/)) {
            scope.parseNodePropertyContinued(line);
          }
        });
        return this.allNodes;
      },
      parseNodeBegin: function(line, property) {
        var nodeName = property[1].trim().replace(/^"/, "").replace(/"$/, "");
        var nodeAttrs = property[2].split(",").map(function(attr) {
          return attr.trim().replace(/^"/, "").replace(/"$/, "");
        });
        var node = { name: nodeName };
        var attrs = this.parseNodeAttr(nodeAttrs);
        var currentNode = this.getCurrentNode();
        if (this.currentIndent === 0) {
          this.allNodes.add(nodeName, node);
        } else {
          if (nodeName in currentNode) {
            if (nodeName === "PoseNode") {
              currentNode.PoseNode.push(node);
            } else if (currentNode[nodeName].id !== void 0) {
              currentNode[nodeName] = {};
              currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];
            }
            if (attrs.id !== "")
              currentNode[nodeName][attrs.id] = node;
          } else if (typeof attrs.id === "number") {
            currentNode[nodeName] = {};
            currentNode[nodeName][attrs.id] = node;
          } else if (nodeName !== "Properties70") {
            if (nodeName === "PoseNode")
              currentNode[nodeName] = [node];
            else
              currentNode[nodeName] = node;
          }
        }
        if (typeof attrs.id === "number")
          node.id = attrs.id;
        if (attrs.name !== "")
          node.attrName = attrs.name;
        if (attrs.type !== "")
          node.attrType = attrs.type;
        this.pushStack(node);
      },
      parseNodeAttr: function(attrs) {
        var id = attrs[0];
        if (attrs[0] !== "") {
          id = parseInt(attrs[0]);
          if (isNaN(id)) {
            id = attrs[0];
          }
        }
        var name = "", type = "";
        if (attrs.length > 1) {
          name = attrs[1].replace(/^(\w+)::/, "");
          type = attrs[2];
        }
        return { id, name, type };
      },
      parseNodeProperty: function(line, property, contentLine) {
        var propName = property[1].replace(/^"/, "").replace(/"$/, "").trim();
        var propValue = property[2].replace(/^"/, "").replace(/"$/, "").trim();
        if (propName === "Content" && propValue === ",") {
          propValue = contentLine.replace(/"/g, "").replace(/,$/, "").trim();
        }
        var currentNode = this.getCurrentNode();
        var parentName = currentNode.name;
        if (parentName === "Properties70") {
          this.parseNodeSpecialProperty(line, propName, propValue);
          return;
        }
        if (propName === "C") {
          var connProps = propValue.split(",").slice(1);
          var from = parseInt(connProps[0]);
          var to = parseInt(connProps[1]);
          var rest = propValue.split(",").slice(3);
          rest = rest.map(function(elem) {
            return elem.trim().replace(/^"/, "");
          });
          propName = "connections";
          propValue = [from, to];
          append(propValue, rest);
          if (currentNode[propName] === void 0) {
            currentNode[propName] = [];
          }
        }
        if (propName === "Node")
          currentNode.id = propValue;
        if (propName in currentNode && Array.isArray(currentNode[propName])) {
          currentNode[propName].push(propValue);
        } else {
          if (propName !== "a")
            currentNode[propName] = propValue;
          else
            currentNode.a = propValue;
        }
        this.setCurrentProp(currentNode, propName);
        if (propName === "a" && propValue.slice(-1) !== ",") {
          currentNode.a = parseNumberArray(propValue);
        }
      },
      parseNodePropertyContinued: function(line) {
        var currentNode = this.getCurrentNode();
        currentNode.a += line;
        if (line.slice(-1) !== ",") {
          currentNode.a = parseNumberArray(currentNode.a);
        }
      },
      parseNodeSpecialProperty: function(line, propName, propValue) {
        var props = propValue.split('",').map(function(prop) {
          return prop.trim().replace(/^\"/, "").replace(/\s/, "_");
        });
        var innerPropName = props[0];
        var innerPropType1 = props[1];
        var innerPropType2 = props[2];
        var innerPropFlag = props[3];
        var innerPropValue = props[4];
        switch (innerPropType1) {
          case "int":
          case "enum":
          case "bool":
          case "ULongLong":
          case "double":
          case "Number":
          case "FieldOfView":
            innerPropValue = parseFloat(innerPropValue);
            break;
          case "Color":
          case "ColorRGB":
          case "Vector3D":
          case "Lcl_Translation":
          case "Lcl_Rotation":
          case "Lcl_Scaling":
            innerPropValue = parseNumberArray(innerPropValue);
            break;
        }
        this.getPrevNode()[innerPropName] = {
          "type": innerPropType1,
          "type2": innerPropType2,
          "flag": innerPropFlag,
          "value": innerPropValue
        };
        this.setCurrentProp(this.getPrevNode(), innerPropName);
      }
    };
    function BinaryParser() {
    }
    BinaryParser.prototype = {
      constructor: BinaryParser,
      parse: function(buffer) {
        var reader = new BinaryReader(buffer);
        reader.skip(23);
        var version = reader.getUint32();
        if (version < 6400) {
          throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + version);
        }
        var allNodes = new FBXTree();
        while (!this.endOfContent(reader)) {
          var node = this.parseNode(reader, version);
          if (node !== null)
            allNodes.add(node.name, node);
        }
        return allNodes;
      },
      endOfContent: function(reader) {
        if (reader.size() % 16 === 0) {
          return (reader.getOffset() + 160 + 16 & ~15) >= reader.size();
        } else {
          return reader.getOffset() + 160 + 16 >= reader.size();
        }
      },
      parseNode: function(reader, version) {
        var node = {};
        var endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();
        var numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32();
        version >= 7500 ? reader.getUint64() : reader.getUint32();
        var nameLen = reader.getUint8();
        var name = reader.getString(nameLen);
        if (endOffset === 0)
          return null;
        var propertyList = [];
        for (var i = 0; i < numProperties; i++) {
          propertyList.push(this.parseProperty(reader));
        }
        var id = propertyList.length > 0 ? propertyList[0] : "";
        var attrName = propertyList.length > 1 ? propertyList[1] : "";
        var attrType = propertyList.length > 2 ? propertyList[2] : "";
        node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;
        while (endOffset > reader.getOffset()) {
          var subNode = this.parseNode(reader, version);
          if (subNode !== null)
            this.parseSubNode(name, node, subNode);
        }
        node.propertyList = propertyList;
        if (typeof id === "number")
          node.id = id;
        if (attrName !== "")
          node.attrName = attrName;
        if (attrType !== "")
          node.attrType = attrType;
        if (name !== "")
          node.name = name;
        return node;
      },
      parseSubNode: function(name, node, subNode) {
        if (subNode.singleProperty === true) {
          var value = subNode.propertyList[0];
          if (Array.isArray(value)) {
            node[subNode.name] = subNode;
            subNode.a = value;
          } else {
            node[subNode.name] = value;
          }
        } else if (name === "Connections" && subNode.name === "C") {
          var array = [];
          subNode.propertyList.forEach(function(property, i) {
            if (i !== 0)
              array.push(property);
          });
          if (node.connections === void 0) {
            node.connections = [];
          }
          node.connections.push(array);
        } else if (subNode.name === "Properties70") {
          var keys = Object.keys(subNode);
          keys.forEach(function(key) {
            node[key] = subNode[key];
          });
        } else if (name === "Properties70" && subNode.name === "P") {
          var innerPropName = subNode.propertyList[0];
          var innerPropType1 = subNode.propertyList[1];
          var innerPropType2 = subNode.propertyList[2];
          var innerPropFlag = subNode.propertyList[3];
          var innerPropValue;
          if (innerPropName.indexOf("Lcl ") === 0)
            innerPropName = innerPropName.replace("Lcl ", "Lcl_");
          if (innerPropType1.indexOf("Lcl ") === 0)
            innerPropType1 = innerPropType1.replace("Lcl ", "Lcl_");
          if (innerPropType1 === "Color" || innerPropType1 === "ColorRGB" || innerPropType1 === "Vector" || innerPropType1 === "Vector3D" || innerPropType1.indexOf("Lcl_") === 0) {
            innerPropValue = [
              subNode.propertyList[4],
              subNode.propertyList[5],
              subNode.propertyList[6]
            ];
          } else {
            innerPropValue = subNode.propertyList[4];
          }
          node[innerPropName] = {
            "type": innerPropType1,
            "type2": innerPropType2,
            "flag": innerPropFlag,
            "value": innerPropValue
          };
        } else if (node[subNode.name] === void 0) {
          if (typeof subNode.id === "number") {
            node[subNode.name] = {};
            node[subNode.name][subNode.id] = subNode;
          } else {
            node[subNode.name] = subNode;
          }
        } else {
          if (subNode.name === "PoseNode") {
            if (!Array.isArray(node[subNode.name])) {
              node[subNode.name] = [node[subNode.name]];
            }
            node[subNode.name].push(subNode);
          } else if (node[subNode.name][subNode.id] === void 0) {
            node[subNode.name][subNode.id] = subNode;
          }
        }
      },
      parseProperty: function(reader) {
        var type = reader.getString(1);
        switch (type) {
          case "C":
            return reader.getBoolean();
          case "D":
            return reader.getFloat64();
          case "F":
            return reader.getFloat32();
          case "I":
            return reader.getInt32();
          case "L":
            return reader.getInt64();
          case "R":
            var length = reader.getUint32();
            return reader.getArrayBuffer(length);
          case "S":
            var length = reader.getUint32();
            return reader.getString(length);
          case "Y":
            return reader.getInt16();
          case "b":
          case "c":
          case "d":
          case "f":
          case "i":
          case "l":
            var arrayLength = reader.getUint32();
            var encoding = reader.getUint32();
            var compressedLength = reader.getUint32();
            if (encoding === 0) {
              switch (type) {
                case "b":
                case "c":
                  return reader.getBooleanArray(arrayLength);
                case "d":
                  return reader.getFloat64Array(arrayLength);
                case "f":
                  return reader.getFloat32Array(arrayLength);
                case "i":
                  return reader.getInt32Array(arrayLength);
                case "l":
                  return reader.getInt64Array(arrayLength);
              }
            }
            if (typeof fflate_module_min_exports === "undefined") {
              console.error("THREE.FBXLoader: External library fflate.min.js required.");
            }
            var data = Jr(new Uint8Array(reader.getArrayBuffer(compressedLength)));
            var reader2 = new BinaryReader(data.buffer);
            switch (type) {
              case "b":
              case "c":
                return reader2.getBooleanArray(arrayLength);
              case "d":
                return reader2.getFloat64Array(arrayLength);
              case "f":
                return reader2.getFloat32Array(arrayLength);
              case "i":
                return reader2.getInt32Array(arrayLength);
              case "l":
                return reader2.getInt64Array(arrayLength);
            }
          default:
            throw new Error("THREE.FBXLoader: Unknown property type " + type);
        }
      }
    };
    function BinaryReader(buffer, littleEndian) {
      this.dv = new DataView(buffer);
      this.offset = 0;
      this.littleEndian = littleEndian !== void 0 ? littleEndian : true;
    }
    BinaryReader.prototype = {
      constructor: BinaryReader,
      getOffset: function() {
        return this.offset;
      },
      size: function() {
        return this.dv.buffer.byteLength;
      },
      skip: function(length) {
        this.offset += length;
      },
      getBoolean: function() {
        return (this.getUint8() & 1) === 1;
      },
      getBooleanArray: function(size2) {
        var a = [];
        for (var i = 0; i < size2; i++) {
          a.push(this.getBoolean());
        }
        return a;
      },
      getUint8: function() {
        var value = this.dv.getUint8(this.offset);
        this.offset += 1;
        return value;
      },
      getInt16: function() {
        var value = this.dv.getInt16(this.offset, this.littleEndian);
        this.offset += 2;
        return value;
      },
      getInt32: function() {
        var value = this.dv.getInt32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      },
      getInt32Array: function(size2) {
        var a = [];
        for (var i = 0; i < size2; i++) {
          a.push(this.getInt32());
        }
        return a;
      },
      getUint32: function() {
        var value = this.dv.getUint32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      },
      getInt64: function() {
        var low, high;
        if (this.littleEndian) {
          low = this.getUint32();
          high = this.getUint32();
        } else {
          high = this.getUint32();
          low = this.getUint32();
        }
        if (high & 2147483648) {
          high = ~high & 4294967295;
          low = ~low & 4294967295;
          if (low === 4294967295)
            high = high + 1 & 4294967295;
          low = low + 1 & 4294967295;
          return -(high * 4294967296 + low);
        }
        return high * 4294967296 + low;
      },
      getInt64Array: function(size2) {
        var a = [];
        for (var i = 0; i < size2; i++) {
          a.push(this.getInt64());
        }
        return a;
      },
      getUint64: function() {
        var low, high;
        if (this.littleEndian) {
          low = this.getUint32();
          high = this.getUint32();
        } else {
          high = this.getUint32();
          low = this.getUint32();
        }
        return high * 4294967296 + low;
      },
      getFloat32: function() {
        var value = this.dv.getFloat32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      },
      getFloat32Array: function(size2) {
        var a = [];
        for (var i = 0; i < size2; i++) {
          a.push(this.getFloat32());
        }
        return a;
      },
      getFloat64: function() {
        var value = this.dv.getFloat64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
      },
      getFloat64Array: function(size2) {
        var a = [];
        for (var i = 0; i < size2; i++) {
          a.push(this.getFloat64());
        }
        return a;
      },
      getArrayBuffer: function(size2) {
        var value = this.dv.buffer.slice(this.offset, this.offset + size2);
        this.offset += size2;
        return value;
      },
      getString: function(size2) {
        var a = [];
        for (var i = 0; i < size2; i++) {
          a[i] = this.getUint8();
        }
        var nullByte = a.indexOf(0);
        if (nullByte >= 0)
          a = a.slice(0, nullByte);
        return LoaderUtils.decodeText(new Uint8Array(a));
      }
    };
    function FBXTree() {
    }
    FBXTree.prototype = {
      constructor: FBXTree,
      add: function(key, val) {
        this[key] = val;
      }
    };
    function isFbxFormatBinary(buffer) {
      var CORRECT = "Kaydara FBX Binary  \0";
      return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length);
    }
    function isFbxFormatASCII(text) {
      var CORRECT = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
      var cursor = 0;
      function read(offset) {
        var result = text[offset - 1];
        text = text.slice(cursor + offset);
        cursor++;
        return result;
      }
      for (var i = 0; i < CORRECT.length; ++i) {
        var num = read(1);
        if (num === CORRECT[i]) {
          return false;
        }
      }
      return true;
    }
    function getFbxVersion(text) {
      var versionRegExp = /FBXVersion: (\d+)/;
      var match = text.match(versionRegExp);
      if (match) {
        var version = parseInt(match[1]);
        return version;
      }
      throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
    }
    function convertFBXTimeToSeconds(time) {
      return time / 46186158e3;
    }
    var dataArray = [];
    function getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {
      var index;
      switch (infoObject.mappingType) {
        case "ByPolygonVertex":
          index = polygonVertexIndex;
          break;
        case "ByPolygon":
          index = polygonIndex;
          break;
        case "ByVertice":
          index = vertexIndex;
          break;
        case "AllSame":
          index = infoObject.indices[0];
          break;
        default:
          console.warn("THREE.FBXLoader: unknown attribute mapping type " + infoObject.mappingType);
      }
      if (infoObject.referenceType === "IndexToDirect")
        index = infoObject.indices[index];
      var from = index * infoObject.dataSize;
      var to = from + infoObject.dataSize;
      return slice(dataArray, infoObject.buffer, from, to);
    }
    var tempEuler = new Euler();
    var tempVec = new Vector3();
    function generateTransform(transformData) {
      var lTranslationM = new Matrix4();
      var lPreRotationM = new Matrix4();
      var lRotationM = new Matrix4();
      var lPostRotationM = new Matrix4();
      var lScalingM = new Matrix4();
      var lScalingPivotM = new Matrix4();
      var lScalingOffsetM = new Matrix4();
      var lRotationOffsetM = new Matrix4();
      var lRotationPivotM = new Matrix4();
      var lParentGX = new Matrix4();
      var lParentLX = new Matrix4();
      var lGlobalT = new Matrix4();
      var inheritType = transformData.inheritType ? transformData.inheritType : 0;
      if (transformData.translation)
        lTranslationM.setPosition(tempVec.fromArray(transformData.translation));
      if (transformData.preRotation) {
        var array = transformData.preRotation.map(MathUtils.degToRad);
        array.push(transformData.eulerOrder);
        lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
      }
      if (transformData.rotation) {
        var array = transformData.rotation.map(MathUtils.degToRad);
        array.push(transformData.eulerOrder);
        lRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
      }
      if (transformData.postRotation) {
        var array = transformData.postRotation.map(MathUtils.degToRad);
        array.push(transformData.eulerOrder);
        lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
        lPostRotationM.invert();
      }
      if (transformData.scale)
        lScalingM.scale(tempVec.fromArray(transformData.scale));
      if (transformData.scalingOffset)
        lScalingOffsetM.setPosition(tempVec.fromArray(transformData.scalingOffset));
      if (transformData.scalingPivot)
        lScalingPivotM.setPosition(tempVec.fromArray(transformData.scalingPivot));
      if (transformData.rotationOffset)
        lRotationOffsetM.setPosition(tempVec.fromArray(transformData.rotationOffset));
      if (transformData.rotationPivot)
        lRotationPivotM.setPosition(tempVec.fromArray(transformData.rotationPivot));
      if (transformData.parentMatrixWorld) {
        lParentLX.copy(transformData.parentMatrix);
        lParentGX.copy(transformData.parentMatrixWorld);
      }
      var lLRM = new Matrix4().copy(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM);
      var lParentGRM = new Matrix4();
      lParentGRM.extractRotation(lParentGX);
      var lParentTM = new Matrix4();
      lParentTM.copyPosition(lParentGX);
      var lParentGSM = new Matrix4();
      var lParentGRSM = new Matrix4().copy(lParentTM).invert().multiply(lParentGX);
      lParentGSM.copy(lParentGRM).invert().multiply(lParentGRSM);
      var lLSM = lScalingM;
      var lGlobalRS = new Matrix4();
      if (inheritType === 0) {
        lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM);
      } else if (inheritType === 1) {
        lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM);
      } else {
        var lParentLSM = new Matrix4().scale(new Vector3().setFromMatrixScale(lParentLX));
        var lParentLSM_inv = new Matrix4().copy(lParentLSM).invert();
        var lParentGSM_noLocal = new Matrix4().copy(lParentGSM).multiply(lParentLSM_inv);
        lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM);
      }
      var lRotationPivotM_inv = new Matrix4();
      lRotationPivotM_inv.copy(lRotationPivotM).invert();
      var lScalingPivotM_inv = new Matrix4();
      lScalingPivotM_inv.copy(lScalingPivotM).invert();
      var lTransform = new Matrix4();
      lTransform.copy(lTranslationM).multiply(lRotationOffsetM).multiply(lRotationPivotM).multiply(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM).multiply(lRotationPivotM_inv).multiply(lScalingOffsetM).multiply(lScalingPivotM).multiply(lScalingM).multiply(lScalingPivotM_inv);
      var lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition(lTransform);
      var lGlobalTranslation = new Matrix4().copy(lParentGX).multiply(lLocalTWithAllPivotAndOffsetInfo);
      lGlobalT.copyPosition(lGlobalTranslation);
      lTransform = new Matrix4().copy(lGlobalT).multiply(lGlobalRS);
      lTransform.premultiply(lParentGX.invert());
      return lTransform;
    }
    function getEulerOrder(order) {
      order = order || 0;
      var enums = [
        "ZYX",
        "YZX",
        "XZY",
        "ZXY",
        "YXZ",
        "XYZ"
      ];
      if (order === 6) {
        console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.");
        return enums[0];
      }
      return enums[order];
    }
    function parseNumberArray(value) {
      var array = value.split(",").map(function(val) {
        return parseFloat(val);
      });
      return array;
    }
    function convertArrayBufferToString(buffer, from, to) {
      if (from === void 0)
        from = 0;
      if (to === void 0)
        to = buffer.byteLength;
      return LoaderUtils.decodeText(new Uint8Array(buffer, from, to));
    }
    function append(a, b2) {
      for (var i = 0, j = a.length, l = b2.length; i < l; i++, j++) {
        a[j] = b2[i];
      }
    }
    function slice(a, b2, from, to) {
      for (var i = from, j = 0; i < to; i++, j++) {
        a[j] = b2[i];
      }
      return a;
    }
    function inject(a1, index, a2) {
      return a1.slice(0, index).concat(a2).concat(a1.slice(index));
    }
    return FBXLoader2;
  }();

  // node_modules/three/examples/jsm/loaders/GLTFLoader.js
  var GLTFLoader = function() {
    function GLTFLoader2(manager) {
      Loader.call(this, manager);
      this.dracoLoader = null;
      this.ktx2Loader = null;
      this.meshoptDecoder = null;
      this.pluginCallbacks = [];
      this.register(function(parser) {
        return new GLTFMaterialsClearcoatExtension(parser);
      });
      this.register(function(parser) {
        return new GLTFTextureBasisUExtension(parser);
      });
      this.register(function(parser) {
        return new GLTFTextureWebPExtension(parser);
      });
      this.register(function(parser) {
        return new GLTFMaterialsTransmissionExtension(parser);
      });
      this.register(function(parser) {
        return new GLTFLightsExtension(parser);
      });
      this.register(function(parser) {
        return new GLTFMeshoptCompression(parser);
      });
    }
    GLTFLoader2.prototype = Object.assign(Object.create(Loader.prototype), {
      constructor: GLTFLoader2,
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var resourcePath;
        if (this.resourcePath !== "") {
          resourcePath = this.resourcePath;
        } else if (this.path !== "") {
          resourcePath = this.path;
        } else {
          resourcePath = LoaderUtils.extractUrlBase(url);
        }
        this.manager.itemStart(url);
        var _onError = function(e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        };
        var loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function(data) {
          try {
            scope.parse(data, resourcePath, function(gltf) {
              onLoad(gltf);
              scope.manager.itemEnd(url);
            }, _onError);
          } catch (e) {
            _onError(e);
          }
        }, onProgress, _onError);
      },
      setDRACOLoader: function(dracoLoader) {
        this.dracoLoader = dracoLoader;
        return this;
      },
      setDDSLoader: function() {
        throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
      },
      setKTX2Loader: function(ktx2Loader) {
        this.ktx2Loader = ktx2Loader;
        return this;
      },
      setMeshoptDecoder: function(meshoptDecoder) {
        this.meshoptDecoder = meshoptDecoder;
        return this;
      },
      register: function(callback) {
        if (this.pluginCallbacks.indexOf(callback) === -1) {
          this.pluginCallbacks.push(callback);
        }
        return this;
      },
      unregister: function(callback) {
        if (this.pluginCallbacks.indexOf(callback) !== -1) {
          this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
        }
        return this;
      },
      parse: function(data, path, onLoad, onError) {
        var content;
        var extensions = {};
        var plugins = {};
        if (typeof data === "string") {
          content = data;
        } else {
          var magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));
          if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
            try {
              extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
            } catch (error) {
              if (onError)
                onError(error);
              return;
            }
            content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;
          } else {
            content = LoaderUtils.decodeText(new Uint8Array(data));
          }
        }
        var json = JSON.parse(content);
        if (json.asset === void 0 || json.asset.version[0] < 2) {
          if (onError)
            onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
          return;
        }
        var parser = new GLTFParser(json, {
          path: path || this.resourcePath || "",
          crossOrigin: this.crossOrigin,
          requestHeader: this.requestHeader,
          manager: this.manager,
          ktx2Loader: this.ktx2Loader,
          meshoptDecoder: this.meshoptDecoder
        });
        parser.fileLoader.setRequestHeader(this.requestHeader);
        for (var i = 0; i < this.pluginCallbacks.length; i++) {
          var plugin = this.pluginCallbacks[i](parser);
          plugins[plugin.name] = plugin;
          extensions[plugin.name] = true;
        }
        if (json.extensionsUsed) {
          for (var i = 0; i < json.extensionsUsed.length; ++i) {
            var extensionName = json.extensionsUsed[i];
            var extensionsRequired = json.extensionsRequired || [];
            switch (extensionName) {
              case EXTENSIONS.KHR_MATERIALS_UNLIT:
                extensions[extensionName] = new GLTFMaterialsUnlitExtension();
                break;
              case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();
                break;
              case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
                extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
                break;
              case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
                extensions[extensionName] = new GLTFTextureTransformExtension();
                break;
              case EXTENSIONS.KHR_MESH_QUANTIZATION:
                extensions[extensionName] = new GLTFMeshQuantizationExtension();
                break;
              default:
                if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {
                  console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
                }
            }
          }
        }
        parser.setExtensions(extensions);
        parser.setPlugins(plugins);
        parser.parse(onLoad, onError);
      }
    });
    function GLTFRegistry() {
      var objects = {};
      return {
        get: function(key) {
          return objects[key];
        },
        add: function(key, object) {
          objects[key] = object;
        },
        remove: function(key) {
          delete objects[key];
        },
        removeAll: function() {
          objects = {};
        }
      };
    }
    var EXTENSIONS = {
      KHR_BINARY_GLTF: "KHR_binary_glTF",
      KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
      KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
      KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
      KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
      KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
      KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
      KHR_TEXTURE_BASISU: "KHR_texture_basisu",
      KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
      KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
      EXT_TEXTURE_WEBP: "EXT_texture_webp",
      EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
    };
    function GLTFLightsExtension(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
      this.cache = { refs: {}, uses: {} };
    }
    GLTFLightsExtension.prototype._markDefs = function() {
      var parser = this.parser;
      var nodeDefs = this.parser.json.nodes || [];
      for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
        var nodeDef = nodeDefs[nodeIndex];
        if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {
          parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
        }
      }
    };
    GLTFLightsExtension.prototype._loadLight = function(lightIndex) {
      var parser = this.parser;
      var cacheKey = "light:" + lightIndex;
      var dependency = parser.cache.get(cacheKey);
      if (dependency)
        return dependency;
      var json = parser.json;
      var extensions = json.extensions && json.extensions[this.name] || {};
      var lightDefs = extensions.lights || [];
      var lightDef = lightDefs[lightIndex];
      var lightNode;
      var color = new Color(16777215);
      if (lightDef.color !== void 0)
        color.fromArray(lightDef.color);
      var range = lightDef.range !== void 0 ? lightDef.range : 0;
      switch (lightDef.type) {
        case "directional":
          lightNode = new DirectionalLight(color);
          lightNode.target.position.set(0, 0, -1);
          lightNode.add(lightNode.target);
          break;
        case "point":
          lightNode = new PointLight(color);
          lightNode.distance = range;
          break;
        case "spot":
          lightNode = new SpotLight(color);
          lightNode.distance = range;
          lightDef.spot = lightDef.spot || {};
          lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;
          lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;
          lightNode.angle = lightDef.spot.outerConeAngle;
          lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
          lightNode.target.position.set(0, 0, -1);
          lightNode.add(lightNode.target);
          break;
        default:
          throw new Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type);
      }
      lightNode.position.set(0, 0, 0);
      lightNode.decay = 2;
      if (lightDef.intensity !== void 0)
        lightNode.intensity = lightDef.intensity;
      lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex);
      dependency = Promise.resolve(lightNode);
      parser.cache.add(cacheKey, dependency);
      return dependency;
    };
    GLTFLightsExtension.prototype.createNodeAttachment = function(nodeIndex) {
      var self2 = this;
      var parser = this.parser;
      var json = parser.json;
      var nodeDef = json.nodes[nodeIndex];
      var lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
      var lightIndex = lightDef.light;
      if (lightIndex === void 0)
        return null;
      return this._loadLight(lightIndex).then(function(light) {
        return parser._getNodeRef(self2.cache, lightIndex, light);
      });
    };
    function GLTFMaterialsUnlitExtension() {
      this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
    }
    GLTFMaterialsUnlitExtension.prototype.getMaterialType = function() {
      return MeshBasicMaterial;
    };
    GLTFMaterialsUnlitExtension.prototype.extendParams = function(materialParams, materialDef, parser) {
      var pending = [];
      materialParams.color = new Color(1, 1, 1);
      materialParams.opacity = 1;
      var metallicRoughness = materialDef.pbrMetallicRoughness;
      if (metallicRoughness) {
        if (Array.isArray(metallicRoughness.baseColorFactor)) {
          var array = metallicRoughness.baseColorFactor;
          materialParams.color.fromArray(array);
          materialParams.opacity = array[3];
        }
        if (metallicRoughness.baseColorTexture !== void 0) {
          pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture));
        }
      }
      return Promise.all(pending);
    };
    function GLTFMaterialsClearcoatExtension(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
    }
    GLTFMaterialsClearcoatExtension.prototype.getMaterialType = function(materialIndex) {
      var parser = this.parser;
      var materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name])
        return null;
      return MeshPhysicalMaterial;
    };
    GLTFMaterialsClearcoatExtension.prototype.extendMaterialParams = function(materialIndex, materialParams) {
      var parser = this.parser;
      var materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }
      var pending = [];
      var extension = materialDef.extensions[this.name];
      if (extension.clearcoatFactor !== void 0) {
        materialParams.clearcoat = extension.clearcoatFactor;
      }
      if (extension.clearcoatTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture));
      }
      if (extension.clearcoatRoughnessFactor !== void 0) {
        materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
      }
      if (extension.clearcoatRoughnessTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture));
      }
      if (extension.clearcoatNormalTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture));
        if (extension.clearcoatNormalTexture.scale !== void 0) {
          var scale = extension.clearcoatNormalTexture.scale;
          materialParams.clearcoatNormalScale = new Vector2(scale, -scale);
        }
      }
      return Promise.all(pending);
    };
    function GLTFMaterialsTransmissionExtension(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
    }
    GLTFMaterialsTransmissionExtension.prototype.getMaterialType = function(materialIndex) {
      var parser = this.parser;
      var materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name])
        return null;
      return MeshPhysicalMaterial;
    };
    GLTFMaterialsTransmissionExtension.prototype.extendMaterialParams = function(materialIndex, materialParams) {
      var parser = this.parser;
      var materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }
      var pending = [];
      var extension = materialDef.extensions[this.name];
      if (extension.transmissionFactor !== void 0) {
        materialParams.transmission = extension.transmissionFactor;
      }
      if (extension.transmissionTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture));
      }
      return Promise.all(pending);
    };
    function GLTFTextureBasisUExtension(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
    }
    GLTFTextureBasisUExtension.prototype.loadTexture = function(textureIndex) {
      var parser = this.parser;
      var json = parser.json;
      var textureDef = json.textures[textureIndex];
      if (!textureDef.extensions || !textureDef.extensions[this.name]) {
        return null;
      }
      var extension = textureDef.extensions[this.name];
      var source = json.images[extension.source];
      var loader = parser.options.ktx2Loader;
      if (!loader) {
        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
          throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
        } else {
          return null;
        }
      }
      return parser.loadTextureImage(textureIndex, source, loader);
    };
    function GLTFTextureWebPExtension(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
      this.isSupported = null;
    }
    GLTFTextureWebPExtension.prototype.loadTexture = function(textureIndex) {
      var name = this.name;
      var parser = this.parser;
      var json = parser.json;
      var textureDef = json.textures[textureIndex];
      if (!textureDef.extensions || !textureDef.extensions[name]) {
        return null;
      }
      var extension = textureDef.extensions[name];
      var source = json.images[extension.source];
      var loader = parser.textureLoader;
      if (source.uri) {
        var handler = parser.options.manager.getHandler(source.uri);
        if (handler !== null)
          loader = handler;
      }
      return this.detectSupport().then(function(isSupported) {
        if (isSupported)
          return parser.loadTextureImage(textureIndex, source, loader);
        if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
          throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
        }
        return parser.loadTexture(textureIndex);
      });
    };
    GLTFTextureWebPExtension.prototype.detectSupport = function() {
      if (!this.isSupported) {
        this.isSupported = new Promise(function(resolve) {
          var image = new Image();
          image.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
          image.onload = image.onerror = function() {
            resolve(image.height === 1);
          };
        });
      }
      return this.isSupported;
    };
    function GLTFMeshoptCompression(parser) {
      this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
      this.parser = parser;
    }
    GLTFMeshoptCompression.prototype.loadBufferView = function(index) {
      var json = this.parser.json;
      var bufferView = json.bufferViews[index];
      if (bufferView.extensions && bufferView.extensions[this.name]) {
        var extensionDef = bufferView.extensions[this.name];
        var buffer = this.parser.getDependency("buffer", extensionDef.buffer);
        var decoder = this.parser.options.meshoptDecoder;
        if (!decoder || !decoder.supported) {
          if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
            throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
          } else {
            return null;
          }
        }
        return Promise.all([buffer, decoder.ready]).then(function(res) {
          var byteOffset = extensionDef.byteOffset || 0;
          var byteLength = extensionDef.byteLength || 0;
          var count = extensionDef.count;
          var stride = extensionDef.byteStride;
          var result = new ArrayBuffer(count * stride);
          var source = new Uint8Array(res[0], byteOffset, byteLength);
          decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
          return result;
        });
      } else {
        return null;
      }
    };
    var BINARY_EXTENSION_HEADER_MAGIC = "glTF";
    var BINARY_EXTENSION_HEADER_LENGTH = 12;
    var BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
    function GLTFBinaryExtension(data) {
      this.name = EXTENSIONS.KHR_BINARY_GLTF;
      this.content = null;
      this.body = null;
      var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
      this.header = {
        magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
        version: headerView.getUint32(4, true),
        length: headerView.getUint32(8, true)
      };
      if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
        throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
      } else if (this.header.version < 2) {
        throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
      }
      var chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
      var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
      var chunkIndex = 0;
      while (chunkIndex < chunkContentsLength) {
        var chunkLength = chunkView.getUint32(chunkIndex, true);
        chunkIndex += 4;
        var chunkType = chunkView.getUint32(chunkIndex, true);
        chunkIndex += 4;
        if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
          var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
          this.content = LoaderUtils.decodeText(contentArray);
        } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
          var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
          this.body = data.slice(byteOffset, byteOffset + chunkLength);
        }
        chunkIndex += chunkLength;
      }
      if (this.content === null) {
        throw new Error("THREE.GLTFLoader: JSON content not found.");
      }
    }
    function GLTFDracoMeshCompressionExtension(json, dracoLoader) {
      if (!dracoLoader) {
        throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
      }
      this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
      this.json = json;
      this.dracoLoader = dracoLoader;
      this.dracoLoader.preload();
    }
    GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function(primitive, parser) {
      var json = this.json;
      var dracoLoader = this.dracoLoader;
      var bufferViewIndex = primitive.extensions[this.name].bufferView;
      var gltfAttributeMap = primitive.extensions[this.name].attributes;
      var threeAttributeMap = {};
      var attributeNormalizedMap = {};
      var attributeTypeMap = {};
      for (var attributeName in gltfAttributeMap) {
        var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
        threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
      }
      for (attributeName in primitive.attributes) {
        var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
        if (gltfAttributeMap[attributeName] !== void 0) {
          var accessorDef = json.accessors[primitive.attributes[attributeName]];
          var componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
          attributeTypeMap[threeAttributeName] = componentType;
          attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
        }
      }
      return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
        return new Promise(function(resolve) {
          dracoLoader.decodeDracoFile(bufferView, function(geometry) {
            for (var attributeName2 in geometry.attributes) {
              var attribute = geometry.attributes[attributeName2];
              var normalized = attributeNormalizedMap[attributeName2];
              if (normalized !== void 0)
                attribute.normalized = normalized;
            }
            resolve(geometry);
          }, threeAttributeMap, attributeTypeMap);
        });
      });
    };
    function GLTFTextureTransformExtension() {
      this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
    }
    GLTFTextureTransformExtension.prototype.extendTexture = function(texture, transform) {
      texture = texture.clone();
      if (transform.offset !== void 0) {
        texture.offset.fromArray(transform.offset);
      }
      if (transform.rotation !== void 0) {
        texture.rotation = transform.rotation;
      }
      if (transform.scale !== void 0) {
        texture.repeat.fromArray(transform.scale);
      }
      if (transform.texCoord !== void 0) {
        console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.');
      }
      texture.needsUpdate = true;
      return texture;
    };
    function GLTFMeshStandardSGMaterial(params) {
      MeshStandardMaterial.call(this);
      this.isGLTFSpecularGlossinessMaterial = true;
      var specularMapParsFragmentChunk = [
        "#ifdef USE_SPECULARMAP",
        "	uniform sampler2D specularMap;",
        "#endif"
      ].join("\n");
      var glossinessMapParsFragmentChunk = [
        "#ifdef USE_GLOSSINESSMAP",
        "	uniform sampler2D glossinessMap;",
        "#endif"
      ].join("\n");
      var specularMapFragmentChunk = [
        "vec3 specularFactor = specular;",
        "#ifdef USE_SPECULARMAP",
        "	vec4 texelSpecular = texture2D( specularMap, vUv );",
        "	texelSpecular = sRGBToLinear( texelSpecular );",
        "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
        "	specularFactor *= texelSpecular.rgb;",
        "#endif"
      ].join("\n");
      var glossinessMapFragmentChunk = [
        "float glossinessFactor = glossiness;",
        "#ifdef USE_GLOSSINESSMAP",
        "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );",
        "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
        "	glossinessFactor *= texelGlossiness.a;",
        "#endif"
      ].join("\n");
      var lightPhysicalFragmentChunk = [
        "PhysicalMaterial material;",
        "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
        "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
        "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
        "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
        "material.specularRoughness += geometryRoughness;",
        "material.specularRoughness = min( material.specularRoughness, 1.0 );",
        "material.specularColor = specularFactor;"
      ].join("\n");
      var uniforms = {
        specular: { value: new Color().setHex(16777215) },
        glossiness: { value: 1 },
        specularMap: { value: null },
        glossinessMap: { value: null }
      };
      this._extraUniforms = uniforms;
      this.onBeforeCompile = function(shader) {
        for (var uniformName in uniforms) {
          shader.uniforms[uniformName] = uniforms[uniformName];
        }
        shader.fragmentShader = shader.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", specularMapParsFragmentChunk).replace("#include <metalnessmap_pars_fragment>", glossinessMapParsFragmentChunk).replace("#include <roughnessmap_fragment>", specularMapFragmentChunk).replace("#include <metalnessmap_fragment>", glossinessMapFragmentChunk).replace("#include <lights_physical_fragment>", lightPhysicalFragmentChunk);
      };
      Object.defineProperties(this, {
        specular: {
          get: function() {
            return uniforms.specular.value;
          },
          set: function(v) {
            uniforms.specular.value = v;
          }
        },
        specularMap: {
          get: function() {
            return uniforms.specularMap.value;
          },
          set: function(v) {
            uniforms.specularMap.value = v;
            if (v) {
              this.defines.USE_SPECULARMAP = "";
            } else {
              delete this.defines.USE_SPECULARMAP;
            }
          }
        },
        glossiness: {
          get: function() {
            return uniforms.glossiness.value;
          },
          set: function(v) {
            uniforms.glossiness.value = v;
          }
        },
        glossinessMap: {
          get: function() {
            return uniforms.glossinessMap.value;
          },
          set: function(v) {
            uniforms.glossinessMap.value = v;
            if (v) {
              this.defines.USE_GLOSSINESSMAP = "";
              this.defines.USE_UV = "";
            } else {
              delete this.defines.USE_GLOSSINESSMAP;
              delete this.defines.USE_UV;
            }
          }
        }
      });
      delete this.metalness;
      delete this.roughness;
      delete this.metalnessMap;
      delete this.roughnessMap;
      this.setValues(params);
    }
    GLTFMeshStandardSGMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
    GLTFMeshStandardSGMaterial.prototype.constructor = GLTFMeshStandardSGMaterial;
    GLTFMeshStandardSGMaterial.prototype.copy = function(source) {
      MeshStandardMaterial.prototype.copy.call(this, source);
      this.specularMap = source.specularMap;
      this.specular.copy(source.specular);
      this.glossinessMap = source.glossinessMap;
      this.glossiness = source.glossiness;
      delete this.metalness;
      delete this.roughness;
      delete this.metalnessMap;
      delete this.roughnessMap;
      return this;
    };
    function GLTFMaterialsPbrSpecularGlossinessExtension() {
      return {
        name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
        specularGlossinessParams: [
          "color",
          "map",
          "lightMap",
          "lightMapIntensity",
          "aoMap",
          "aoMapIntensity",
          "emissive",
          "emissiveIntensity",
          "emissiveMap",
          "bumpMap",
          "bumpScale",
          "normalMap",
          "normalMapType",
          "displacementMap",
          "displacementScale",
          "displacementBias",
          "specularMap",
          "specular",
          "glossinessMap",
          "glossiness",
          "alphaMap",
          "envMap",
          "envMapIntensity",
          "refractionRatio"
        ],
        getMaterialType: function() {
          return GLTFMeshStandardSGMaterial;
        },
        extendParams: function(materialParams, materialDef, parser) {
          var pbrSpecularGlossiness = materialDef.extensions[this.name];
          materialParams.color = new Color(1, 1, 1);
          materialParams.opacity = 1;
          var pending = [];
          if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {
            var array = pbrSpecularGlossiness.diffuseFactor;
            materialParams.color.fromArray(array);
            materialParams.opacity = array[3];
          }
          if (pbrSpecularGlossiness.diffuseTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "map", pbrSpecularGlossiness.diffuseTexture));
          }
          materialParams.emissive = new Color(0, 0, 0);
          materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== void 0 ? pbrSpecularGlossiness.glossinessFactor : 1;
          materialParams.specular = new Color(1, 1, 1);
          if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {
            materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);
          }
          if (pbrSpecularGlossiness.specularGlossinessTexture !== void 0) {
            var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
            pending.push(parser.assignTexture(materialParams, "glossinessMap", specGlossMapDef));
            pending.push(parser.assignTexture(materialParams, "specularMap", specGlossMapDef));
          }
          return Promise.all(pending);
        },
        createMaterial: function(materialParams) {
          var material = new GLTFMeshStandardSGMaterial(materialParams);
          material.fog = true;
          material.color = materialParams.color;
          material.map = materialParams.map === void 0 ? null : materialParams.map;
          material.lightMap = null;
          material.lightMapIntensity = 1;
          material.aoMap = materialParams.aoMap === void 0 ? null : materialParams.aoMap;
          material.aoMapIntensity = 1;
          material.emissive = materialParams.emissive;
          material.emissiveIntensity = 1;
          material.emissiveMap = materialParams.emissiveMap === void 0 ? null : materialParams.emissiveMap;
          material.bumpMap = materialParams.bumpMap === void 0 ? null : materialParams.bumpMap;
          material.bumpScale = 1;
          material.normalMap = materialParams.normalMap === void 0 ? null : materialParams.normalMap;
          material.normalMapType = TangentSpaceNormalMap;
          if (materialParams.normalScale)
            material.normalScale = materialParams.normalScale;
          material.displacementMap = null;
          material.displacementScale = 1;
          material.displacementBias = 0;
          material.specularMap = materialParams.specularMap === void 0 ? null : materialParams.specularMap;
          material.specular = materialParams.specular;
          material.glossinessMap = materialParams.glossinessMap === void 0 ? null : materialParams.glossinessMap;
          material.glossiness = materialParams.glossiness;
          material.alphaMap = null;
          material.envMap = materialParams.envMap === void 0 ? null : materialParams.envMap;
          material.envMapIntensity = 1;
          material.refractionRatio = 0.98;
          return material;
        }
      };
    }
    function GLTFMeshQuantizationExtension() {
      this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
    }
    function GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    GLTFCubicSplineInterpolant.prototype = Object.create(Interpolant.prototype);
    GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;
    GLTFCubicSplineInterpolant.prototype.copySampleValue_ = function(index) {
      var result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;
      for (var i = 0; i !== valueSize; i++) {
        result[i] = values[offset + i];
      }
      return result;
    };
    GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
    GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
    GLTFCubicSplineInterpolant.prototype.interpolate_ = function(i1, t0, t, t1) {
      var result = this.resultBuffer;
      var values = this.sampleValues;
      var stride = this.valueSize;
      var stride2 = stride * 2;
      var stride3 = stride * 3;
      var td = t1 - t0;
      var p = (t - t0) / td;
      var pp = p * p;
      var ppp = pp * p;
      var offset1 = i1 * stride3;
      var offset0 = offset1 - stride3;
      var s2 = -2 * ppp + 3 * pp;
      var s3 = ppp - pp;
      var s0 = 1 - s2;
      var s1 = s3 - pp + p;
      for (var i = 0; i !== stride; i++) {
        var p0 = values[offset0 + i + stride];
        var m0 = values[offset0 + i + stride2] * td;
        var p1 = values[offset1 + i + stride];
        var m1 = values[offset1 + i] * td;
        result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
      }
      return result;
    };
    var WEBGL_CONSTANTS = {
      FLOAT: 5126,
      FLOAT_MAT3: 35675,
      FLOAT_MAT4: 35676,
      FLOAT_VEC2: 35664,
      FLOAT_VEC3: 35665,
      FLOAT_VEC4: 35666,
      LINEAR: 9729,
      REPEAT: 10497,
      SAMPLER_2D: 35678,
      POINTS: 0,
      LINES: 1,
      LINE_LOOP: 2,
      LINE_STRIP: 3,
      TRIANGLES: 4,
      TRIANGLE_STRIP: 5,
      TRIANGLE_FAN: 6,
      UNSIGNED_BYTE: 5121,
      UNSIGNED_SHORT: 5123
    };
    var WEBGL_COMPONENT_TYPES = {
      5120: Int8Array,
      5121: Uint8Array,
      5122: Int16Array,
      5123: Uint16Array,
      5125: Uint32Array,
      5126: Float32Array
    };
    var WEBGL_FILTERS = {
      9728: NearestFilter,
      9729: LinearFilter,
      9984: NearestMipmapNearestFilter,
      9985: LinearMipmapNearestFilter,
      9986: NearestMipmapLinearFilter,
      9987: LinearMipmapLinearFilter
    };
    var WEBGL_WRAPPINGS = {
      33071: ClampToEdgeWrapping,
      33648: MirroredRepeatWrapping,
      10497: RepeatWrapping
    };
    var WEBGL_TYPE_SIZES = {
      "SCALAR": 1,
      "VEC2": 2,
      "VEC3": 3,
      "VEC4": 4,
      "MAT2": 4,
      "MAT3": 9,
      "MAT4": 16
    };
    var ATTRIBUTES = {
      POSITION: "position",
      NORMAL: "normal",
      TANGENT: "tangent",
      TEXCOORD_0: "uv",
      TEXCOORD_1: "uv2",
      COLOR_0: "color",
      WEIGHTS_0: "skinWeight",
      JOINTS_0: "skinIndex"
    };
    var PATH_PROPERTIES = {
      scale: "scale",
      translation: "position",
      rotation: "quaternion",
      weights: "morphTargetInfluences"
    };
    var INTERPOLATION = {
      CUBICSPLINE: void 0,
      LINEAR: InterpolateLinear,
      STEP: InterpolateDiscrete
    };
    var ALPHA_MODES = {
      OPAQUE: "OPAQUE",
      MASK: "MASK",
      BLEND: "BLEND"
    };
    function resolveURL(url, path) {
      if (typeof url !== "string" || url === "")
        return "";
      if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
        path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
      }
      if (/^(https?:)?\/\//i.test(url))
        return url;
      if (/^data:.*,.*$/i.test(url))
        return url;
      if (/^blob:.*$/i.test(url))
        return url;
      return path + url;
    }
    function createDefaultMaterial(cache) {
      if (cache["DefaultMaterial"] === void 0) {
        cache["DefaultMaterial"] = new MeshStandardMaterial({
          color: 16777215,
          emissive: 0,
          metalness: 1,
          roughness: 1,
          transparent: false,
          depthTest: true,
          side: FrontSide
        });
      }
      return cache["DefaultMaterial"];
    }
    function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
      for (var name in objectDef.extensions) {
        if (knownExtensions[name] === void 0) {
          object.userData.gltfExtensions = object.userData.gltfExtensions || {};
          object.userData.gltfExtensions[name] = objectDef.extensions[name];
        }
      }
    }
    function assignExtrasToUserData(object, gltfDef) {
      if (gltfDef.extras !== void 0) {
        if (typeof gltfDef.extras === "object") {
          Object.assign(object.userData, gltfDef.extras);
        } else {
          console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
        }
      }
    }
    function addMorphTargets(geometry, targets, parser) {
      var hasMorphPosition = false;
      var hasMorphNormal = false;
      for (var i = 0, il = targets.length; i < il; i++) {
        var target = targets[i];
        if (target.POSITION !== void 0)
          hasMorphPosition = true;
        if (target.NORMAL !== void 0)
          hasMorphNormal = true;
        if (hasMorphPosition && hasMorphNormal)
          break;
      }
      if (!hasMorphPosition && !hasMorphNormal)
        return Promise.resolve(geometry);
      var pendingPositionAccessors = [];
      var pendingNormalAccessors = [];
      for (var i = 0, il = targets.length; i < il; i++) {
        var target = targets[i];
        if (hasMorphPosition) {
          var pendingAccessor = target.POSITION !== void 0 ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
          pendingPositionAccessors.push(pendingAccessor);
        }
        if (hasMorphNormal) {
          var pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
          pendingNormalAccessors.push(pendingAccessor);
        }
      }
      return Promise.all([
        Promise.all(pendingPositionAccessors),
        Promise.all(pendingNormalAccessors)
      ]).then(function(accessors) {
        var morphPositions = accessors[0];
        var morphNormals = accessors[1];
        if (hasMorphPosition)
          geometry.morphAttributes.position = morphPositions;
        if (hasMorphNormal)
          geometry.morphAttributes.normal = morphNormals;
        geometry.morphTargetsRelative = true;
        return geometry;
      });
    }
    function updateMorphTargets(mesh, meshDef) {
      mesh.updateMorphTargets();
      if (meshDef.weights !== void 0) {
        for (var i = 0, il = meshDef.weights.length; i < il; i++) {
          mesh.morphTargetInfluences[i] = meshDef.weights[i];
        }
      }
      if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
        var targetNames = meshDef.extras.targetNames;
        if (mesh.morphTargetInfluences.length === targetNames.length) {
          mesh.morphTargetDictionary = {};
          for (var i = 0, il = targetNames.length; i < il; i++) {
            mesh.morphTargetDictionary[targetNames[i]] = i;
          }
        } else {
          console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
        }
      }
    }
    function createPrimitiveKey(primitiveDef) {
      var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
      var geometryKey;
      if (dracoExtension) {
        geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
      } else {
        geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
      }
      return geometryKey;
    }
    function createAttributesKey(attributes) {
      var attributesKey = "";
      var keys = Object.keys(attributes).sort();
      for (var i = 0, il = keys.length; i < il; i++) {
        attributesKey += keys[i] + ":" + attributes[keys[i]] + ";";
      }
      return attributesKey;
    }
    function GLTFParser(json, options) {
      this.json = json || {};
      this.extensions = {};
      this.plugins = {};
      this.options = options || {};
      this.cache = new GLTFRegistry();
      this.associations = new Map();
      this.primitiveCache = {};
      this.meshCache = { refs: {}, uses: {} };
      this.cameraCache = { refs: {}, uses: {} };
      this.lightCache = { refs: {}, uses: {} };
      this.nodeNamesUsed = {};
      if (typeof createImageBitmap !== "undefined" && /Firefox/.test(navigator.userAgent) === false) {
        this.textureLoader = new ImageBitmapLoader(this.options.manager);
      } else {
        this.textureLoader = new TextureLoader(this.options.manager);
      }
      this.textureLoader.setCrossOrigin(this.options.crossOrigin);
      this.textureLoader.setRequestHeader(this.options.requestHeader);
      this.fileLoader = new FileLoader(this.options.manager);
      this.fileLoader.setResponseType("arraybuffer");
      if (this.options.crossOrigin === "use-credentials") {
        this.fileLoader.setWithCredentials(true);
      }
    }
    GLTFParser.prototype.setExtensions = function(extensions) {
      this.extensions = extensions;
    };
    GLTFParser.prototype.setPlugins = function(plugins) {
      this.plugins = plugins;
    };
    GLTFParser.prototype.parse = function(onLoad, onError) {
      var parser = this;
      var json = this.json;
      var extensions = this.extensions;
      this.cache.removeAll();
      this._invokeAll(function(ext) {
        return ext._markDefs && ext._markDefs();
      });
      Promise.all(this._invokeAll(function(ext) {
        return ext.beforeRoot && ext.beforeRoot();
      })).then(function() {
        return Promise.all([
          parser.getDependencies("scene"),
          parser.getDependencies("animation"),
          parser.getDependencies("camera")
        ]);
      }).then(function(dependencies) {
        var result = {
          scene: dependencies[0][json.scene || 0],
          scenes: dependencies[0],
          animations: dependencies[1],
          cameras: dependencies[2],
          asset: json.asset,
          parser,
          userData: {}
        };
        addUnknownExtensionsToUserData(extensions, result, json);
        assignExtrasToUserData(result, json);
        Promise.all(parser._invokeAll(function(ext) {
          return ext.afterRoot && ext.afterRoot(result);
        })).then(function() {
          onLoad(result);
        });
      }).catch(onError);
    };
    GLTFParser.prototype._markDefs = function() {
      var nodeDefs = this.json.nodes || [];
      var skinDefs = this.json.skins || [];
      var meshDefs = this.json.meshes || [];
      for (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
        var joints = skinDefs[skinIndex].joints;
        for (var i = 0, il = joints.length; i < il; i++) {
          nodeDefs[joints[i]].isBone = true;
        }
      }
      for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
        var nodeDef = nodeDefs[nodeIndex];
        if (nodeDef.mesh !== void 0) {
          this._addNodeRef(this.meshCache, nodeDef.mesh);
          if (nodeDef.skin !== void 0) {
            meshDefs[nodeDef.mesh].isSkinnedMesh = true;
          }
        }
        if (nodeDef.camera !== void 0) {
          this._addNodeRef(this.cameraCache, nodeDef.camera);
        }
      }
    };
    GLTFParser.prototype._addNodeRef = function(cache, index) {
      if (index === void 0)
        return;
      if (cache.refs[index] === void 0) {
        cache.refs[index] = cache.uses[index] = 0;
      }
      cache.refs[index]++;
    };
    GLTFParser.prototype._getNodeRef = function(cache, index, object) {
      if (cache.refs[index] <= 1)
        return object;
      var ref = object.clone();
      ref.name += "_instance_" + cache.uses[index]++;
      return ref;
    };
    GLTFParser.prototype._invokeOne = function(func) {
      var extensions = Object.values(this.plugins);
      extensions.push(this);
      for (var i = 0; i < extensions.length; i++) {
        var result = func(extensions[i]);
        if (result)
          return result;
      }
    };
    GLTFParser.prototype._invokeAll = function(func) {
      var extensions = Object.values(this.plugins);
      extensions.unshift(this);
      var pending = [];
      for (var i = 0; i < extensions.length; i++) {
        var result = func(extensions[i]);
        if (result)
          pending.push(result);
      }
      return pending;
    };
    GLTFParser.prototype.getDependency = function(type, index) {
      var cacheKey = type + ":" + index;
      var dependency = this.cache.get(cacheKey);
      if (!dependency) {
        switch (type) {
          case "scene":
            dependency = this.loadScene(index);
            break;
          case "node":
            dependency = this.loadNode(index);
            break;
          case "mesh":
            dependency = this._invokeOne(function(ext) {
              return ext.loadMesh && ext.loadMesh(index);
            });
            break;
          case "accessor":
            dependency = this.loadAccessor(index);
            break;
          case "bufferView":
            dependency = this._invokeOne(function(ext) {
              return ext.loadBufferView && ext.loadBufferView(index);
            });
            break;
          case "buffer":
            dependency = this.loadBuffer(index);
            break;
          case "material":
            dependency = this._invokeOne(function(ext) {
              return ext.loadMaterial && ext.loadMaterial(index);
            });
            break;
          case "texture":
            dependency = this._invokeOne(function(ext) {
              return ext.loadTexture && ext.loadTexture(index);
            });
            break;
          case "skin":
            dependency = this.loadSkin(index);
            break;
          case "animation":
            dependency = this.loadAnimation(index);
            break;
          case "camera":
            dependency = this.loadCamera(index);
            break;
          default:
            throw new Error("Unknown type: " + type);
        }
        this.cache.add(cacheKey, dependency);
      }
      return dependency;
    };
    GLTFParser.prototype.getDependencies = function(type) {
      var dependencies = this.cache.get(type);
      if (!dependencies) {
        var parser = this;
        var defs = this.json[type + (type === "mesh" ? "es" : "s")] || [];
        dependencies = Promise.all(defs.map(function(def, index) {
          return parser.getDependency(type, index);
        }));
        this.cache.add(type, dependencies);
      }
      return dependencies;
    };
    GLTFParser.prototype.loadBuffer = function(bufferIndex) {
      var bufferDef = this.json.buffers[bufferIndex];
      var loader = this.fileLoader;
      if (bufferDef.type && bufferDef.type !== "arraybuffer") {
        throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
      }
      if (bufferDef.uri === void 0 && bufferIndex === 0) {
        return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
      }
      var options = this.options;
      return new Promise(function(resolve, reject) {
        loader.load(resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {
          reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
        });
      });
    };
    GLTFParser.prototype.loadBufferView = function(bufferViewIndex) {
      var bufferViewDef = this.json.bufferViews[bufferViewIndex];
      return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer) {
        var byteLength = bufferViewDef.byteLength || 0;
        var byteOffset = bufferViewDef.byteOffset || 0;
        return buffer.slice(byteOffset, byteOffset + byteLength);
      });
    };
    GLTFParser.prototype.loadAccessor = function(accessorIndex) {
      var parser = this;
      var json = this.json;
      var accessorDef = this.json.accessors[accessorIndex];
      if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
        return Promise.resolve(null);
      }
      var pendingBufferViews = [];
      if (accessorDef.bufferView !== void 0) {
        pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
      } else {
        pendingBufferViews.push(null);
      }
      if (accessorDef.sparse !== void 0) {
        pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
        pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
      }
      return Promise.all(pendingBufferViews).then(function(bufferViews) {
        var bufferView = bufferViews[0];
        var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
        var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        var elementBytes = TypedArray.BYTES_PER_ELEMENT;
        var itemBytes = elementBytes * itemSize;
        var byteOffset = accessorDef.byteOffset || 0;
        var byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;
        var normalized = accessorDef.normalized === true;
        var array, bufferAttribute;
        if (byteStride && byteStride !== itemBytes) {
          var ibSlice = Math.floor(byteOffset / byteStride);
          var ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
          var ib = parser.cache.get(ibCacheKey);
          if (!ib) {
            array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
            ib = new InterleavedBuffer(array, byteStride / elementBytes);
            parser.cache.add(ibCacheKey, ib);
          }
          bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
        } else {
          if (bufferView === null) {
            array = new TypedArray(accessorDef.count * itemSize);
          } else {
            array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
          }
          bufferAttribute = new BufferAttribute(array, itemSize, normalized);
        }
        if (accessorDef.sparse !== void 0) {
          var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
          var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
          var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
          var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
          var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
          var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
          if (bufferView !== null) {
            bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
          }
          for (var i = 0, il = sparseIndices.length; i < il; i++) {
            var index = sparseIndices[i];
            bufferAttribute.setX(index, sparseValues[i * itemSize]);
            if (itemSize >= 2)
              bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
            if (itemSize >= 3)
              bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
            if (itemSize >= 4)
              bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
            if (itemSize >= 5)
              throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
          }
        }
        return bufferAttribute;
      });
    };
    GLTFParser.prototype.loadTexture = function(textureIndex) {
      var json = this.json;
      var options = this.options;
      var textureDef = json.textures[textureIndex];
      var source = json.images[textureDef.source];
      var loader = this.textureLoader;
      if (source.uri) {
        var handler = options.manager.getHandler(source.uri);
        if (handler !== null)
          loader = handler;
      }
      return this.loadTextureImage(textureIndex, source, loader);
    };
    GLTFParser.prototype.loadTextureImage = function(textureIndex, source, loader) {
      var parser = this;
      var json = this.json;
      var options = this.options;
      var textureDef = json.textures[textureIndex];
      var URL2 = self.URL || self.webkitURL;
      var sourceURI = source.uri;
      var isObjectURL = false;
      var hasAlpha = true;
      if (source.mimeType === "image/jpeg")
        hasAlpha = false;
      if (source.bufferView !== void 0) {
        sourceURI = parser.getDependency("bufferView", source.bufferView).then(function(bufferView) {
          if (source.mimeType === "image/png") {
            var colorType = new DataView(bufferView, 25, 1).getUint8(0, false);
            hasAlpha = colorType === 6 || colorType === 4 || colorType === 3;
          }
          isObjectURL = true;
          var blob = new Blob([bufferView], { type: source.mimeType });
          sourceURI = URL2.createObjectURL(blob);
          return sourceURI;
        });
      } else if (source.uri === void 0) {
        throw new Error("THREE.GLTFLoader: Image " + textureIndex + " is missing URI and bufferView");
      }
      return Promise.resolve(sourceURI).then(function(sourceURI2) {
        return new Promise(function(resolve, reject) {
          var onLoad = resolve;
          if (loader.isImageBitmapLoader === true) {
            onLoad = function(imageBitmap) {
              resolve(new CanvasTexture(imageBitmap));
            };
          }
          loader.load(resolveURL(sourceURI2, options.path), onLoad, void 0, reject);
        });
      }).then(function(texture) {
        if (isObjectURL === true) {
          URL2.revokeObjectURL(sourceURI);
        }
        texture.flipY = false;
        if (textureDef.name)
          texture.name = textureDef.name;
        if (!hasAlpha)
          texture.format = RGBFormat;
        var samplers = json.samplers || {};
        var sampler = samplers[textureDef.sampler] || {};
        texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
        texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
        texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
        texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
        parser.associations.set(texture, {
          type: "textures",
          index: textureIndex
        });
        return texture;
      });
    };
    GLTFParser.prototype.assignTexture = function(materialParams, mapName, mapDef) {
      var parser = this;
      return this.getDependency("texture", mapDef.index).then(function(texture) {
        if (mapDef.texCoord !== void 0 && mapDef.texCoord != 0 && !(mapName === "aoMap" && mapDef.texCoord == 1)) {
          console.warn("THREE.GLTFLoader: Custom UV set " + mapDef.texCoord + " for texture " + mapName + " not yet supported.");
        }
        if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
          var transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
          if (transform) {
            var gltfReference = parser.associations.get(texture);
            texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
            parser.associations.set(texture, gltfReference);
          }
        }
        materialParams[mapName] = texture;
      });
    };
    GLTFParser.prototype.assignFinalMaterial = function(mesh) {
      var geometry = mesh.geometry;
      var material = mesh.material;
      var useVertexTangents = geometry.attributes.tangent !== void 0;
      var useVertexColors = geometry.attributes.color !== void 0;
      var useFlatShading = geometry.attributes.normal === void 0;
      var useSkinning = mesh.isSkinnedMesh === true;
      var useMorphTargets = Object.keys(geometry.morphAttributes).length > 0;
      var useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== void 0;
      if (mesh.isPoints) {
        var cacheKey = "PointsMaterial:" + material.uuid;
        var pointsMaterial = this.cache.get(cacheKey);
        if (!pointsMaterial) {
          pointsMaterial = new PointsMaterial();
          Material.prototype.copy.call(pointsMaterial, material);
          pointsMaterial.color.copy(material.color);
          pointsMaterial.map = material.map;
          pointsMaterial.sizeAttenuation = false;
          this.cache.add(cacheKey, pointsMaterial);
        }
        material = pointsMaterial;
      } else if (mesh.isLine) {
        var cacheKey = "LineBasicMaterial:" + material.uuid;
        var lineMaterial = this.cache.get(cacheKey);
        if (!lineMaterial) {
          lineMaterial = new LineBasicMaterial();
          Material.prototype.copy.call(lineMaterial, material);
          lineMaterial.color.copy(material.color);
          this.cache.add(cacheKey, lineMaterial);
        }
        material = lineMaterial;
      }
      if (useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets) {
        var cacheKey = "ClonedMaterial:" + material.uuid + ":";
        if (material.isGLTFSpecularGlossinessMaterial)
          cacheKey += "specular-glossiness:";
        if (useSkinning)
          cacheKey += "skinning:";
        if (useVertexTangents)
          cacheKey += "vertex-tangents:";
        if (useVertexColors)
          cacheKey += "vertex-colors:";
        if (useFlatShading)
          cacheKey += "flat-shading:";
        if (useMorphTargets)
          cacheKey += "morph-targets:";
        if (useMorphNormals)
          cacheKey += "morph-normals:";
        var cachedMaterial = this.cache.get(cacheKey);
        if (!cachedMaterial) {
          cachedMaterial = material.clone();
          if (useSkinning)
            cachedMaterial.skinning = true;
          if (useVertexColors)
            cachedMaterial.vertexColors = true;
          if (useFlatShading)
            cachedMaterial.flatShading = true;
          if (useMorphTargets)
            cachedMaterial.morphTargets = true;
          if (useMorphNormals)
            cachedMaterial.morphNormals = true;
          if (useVertexTangents) {
            cachedMaterial.vertexTangents = true;
            if (cachedMaterial.normalScale)
              cachedMaterial.normalScale.y *= -1;
            if (cachedMaterial.clearcoatNormalScale)
              cachedMaterial.clearcoatNormalScale.y *= -1;
          }
          this.cache.add(cacheKey, cachedMaterial);
          this.associations.set(cachedMaterial, this.associations.get(material));
        }
        material = cachedMaterial;
      }
      if (material.aoMap && geometry.attributes.uv2 === void 0 && geometry.attributes.uv !== void 0) {
        geometry.setAttribute("uv2", geometry.attributes.uv);
      }
      mesh.material = material;
    };
    GLTFParser.prototype.getMaterialType = function() {
      return MeshStandardMaterial;
    };
    GLTFParser.prototype.loadMaterial = function(materialIndex) {
      var parser = this;
      var json = this.json;
      var extensions = this.extensions;
      var materialDef = json.materials[materialIndex];
      var materialType;
      var materialParams = {};
      var materialExtensions = materialDef.extensions || {};
      var pending = [];
      if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
        var sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
        materialType = sgExtension.getMaterialType();
        pending.push(sgExtension.extendParams(materialParams, materialDef, parser));
      } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
        var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
        materialType = kmuExtension.getMaterialType();
        pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
      } else {
        var metallicRoughness = materialDef.pbrMetallicRoughness || {};
        materialParams.color = new Color(1, 1, 1);
        materialParams.opacity = 1;
        if (Array.isArray(metallicRoughness.baseColorFactor)) {
          var array = metallicRoughness.baseColorFactor;
          materialParams.color.fromArray(array);
          materialParams.opacity = array[3];
        }
        if (metallicRoughness.baseColorTexture !== void 0) {
          pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture));
        }
        materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;
        materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;
        if (metallicRoughness.metallicRoughnessTexture !== void 0) {
          pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
          pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
        }
        materialType = this._invokeOne(function(ext) {
          return ext.getMaterialType && ext.getMaterialType(materialIndex);
        });
        pending.push(Promise.all(this._invokeAll(function(ext) {
          return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
        })));
      }
      if (materialDef.doubleSided === true) {
        materialParams.side = DoubleSide;
      }
      var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
      if (alphaMode === ALPHA_MODES.BLEND) {
        materialParams.transparent = true;
        materialParams.depthWrite = false;
      } else {
        materialParams.transparent = false;
        if (alphaMode === ALPHA_MODES.MASK) {
          materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;
        }
      }
      if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {
        pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
        materialParams.normalScale = new Vector2(1, -1);
        if (materialDef.normalTexture.scale !== void 0) {
          materialParams.normalScale.set(materialDef.normalTexture.scale, -materialDef.normalTexture.scale);
        }
      }
      if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {
        pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
        if (materialDef.occlusionTexture.strength !== void 0) {
          materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
        }
      }
      if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {
        materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor);
      }
      if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {
        pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture));
      }
      return Promise.all(pending).then(function() {
        var material;
        if (materialType === GLTFMeshStandardSGMaterial) {
          material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);
        } else {
          material = new materialType(materialParams);
        }
        if (materialDef.name)
          material.name = materialDef.name;
        if (material.map)
          material.map.encoding = sRGBEncoding;
        if (material.emissiveMap)
          material.emissiveMap.encoding = sRGBEncoding;
        assignExtrasToUserData(material, materialDef);
        parser.associations.set(material, { type: "materials", index: materialIndex });
        if (materialDef.extensions)
          addUnknownExtensionsToUserData(extensions, material, materialDef);
        return material;
      });
    };
    GLTFParser.prototype.createUniqueName = function(originalName) {
      var sanitizedName = PropertyBinding.sanitizeNodeName(originalName || "");
      var name = sanitizedName;
      for (var i = 1; this.nodeNamesUsed[name]; ++i) {
        name = sanitizedName + "_" + i;
      }
      this.nodeNamesUsed[name] = true;
      return name;
    };
    function computeBounds(geometry, primitiveDef, parser) {
      var attributes = primitiveDef.attributes;
      var box = new Box3();
      if (attributes.POSITION !== void 0) {
        var accessor = parser.json.accessors[attributes.POSITION];
        var min = accessor.min;
        var max = accessor.max;
        if (min !== void 0 && max !== void 0) {
          box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]));
        } else {
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
          return;
        }
      } else {
        return;
      }
      var targets = primitiveDef.targets;
      if (targets !== void 0) {
        var maxDisplacement = new Vector3();
        var vector = new Vector3();
        for (var i = 0, il = targets.length; i < il; i++) {
          var target = targets[i];
          if (target.POSITION !== void 0) {
            var accessor = parser.json.accessors[target.POSITION];
            var min = accessor.min;
            var max = accessor.max;
            if (min !== void 0 && max !== void 0) {
              vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
              vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
              vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));
              maxDisplacement.max(vector);
            } else {
              console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            }
          }
        }
        box.expandByVector(maxDisplacement);
      }
      geometry.boundingBox = box;
      var sphere = new Sphere();
      box.getCenter(sphere.center);
      sphere.radius = box.min.distanceTo(box.max) / 2;
      geometry.boundingSphere = sphere;
    }
    function addPrimitiveAttributes(geometry, primitiveDef, parser) {
      var attributes = primitiveDef.attributes;
      var pending = [];
      function assignAttributeAccessor(accessorIndex, attributeName) {
        return parser.getDependency("accessor", accessorIndex).then(function(accessor2) {
          geometry.setAttribute(attributeName, accessor2);
        });
      }
      for (var gltfAttributeName in attributes) {
        var threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
        if (threeAttributeName in geometry.attributes)
          continue;
        pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
      }
      if (primitiveDef.indices !== void 0 && !geometry.index) {
        var accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
          geometry.setIndex(accessor2);
        });
        pending.push(accessor);
      }
      assignExtrasToUserData(geometry, primitiveDef);
      computeBounds(geometry, primitiveDef, parser);
      return Promise.all(pending).then(function() {
        return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
      });
    }
    function toTrianglesDrawMode(geometry, drawMode) {
      var index = geometry.getIndex();
      if (index === null) {
        var indices = [];
        var position = geometry.getAttribute("position");
        if (position !== void 0) {
          for (var i = 0; i < position.count; i++) {
            indices.push(i);
          }
          geometry.setIndex(indices);
          index = geometry.getIndex();
        } else {
          console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
          return geometry;
        }
      }
      var numberOfTriangles = index.count - 2;
      var newIndices = [];
      if (drawMode === TriangleFanDrawMode) {
        for (var i = 1; i <= numberOfTriangles; i++) {
          newIndices.push(index.getX(0));
          newIndices.push(index.getX(i));
          newIndices.push(index.getX(i + 1));
        }
      } else {
        for (var i = 0; i < numberOfTriangles; i++) {
          if (i % 2 === 0) {
            newIndices.push(index.getX(i));
            newIndices.push(index.getX(i + 1));
            newIndices.push(index.getX(i + 2));
          } else {
            newIndices.push(index.getX(i + 2));
            newIndices.push(index.getX(i + 1));
            newIndices.push(index.getX(i));
          }
        }
      }
      if (newIndices.length / 3 !== numberOfTriangles) {
        console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
      }
      var newGeometry = geometry.clone();
      newGeometry.setIndex(newIndices);
      return newGeometry;
    }
    GLTFParser.prototype.loadGeometries = function(primitives) {
      var parser = this;
      var extensions = this.extensions;
      var cache = this.primitiveCache;
      function createDracoPrimitive(primitive2) {
        return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive2, parser).then(function(geometry) {
          return addPrimitiveAttributes(geometry, primitive2, parser);
        });
      }
      var pending = [];
      for (var i = 0, il = primitives.length; i < il; i++) {
        var primitive = primitives[i];
        var cacheKey = createPrimitiveKey(primitive);
        var cached = cache[cacheKey];
        if (cached) {
          pending.push(cached.promise);
        } else {
          var geometryPromise;
          if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
            geometryPromise = createDracoPrimitive(primitive);
          } else {
            geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
          }
          cache[cacheKey] = { primitive, promise: geometryPromise };
          pending.push(geometryPromise);
        }
      }
      return Promise.all(pending);
    };
    GLTFParser.prototype.loadMesh = function(meshIndex) {
      var parser = this;
      var json = this.json;
      var extensions = this.extensions;
      var meshDef = json.meshes[meshIndex];
      var primitives = meshDef.primitives;
      var pending = [];
      for (var i = 0, il = primitives.length; i < il; i++) {
        var material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i].material);
        pending.push(material);
      }
      pending.push(parser.loadGeometries(primitives));
      return Promise.all(pending).then(function(results) {
        var materials = results.slice(0, results.length - 1);
        var geometries = results[results.length - 1];
        var meshes = [];
        for (var i2 = 0, il2 = geometries.length; i2 < il2; i2++) {
          var geometry = geometries[i2];
          var primitive = primitives[i2];
          var mesh;
          var material2 = materials[i2];
          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {
            mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material2) : new Mesh(geometry, material2);
            if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {
              mesh.normalizeSkinWeights();
            }
            if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
              mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);
            } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
              mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);
            }
          } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
            mesh = new LineSegments(geometry, material2);
          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
            mesh = new Line(geometry, material2);
          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
            mesh = new LineLoop(geometry, material2);
          } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
            mesh = new Points(geometry, material2);
          } else {
            throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
          }
          if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
            updateMorphTargets(mesh, meshDef);
          }
          mesh.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex);
          assignExtrasToUserData(mesh, meshDef);
          if (primitive.extensions)
            addUnknownExtensionsToUserData(extensions, mesh, primitive);
          parser.assignFinalMaterial(mesh);
          meshes.push(mesh);
        }
        if (meshes.length === 1) {
          return meshes[0];
        }
        var group = new Group();
        for (var i2 = 0, il2 = meshes.length; i2 < il2; i2++) {
          group.add(meshes[i2]);
        }
        return group;
      });
    };
    GLTFParser.prototype.loadCamera = function(cameraIndex) {
      var camera;
      var cameraDef = this.json.cameras[cameraIndex];
      var params = cameraDef[cameraDef.type];
      if (!params) {
        console.warn("THREE.GLTFLoader: Missing camera parameters.");
        return;
      }
      if (cameraDef.type === "perspective") {
        camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
      } else if (cameraDef.type === "orthographic") {
        camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
      }
      if (cameraDef.name)
        camera.name = this.createUniqueName(cameraDef.name);
      assignExtrasToUserData(camera, cameraDef);
      return Promise.resolve(camera);
    };
    GLTFParser.prototype.loadSkin = function(skinIndex) {
      var skinDef = this.json.skins[skinIndex];
      var skinEntry = { joints: skinDef.joints };
      if (skinDef.inverseBindMatrices === void 0) {
        return Promise.resolve(skinEntry);
      }
      return this.getDependency("accessor", skinDef.inverseBindMatrices).then(function(accessor) {
        skinEntry.inverseBindMatrices = accessor;
        return skinEntry;
      });
    };
    GLTFParser.prototype.loadAnimation = function(animationIndex) {
      var json = this.json;
      var animationDef = json.animations[animationIndex];
      var pendingNodes = [];
      var pendingInputAccessors = [];
      var pendingOutputAccessors = [];
      var pendingSamplers = [];
      var pendingTargets = [];
      for (var i = 0, il = animationDef.channels.length; i < il; i++) {
        var channel = animationDef.channels[i];
        var sampler = animationDef.samplers[channel.sampler];
        var target = channel.target;
        var name = target.node !== void 0 ? target.node : target.id;
        var input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;
        var output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;
        pendingNodes.push(this.getDependency("node", name));
        pendingInputAccessors.push(this.getDependency("accessor", input));
        pendingOutputAccessors.push(this.getDependency("accessor", output));
        pendingSamplers.push(sampler);
        pendingTargets.push(target);
      }
      return Promise.all([
        Promise.all(pendingNodes),
        Promise.all(pendingInputAccessors),
        Promise.all(pendingOutputAccessors),
        Promise.all(pendingSamplers),
        Promise.all(pendingTargets)
      ]).then(function(dependencies) {
        var nodes = dependencies[0];
        var inputAccessors = dependencies[1];
        var outputAccessors = dependencies[2];
        var samplers = dependencies[3];
        var targets = dependencies[4];
        var tracks = [];
        for (var i2 = 0, il2 = nodes.length; i2 < il2; i2++) {
          var node = nodes[i2];
          var inputAccessor = inputAccessors[i2];
          var outputAccessor = outputAccessors[i2];
          var sampler2 = samplers[i2];
          var target2 = targets[i2];
          if (node === void 0)
            continue;
          node.updateMatrix();
          node.matrixAutoUpdate = true;
          var TypedKeyframeTrack;
          switch (PATH_PROPERTIES[target2.path]) {
            case PATH_PROPERTIES.weights:
              TypedKeyframeTrack = NumberKeyframeTrack;
              break;
            case PATH_PROPERTIES.rotation:
              TypedKeyframeTrack = QuaternionKeyframeTrack;
              break;
            case PATH_PROPERTIES.position:
            case PATH_PROPERTIES.scale:
            default:
              TypedKeyframeTrack = VectorKeyframeTrack;
              break;
          }
          var targetName = node.name ? node.name : node.uuid;
          var interpolation = sampler2.interpolation !== void 0 ? INTERPOLATION[sampler2.interpolation] : InterpolateLinear;
          var targetNames = [];
          if (PATH_PROPERTIES[target2.path] === PATH_PROPERTIES.weights) {
            node.traverse(function(object) {
              if (object.isMesh === true && object.morphTargetInfluences) {
                targetNames.push(object.name ? object.name : object.uuid);
              }
            });
          } else {
            targetNames.push(targetName);
          }
          var outputArray = outputAccessor.array;
          if (outputAccessor.normalized) {
            var scale;
            if (outputArray.constructor === Int8Array) {
              scale = 1 / 127;
            } else if (outputArray.constructor === Uint8Array) {
              scale = 1 / 255;
            } else if (outputArray.constructor == Int16Array) {
              scale = 1 / 32767;
            } else if (outputArray.constructor === Uint16Array) {
              scale = 1 / 65535;
            } else {
              throw new Error("THREE.GLTFLoader: Unsupported output accessor component type.");
            }
            var scaled = new Float32Array(outputArray.length);
            for (var j = 0, jl = outputArray.length; j < jl; j++) {
              scaled[j] = outputArray[j] * scale;
            }
            outputArray = scaled;
          }
          for (var j = 0, jl = targetNames.length; j < jl; j++) {
            var track = new TypedKeyframeTrack(targetNames[j] + "." + PATH_PROPERTIES[target2.path], inputAccessor.array, outputArray, interpolation);
            if (sampler2.interpolation === "CUBICSPLINE") {
              track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
                return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);
              };
              track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
            }
            tracks.push(track);
          }
        }
        var name2 = animationDef.name ? animationDef.name : "animation_" + animationIndex;
        return new AnimationClip(name2, void 0, tracks);
      });
    };
    GLTFParser.prototype.loadNode = function(nodeIndex) {
      var json = this.json;
      var extensions = this.extensions;
      var parser = this;
      var nodeDef = json.nodes[nodeIndex];
      var nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "";
      return function() {
        var pending = [];
        if (nodeDef.mesh !== void 0) {
          pending.push(parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
            var node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
            if (nodeDef.weights !== void 0) {
              node.traverse(function(o) {
                if (!o.isMesh)
                  return;
                for (var i = 0, il = nodeDef.weights.length; i < il; i++) {
                  o.morphTargetInfluences[i] = nodeDef.weights[i];
                }
              });
            }
            return node;
          }));
        }
        if (nodeDef.camera !== void 0) {
          pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera) {
            return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
          }));
        }
        parser._invokeAll(function(ext) {
          return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
        }).forEach(function(promise) {
          pending.push(promise);
        });
        return Promise.all(pending);
      }().then(function(objects) {
        var node;
        if (nodeDef.isBone === true) {
          node = new Bone();
        } else if (objects.length > 1) {
          node = new Group();
        } else if (objects.length === 1) {
          node = objects[0];
        } else {
          node = new Object3D();
        }
        if (node !== objects[0]) {
          for (var i = 0, il = objects.length; i < il; i++) {
            node.add(objects[i]);
          }
        }
        if (nodeDef.name) {
          node.userData.name = nodeDef.name;
          node.name = nodeName;
        }
        assignExtrasToUserData(node, nodeDef);
        if (nodeDef.extensions)
          addUnknownExtensionsToUserData(extensions, node, nodeDef);
        if (nodeDef.matrix !== void 0) {
          var matrix = new Matrix4();
          matrix.fromArray(nodeDef.matrix);
          node.applyMatrix4(matrix);
        } else {
          if (nodeDef.translation !== void 0) {
            node.position.fromArray(nodeDef.translation);
          }
          if (nodeDef.rotation !== void 0) {
            node.quaternion.fromArray(nodeDef.rotation);
          }
          if (nodeDef.scale !== void 0) {
            node.scale.fromArray(nodeDef.scale);
          }
        }
        parser.associations.set(node, { type: "nodes", index: nodeIndex });
        return node;
      });
    };
    GLTFParser.prototype.loadScene = function() {
      function buildNodeHierachy(nodeId, parentObject, json, parser) {
        var nodeDef = json.nodes[nodeId];
        return parser.getDependency("node", nodeId).then(function(node) {
          if (nodeDef.skin === void 0)
            return node;
          var skinEntry;
          return parser.getDependency("skin", nodeDef.skin).then(function(skin) {
            skinEntry = skin;
            var pendingJoints = [];
            for (var i = 0, il = skinEntry.joints.length; i < il; i++) {
              pendingJoints.push(parser.getDependency("node", skinEntry.joints[i]));
            }
            return Promise.all(pendingJoints);
          }).then(function(jointNodes) {
            node.traverse(function(mesh) {
              if (!mesh.isMesh)
                return;
              var bones = [];
              var boneInverses = [];
              for (var j = 0, jl = jointNodes.length; j < jl; j++) {
                var jointNode = jointNodes[j];
                if (jointNode) {
                  bones.push(jointNode);
                  var mat = new Matrix4();
                  if (skinEntry.inverseBindMatrices !== void 0) {
                    mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);
                  }
                  boneInverses.push(mat);
                } else {
                  console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[j]);
                }
              }
              mesh.bind(new Skeleton(bones, boneInverses), mesh.matrixWorld);
            });
            return node;
          });
        }).then(function(node) {
          parentObject.add(node);
          var pending = [];
          if (nodeDef.children) {
            var children = nodeDef.children;
            for (var i = 0, il = children.length; i < il; i++) {
              var child = children[i];
              pending.push(buildNodeHierachy(child, node, json, parser));
            }
          }
          return Promise.all(pending);
        });
      }
      return function loadScene(sceneIndex) {
        var json = this.json;
        var extensions = this.extensions;
        var sceneDef = this.json.scenes[sceneIndex];
        var parser = this;
        var scene = new Group();
        if (sceneDef.name)
          scene.name = parser.createUniqueName(sceneDef.name);
        assignExtrasToUserData(scene, sceneDef);
        if (sceneDef.extensions)
          addUnknownExtensionsToUserData(extensions, scene, sceneDef);
        var nodeIds = sceneDef.nodes || [];
        var pending = [];
        for (var i = 0, il = nodeIds.length; i < il; i++) {
          pending.push(buildNodeHierachy(nodeIds[i], scene, json, parser));
        }
        return Promise.all(pending).then(function() {
          return scene;
        });
      };
    }();
    return GLTFLoader2;
  }();

  // node_modules/@enable3d/three-graphics/jsm/plugins/loaders.js
  var __awaiter = function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var Loaders = class {
    constructor(cache, textureAnisotropy) {
      this.cache = cache;
      this.textureAnisotropy = textureAnisotropy;
    }
    get fileLoader() {
      if (!this._fileLoader)
        this._fileLoader = new FileLoader();
      return this._fileLoader;
    }
    get imageLoader() {
      if (!this._imgLoader)
        this._imgLoader = new ImageLoader();
      return this._imgLoader;
    }
    get svgLoader() {
      if (!this._svgLoader)
        this._svgLoader = new SVGLoader();
      return this._svgLoader;
    }
    get textureLoader() {
      if (!this._textureLoader)
        this._textureLoader = new TextureLoader();
      return this._textureLoader;
    }
    get objectLoader() {
      if (!this._objectLoader)
        this._objectLoader = new ObjectLoader();
      return this._objectLoader;
    }
    get gltfLoader() {
      if (!this._gltfLoader)
        this._gltfLoader = new GLTFLoader();
      return this._gltfLoader;
    }
    get fbxLoader() {
      if (!this._fbxLoader)
        this._fbxLoader = new FBXLoader();
      return this._fbxLoader;
    }
    preload(key, url) {
      return __awaiter(this, void 0, void 0, function* () {
        this.cache.add(key, url);
        return new Promise((resolve) => {
          const isModel = /\.fbx$|\.glb$|\.gltf$/.test(url);
          const isTexture = /\.jpe?g$|\.png$/.test(url);
          if (isTexture) {
            this.textureLoader.load(url, (texture) => {
              return resolve(texture);
            });
          } else {
            if (isModel)
              this.fileLoader.setResponseType("arraybuffer");
            this.fileLoader.load(url, (file) => {
              return resolve(file);
            });
          }
        });
      });
    }
    textureAtlas(texture, json, _type = "JSONHash") {
      return __awaiter(this, void 0, void 0, function* () {
        let parsed = JSON.parse(yield this.file(json));
        const isJSONArray = parsed.textures;
        if (isJSONArray) {
          const frames = parsed.textures[0].frames;
          let jsonHash = { frames: {} };
          frames.forEach((frame) => {
            jsonHash = Object.assign(Object.assign({}, jsonHash), { frames: Object.assign(Object.assign({}, jsonHash.frames), { [frame.filename]: {
              frame: frame.frame,
              rotated: frame.rotated,
              sourceSize: frame.sourceSize,
              spriteSourceSize: frame.spriteSourceSize,
              trimmed: frame.trimmed
            } }) });
          });
          parsed = jsonHash;
        }
        const atlas = {
          texture: yield this.texture(texture),
          json: parsed
        };
        return atlas;
      });
    }
    file(url) {
      const key = this.cache.get(url);
      url = key ? key : url;
      return new Promise((resolve) => {
        this.fileLoader.load(url, (file) => {
          return resolve(file);
        });
      });
    }
    svg(url) {
      const key = this.cache.get(url);
      url = key ? key : url;
      return new Promise((resolve) => {
        this.svgLoader.load(url, (svg) => {
          return resolve(svg);
        });
      });
    }
    texture(url) {
      const isBase64 = /^data:image\/[\S]+;base64,/gm.test(url);
      if (!isBase64) {
        const key = this.cache.get(url);
        url = key ? key : url;
      }
      return new Promise((resolve) => {
        this.textureLoader.load(url, (texture) => {
          texture.anisotropy = this.textureAnisotropy;
          texture.needsUpdate = true;
          resolve(texture);
        });
      });
    }
    object(url) {
      const key = this.cache.get(url);
      url = key ? key : url;
      return new Promise((resolve) => {
        this.objectLoader.load(url, (json) => {
          resolve(json);
        });
      });
    }
    gltf(url) {
      const key = this.cache.get(url);
      url = key ? key : url;
      return new Promise((resolve) => {
        this.gltfLoader.load(url, (gltf) => {
          resolve(gltf);
        });
      });
    }
    fbx(url) {
      const key = this.cache.get(url);
      url = key ? key : url;
      return new Promise((resolve) => {
        this.fbxLoader.load(url, (fbx) => {
          resolve(fbx);
        });
      });
    }
  };

  // node_modules/@enable3d/three-graphics/jsm/plugins/lights.js
  var PointLightHelper = class extends Object3D {
    constructor(scene, light, size2, color) {
      super();
      this.scene = scene;
      this.light = light;
      this.size = size2;
      this.color = color;
      this.geo = new SphereGeometry(size2 || 0.2, 16, 8);
      this.mat = new MeshBasicMaterial({ color: color || light.color });
      this.mesh = new Mesh(this.geo, this.mat);
      this.add(this.mesh);
      light.add(this);
    }
    dispose() {
      this.mesh.geometry.dispose();
      if (!Array.isArray(this.mesh.material))
        this.mesh.material.dispose();
      else
        this.mesh.material.forEach((m) => m.dispose());
      this.remove(this.mesh);
    }
    update() {
    }
  };
  var Lights = class {
    constructor(scene) {
      this.scene = scene;
    }
    get helper() {
      return {
        directionalLightHelper: (light, size2, color) => {
          const helper = new DirectionalLightHelper(light, size2, color);
          this.scene.add(helper);
          return helper;
        },
        spotLightHelper: (light, color) => {
          const helper = new SpotLightHelper(light, color);
          this.scene.add(helper);
          return helper;
        },
        pointLightHelper: (light, size2, color) => new PointLightHelper(this.scene, light, size2, color)
      };
    }
    directionalLight(options = {}) {
      const { color = 16777215, intensity = 1 } = options;
      const light = new DirectionalLight(color, intensity);
      light.castShadow = true;
      this.scene.add(light);
      return light;
    }
    hemisphereLight(options = {}) {
      const { skyColor = 16777215, groundColor = 16777215, intensity = 1 } = options;
      const light = new HemisphereLight(skyColor, groundColor, intensity);
      this.scene.add(light);
      return light;
    }
    ambientLight(options = {}) {
      const { color = 16777215, intensity = 1 } = options;
      const light = new AmbientLight(color, intensity);
      this.scene.add(light);
      return light;
    }
    pointLight(options = {}) {
      const { color = 16777215, intensity = 1, distance = 0, decay = 1 } = options;
      const light = new PointLight(color, intensity, distance, decay);
      light.castShadow = true;
      this.scene.add(light);
      return light;
    }
    spotLight(options = {}) {
      const { color = 16777215, intensity = 1, distance = 0, angle = Math.PI / 8, penumbra = 0, decay = 1 } = options;
      const light = new SpotLight(color, intensity, distance, angle, penumbra, decay);
      light.castShadow = true;
      this.scene.add(light);
      return light;
    }
    rectAreaLight(options = {}) {
      const { color = 16777215, intensity = 1, width = 10, height = 10 } = options;
      const light = new RectAreaLight(color, intensity, width, height);
      this.scene.add(light);
      return light;
    }
  };

  // node_modules/@enable3d/common/dist/extendedMesh.js
  var ExtendedMesh = class extends Mesh {
    constructor(geometry, material) {
      super(geometry, material);
      this.isExtendedMesh = true;
      this.isGroup = false;
      this.vector3 = new Vector3();
      this.hasBody = false;
      this.fragmentDepth = 0;
      this.breakable = false;
      this.fractureImpulse = 1;
      this.name = `object-${this.id}`;
    }
    get world() {
      return {
        theta: this.worldTheta,
        phi: this.worldPhi
      };
    }
    get worldTheta() {
      this.getWorldDirection(this.vector3);
      return Math.atan2(this.vector3.x, this.vector3.z);
    }
    get worldPhi() {
      this.getWorldDirection(this.vector3);
      return Math.acos(this.vector3.y);
    }
  };

  // node_modules/@enable3d/common/dist/logger.js
  var loggerCache = new Map();
  var LOG_LIMIT = 5;
  var logger = (msg, error = false) => {
    if (!loggerCache.has(msg)) {
      loggerCache.set(msg, 1);
    } else {
      const count = loggerCache.get(msg);
      if (typeof count === "undefined")
        return;
      if (count >= LOG_LIMIT)
        return;
      loggerCache.set(msg, count + 1);
    }
    if (error)
      console.error(`%c [enable3d] ${msg} `, "background: #222; color: #bada55");
    else
      console.warn(`%c [enable3d] ${msg} `, "background: #222; color: #bada55");
  };

  // node_modules/@enable3d/common/dist/defaultMaterial.js
  var DefaultMaterial = class {
    constructor() {
      this._defaultMaterial = new MeshLambertMaterial({ color: 13421772 });
    }
    get() {
      return this._defaultMaterial;
    }
  };
  var defaultMaterial_default = DefaultMaterial;

  // node_modules/@enable3d/common/dist/factories.js
  var __rest = function(s, e) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  var Factories = class {
    constructor(scene) {
      this.scene = scene;
      this.isHeadless = scene === "headless" ? true : false;
      this.defaultMaterial = new defaultMaterial_default();
    }
    get make() {
      return {
        plane: (planeConfig = {}, materialConfig = {}) => this.makePlane(planeConfig, materialConfig),
        box: (boxConfig = {}, materialConfig = {}) => this.makeBox(boxConfig, materialConfig),
        sphere: (sphereConfig = {}, materialConfig = {}) => this.makeSphere(sphereConfig, materialConfig),
        cylinder: (cylinderConfig = {}, materialConfig = {}) => this.makeCylinder(cylinderConfig, materialConfig),
        cone: (coneConfig = {}, materialConfig = {}) => this.makeCone(coneConfig, materialConfig),
        torus: (torusConfig = {}, materialConfig = {}) => this.makeTorus(torusConfig, materialConfig),
        extrude: (extrudeConfig, materialConfig = {}) => this.makeExtrude(extrudeConfig, materialConfig)
      };
    }
    get add() {
      return {
        mesh: (mesh) => this.addMesh(mesh),
        existing: (object) => this.addExisting(object),
        plane: (planeConfig = {}, materialConfig = {}) => this.addPlane(planeConfig, materialConfig),
        box: (boxConfig = {}, materialConfig = {}) => this.addBox(boxConfig, materialConfig),
        ground: (groundConfig, materialConfig = {}) => this.addGround(groundConfig, materialConfig),
        sphere: (sphereConfig = {}, materialConfig = {}) => this.addSphere(sphereConfig, materialConfig),
        cylinder: (cylinderConfig = {}, materialConfig = {}) => this.addCylinder(cylinderConfig, materialConfig),
        cone: (coneConfig = {}, materialConfig = {}) => this.addCone(coneConfig, materialConfig),
        torus: (torusConfig = {}, materialConfig = {}) => this.addTorus(torusConfig, materialConfig),
        extrude: (extrudeConfig, materialConfig = {}) => this.addExtrude(extrudeConfig, materialConfig),
        material: (materialConfig = {}) => this.addMaterial(materialConfig)
      };
    }
    addExisting(...object) {
      if (this.scene === "headless")
        return;
      this.scene.add(...object);
    }
    addMesh(mesh) {
      if (Array.isArray(mesh)) {
        for (let i = 0; i < mesh.length; i++) {
          this.addExisting(mesh[i]);
        }
      } else {
        this.addExisting(mesh);
      }
      return this;
    }
    createMesh(geometry, material, position) {
      const { x = 0, y = 0, z = 0 } = position;
      let obj;
      switch (!Array.isArray(material) && material.type) {
        case "LineBasicMaterial":
          obj = new Line(geometry, material);
          break;
        case "PointsMaterial":
          obj = new Points(geometry, material);
          break;
        default:
          obj = new ExtendedMesh(geometry, material);
          break;
      }
      obj.position.set(x, y, z);
      obj.castShadow = obj.receiveShadow = true;
      return obj;
    }
    makeExtrude(extrudeConfig, materialConfig) {
      const { x, y, z, name, shape, autoCenter = true, breakable = false } = extrudeConfig, rest = __rest(extrudeConfig, ["x", "y", "z", "name", "shape", "autoCenter", "breakable"]);
      const { depth = 1, bevelEnabled = false } = rest;
      const geometry = new ExtrudeGeometry(shape, Object.assign({ depth, bevelEnabled }, rest));
      const material = this.addMaterial(materialConfig);
      const mesh = this.createMesh(geometry, material, { x, y, z });
      if (autoCenter)
        mesh.geometry.center();
      mesh.name = name || `body_id_${mesh.id}`;
      mesh.shape = "extrude";
      return mesh;
    }
    addExtrude(extrudeConfig, materialConfig = {}) {
      const obj = this.makeExtrude(extrudeConfig, materialConfig);
      this.addExisting(obj);
      return obj;
    }
    makePlane(planeConfig, materialConfig) {
      const { x, y, z, name, breakable = false } = planeConfig, rest = __rest(planeConfig, ["x", "y", "z", "name", "breakable"]);
      const geometry = new PlaneGeometry(rest.width || 1, rest.height || 1, rest.widthSegments || 1, rest.heightSegments || 1);
      const material = this.addMaterial(materialConfig);
      material.side = DoubleSide;
      const mesh = this.createMesh(geometry, material, { x, y, z });
      mesh.name = name || `body_id_${mesh.id}`;
      mesh.shape = "plane";
      return mesh;
    }
    addPlane(planeConfig, materialConfig) {
      const obj = this.makePlane(planeConfig, materialConfig);
      this.addExisting(obj);
      return obj;
    }
    makeSphere(sphereConfig, materialConfig) {
      const { x, y, z, name, breakable = false } = sphereConfig, rest = __rest(sphereConfig, ["x", "y", "z", "name", "breakable"]);
      const geometry = new SphereGeometry(rest.radius || 1, rest.widthSegments || 16, rest.heightSegments || 12, rest.phiStart || void 0, rest.phiLength || void 0, rest.thetaStart || void 0, rest.thetaLength || void 0);
      const material = this.addMaterial(materialConfig);
      const mesh = this.createMesh(geometry, material, { x, y, z });
      mesh.name = name || `body_id_${mesh.id}`;
      mesh.shape = "sphere";
      return mesh;
    }
    addSphere(sphereConfig = {}, materialConfig = {}) {
      const obj = this.makeSphere(sphereConfig, materialConfig);
      this.addExisting(obj);
      return obj;
    }
    makeBox(boxConfig, materialConfig) {
      const { x, y, z, name, breakable = false } = boxConfig, rest = __rest(boxConfig, ["x", "y", "z", "name", "breakable"]);
      const geometry = new BoxGeometry(rest.width || 1, rest.height || 1, rest.depth || 1, rest.widthSegments || void 0, rest.heightSegments || void 0, rest.depthSegments || void 0);
      const material = this.addMaterial(materialConfig);
      const mesh = this.createMesh(geometry, material, { x, y, z });
      mesh.name = name || `body_id_${mesh.id}`;
      mesh.shape = "box";
      return mesh;
    }
    addBox(boxConfig = {}, materialConfig = {}) {
      const obj = this.makeBox(boxConfig, materialConfig);
      this.addExisting(obj);
      return obj;
    }
    addGround(groundConfig, materialConfig = {}) {
      const obj = this.makeBox(groundConfig, materialConfig);
      obj.rotateX(MathUtils.degToRad(90));
      this.addExisting(obj);
      return obj;
    }
    makeCylinder(cylinderConfig = {}, materialConfig = {}) {
      const { x, y, z, name, breakable = false } = cylinderConfig, rest = __rest(cylinderConfig, ["x", "y", "z", "name", "breakable"]);
      const geometry = new CylinderGeometry(rest.radiusTop || 1, rest.radiusBottom || 1, rest.height || 1, rest.radiusSegments || void 0, rest.heightSegments || void 0, rest.openEnded || void 0, rest.thetaStart || void 0, rest.thetaLength || void 0);
      const material = this.addMaterial(materialConfig);
      const mesh = this.createMesh(geometry, material, { x, y, z });
      mesh.name = name || `body_id_${mesh.id}`;
      mesh.shape = "cylinder";
      return mesh;
    }
    addCylinder(cylinderConfig = {}, materialConfig = {}) {
      const obj = this.makeCylinder(cylinderConfig, materialConfig);
      this.addExisting(obj);
      return obj;
    }
    makeCone(coneConfig = {}, materialConfig = {}) {
      const { x, y, z, name, breakable = false } = coneConfig, rest = __rest(coneConfig, ["x", "y", "z", "name", "breakable"]);
      const geometry = new ConeGeometry(rest.radius || 1, rest.height || 1, rest.radiusSegments || 8, rest.heightSegments || 1, rest.openEnded || false, rest.thetaStart || 0, rest.thetaLength || 2 * Math.PI);
      const material = this.addMaterial(materialConfig);
      const mesh = this.createMesh(geometry, material, { x, y, z });
      mesh.name = name || `body_id_${mesh.id}`;
      mesh.shape = "cone";
      return mesh;
    }
    addCone(coneConfig = {}, materialConfig = {}) {
      const obj = this.makeCone(coneConfig, materialConfig);
      this.addExisting(obj);
      return obj;
    }
    makeTorus(torusConfig = {}, materialConfig = {}) {
      const { x, y, z, name, breakable = false } = torusConfig, rest = __rest(torusConfig, ["x", "y", "z", "name", "breakable"]);
      const geometry = new TorusGeometry(rest.radius || void 0, rest.tube || void 0, rest.radialSegments || void 0, rest.tubularSegments || void 0, rest.arc || void 0);
      const material = this.addMaterial(materialConfig);
      const mesh = this.createMesh(geometry, material, { x, y, z });
      mesh.name = name || `body_id_${mesh.id}`;
      mesh.shape = "torus";
      return mesh;
    }
    addTorus(torusConfig = {}, materialConfig = {}) {
      const obj = this.makeTorus(torusConfig, materialConfig);
      this.addExisting(obj);
      return obj;
    }
    addMaterial(materialConfig = {}) {
      const type = Object.keys(materialConfig)[0];
      let material;
      if (this.scene === "headless")
        return this.defaultMaterial.get();
      switch (type) {
        case "basic":
          material = new MeshBasicMaterial(materialConfig.basic);
          break;
        case "normal":
          material = new MeshNormalMaterial(materialConfig.normal);
          break;
        case "standard":
          material = new MeshStandardMaterial(materialConfig.standard);
          break;
        case "lambert":
          material = new MeshLambertMaterial(materialConfig.lambert);
          break;
        case "phong":
          material = new MeshPhongMaterial(materialConfig.phong);
          break;
        case "physical":
          if (typeof materialConfig.physical !== "undefined") {
            material = new MeshPhysicalMaterial(materialConfig.physical);
          } else {
            logger("You need to pass parameters to the physical material. (Fallback to default material)");
            material = this.defaultMaterial.get();
          }
          break;
        case "toon":
          material = new MeshToonMaterial(materialConfig.toon);
          break;
        case "line":
          material = new LineBasicMaterial(materialConfig.line);
          break;
        case "points":
          material = new PointsMaterial(materialConfig.points);
          break;
        case "custom":
          material = materialConfig.custom || this.defaultMaterial.get();
          break;
        default:
          material = this.defaultMaterial.get();
          break;
      }
      return material;
    }
  };

  // node_modules/@enable3d/three-graphics/jsm/plugins/heightmap.js
  var HeightMap = class {
    constructor(scene) {
      this.scene = scene;
    }
    add(texture, config = {}) {
      const heightMap = this.make(texture, config);
      if (heightMap)
        this.scene.add(heightMap);
      else
        console.warn("Could not make heightmap");
      return heightMap;
    }
    make(texture, config = {}) {
      const { image } = texture;
      const { width, height } = image;
      const { colorScale } = config;
      const canvas2 = document.createElement("canvas");
      canvas2.width = width;
      canvas2.height = height;
      const ctx = canvas2.getContext("2d");
      if (!ctx)
        return;
      ctx.drawImage(texture.image, 0, 0);
      const pixel = ctx.getImageData(0, 0, width, height);
      const plane = new Geometry().fromBufferGeometry(new PlaneGeometry(10, 10, width - 1, height - 1));
      let materialConfig = { color: 13421772, side: DoubleSide };
      if (colorScale)
        materialConfig = Object.assign(Object.assign({}, materialConfig), { vertexColors: true });
      const material = new MeshPhongMaterial(materialConfig);
      const mesh = new ExtendedMesh(plane, material);
      mesh.receiveShadow = mesh.castShadow = true;
      mesh.shape = "concave";
      const geo = mesh.geometry;
      for (let i = 0; i < geo.vertices.length; i++) {
        geo.vertices[i].z = pixel.data[i * 4] / 120;
      }
      const getHighPoint = (geometry, face) => {
        var v1 = geometry.vertices[face.a].z;
        var v2 = geometry.vertices[face.b].z;
        var v3 = geometry.vertices[face.c].z;
        return Math.max(v1, v2, v3);
      };
      if (colorScale)
        geo.faces.forEach((face) => face.color = new Color(colorScale(getHighPoint(geo, face)).hex()));
      mesh.rotateX(-Math.PI / 2);
      mesh.updateMatrix();
      plane.computeFaceNormals();
      plane.computeVertexNormals();
      mesh.name = "heightmap";
      mesh.geometry = fromGeometry(new BufferGeometry(), mesh.geometry);
      return mesh;
    }
  };

  // node_modules/three/examples/jsm/controls/OrbitControls.js
  var OrbitControls = function(object, domElement) {
    if (domElement === void 0)
      console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.');
    if (domElement === document)
      console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
    this.object = object;
    this.domElement = domElement;
    this.enabled = true;
    this.target = new Vector3();
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.enableDamping = false;
    this.dampingFactor = 0.05;
    this.enableZoom = true;
    this.zoomSpeed = 1;
    this.enableRotate = true;
    this.rotateSpeed = 1;
    this.enablePan = true;
    this.panSpeed = 1;
    this.screenSpacePanning = true;
    this.keyPanSpeed = 7;
    this.autoRotate = false;
    this.autoRotateSpeed = 2;
    this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" };
    this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
    this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;
    this._domElementKeyEvents = null;
    this.getPolarAngle = function() {
      return spherical.phi;
    };
    this.getAzimuthalAngle = function() {
      return spherical.theta;
    };
    this.listenToKeyEvents = function(domElement2) {
      domElement2.addEventListener("keydown", onKeyDown);
      this._domElementKeyEvents = domElement2;
    };
    this.saveState = function() {
      scope.target0.copy(scope.target);
      scope.position0.copy(scope.object.position);
      scope.zoom0 = scope.object.zoom;
    };
    this.reset = function() {
      scope.target.copy(scope.target0);
      scope.object.position.copy(scope.position0);
      scope.object.zoom = scope.zoom0;
      scope.object.updateProjectionMatrix();
      scope.dispatchEvent(changeEvent);
      scope.update();
      state = STATE.NONE;
    };
    this.update = function() {
      var offset = new Vector3();
      var quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
      var quatInverse = quat.clone().invert();
      var lastPosition = new Vector3();
      var lastQuaternion = new Quaternion();
      var twoPI = 2 * Math.PI;
      return function update() {
        var position = scope.object.position;
        offset.copy(position).sub(scope.target);
        offset.applyQuaternion(quat);
        spherical.setFromVector3(offset);
        if (scope.autoRotate && state === STATE.NONE) {
          rotateLeft(getAutoRotationAngle());
        }
        if (scope.enableDamping) {
          spherical.theta += sphericalDelta.theta * scope.dampingFactor;
          spherical.phi += sphericalDelta.phi * scope.dampingFactor;
        } else {
          spherical.theta += sphericalDelta.theta;
          spherical.phi += sphericalDelta.phi;
        }
        var min = scope.minAzimuthAngle;
        var max = scope.maxAzimuthAngle;
        if (isFinite(min) && isFinite(max)) {
          if (min < -Math.PI)
            min += twoPI;
          else if (min > Math.PI)
            min -= twoPI;
          if (max < -Math.PI)
            max += twoPI;
          else if (max > Math.PI)
            max -= twoPI;
          if (min <= max) {
            spherical.theta = Math.max(min, Math.min(max, spherical.theta));
          } else {
            spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);
          }
        }
        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
        spherical.makeSafe();
        spherical.radius *= scale;
        spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
        if (scope.enableDamping === true) {
          scope.target.addScaledVector(panOffset, scope.dampingFactor);
        } else {
          scope.target.add(panOffset);
        }
        offset.setFromSpherical(spherical);
        offset.applyQuaternion(quatInverse);
        position.copy(scope.target).add(offset);
        scope.object.lookAt(scope.target);
        if (scope.enableDamping === true) {
          sphericalDelta.theta *= 1 - scope.dampingFactor;
          sphericalDelta.phi *= 1 - scope.dampingFactor;
          panOffset.multiplyScalar(1 - scope.dampingFactor);
        } else {
          sphericalDelta.set(0, 0, 0);
          panOffset.set(0, 0, 0);
        }
        scale = 1;
        if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
          scope.dispatchEvent(changeEvent);
          lastPosition.copy(scope.object.position);
          lastQuaternion.copy(scope.object.quaternion);
          zoomChanged = false;
          return true;
        }
        return false;
      };
    }();
    this.dispose = function() {
      scope.domElement.removeEventListener("contextmenu", onContextMenu);
      scope.domElement.removeEventListener("pointerdown", onPointerDown);
      scope.domElement.removeEventListener("wheel", onMouseWheel);
      scope.domElement.removeEventListener("touchstart", onTouchStart);
      scope.domElement.removeEventListener("touchend", onTouchEnd);
      scope.domElement.removeEventListener("touchmove", onTouchMove);
      scope.domElement.ownerDocument.removeEventListener("pointermove", onPointerMove);
      scope.domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
      if (scope._domElementKeyEvents !== null) {
        scope._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
      }
    };
    var scope = this;
    var changeEvent = { type: "change" };
    var startEvent = { type: "start" };
    var endEvent = { type: "end" };
    var STATE = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    var state = STATE.NONE;
    var EPS = 1e-6;
    var spherical = new Spherical();
    var sphericalDelta = new Spherical();
    var scale = 1;
    var panOffset = new Vector3();
    var zoomChanged = false;
    var rotateStart = new Vector2();
    var rotateEnd = new Vector2();
    var rotateDelta = new Vector2();
    var panStart = new Vector2();
    var panEnd = new Vector2();
    var panDelta = new Vector2();
    var dollyStart = new Vector2();
    var dollyEnd = new Vector2();
    var dollyDelta = new Vector2();
    function getAutoRotationAngle() {
      return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
    }
    function getZoomScale() {
      return Math.pow(0.95, scope.zoomSpeed);
    }
    function rotateLeft(angle) {
      sphericalDelta.theta -= angle;
    }
    function rotateUp(angle) {
      sphericalDelta.phi -= angle;
    }
    var panLeft = function() {
      var v = new Vector3();
      return function panLeft2(distance, objectMatrix) {
        v.setFromMatrixColumn(objectMatrix, 0);
        v.multiplyScalar(-distance);
        panOffset.add(v);
      };
    }();
    var panUp = function() {
      var v = new Vector3();
      return function panUp2(distance, objectMatrix) {
        if (scope.screenSpacePanning === true) {
          v.setFromMatrixColumn(objectMatrix, 1);
        } else {
          v.setFromMatrixColumn(objectMatrix, 0);
          v.crossVectors(scope.object.up, v);
        }
        v.multiplyScalar(distance);
        panOffset.add(v);
      };
    }();
    var pan = function() {
      var offset = new Vector3();
      return function pan2(deltaX, deltaY) {
        var element = scope.domElement;
        if (scope.object.isPerspectiveCamera) {
          var position = scope.object.position;
          offset.copy(position).sub(scope.target);
          var targetDistance = offset.length();
          targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);
          panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
          panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
        } else if (scope.object.isOrthographicCamera) {
          panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
          panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
        } else {
          console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
          scope.enablePan = false;
        }
      };
    }();
    function dollyOut(dollyScale) {
      if (scope.object.isPerspectiveCamera) {
        scale /= dollyScale;
      } else if (scope.object.isOrthographicCamera) {
        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
        scope.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        scope.enableZoom = false;
      }
    }
    function dollyIn(dollyScale) {
      if (scope.object.isPerspectiveCamera) {
        scale *= dollyScale;
      } else if (scope.object.isOrthographicCamera) {
        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
        scope.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
        scope.enableZoom = false;
      }
    }
    function handleMouseDownRotate(event) {
      rotateStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownDolly(event) {
      dollyStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownPan(event) {
      panStart.set(event.clientX, event.clientY);
    }
    function handleMouseMoveRotate(event) {
      rotateEnd.set(event.clientX, event.clientY);
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      var element = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
      rotateStart.copy(rotateEnd);
      scope.update();
    }
    function handleMouseMoveDolly(event) {
      dollyEnd.set(event.clientX, event.clientY);
      dollyDelta.subVectors(dollyEnd, dollyStart);
      if (dollyDelta.y > 0) {
        dollyOut(getZoomScale());
      } else if (dollyDelta.y < 0) {
        dollyIn(getZoomScale());
      }
      dollyStart.copy(dollyEnd);
      scope.update();
    }
    function handleMouseMovePan(event) {
      panEnd.set(event.clientX, event.clientY);
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
      scope.update();
    }
    function handleMouseUp() {
    }
    function handleMouseWheel(event) {
      if (event.deltaY < 0) {
        dollyIn(getZoomScale());
      } else if (event.deltaY > 0) {
        dollyOut(getZoomScale());
      }
      scope.update();
    }
    function handleKeyDown(event) {
      var needsUpdate = false;
      switch (event.code) {
        case scope.keys.UP:
          pan(0, scope.keyPanSpeed);
          needsUpdate = true;
          break;
        case scope.keys.BOTTOM:
          pan(0, -scope.keyPanSpeed);
          needsUpdate = true;
          break;
        case scope.keys.LEFT:
          pan(scope.keyPanSpeed, 0);
          needsUpdate = true;
          break;
        case scope.keys.RIGHT:
          pan(-scope.keyPanSpeed, 0);
          needsUpdate = true;
          break;
      }
      if (needsUpdate) {
        event.preventDefault();
        scope.update();
      }
    }
    function handleTouchStartRotate(event) {
      if (event.touches.length == 1) {
        rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
      } else {
        var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
        var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
        rotateStart.set(x, y);
      }
    }
    function handleTouchStartPan(event) {
      if (event.touches.length == 1) {
        panStart.set(event.touches[0].pageX, event.touches[0].pageY);
      } else {
        var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
        var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
        panStart.set(x, y);
      }
    }
    function handleTouchStartDolly(event) {
      var dx = event.touches[0].pageX - event.touches[1].pageX;
      var dy = event.touches[0].pageY - event.touches[1].pageY;
      var distance = Math.sqrt(dx * dx + dy * dy);
      dollyStart.set(0, distance);
    }
    function handleTouchStartDollyPan(event) {
      if (scope.enableZoom)
        handleTouchStartDolly(event);
      if (scope.enablePan)
        handleTouchStartPan(event);
    }
    function handleTouchStartDollyRotate(event) {
      if (scope.enableZoom)
        handleTouchStartDolly(event);
      if (scope.enableRotate)
        handleTouchStartRotate(event);
    }
    function handleTouchMoveRotate(event) {
      if (event.touches.length == 1) {
        rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
      } else {
        var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
        var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
        rotateEnd.set(x, y);
      }
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
      var element = scope.domElement;
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
      rotateStart.copy(rotateEnd);
    }
    function handleTouchMovePan(event) {
      if (event.touches.length == 1) {
        panEnd.set(event.touches[0].pageX, event.touches[0].pageY);
      } else {
        var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
        var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
        panEnd.set(x, y);
      }
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
    }
    function handleTouchMoveDolly(event) {
      var dx = event.touches[0].pageX - event.touches[1].pageX;
      var dy = event.touches[0].pageY - event.touches[1].pageY;
      var distance = Math.sqrt(dx * dx + dy * dy);
      dollyEnd.set(0, distance);
      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
      dollyOut(dollyDelta.y);
      dollyStart.copy(dollyEnd);
    }
    function handleTouchMoveDollyPan(event) {
      if (scope.enableZoom)
        handleTouchMoveDolly(event);
      if (scope.enablePan)
        handleTouchMovePan(event);
    }
    function handleTouchMoveDollyRotate(event) {
      if (scope.enableZoom)
        handleTouchMoveDolly(event);
      if (scope.enableRotate)
        handleTouchMoveRotate(event);
    }
    function handleTouchEnd() {
    }
    function onPointerDown(event) {
      if (scope.enabled === false)
        return;
      switch (event.pointerType) {
        case "mouse":
        case "pen":
          onMouseDown(event);
          break;
      }
    }
    function onPointerMove(event) {
      if (scope.enabled === false)
        return;
      switch (event.pointerType) {
        case "mouse":
        case "pen":
          onMouseMove(event);
          break;
      }
    }
    function onPointerUp(event) {
      switch (event.pointerType) {
        case "mouse":
        case "pen":
          onMouseUp(event);
          break;
      }
    }
    function onMouseDown(event) {
      event.preventDefault();
      scope.domElement.focus ? scope.domElement.focus() : window.focus();
      var mouseAction;
      switch (event.button) {
        case 0:
          mouseAction = scope.mouseButtons.LEFT;
          break;
        case 1:
          mouseAction = scope.mouseButtons.MIDDLE;
          break;
        case 2:
          mouseAction = scope.mouseButtons.RIGHT;
          break;
        default:
          mouseAction = -1;
      }
      switch (mouseAction) {
        case MOUSE.DOLLY:
          if (scope.enableZoom === false)
            return;
          handleMouseDownDolly(event);
          state = STATE.DOLLY;
          break;
        case MOUSE.ROTATE:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enablePan === false)
              return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          } else {
            if (scope.enableRotate === false)
              return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          }
          break;
        case MOUSE.PAN:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enableRotate === false)
              return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          } else {
            if (scope.enablePan === false)
              return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.domElement.ownerDocument.addEventListener("pointermove", onPointerMove);
        scope.domElement.ownerDocument.addEventListener("pointerup", onPointerUp);
        scope.dispatchEvent(startEvent);
      }
    }
    function onMouseMove(event) {
      if (scope.enabled === false)
        return;
      event.preventDefault();
      switch (state) {
        case STATE.ROTATE:
          if (scope.enableRotate === false)
            return;
          handleMouseMoveRotate(event);
          break;
        case STATE.DOLLY:
          if (scope.enableZoom === false)
            return;
          handleMouseMoveDolly(event);
          break;
        case STATE.PAN:
          if (scope.enablePan === false)
            return;
          handleMouseMovePan(event);
          break;
      }
    }
    function onMouseUp(event) {
      scope.domElement.ownerDocument.removeEventListener("pointermove", onPointerMove);
      scope.domElement.ownerDocument.removeEventListener("pointerup", onPointerUp);
      if (scope.enabled === false)
        return;
      handleMouseUp(event);
      scope.dispatchEvent(endEvent);
      state = STATE.NONE;
    }
    function onMouseWheel(event) {
      if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE)
        return;
      event.preventDefault();
      scope.dispatchEvent(startEvent);
      handleMouseWheel(event);
      scope.dispatchEvent(endEvent);
    }
    function onKeyDown(event) {
      if (scope.enabled === false || scope.enablePan === false)
        return;
      handleKeyDown(event);
    }
    function onTouchStart(event) {
      if (scope.enabled === false)
        return;
      event.preventDefault();
      switch (event.touches.length) {
        case 1:
          switch (scope.touches.ONE) {
            case TOUCH.ROTATE:
              if (scope.enableRotate === false)
                return;
              handleTouchStartRotate(event);
              state = STATE.TOUCH_ROTATE;
              break;
            case TOUCH.PAN:
              if (scope.enablePan === false)
                return;
              handleTouchStartPan(event);
              state = STATE.TOUCH_PAN;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        case 2:
          switch (scope.touches.TWO) {
            case TOUCH.DOLLY_PAN:
              if (scope.enableZoom === false && scope.enablePan === false)
                return;
              handleTouchStartDollyPan(event);
              state = STATE.TOUCH_DOLLY_PAN;
              break;
            case TOUCH.DOLLY_ROTATE:
              if (scope.enableZoom === false && scope.enableRotate === false)
                return;
              handleTouchStartDollyRotate(event);
              state = STATE.TOUCH_DOLLY_ROTATE;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(startEvent);
      }
    }
    function onTouchMove(event) {
      if (scope.enabled === false)
        return;
      event.preventDefault();
      switch (state) {
        case STATE.TOUCH_ROTATE:
          if (scope.enableRotate === false)
            return;
          handleTouchMoveRotate(event);
          scope.update();
          break;
        case STATE.TOUCH_PAN:
          if (scope.enablePan === false)
            return;
          handleTouchMovePan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_PAN:
          if (scope.enableZoom === false && scope.enablePan === false)
            return;
          handleTouchMoveDollyPan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_ROTATE:
          if (scope.enableZoom === false && scope.enableRotate === false)
            return;
          handleTouchMoveDollyRotate(event);
          scope.update();
          break;
        default:
          state = STATE.NONE;
      }
    }
    function onTouchEnd(event) {
      if (scope.enabled === false)
        return;
      handleTouchEnd(event);
      scope.dispatchEvent(endEvent);
      state = STATE.NONE;
    }
    function onContextMenu(event) {
      if (scope.enabled === false)
        return;
      event.preventDefault();
    }
    scope.domElement.addEventListener("contextmenu", onContextMenu);
    scope.domElement.addEventListener("pointerdown", onPointerDown);
    scope.domElement.addEventListener("wheel", onMouseWheel);
    scope.domElement.addEventListener("touchstart", onTouchStart);
    scope.domElement.addEventListener("touchend", onTouchEnd);
    scope.domElement.addEventListener("touchmove", onTouchMove);
    this.update();
  };
  OrbitControls.prototype = Object.create(EventDispatcher.prototype);
  OrbitControls.prototype.constructor = OrbitControls;
  var MapControls = function(object, domElement) {
    OrbitControls.call(this, object, domElement);
    this.screenSpacePanning = false;
    this.mouseButtons.LEFT = MOUSE.PAN;
    this.mouseButtons.RIGHT = MOUSE.ROTATE;
    this.touches.ONE = TOUCH.PAN;
    this.touches.TWO = TOUCH.DOLLY_ROTATE;
  };
  MapControls.prototype = Object.create(EventDispatcher.prototype);
  MapControls.prototype.constructor = MapControls;

  // node_modules/@enable3d/three-graphics/jsm/plugins/warpSpeed.js
  var __awaiter2 = function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var WarpSpeed = class {
    constructor(scene, renderer, camera, lights, physics, load, factories) {
      this.scene = scene;
      this.renderer = renderer;
      this.camera = camera;
      this.lights = lights;
      this.physics = physics;
      this.load = load;
      this.factories = factories;
    }
    warpSpeed(...features) {
      return __awaiter2(this, void 0, void 0, function* () {
        let Features = {};
        const negativeFeatures = features.filter((feature) => /^-\w+/.test(feature));
        const hasNegativeFeatures = negativeFeatures.length > 0 ? true : false;
        if (features.length === 0 || hasNegativeFeatures)
          features = ["light", "camera", "lookAtCenter", "ground", "grid", "orbitControls", "fog", "sky"];
        if (hasNegativeFeatures) {
          const featuresToRemove = negativeFeatures.map((feature) => feature.substr(1));
          featuresToRemove.forEach((feature) => {
            const index = features.indexOf(feature);
            features.splice(index, 1);
          });
        }
        if (features.includes("sky")) {
          const vertexShader = [
            "varying vec3 vWorldPosition;",
            "",
            "void main() {",
            "",
            "vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
            "vWorldPosition = worldPosition.xyz;",
            "",
            "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
            "",
            "}"
          ].join("\n");
          const fragmentShader = [
            "uniform vec3 topColor;",
            "uniform vec3 bottomColor;",
            "uniform float offset;",
            "uniform float exponent;",
            "",
            "varying vec3 vWorldPosition;",
            "",
            "void main() {",
            "",
            "float h = normalize( vWorldPosition + offset ).y;",
            "gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );",
            "",
            "}"
          ].join("\n");
          const uniforms = {
            topColor: { value: new Color(30719) },
            bottomColor: { value: new Color(15595007) },
            offset: { value: 33 },
            exponent: { value: 0.6 }
          };
          var skyGeo = new SphereGeometry(500, 32, 15);
          var skyMat = new ShaderMaterial({
            uniforms,
            vertexShader,
            fragmentShader,
            side: BackSide
          });
          var sky = new Mesh(skyGeo, skyMat);
          this.scene.add(sky);
        }
        if (features.includes("camera")) {
          this.camera.position.set(0, 6, 12);
          Features = Object.assign({ camera: this.camera }, Features);
        }
        if (features.includes("light")) {
          const intensity = 0.4;
          const hemisphereLight = this.lights.hemisphereLight({ skyColor: 16777215, groundColor: 0, intensity });
          const ambientLight = this.lights.ambientLight({ color: 16777215, intensity });
          const directionalLight = this.lights.directionalLight({ color: 16777215, intensity });
          directionalLight.position.set(100, 200, 50);
          const d = 20;
          directionalLight.shadow.camera.top = d;
          directionalLight.shadow.camera.bottom = -d;
          directionalLight.shadow.camera.left = -d;
          directionalLight.shadow.camera.right = d;
          directionalLight.shadow.mapSize.set(1024, 1024);
          const lights = {
            ambientLight,
            directionalLight,
            hemisphereLight
          };
          Features = Object.assign({ lights }, Features);
        }
        if (features.includes("lookAtCenter")) {
          this.camera.lookAt(this.scene.position);
        }
        if (features.includes("ground")) {
          const addGrid = features.includes("grid");
          const gridData = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAOnAAADusBZ+q87AAAAJtJREFUeJzt0EENwDAAxLDbNP6UOxh+NEYQ5dl2drFv286598GrA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAu37AD8eaBH5JQdVbAAAAAElFTkSuQmCC";
          const texture = yield this.load.texture(gridData);
          texture.wrapS = texture.wrapT = RepeatWrapping;
          texture.repeat.set(21, 21);
          const geometry = { name: "ground", width: 21, height: 21, depth: 1, y: -0.5 };
          const material = {
            phong: { map: addGrid ? texture : null, color: 16777215 }
          };
          let ground;
          if (window.__loadPhysics) {
            ground = this.physics.add.ground(geometry, material);
            ground.body.setRestitution(1);
          } else {
            ground = this.factories.add.ground(geometry, material);
          }
          ground.receiveShadow = true;
          Features = Object.assign({ ground }, Features);
        }
        if (features.includes("orbitControls")) {
          const orbitControls = new OrbitControls(this.camera, document.getElementById("enable3d-phaser-canvas") || this.renderer.domElement);
          Features = Object.assign({ orbitControls }, Features);
        }
        return Features;
      });
    }
  };

  // node_modules/@enable3d/three-graphics/jsm/plugins/mixers.js
  var Mixers = class {
    constructor() {
      this._mixers = [];
    }
    animationMixer(root) {
      const mixer = new AnimationMixer(root);
      this.mixers.add(mixer);
      return mixer;
    }
    get mixers() {
      return {
        create: (root) => this.animationMixer(root),
        add: (animationMixer) => this._mixers.push(animationMixer),
        get: () => this._mixers,
        update: (delta) => {
          var _a;
          return (_a = this._mixers) === null || _a === void 0 ? void 0 : _a.forEach((mixer) => mixer.update(delta / 1e3));
        }
      };
    }
  };
  var mixers_default = Mixers;

  // node_modules/three/examples/jsm/objects/Reflector.js
  var Reflector = function(geometry, options) {
    Mesh.call(this, geometry);
    this.type = "Reflector";
    var scope = this;
    options = options || {};
    var color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);
    var textureWidth = options.textureWidth || 512;
    var textureHeight = options.textureHeight || 512;
    var clipBias = options.clipBias || 0;
    var shader = options.shader || Reflector.ReflectorShader;
    var reflectorPlane = new Plane();
    var normal = new Vector3();
    var reflectorWorldPosition = new Vector3();
    var cameraWorldPosition = new Vector3();
    var rotationMatrix = new Matrix4();
    var lookAtPosition = new Vector3(0, 0, -1);
    var clipPlane = new Vector4();
    var view = new Vector3();
    var target = new Vector3();
    var q = new Vector4();
    var textureMatrix = new Matrix4();
    var virtualCamera = new PerspectiveCamera();
    var parameters = {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      format: RGBFormat
    };
    var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);
    if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {
      renderTarget.texture.generateMipmaps = false;
    }
    var material = new ShaderMaterial({
      uniforms: UniformsUtils.clone(shader.uniforms),
      fragmentShader: shader.fragmentShader,
      vertexShader: shader.vertexShader
    });
    material.uniforms["tDiffuse"].value = renderTarget.texture;
    material.uniforms["color"].value = color;
    material.uniforms["textureMatrix"].value = textureMatrix;
    this.material = material;
    this.onBeforeRender = function(renderer, scene, camera) {
      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);
      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
      rotationMatrix.extractRotation(scope.matrixWorld);
      normal.set(0, 0, 1);
      normal.applyMatrix4(rotationMatrix);
      view.subVectors(reflectorWorldPosition, cameraWorldPosition);
      if (view.dot(normal) > 0)
        return;
      view.reflect(normal).negate();
      view.add(reflectorWorldPosition);
      rotationMatrix.extractRotation(camera.matrixWorld);
      lookAtPosition.set(0, 0, -1);
      lookAtPosition.applyMatrix4(rotationMatrix);
      lookAtPosition.add(cameraWorldPosition);
      target.subVectors(reflectorWorldPosition, lookAtPosition);
      target.reflect(normal).negate();
      target.add(reflectorWorldPosition);
      virtualCamera.position.copy(view);
      virtualCamera.up.set(0, 1, 0);
      virtualCamera.up.applyMatrix4(rotationMatrix);
      virtualCamera.up.reflect(normal);
      virtualCamera.lookAt(target);
      virtualCamera.far = camera.far;
      virtualCamera.updateMatrixWorld();
      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      textureMatrix.multiply(virtualCamera.projectionMatrix);
      textureMatrix.multiply(virtualCamera.matrixWorldInverse);
      textureMatrix.multiply(scope.matrixWorld);
      reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);
      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
      clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);
      var projectionMatrix = virtualCamera.projectionMatrix;
      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
      q.z = -1;
      q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
      clipPlane.multiplyScalar(2 / clipPlane.dot(q));
      projectionMatrix.elements[2] = clipPlane.x;
      projectionMatrix.elements[6] = clipPlane.y;
      projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias;
      projectionMatrix.elements[14] = clipPlane.w;
      renderTarget.texture.encoding = renderer.outputEncoding;
      scope.visible = false;
      var currentRenderTarget = renderer.getRenderTarget();
      var currentXrEnabled = renderer.xr.enabled;
      var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
      renderer.xr.enabled = false;
      renderer.shadowMap.autoUpdate = false;
      renderer.setRenderTarget(renderTarget);
      renderer.state.buffers.depth.setMask(true);
      if (renderer.autoClear === false)
        renderer.clear();
      renderer.render(scene, virtualCamera);
      renderer.xr.enabled = currentXrEnabled;
      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
      renderer.setRenderTarget(currentRenderTarget);
      var viewport = camera.viewport;
      if (viewport !== void 0) {
        renderer.state.viewport(viewport);
      }
      scope.visible = true;
    };
    this.getRenderTarget = function() {
      return renderTarget;
    };
  };
  Reflector.prototype = Object.create(Mesh.prototype);
  Reflector.prototype.constructor = Reflector;
  Reflector.ReflectorShader = {
    uniforms: {
      "color": {
        value: null
      },
      "tDiffuse": {
        value: null
      },
      "textureMatrix": {
        value: null
      }
    },
    vertexShader: [
      "uniform mat4 textureMatrix;",
      "varying vec4 vUv;",
      "void main() {",
      "	vUv = textureMatrix * vec4( position, 1.0 );",
      "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
      "}"
    ].join("\n"),
    fragmentShader: [
      "uniform vec3 color;",
      "uniform sampler2D tDiffuse;",
      "varying vec4 vUv;",
      "float blendOverlay( float base, float blend ) {",
      "	return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );",
      "}",
      "vec3 blendOverlay( vec3 base, vec3 blend ) {",
      "	return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );",
      "}",
      "void main() {",
      "	vec4 base = texture2DProj( tDiffuse, vUv );",
      "	gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );",
      "}"
    ].join("\n")
  };

  // node_modules/three/examples/jsm/objects/Refractor.js
  var Refractor = function(geometry, options) {
    Mesh.call(this, geometry);
    this.type = "Refractor";
    var scope = this;
    options = options || {};
    var color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);
    var textureWidth = options.textureWidth || 512;
    var textureHeight = options.textureHeight || 512;
    var clipBias = options.clipBias || 0;
    var shader = options.shader || Refractor.RefractorShader;
    var virtualCamera = new PerspectiveCamera();
    virtualCamera.matrixAutoUpdate = false;
    virtualCamera.userData.refractor = true;
    var refractorPlane = new Plane();
    var textureMatrix = new Matrix4();
    var parameters = {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      format: RGBFormat
    };
    var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);
    if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {
      renderTarget.texture.generateMipmaps = false;
    }
    this.material = new ShaderMaterial({
      uniforms: UniformsUtils.clone(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      transparent: true
    });
    this.material.uniforms["color"].value = color;
    this.material.uniforms["tDiffuse"].value = renderTarget.texture;
    this.material.uniforms["textureMatrix"].value = textureMatrix;
    var visible = function() {
      var refractorWorldPosition = new Vector3();
      var cameraWorldPosition = new Vector3();
      var rotationMatrix = new Matrix4();
      var view = new Vector3();
      var normal = new Vector3();
      return function visible2(camera) {
        refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);
        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
        view.subVectors(refractorWorldPosition, cameraWorldPosition);
        rotationMatrix.extractRotation(scope.matrixWorld);
        normal.set(0, 0, 1);
        normal.applyMatrix4(rotationMatrix);
        return view.dot(normal) < 0;
      };
    }();
    var updateRefractorPlane = function() {
      var normal = new Vector3();
      var position = new Vector3();
      var quaternion = new Quaternion();
      var scale = new Vector3();
      return function updateRefractorPlane2() {
        scope.matrixWorld.decompose(position, quaternion, scale);
        normal.set(0, 0, 1).applyQuaternion(quaternion).normalize();
        normal.negate();
        refractorPlane.setFromNormalAndCoplanarPoint(normal, position);
      };
    }();
    var updateVirtualCamera = function() {
      var clipPlane = new Plane();
      var clipVector = new Vector4();
      var q = new Vector4();
      return function updateVirtualCamera2(camera) {
        virtualCamera.matrixWorld.copy(camera.matrixWorld);
        virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();
        virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
        virtualCamera.far = camera.far;
        clipPlane.copy(refractorPlane);
        clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
        clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant);
        var projectionMatrix = virtualCamera.projectionMatrix;
        q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
        q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
        q.z = -1;
        q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
        clipVector.multiplyScalar(2 / clipVector.dot(q));
        projectionMatrix.elements[2] = clipVector.x;
        projectionMatrix.elements[6] = clipVector.y;
        projectionMatrix.elements[10] = clipVector.z + 1 - clipBias;
        projectionMatrix.elements[14] = clipVector.w;
      };
    }();
    function updateTextureMatrix(camera) {
      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      textureMatrix.multiply(camera.projectionMatrix);
      textureMatrix.multiply(camera.matrixWorldInverse);
      textureMatrix.multiply(scope.matrixWorld);
    }
    function render(renderer, scene, camera) {
      scope.visible = false;
      var currentRenderTarget = renderer.getRenderTarget();
      var currentXrEnabled = renderer.xr.enabled;
      var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
      renderer.xr.enabled = false;
      renderer.shadowMap.autoUpdate = false;
      renderer.setRenderTarget(renderTarget);
      if (renderer.autoClear === false)
        renderer.clear();
      renderer.render(scene, virtualCamera);
      renderer.xr.enabled = currentXrEnabled;
      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
      renderer.setRenderTarget(currentRenderTarget);
      var viewport = camera.viewport;
      if (viewport !== void 0) {
        renderer.state.viewport(viewport);
      }
      scope.visible = true;
    }
    this.onBeforeRender = function(renderer, scene, camera) {
      renderTarget.texture.encoding = renderer.outputEncoding;
      if (camera.userData.refractor === true)
        return;
      if (!visible(camera) === true)
        return;
      updateRefractorPlane();
      updateTextureMatrix(camera);
      updateVirtualCamera(camera);
      render(renderer, scene, camera);
    };
    this.getRenderTarget = function() {
      return renderTarget;
    };
  };
  Refractor.prototype = Object.create(Mesh.prototype);
  Refractor.prototype.constructor = Refractor;
  Refractor.RefractorShader = {
    uniforms: {
      "color": {
        value: null
      },
      "tDiffuse": {
        value: null
      },
      "textureMatrix": {
        value: null
      }
    },
    vertexShader: [
      "uniform mat4 textureMatrix;",
      "varying vec4 vUv;",
      "void main() {",
      "	vUv = textureMatrix * vec4( position, 1.0 );",
      "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
      "}"
    ].join("\n"),
    fragmentShader: [
      "uniform vec3 color;",
      "uniform sampler2D tDiffuse;",
      "varying vec4 vUv;",
      "float blendOverlay( float base, float blend ) {",
      "	return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );",
      "}",
      "vec3 blendOverlay( vec3 base, vec3 blend ) {",
      "	return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );",
      "}",
      "void main() {",
      "	vec4 base = texture2DProj( tDiffuse, vUv );",
      "	gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );",
      "}"
    ].join("\n")
  };

  // node_modules/three/examples/jsm/objects/Water2.js
  var Water = function(geometry, options) {
    Mesh.call(this, geometry);
    this.type = "Water";
    var scope = this;
    options = options || {};
    var color = options.color !== void 0 ? new Color(options.color) : new Color(16777215);
    var textureWidth = options.textureWidth || 512;
    var textureHeight = options.textureHeight || 512;
    var clipBias = options.clipBias || 0;
    var flowDirection = options.flowDirection || new Vector2(1, 0);
    var flowSpeed = options.flowSpeed || 0.03;
    var reflectivity = options.reflectivity || 0.02;
    var scale = options.scale || 1;
    var shader = options.shader || Water.WaterShader;
    var encoding = options.encoding !== void 0 ? options.encoding : LinearEncoding;
    var textureLoader = new TextureLoader();
    var flowMap = options.flowMap || void 0;
    var normalMap0 = options.normalMap0 || textureLoader.load("textures/water/Water_1_M_Normal.jpg");
    var normalMap1 = options.normalMap1 || textureLoader.load("textures/water/Water_2_M_Normal.jpg");
    var cycle = 0.15;
    var halfCycle = cycle * 0.5;
    var textureMatrix = new Matrix4();
    var clock = new Clock();
    if (Reflector === void 0) {
      console.error("THREE.Water: Required component Reflector not found.");
      return;
    }
    if (Refractor === void 0) {
      console.error("THREE.Water: Required component Refractor not found.");
      return;
    }
    var reflector = new Reflector(geometry, {
      textureWidth,
      textureHeight,
      clipBias,
      encoding
    });
    var refractor = new Refractor(geometry, {
      textureWidth,
      textureHeight,
      clipBias,
      encoding
    });
    reflector.matrixAutoUpdate = false;
    refractor.matrixAutoUpdate = false;
    this.material = new ShaderMaterial({
      uniforms: UniformsUtils.merge([
        UniformsLib["fog"],
        shader.uniforms
      ]),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      transparent: true,
      fog: true
    });
    if (flowMap !== void 0) {
      this.material.defines.USE_FLOWMAP = "";
      this.material.uniforms["tFlowMap"] = {
        type: "t",
        value: flowMap
      };
    } else {
      this.material.uniforms["flowDirection"] = {
        type: "v2",
        value: flowDirection
      };
    }
    normalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;
    normalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;
    this.material.uniforms["tReflectionMap"].value = reflector.getRenderTarget().texture;
    this.material.uniforms["tRefractionMap"].value = refractor.getRenderTarget().texture;
    this.material.uniforms["tNormalMap0"].value = normalMap0;
    this.material.uniforms["tNormalMap1"].value = normalMap1;
    this.material.uniforms["color"].value = color;
    this.material.uniforms["reflectivity"].value = reflectivity;
    this.material.uniforms["textureMatrix"].value = textureMatrix;
    this.material.uniforms["config"].value.x = 0;
    this.material.uniforms["config"].value.y = halfCycle;
    this.material.uniforms["config"].value.z = halfCycle;
    this.material.uniforms["config"].value.w = scale;
    function updateTextureMatrix(camera) {
      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      textureMatrix.multiply(camera.projectionMatrix);
      textureMatrix.multiply(camera.matrixWorldInverse);
      textureMatrix.multiply(scope.matrixWorld);
    }
    function updateFlow() {
      var delta = clock.getDelta();
      var config = scope.material.uniforms["config"];
      config.value.x += flowSpeed * delta;
      config.value.y = config.value.x + halfCycle;
      if (config.value.x >= cycle) {
        config.value.x = 0;
        config.value.y = halfCycle;
      } else if (config.value.y >= cycle) {
        config.value.y = config.value.y - cycle;
      }
    }
    this.onBeforeRender = function(renderer, scene, camera) {
      updateTextureMatrix(camera);
      updateFlow();
      scope.visible = false;
      reflector.matrixWorld.copy(scope.matrixWorld);
      refractor.matrixWorld.copy(scope.matrixWorld);
      reflector.onBeforeRender(renderer, scene, camera);
      refractor.onBeforeRender(renderer, scene, camera);
      scope.visible = true;
    };
  };
  Water.prototype = Object.create(Mesh.prototype);
  Water.prototype.constructor = Water;
  Water.WaterShader = {
    uniforms: {
      "color": {
        type: "c",
        value: null
      },
      "reflectivity": {
        type: "f",
        value: 0
      },
      "tReflectionMap": {
        type: "t",
        value: null
      },
      "tRefractionMap": {
        type: "t",
        value: null
      },
      "tNormalMap0": {
        type: "t",
        value: null
      },
      "tNormalMap1": {
        type: "t",
        value: null
      },
      "textureMatrix": {
        type: "m4",
        value: null
      },
      "config": {
        type: "v4",
        value: new Vector4()
      }
    },
    vertexShader: [
      "#include <common>",
      "#include <fog_pars_vertex>",
      "#include <logdepthbuf_pars_vertex>",
      "uniform mat4 textureMatrix;",
      "varying vec4 vCoord;",
      "varying vec2 vUv;",
      "varying vec3 vToEye;",
      "void main() {",
      "	vUv = uv;",
      "	vCoord = textureMatrix * vec4( position, 1.0 );",
      "	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
      "	vToEye = cameraPosition - worldPosition.xyz;",
      "	vec4 mvPosition =  viewMatrix * worldPosition;",
      "	gl_Position = projectionMatrix * mvPosition;",
      "	#include <logdepthbuf_vertex>",
      "	#include <fog_vertex>",
      "}"
    ].join("\n"),
    fragmentShader: [
      "#include <common>",
      "#include <fog_pars_fragment>",
      "#include <logdepthbuf_pars_fragment>",
      "uniform sampler2D tReflectionMap;",
      "uniform sampler2D tRefractionMap;",
      "uniform sampler2D tNormalMap0;",
      "uniform sampler2D tNormalMap1;",
      "#ifdef USE_FLOWMAP",
      "	uniform sampler2D tFlowMap;",
      "#else",
      "	uniform vec2 flowDirection;",
      "#endif",
      "uniform vec3 color;",
      "uniform float reflectivity;",
      "uniform vec4 config;",
      "varying vec4 vCoord;",
      "varying vec2 vUv;",
      "varying vec3 vToEye;",
      "void main() {",
      "	#include <logdepthbuf_fragment>",
      "	float flowMapOffset0 = config.x;",
      "	float flowMapOffset1 = config.y;",
      "	float halfCycle = config.z;",
      "	float scale = config.w;",
      "	vec3 toEye = normalize( vToEye );",
      "	vec2 flow;",
      "	#ifdef USE_FLOWMAP",
      "		flow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;",
      "	#else",
      "		flow = flowDirection;",
      "	#endif",
      "	flow.x *= - 1.0;",
      "	vec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );",
      "	vec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );",
      "	float flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;",
      "	vec4 normalColor = mix( normalColor0, normalColor1, flowLerp );",
      "	vec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );",
      "	float theta = max( dot( toEye, normal ), 0.0 );",
      "	float reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );",
      "	vec3 coord = vCoord.xyz / vCoord.w;",
      "	vec2 uv = coord.xy + coord.z * normal.xz * 0.05;",
      "	vec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );",
      "	vec4 refractColor = texture2D( tRefractionMap, uv );",
      "	gl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );",
      "	#include <tonemapping_fragment>",
      "	#include <encodings_fragment>",
      "	#include <fog_fragment>",
      "}"
    ].join("\n")
  };

  // node_modules/@enable3d/three-graphics/jsm/plugins/water.js
  var addWater = (scene, renderer, config = {}) => {
    const { width = 20, height = 20, x = 0, y = 0, z = 0, color = "#ffffff", scale = 4, flowX = 1, flowY = 1, normalMap0 = void 0, normalMap1 = void 0 } = config;
    const groundGeometry = new PlaneGeometry(width, height);
    const groundMaterial = new MeshStandardMaterial({ color: 30654, transparent: true, opacity: 0.8 });
    const ground = new Mesh(groundGeometry, groundMaterial);
    ground.position.set(x, y, z);
    ground.rotation.x = Math.PI * -0.5;
    scene.add(ground);
    const waterGeometry = new PlaneGeometry(width, height);
    const water = new Water(waterGeometry, {
      color,
      scale,
      flowDirection: new Vector2(flowX, flowY),
      textureWidth: 1024,
      textureHeight: 1024,
      normalMap0,
      normalMap1,
      encoding: renderer.outputEncoding
    });
    water.position.set(x, y + 0.1, z);
    water.rotation.x = Math.PI * -0.5;
    scene.add(water);
    return { ground, water };
  };

  // node_modules/@enable3d/three-graphics/jsm/plugins/misc.js
  var Misc = class {
    constructor(scene, renderer, factories) {
      this.scene = scene;
      this.renderer = renderer;
      this.factories = factories;
    }
    water(config = {}) {
      addWater(this.scene, this.renderer, config);
    }
    textureCube(textures) {
      if (textures.length !== 6) {
        logger("You need to pass 6 urls to textureCube()");
      }
      const textureCube = new TextureCube();
      textures.forEach((texture, i) => {
        texture.wrapS = texture.wrapT = RepeatWrapping;
        const material = this.factories.add.material({ phong: { map: texture } });
        textureCube.materials[i] = material;
      });
      return textureCube;
    }
  };
  var TextureCube = class {
    constructor() {
      this.materials = new Array(6);
    }
    get texture() {
      return {
        left: this.getTexture(0),
        right: this.getTexture(1),
        up: this.getTexture(2),
        down: this.getTexture(3),
        front: this.getTexture(4),
        back: this.getTexture(5)
      };
    }
    getTexture(i) {
      return this.materials[i].map;
    }
  };

  // node_modules/three/examples/jsm/webxr/VRButton.js
  var VRButton = class {
    static createButton(renderer, options) {
      if (options) {
        console.error('THREE.VRButton: The "options" parameter has been removed. Please set the reference space type via renderer.xr.setReferenceSpaceType() instead.');
      }
      const button = document.createElement("button");
      function showEnterVR() {
        let currentSession = null;
        async function onSessionStarted(session) {
          session.addEventListener("end", onSessionEnded);
          await renderer.xr.setSession(session);
          button.textContent = "EXIT VR";
          currentSession = session;
        }
        function onSessionEnded() {
          currentSession.removeEventListener("end", onSessionEnded);
          button.textContent = "ENTER VR";
          currentSession = null;
        }
        button.style.display = "";
        button.style.cursor = "pointer";
        button.style.left = "calc(50% - 50px)";
        button.style.width = "100px";
        button.textContent = "ENTER VR";
        button.onmouseenter = function() {
          button.style.opacity = "1.0";
        };
        button.onmouseleave = function() {
          button.style.opacity = "0.5";
        };
        button.onclick = function() {
          if (currentSession === null) {
            const sessionInit = { optionalFeatures: ["local-floor", "bounded-floor", "hand-tracking"] };
            navigator.xr.requestSession("immersive-vr", sessionInit).then(onSessionStarted);
          } else {
            currentSession.end();
          }
        };
      }
      function disableButton() {
        button.style.display = "";
        button.style.cursor = "auto";
        button.style.left = "calc(50% - 75px)";
        button.style.width = "150px";
        button.onmouseenter = null;
        button.onmouseleave = null;
        button.onclick = null;
      }
      function showWebXRNotFound() {
        disableButton();
        button.textContent = "VR NOT SUPPORTED";
      }
      function stylizeElement(element) {
        element.style.position = "absolute";
        element.style.bottom = "20px";
        element.style.padding = "12px 6px";
        element.style.border = "1px solid #fff";
        element.style.borderRadius = "4px";
        element.style.background = "rgba(0,0,0,0.1)";
        element.style.color = "#fff";
        element.style.font = "normal 13px sans-serif";
        element.style.textAlign = "center";
        element.style.opacity = "0.5";
        element.style.outline = "none";
        element.style.zIndex = "999";
      }
      if ("xr" in navigator) {
        button.id = "VRButton";
        button.style.display = "none";
        stylizeElement(button);
        navigator.xr.isSessionSupported("immersive-vr").then(function(supported) {
          supported ? showEnterVR() : showWebXRNotFound();
        });
        return button;
      } else {
        const message = document.createElement("a");
        if (window.isSecureContext === false) {
          message.href = document.location.href.replace(/^http:/, "https:");
          message.innerHTML = "WEBXR NEEDS HTTPS";
        } else {
          message.href = "https://immersiveweb.dev/";
          message.innerHTML = "WEBXR NOT AVAILABLE";
        }
        message.style.left = "calc(50% - 90px)";
        message.style.width = "180px";
        message.style.textDecoration = "none";
        stylizeElement(message);
        return message;
      }
    }
  };

  // node_modules/three/examples/jsm/libs/motion-controllers.module.js
  var Constants = {
    Handedness: Object.freeze({
      NONE: "none",
      LEFT: "left",
      RIGHT: "right"
    }),
    ComponentState: Object.freeze({
      DEFAULT: "default",
      TOUCHED: "touched",
      PRESSED: "pressed"
    }),
    ComponentProperty: Object.freeze({
      BUTTON: "button",
      X_AXIS: "xAxis",
      Y_AXIS: "yAxis",
      STATE: "state"
    }),
    ComponentType: Object.freeze({
      TRIGGER: "trigger",
      SQUEEZE: "squeeze",
      TOUCHPAD: "touchpad",
      THUMBSTICK: "thumbstick",
      BUTTON: "button"
    }),
    ButtonTouchThreshold: 0.05,
    AxisTouchThreshold: 0.1,
    VisualResponseProperty: Object.freeze({
      TRANSFORM: "transform",
      VISIBILITY: "visibility"
    })
  };
  async function fetchJsonFile(path) {
    const response = await fetch(path);
    if (!response.ok) {
      throw new Error(response.statusText);
    } else {
      return response.json();
    }
  }
  async function fetchProfilesList(basePath) {
    if (!basePath) {
      throw new Error("No basePath supplied");
    }
    const profileListFileName = "profilesList.json";
    const profilesList = await fetchJsonFile(`${basePath}/${profileListFileName}`);
    return profilesList;
  }
  async function fetchProfile(xrInputSource, basePath, defaultProfile = null, getAssetPath = true) {
    if (!xrInputSource) {
      throw new Error("No xrInputSource supplied");
    }
    if (!basePath) {
      throw new Error("No basePath supplied");
    }
    const supportedProfilesList = await fetchProfilesList(basePath);
    let match;
    xrInputSource.profiles.some((profileId) => {
      const supportedProfile = supportedProfilesList[profileId];
      if (supportedProfile) {
        match = {
          profileId,
          profilePath: `${basePath}/${supportedProfile.path}`,
          deprecated: !!supportedProfile.deprecated
        };
      }
      return !!match;
    });
    if (!match) {
      if (!defaultProfile) {
        throw new Error("No matching profile name found");
      }
      const supportedProfile = supportedProfilesList[defaultProfile];
      if (!supportedProfile) {
        throw new Error(`No matching profile name found and default profile "${defaultProfile}" missing.`);
      }
      match = {
        profileId: defaultProfile,
        profilePath: `${basePath}/${supportedProfile.path}`,
        deprecated: !!supportedProfile.deprecated
      };
    }
    const profile = await fetchJsonFile(match.profilePath);
    let assetPath;
    if (getAssetPath) {
      let layout;
      if (xrInputSource.handedness === "any") {
        layout = profile.layouts[Object.keys(profile.layouts)[0]];
      } else {
        layout = profile.layouts[xrInputSource.handedness];
      }
      if (!layout) {
        throw new Error(`No matching handedness, ${xrInputSource.handedness}, in profile ${match.profileId}`);
      }
      if (layout.assetPath) {
        assetPath = match.profilePath.replace("profile.json", layout.assetPath);
      }
    }
    return { profile, assetPath };
  }
  var defaultComponentValues = {
    xAxis: 0,
    yAxis: 0,
    button: 0,
    state: Constants.ComponentState.DEFAULT
  };
  function normalizeAxes(x = 0, y = 0) {
    let xAxis = x;
    let yAxis = y;
    const hypotenuse = Math.sqrt(x * x + y * y);
    if (hypotenuse > 1) {
      const theta = Math.atan2(y, x);
      xAxis = Math.cos(theta);
      yAxis = Math.sin(theta);
    }
    const result = {
      normalizedXAxis: xAxis * 0.5 + 0.5,
      normalizedYAxis: yAxis * 0.5 + 0.5
    };
    return result;
  }
  var VisualResponse = class {
    constructor(visualResponseDescription) {
      this.componentProperty = visualResponseDescription.componentProperty;
      this.states = visualResponseDescription.states;
      this.valueNodeName = visualResponseDescription.valueNodeName;
      this.valueNodeProperty = visualResponseDescription.valueNodeProperty;
      if (this.valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM) {
        this.minNodeName = visualResponseDescription.minNodeName;
        this.maxNodeName = visualResponseDescription.maxNodeName;
      }
      this.value = 0;
      this.updateFromComponent(defaultComponentValues);
    }
    updateFromComponent({
      xAxis,
      yAxis,
      button,
      state
    }) {
      const { normalizedXAxis, normalizedYAxis } = normalizeAxes(xAxis, yAxis);
      switch (this.componentProperty) {
        case Constants.ComponentProperty.X_AXIS:
          this.value = this.states.includes(state) ? normalizedXAxis : 0.5;
          break;
        case Constants.ComponentProperty.Y_AXIS:
          this.value = this.states.includes(state) ? normalizedYAxis : 0.5;
          break;
        case Constants.ComponentProperty.BUTTON:
          this.value = this.states.includes(state) ? button : 0;
          break;
        case Constants.ComponentProperty.STATE:
          if (this.valueNodeProperty === Constants.VisualResponseProperty.VISIBILITY) {
            this.value = this.states.includes(state);
          } else {
            this.value = this.states.includes(state) ? 1 : 0;
          }
          break;
        default:
          throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);
      }
    }
  };
  var Component = class {
    constructor(componentId, componentDescription) {
      if (!componentId || !componentDescription || !componentDescription.visualResponses || !componentDescription.gamepadIndices || Object.keys(componentDescription.gamepadIndices).length === 0) {
        throw new Error("Invalid arguments supplied");
      }
      this.id = componentId;
      this.type = componentDescription.type;
      this.rootNodeName = componentDescription.rootNodeName;
      this.touchPointNodeName = componentDescription.touchPointNodeName;
      this.visualResponses = {};
      Object.keys(componentDescription.visualResponses).forEach((responseName) => {
        const visualResponse = new VisualResponse(componentDescription.visualResponses[responseName]);
        this.visualResponses[responseName] = visualResponse;
      });
      this.gamepadIndices = Object.assign({}, componentDescription.gamepadIndices);
      this.values = {
        state: Constants.ComponentState.DEFAULT,
        button: this.gamepadIndices.button !== void 0 ? 0 : void 0,
        xAxis: this.gamepadIndices.xAxis !== void 0 ? 0 : void 0,
        yAxis: this.gamepadIndices.yAxis !== void 0 ? 0 : void 0
      };
    }
    get data() {
      const data = { id: this.id, ...this.values };
      return data;
    }
    updateFromGamepad(gamepad) {
      this.values.state = Constants.ComponentState.DEFAULT;
      if (this.gamepadIndices.button !== void 0 && gamepad.buttons.length > this.gamepadIndices.button) {
        const gamepadButton = gamepad.buttons[this.gamepadIndices.button];
        this.values.button = gamepadButton.value;
        this.values.button = this.values.button < 0 ? 0 : this.values.button;
        this.values.button = this.values.button > 1 ? 1 : this.values.button;
        if (gamepadButton.pressed || this.values.button === 1) {
          this.values.state = Constants.ComponentState.PRESSED;
        } else if (gamepadButton.touched || this.values.button > Constants.ButtonTouchThreshold) {
          this.values.state = Constants.ComponentState.TOUCHED;
        }
      }
      if (this.gamepadIndices.xAxis !== void 0 && gamepad.axes.length > this.gamepadIndices.xAxis) {
        this.values.xAxis = gamepad.axes[this.gamepadIndices.xAxis];
        this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis;
        this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis;
        if (this.values.state === Constants.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > Constants.AxisTouchThreshold) {
          this.values.state = Constants.ComponentState.TOUCHED;
        }
      }
      if (this.gamepadIndices.yAxis !== void 0 && gamepad.axes.length > this.gamepadIndices.yAxis) {
        this.values.yAxis = gamepad.axes[this.gamepadIndices.yAxis];
        this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis;
        this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis;
        if (this.values.state === Constants.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > Constants.AxisTouchThreshold) {
          this.values.state = Constants.ComponentState.TOUCHED;
        }
      }
      Object.values(this.visualResponses).forEach((visualResponse) => {
        visualResponse.updateFromComponent(this.values);
      });
    }
  };
  var MotionController = class {
    constructor(xrInputSource, profile, assetUrl) {
      if (!xrInputSource) {
        throw new Error("No xrInputSource supplied");
      }
      if (!profile) {
        throw new Error("No profile supplied");
      }
      this.xrInputSource = xrInputSource;
      this.assetUrl = assetUrl;
      this.id = profile.profileId;
      this.layoutDescription = profile.layouts[xrInputSource.handedness];
      this.components = {};
      Object.keys(this.layoutDescription.components).forEach((componentId) => {
        const componentDescription = this.layoutDescription.components[componentId];
        this.components[componentId] = new Component(componentId, componentDescription);
      });
      this.updateFromGamepad();
    }
    get gripSpace() {
      return this.xrInputSource.gripSpace;
    }
    get targetRaySpace() {
      return this.xrInputSource.targetRaySpace;
    }
    get data() {
      const data = [];
      Object.values(this.components).forEach((component) => {
        data.push(component.data);
      });
      return data;
    }
    updateFromGamepad() {
      Object.values(this.components).forEach((component) => {
        component.updateFromGamepad(this.xrInputSource.gamepad);
      });
    }
  };

  // node_modules/three/examples/jsm/webxr/XRControllerModelFactory.js
  var DEFAULT_PROFILES_PATH = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles";
  var DEFAULT_PROFILE = "generic-trigger";
  function XRControllerModel() {
    Object3D.call(this);
    this.motionController = null;
    this.envMap = null;
  }
  XRControllerModel.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: XRControllerModel,
    setEnvironmentMap: function(envMap) {
      if (this.envMap == envMap) {
        return this;
      }
      this.envMap = envMap;
      this.traverse((child) => {
        if (child.isMesh) {
          child.material.envMap = this.envMap;
          child.material.needsUpdate = true;
        }
      });
      return this;
    },
    updateMatrixWorld: function(force) {
      Object3D.prototype.updateMatrixWorld.call(this, force);
      if (!this.motionController)
        return;
      this.motionController.updateFromGamepad();
      Object.values(this.motionController.components).forEach((component) => {
        Object.values(component.visualResponses).forEach((visualResponse) => {
          const { valueNode, minNode, maxNode, value, valueNodeProperty } = visualResponse;
          if (!valueNode)
            return;
          if (valueNodeProperty === Constants.VisualResponseProperty.VISIBILITY) {
            valueNode.visible = value;
          } else if (valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM) {
            valueNode.quaternion.slerpQuaternions(minNode.quaternion, maxNode.quaternion, value);
            valueNode.position.lerpVectors(minNode.position, maxNode.position, value);
          }
        });
      });
    }
  });
  function findNodes(motionController, scene) {
    Object.values(motionController.components).forEach((component) => {
      const { type, touchPointNodeName, visualResponses } = component;
      if (type === Constants.ComponentType.TOUCHPAD) {
        component.touchPointNode = scene.getObjectByName(touchPointNodeName);
        if (component.touchPointNode) {
          const sphereGeometry = new SphereGeometry(1e-3);
          const material = new MeshBasicMaterial({ color: 255 });
          const sphere = new Mesh(sphereGeometry, material);
          component.touchPointNode.add(sphere);
        } else {
          console.warn(`Could not find touch dot, ${component.touchPointNodeName}, in touchpad component ${component.id}`);
        }
      }
      Object.values(visualResponses).forEach((visualResponse) => {
        const { valueNodeName, minNodeName, maxNodeName, valueNodeProperty } = visualResponse;
        if (valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM) {
          visualResponse.minNode = scene.getObjectByName(minNodeName);
          visualResponse.maxNode = scene.getObjectByName(maxNodeName);
          if (!visualResponse.minNode) {
            console.warn(`Could not find ${minNodeName} in the model`);
            return;
          }
          if (!visualResponse.maxNode) {
            console.warn(`Could not find ${maxNodeName} in the model`);
            return;
          }
        }
        visualResponse.valueNode = scene.getObjectByName(valueNodeName);
        if (!visualResponse.valueNode) {
          console.warn(`Could not find ${valueNodeName} in the model`);
        }
      });
    });
  }
  function addAssetSceneToControllerModel(controllerModel, scene) {
    findNodes(controllerModel.motionController, scene);
    if (controllerModel.envMap) {
      scene.traverse((child) => {
        if (child.isMesh) {
          child.material.envMap = controllerModel.envMap;
          child.material.needsUpdate = true;
        }
      });
    }
    controllerModel.add(scene);
  }
  var XRControllerModelFactory = function() {
    function XRControllerModelFactory2(gltfLoader = null) {
      this.gltfLoader = gltfLoader;
      this.path = DEFAULT_PROFILES_PATH;
      this._assetCache = {};
      if (!this.gltfLoader) {
        this.gltfLoader = new GLTFLoader();
      }
    }
    XRControllerModelFactory2.prototype = {
      constructor: XRControllerModelFactory2,
      createControllerModel: function(controller) {
        const controllerModel = new XRControllerModel();
        let scene = null;
        controller.addEventListener("connected", (event) => {
          const xrInputSource = event.data;
          if (xrInputSource.targetRayMode !== "tracked-pointer" || !xrInputSource.gamepad)
            return;
          fetchProfile(xrInputSource, this.path, DEFAULT_PROFILE).then(({ profile, assetPath }) => {
            controllerModel.motionController = new MotionController(xrInputSource, profile, assetPath);
            const cachedAsset = this._assetCache[controllerModel.motionController.assetUrl];
            if (cachedAsset) {
              scene = cachedAsset.scene.clone();
              addAssetSceneToControllerModel(controllerModel, scene);
            } else {
              if (!this.gltfLoader) {
                throw new Error("GLTFLoader not set.");
              }
              this.gltfLoader.setPath("");
              this.gltfLoader.load(controllerModel.motionController.assetUrl, (asset) => {
                this._assetCache[controllerModel.motionController.assetUrl] = asset;
                scene = asset.scene.clone();
                addAssetSceneToControllerModel(controllerModel, scene);
              }, null, () => {
                throw new Error(`Asset ${controllerModel.motionController.assetUrl} missing or malformed.`);
              });
            }
          }).catch((err) => {
            console.warn(err);
          });
        });
        controller.addEventListener("disconnected", () => {
          controllerModel.motionController = null;
          controllerModel.remove(scene);
          scene = null;
        });
        return controllerModel;
      }
    };
    return XRControllerModelFactory2;
  }();

  // node_modules/@enable3d/three-graphics/jsm/plugins/webxr.js
  var WebXR = class {
    constructor(_renderer, _scene, _camera) {
      this._renderer = _renderer;
      this._scene = _scene;
      this._camera = _camera;
      this.controllerModelFactory = new XRControllerModelFactory();
      this.cameraGroup = new Group();
      this.cameraGroup.add(_camera);
      _scene.add(this.cameraGroup);
      _renderer.xr.enabled = true;
      const vrButton = VRButton.createButton(_renderer);
      vrButton.style.cssText += "background: rgba(0, 0, 0, 0.8); ";
      document.body.appendChild(vrButton);
    }
    get isPresenting() {
      var _a, _b;
      return !!((_b = (_a = this._renderer) === null || _a === void 0 ? void 0 : _a.xr) === null || _b === void 0 ? void 0 : _b.isPresenting);
    }
    getController(id) {
      const controller = this._renderer.xr.getController(id);
      this.cameraGroup.add(controller);
      return controller;
    }
    getControllerGrip(id) {
      const controllerGrip = this._renderer.xr.getControllerGrip(id);
      const model = this.controllerModelFactory.createControllerModel(controllerGrip);
      controllerGrip.add(model);
      this.cameraGroup.add(controllerGrip);
      return controllerGrip;
    }
    getControllerRay(data) {
      const { targetRayMode } = data;
      if (targetRayMode === "tracked-pointer") {
        const geometry = new BufferGeometry();
        geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, -1], 3));
        geometry.setAttribute("color", new Float32BufferAttribute([1, 0, 0, 1, 1, 1], 3));
        const material = new LineBasicMaterial({
          vertexColors: true
        });
        return new Line(geometry, material);
      }
      if (targetRayMode === "gaze") {
        const geometry = new RingGeometry(0.02, 0.04, 32).translate(0, 0, -1);
        const material = new MeshBasicMaterial({ color: "red", opacity: 0.5, transparent: true });
        return new Mesh(geometry, material);
      }
      return;
    }
    get camera() {
      return this.WebXRCamera;
    }
    get WebXRCamera() {
      var _a;
      return {
        group: this.cameraGroup,
        position: (_a = this.cameraGroup) === null || _a === void 0 ? void 0 : _a.position,
        rotation: this.isPresenting ? this._renderer.xr.getCamera(this._camera).rotation : void 0,
        getWorldDirection: (target) => this.isPresenting ? this._renderer.xr.getCamera(this._camera).getWorldDirection(target) : void 0
      };
    }
  };

  // node_modules/@enable3d/three-graphics/jsm/plugins/haveSomeFun.js
  var HaveSomeFun = (numberOfElements = 20, physics) => {
    if (!window.__loadPhysics) {
      console.log("There is not much fun without physics enabled!");
      return;
    }
    for (let i = 0; i < numberOfElements; i++) {
      const materials = ["standard", "basic", "normal", "phong", "line", "points"];
      const Between = (min, max) => Math.floor(Math.random() * (max - min + 1) + min);
      const RandomPick = (array) => array[Math.floor(Math.random() * array.length)];
      if (Math.random() > 0.5) {
        physics.add.box({
          x: Between(-10, 10),
          y: Between(10, 20),
          z: Between(-10, 10),
          width: Between(1, 2) / 10,
          height: Between(1, 2) / 10,
          depth: Between(1, 2) / 10,
          mass: 1
        }, { [RandomPick(materials)]: { color: Math.floor(Math.random() * 16777215) } }).body.setRestitution(Math.floor(Math.random() * 10) / 20);
      } else {
        physics.add.sphere({
          x: Between(-10, 10),
          y: Between(10, 20),
          z: Between(-10, 10),
          radius: Between(1, 2) / 10,
          mass: 1
        }, { [RandomPick(materials)]: { color: Math.floor(Math.random() * 16777215) } }).body.setRestitution(Math.floor(Math.random() * 10) / 20);
      }
    }
  };
  var haveSomeFun_default = HaveSomeFun;

  // node_modules/@enable3d/three-graphics/jsm/plugins/cameras.js
  var Cameras = class {
    perspectiveCamera(config = {}) {
      return Cameras.Perspective(config);
    }
    orthographicCamera(config = {}) {
      return Cameras.Orthographic(config);
    }
    static Perspective(config = {}) {
      const { fov: fov2 = 50, aspect: aspect2 = window.innerWidth / window.innerHeight, near = 0.1, far = 2e3, x = 0, y = 5, z = 25 } = config;
      const camera = new PerspectiveCamera(fov2, aspect2, near, far);
      camera.position.set(x, y, z);
      return camera;
    }
    static Orthographic(config = {}) {
      const width = window.innerWidth;
      const height = window.innerHeight;
      const { left = width / -2, right = width / 2, top = height / 2, bottom = height / -2, near = 1, far = 1e3, x = 0, y = 0, z = 10 } = config;
      const camera = new OrthographicCamera(left, right, top, bottom, near, far);
      camera.position.set(x, y, z);
      return camera;
    }
  };

  // node_modules/enable3d/dist/scene3d.js
  var __awaiter3 = function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var Scene3D = class {
    constructor(sceneConfig2 = {}) {
      this.sceneConfig = sceneConfig2;
      this.scenes = new Map();
      this.__config = {};
      this._isRunning = false;
      this._deconstructor = [];
      const { key = Math.random().toString(), enableXR = false } = sceneConfig2;
      this.__config.sceneKey = key;
      this.__config.enableXR = enableXR;
    }
    get deconstructor() {
      return {
        add: (...object) => {
          object.forEach((o) => {
            this._deconstructor.push(o);
          });
        }
      };
    }
    initializeScene(plugins) {
      const { renderer, parent, canvas: canvas2, scene, scenes, camera, cache, physics, sceneConfig: sceneConfig2 } = plugins;
      this.scene = scene;
      this.scenes = scenes;
      this.camera = camera;
      this.cache = cache;
      this.physics = physics;
      this.renderer = renderer;
      this.parent = parent;
      this.canvas = canvas2;
      const { autoStart, textureAnisotropy } = sceneConfig2;
      this.load = new Loaders(this.cache, textureAnisotropy);
      this.lights = new Lights(this.scene);
      this.transform = new Transform(this.camera, this.renderer);
      this.csg = CSGWrapper;
      this.heightMap = new HeightMap(this.scene);
      this.factories = new Factories(this.scene);
      this.misc = new Misc(this.scene, this.renderer, this.factories);
      this.ws = new WarpSpeed(scene, renderer, camera, this.lights, this.physics, this.load, this.factories);
      this.mixers = new mixers_default();
      this.cameras = new Cameras();
      this.clock = new Clock();
      if (this.__config.enableXR) {
        this.webXR = new WebXR(this.renderer, this.scene, this.camera);
      }
      if (autoStart)
        this.start(this.__config.sceneKey);
    }
    get sceneKey() {
      return this.__config.sceneKey;
    }
    destroy(obj) {
      var _a;
      (_a = this.physics) === null || _a === void 0 ? void 0 : _a.destroy(obj.body);
      this.scene.remove(obj);
      obj = null;
    }
    warpSpeed(...features) {
      return __awaiter3(this, void 0, void 0, function* () {
        return yield this.ws.warpSpeed(...features);
      });
    }
    get animationMixers() {
      return this.mixers.mixers;
    }
    get make() {
      return this.factories.make;
    }
    get add() {
      return this.factories.add;
    }
    haveSomeFun(numberOfElements = 20) {
      haveSomeFun_default(numberOfElements, this.physics);
    }
    isRunning() {
      return this._isRunning;
    }
    start(key, data) {
      var _a;
      return __awaiter3(this, void 0, void 0, function* () {
        if (key && key !== this.__config.sceneKey) {
          this.stop();
          (_a = this.scenes.get(key)) === null || _a === void 0 ? void 0 : _a._start(data);
        } else {
          this._start(data);
        }
      });
    }
    _start(data) {
      var _a;
      return __awaiter3(this, void 0, void 0, function* () {
        yield (_a = this.init) === null || _a === void 0 ? void 0 : _a.call(this, data);
        yield this._preload();
        yield this._create();
        this.renderer.setAnimationLoop(() => {
          this._update();
        });
        this._isRunning = true;
      });
    }
    restart(data) {
      return __awaiter3(this, void 0, void 0, function* () {
        yield this.stop();
        yield this.start(this.__config.sceneKey, data);
      });
    }
    stop() {
      var _a, _b;
      return __awaiter3(this, void 0, void 0, function* () {
        this._isRunning = false;
        this.renderer.setAnimationLoop(null);
        this.clock.start();
        for (let object of this._deconstructor) {
          yield (_a = object.dispose) === null || _a === void 0 ? void 0 : _a.call(object);
          yield (_b = object.destroy) === null || _b === void 0 ? void 0 : _b.call(object);
          if (typeof object === "function")
            yield object === null || object === void 0 ? void 0 : object();
          object = null;
        }
        this._deconstructor = [];
        for (let i = this.physics.rigidBodies.length - 1; i >= 0; i--) {
          this.physics.destroy(this.physics.rigidBodies[i]);
        }
        for (let i = this.scene.children.length - 1; i >= 0; i--) {
          this.scene.remove(this.scene.children[i]);
        }
      });
    }
    setSize(width, height) {
      this.renderer.setSize(width, height);
      if (typeof this.camera.aspect !== "undefined")
        this.camera.aspect = width / height;
      this.camera.updateProjectionMatrix();
    }
    setPixelRatio(ratio) {
      this.renderer.setPixelRatio(ratio);
    }
    init(data = {}) {
    }
    preload() {
    }
    create() {
    }
    update(_time, _delta) {
    }
    preRender() {
    }
    postRender() {
    }
    _preload() {
      var _a;
      return __awaiter3(this, void 0, void 0, function* () {
        yield (_a = this.preload) === null || _a === void 0 ? void 0 : _a.call(this);
      });
    }
    _create() {
      var _a;
      return __awaiter3(this, void 0, void 0, function* () {
        yield (_a = this.create) === null || _a === void 0 ? void 0 : _a.call(this);
      });
    }
    _update() {
      var _a, _b, _c;
      const delta = this.clock.getDelta() * 1e3;
      const time = this.clock.getElapsedTime();
      (_a = this.update) === null || _a === void 0 ? void 0 : _a.call(this, parseFloat(time.toFixed(3)), parseInt(delta.toString()));
      (_b = this.physics) === null || _b === void 0 ? void 0 : _b.update(delta);
      (_c = this.physics) === null || _c === void 0 ? void 0 : _c.updateDebugger();
      this.animationMixers.update(delta);
      this.preRender();
      if (this.composer)
        this.composer.render();
      else
        this.renderer.render(this.scene, this.camera);
      this.postRender();
    }
  };

  // node_modules/@enable3d/common/dist/typesAmmo.js
  "use strict";

  // node_modules/@enable3d/common/dist/typesCustom.js
  "use strict";

  // node_modules/@enable3d/common/dist/physicsBody.js
  var import_events = __toModule(require_cjs());
  var PhysicsBody = class {
    constructor(physics, ammo) {
      this.physics = physics;
      this.ammo = ammo;
      this.ignoreScale = false;
      this.isSoftBody = false;
      this.offset = { x: 0, y: 0, z: 0 };
      this.errors = [];
      this.checkCollisions = false;
      this.breakable = false;
      this.fractureImpulse = 1;
      this.didUpdate = false;
      this.skipUpdate = false;
      this._emitUpdateEvents = false;
      this._needUpdate = false;
      this.tmpEuler = new Euler();
      this.tmpQuaternion = new Quaternion();
      this.tmpBtVector3 = new Ammo.btVector3();
      this.tmpBtVector3_1 = new Ammo.btVector3();
      this.tmpBtQuaternion = new Ammo.btQuaternion(0, 0, 0, 1);
      this.eventEmitter = new import_events.Events();
      this.name = ammo.name;
    }
    destructor() {
      if (this.eventEmitter)
        this.eventEmitter.removeAllListeners();
      Ammo.destroy(this.tmpBtVector3);
      Ammo.destroy(this.tmpBtVector3_1);
      Ammo.destroy(this.tmpBtQuaternion);
      Ammo.destroy(this.ammo.getCollisionShape());
      Ammo.destroy(this.ammo);
    }
    setupEventEmitter() {
      if (typeof this.eventEmitter === "undefined")
        this.eventEmitter = new import_events.Events();
    }
    get needUpdate() {
      return this._needUpdate;
    }
    set needUpdate(need) {
      if (!need && this._needUpdate)
        this.didUpdate = true;
      this._needUpdate = need;
    }
    onUpdateEvent(updateCallback, once = false) {
      this.setupEventEmitter();
      this._emitUpdateEvents = true;
      if (once)
        this.eventEmitter.once("update", () => {
          updateCallback();
        });
      else
        this.eventEmitter.on("update", () => {
          updateCallback();
        });
    }
    get on() {
      return {
        update: (updateCallback) => this.onUpdateEvent(updateCallback),
        collision: (collisionCallback) => this.onCollision(collisionCallback)
      };
    }
    get once() {
      return {
        update: (updateCallback) => this.onUpdateEvent(updateCallback, true)
      };
    }
    onCollision(collisionCallback) {
      this.checkCollisions = true;
      this.physics.collisionEvents.on("collision", (data) => {
        const { bodies, event } = data;
        if (bodies[0].name === this.name)
          collisionCallback(bodies[1], event);
        else if (bodies[1].name === this.name)
          collisionCallback(bodies[0], event);
      });
    }
    transform() {
      const t = this.physics.worldTransform;
      this.ammo.getMotionState().getWorldTransform(t);
    }
    refresh() {
      const t = this.physics.worldTransform;
      this.ammo.getMotionState().setWorldTransform(t);
    }
    setRotation(x, y, z) {
      const e = this.tmpEuler.set(x, y, z);
      const q = this.tmpQuaternion.set(0, 0, 0, 1);
      q.setFromEuler(e);
      this.tmpBtQuaternion.setValue(0, 0, 0, 1);
      const ammoQuat = this.tmpBtQuaternion;
      ammoQuat.setValue(q.x, q.y, q.z, q.w);
      const t = this.physics.worldTransform;
      t.setRotation(ammoQuat);
    }
    get rotation() {
      let x, y, z;
      const t = this.physics.worldTransform;
      const ammoQuat = t.getRotation();
      let q1 = this.tmpQuaternion.set(ammoQuat.x(), ammoQuat.y(), ammoQuat.z(), ammoQuat.w());
      if (q1.w > 1)
        q1 = q1.normalize();
      const angle = 2 * Math.acos(q1.w);
      const s = Math.sqrt(1 - q1.w * q1.w);
      if (s < 1e-3) {
        x = q1.x;
        y = q1.y;
        z = q1.z;
      } else {
        x = q1.x / s;
        y = q1.y / s;
        z = q1.z / s;
      }
      return { x: x * angle, y: y * angle, z: z * angle };
    }
    get quaternion() {
      const t = this.physics.worldTransform;
      const q = t.getRotation();
      return { x: q.x(), y: q.y(), z: q.z(), w: q.w() };
    }
    setPosition(x, y, z) {
      const t = this.physics.worldTransform;
      t.getOrigin().setValue(x, y, z);
    }
    get position() {
      const t = this.physics.worldTransform;
      return { x: t.getOrigin().x(), y: t.getOrigin().y(), z: t.getOrigin().z() };
    }
    get velocity() {
      return {
        x: this.ammo.getLinearVelocity().x(),
        y: this.ammo.getLinearVelocity().y(),
        z: this.ammo.getLinearVelocity().z()
      };
    }
    get angularVelocity() {
      return {
        x: this.ammo.getAngularVelocity().x(),
        y: this.ammo.getAngularVelocity().y(),
        z: this.ammo.getAngularVelocity().z()
      };
    }
    setVelocity(x, y, z) {
      this.tmpBtVector3.setValue(x, y, z);
      this.ammo.setLinearVelocity(this.tmpBtVector3);
    }
    setVelocityX(value) {
      this.tmpBtVector3.setValue(value, this.velocity.y, this.velocity.z);
      this.ammo.setLinearVelocity(this.tmpBtVector3);
    }
    setVelocityY(value) {
      this.tmpBtVector3.setValue(this.velocity.x, value, this.velocity.z);
      this.ammo.setLinearVelocity(this.tmpBtVector3);
    }
    setVelocityZ(value) {
      this.tmpBtVector3.setValue(this.velocity.x, this.velocity.y, value);
      this.ammo.setLinearVelocity(this.tmpBtVector3);
    }
    setAngularVelocity(x, y, z) {
      this.tmpBtVector3.setValue(x, y, z);
      this.ammo.setAngularVelocity(this.tmpBtVector3);
    }
    setAngularVelocityX(value) {
      this.tmpBtVector3.setValue(value, this.angularVelocity.y, this.angularVelocity.z);
      this.ammo.setAngularVelocity(this.tmpBtVector3);
    }
    setAngularVelocityY(value) {
      this.tmpBtVector3.setValue(this.angularVelocity.x, value, this.angularVelocity.z);
      this.ammo.setAngularVelocity(this.tmpBtVector3);
    }
    setAngularVelocityZ(value) {
      this.tmpBtVector3.setValue(this.angularVelocity.x, this.angularVelocity.y, value);
      this.ammo.setAngularVelocity(this.tmpBtVector3);
    }
    applyForce(x, y, z) {
      this.tmpBtVector3.setValue(x, y, z);
      this.ammo.applyCentralImpulse(this.tmpBtVector3);
    }
    applyForceX(value) {
      this.tmpBtVector3.setValue(value, 0, 0);
      this.ammo.applyCentralImpulse(this.tmpBtVector3);
    }
    applyForceY(value) {
      this.tmpBtVector3.setValue(0, value, 0);
      this.ammo.applyCentralImpulse(this.tmpBtVector3);
    }
    applyForceZ(value) {
      this.tmpBtVector3.setValue(0, 0, value);
      this.ammo.applyCentralImpulse(this.tmpBtVector3);
    }
    applyCentralForce(x, y, z) {
      this.tmpBtVector3.setValue(x, y, z);
      this.ammo.applyCentralForce(this.tmpBtVector3);
    }
    applyCentralImpulse(x, y, z) {
      this.tmpBtVector3.setValue(x, y, z);
      this.ammo.applyCentralImpulse(this.tmpBtVector3);
    }
    applyCentralLocalForce(x, y, z) {
      this.tmpBtVector3.setValue(x, y, z);
      this.ammo.applyCentralLocalForce(this.tmpBtVector3);
    }
    applyImpulse(impulse, relativePosition) {
      this.tmpBtVector3.setValue(impulse.x || 0, impulse.y || 0, impulse.z || 0);
      this.tmpBtVector3_1.setValue(relativePosition.x || 0, relativePosition.y || 0, relativePosition.z || 0);
      this.ammo.applyImpulse(this.tmpBtVector3, this.tmpBtVector3_1);
    }
    applyLocalTorque(x, y, z) {
      this.tmpBtVector3.setValue(x, y, z);
      this.ammo.applyLocalTorque(this.tmpBtVector3);
    }
    applyTorque(x, y, z) {
      this.tmpBtVector3.setValue(x, y, z);
      this.ammo.applyTorque(this.tmpBtVector3);
    }
    applyTorqueImpulse(x, y, z) {
      this.tmpBtVector3.setValue(x, y, z);
      this.ammo.applyTorqueImpulse(this.tmpBtVector3);
    }
    setCollisionFlags(value) {
      this.ammo.setCollisionFlags(value);
    }
    getCollisionFlags() {
      return this.ammo.getCollisionFlags();
    }
    setRestitution(value) {
      this.ammo.setRestitution(value);
    }
    setBounciness(value) {
      this.setRestitution(value);
    }
    setFriction(value) {
      this.ammo.setFriction(value);
    }
    setDamping(linear, angular) {
      this.ammo.setDamping(linear, angular);
    }
    setGravity(x, y, z) {
      this.tmpBtVector3.setValue(x, y, z);
      this.ammo.setGravity(this.tmpBtVector3);
    }
    setLinearFactor(x, y, z) {
      this.tmpBtVector3.setValue(x, y, z);
      this.ammo.setLinearFactor(this.tmpBtVector3);
    }
    setAngularFactor(x, y, z) {
      this.tmpBtVector3.setValue(x, y, z);
      this.ammo.setAngularFactor(this.tmpBtVector3);
    }
    setCcdMotionThreshold(threshold) {
      this.ammo.setCcdMotionThreshold(threshold);
    }
    setCcdSweptSphereRadius(radius) {
      this.ammo.setCcdSweptSphereRadius(radius);
    }
  };
  var physicsBody_default = PhysicsBody;

  // node_modules/@enable3d/common/dist/extendedObject3D.js
  var ExtendedObject3D = class extends Object3D {
    constructor() {
      super();
      this.isExtendedObject3D = true;
      this.isGroup = false;
      this.vector3 = new Vector3();
      this.hasBody = false;
      this.fragmentDepth = 0;
      this.breakable = false;
      this.fractureImpulse = 1;
      this._currentAnimation = "";
      this._animationActions = new Map();
      this.name = `object-${this.id}`;
    }
    get world() {
      return {
        theta: this.worldTheta,
        phi: this.worldPhi
      };
    }
    get worldTheta() {
      this.getWorldDirection(this.vector3);
      return Math.atan2(this.vector3.x, this.vector3.z);
    }
    get worldPhi() {
      this.getWorldDirection(this.vector3);
      return Math.acos(this.vector3.y);
    }
    set animationMixer(animationMixer) {
      this._animationMixer = animationMixer;
    }
    get animationMixer() {
      if (!this._animationMixer)
        this._animationMixer = new AnimationMixer(this);
      return this._animationMixer;
    }
    get anims() {
      return {
        current: this._currentAnimation,
        add: (name, animation) => this._animsAdd(name, animation),
        get: (name) => this._animsGet(name),
        play: (name, transitionDuration = 500, loop = true) => this._animsPlay(name, transitionDuration, loop),
        mixer: this.animationMixer
      };
    }
    get animation() {
      logger('Please use "anims" instead of "animation"');
      return this.anims;
    }
    _animsAdd(name, animation) {
      this._animationActions.set(name, this.animationMixer.clipAction(animation));
    }
    _animsGet(name) {
      const action = this._animationActions.get(name);
      if (!action)
        logger(`Animation(${name}) not found!`);
      return action;
    }
    _animsPlay(name, transitionDuration = 500, loop = true) {
      const next = this._animationActions.get(name);
      const current = this._animationActions.get(this._currentAnimation);
      if (next) {
        next.reset();
        if (current) {
          next.crossFadeFrom(current, transitionDuration / 1e3, true);
          next.clampWhenFinished = true;
        }
        if (!loop)
          next.setLoop(LoopOnce, 0);
        next.play();
      }
      this._currentAnimation = name;
    }
    setAction(name) {
      logger(`setAction(${name}) is deprecated. Use animation.play(${name}) instead!`);
    }
    traverse(callback) {
      super.traverse(callback);
    }
    traverseVisible(callback) {
      super.traverseVisible(callback);
    }
    traverseAncestors(callback) {
      super.traverseAncestors(callback);
    }
  };

  // node_modules/@enable3d/ammo-physics/dist/shapes.js
  var Shapes = class {
    constructor(factory, addExisting) {
      this.factory = factory;
      this.addExisting = addExisting;
    }
    addPlane(planeConfig = {}, materialConfig = {}) {
      const plane = this.factory.add.plane(planeConfig, materialConfig);
      this.addExisting(plane, planeConfig);
      return plane;
    }
    addSphere(sphereConfig = {}, materialConfig = {}) {
      const sphere = this.factory.add.sphere(sphereConfig, materialConfig);
      this.addExisting(sphere, sphereConfig);
      return sphere;
    }
    addBox(boxConfig = {}, materialConfig = {}) {
      const box = this.factory.add.box(boxConfig, materialConfig);
      this.addExisting(box, boxConfig);
      return box;
    }
    addGround(groundConfig, materialConfig = {}) {
      const ground = this.factory.add.ground(groundConfig, materialConfig);
      const config = Object.assign(Object.assign({}, groundConfig), { mass: 0, collisionFlags: 1 });
      this.addExisting(ground, config);
      return ground;
    }
    addCylinder(cylinderConfig = {}, materialConfig = {}) {
      const cylinder = this.factory.add.cylinder(cylinderConfig, materialConfig);
      this.addExisting(cylinder, cylinderConfig);
      return cylinder;
    }
    addCone(coneConfig = {}, materialConfig = {}) {
      const cone = this.factory.add.cone(coneConfig, materialConfig);
      this.addExisting(cone, coneConfig);
      return cone;
    }
    addTorus(torusConfig = {}, materialConfig = {}) {
      const torus = this.factory.add.torus(torusConfig, materialConfig);
      this.addExisting(torus, torusConfig);
      return torus;
    }
    addExtrude(extrudeConfig, materialConfig = {}) {
      const object = this.factory.add.extrude(extrudeConfig, materialConfig);
      object.translateX(1);
      this.addExisting(object);
      return object;
    }
  };
  var shapes_default = Shapes;

  // node_modules/@enable3d/ammo-physics/dist/constraints.js
  var Constraints = class {
    constructor(worldTransform, physicsWorld) {
      this.worldTransform = worldTransform;
      this.physicsWorld = physicsWorld;
      this.tmpBtVector3 = new Ammo.btVector3();
    }
    toAmmoV3(v, d = 0) {
      return new Ammo.btVector3(typeof (v === null || v === void 0 ? void 0 : v.x) !== "undefined" ? v.x : d, typeof (v === null || v === void 0 ? void 0 : v.y) !== "undefined" ? v.y : d, typeof (v === null || v === void 0 ? void 0 : v.z) !== "undefined" ? v.z : d);
    }
    get addConstraints() {
      return {
        lock: (bodyA, bodyB, disableCollisionsBetweenLinkedBodies) => this.lock(bodyA, bodyB, disableCollisionsBetweenLinkedBodies),
        fixed: (bodyA, bodyB, disableCollisionsBetweenLinkedBodies) => this.fixed(bodyA, bodyB, disableCollisionsBetweenLinkedBodies),
        pointToPoint: (bodyA, bodyB, config, disableCollisionsBetweenLinkedBodies) => this.pointToPoint(bodyA, bodyB, config, disableCollisionsBetweenLinkedBodies),
        hinge: (bodyA, bodyB, config, disableCollisionsBetweenLinkedBodies) => this.hinge(bodyA, bodyB, config, disableCollisionsBetweenLinkedBodies),
        slider: (bodyA, bodyB, config = {}, disableCollisionsBetweenLinkedBodies) => this.slider(bodyA, bodyB, config, disableCollisionsBetweenLinkedBodies),
        spring: (bodyA, bodyB, config = {}, disableCollisionsBetweenLinkedBodies) => this.spring(bodyA, bodyB, config, disableCollisionsBetweenLinkedBodies),
        coneTwist: (bodyA, bodyB, config = { frameA: {}, frameB: {} }, disableCollisionsBetweenLinkedBodies) => this.coneTwist(bodyA, bodyB, config, disableCollisionsBetweenLinkedBodies),
        dof: (bodyA, bodyB, config, disableCollisionsBetweenLinkedBodies) => this.dof(bodyA, bodyB, config, disableCollisionsBetweenLinkedBodies)
      };
    }
    getTransform(bodyA, bodyB, offset = { x: 0, y: 0, z: 0 }, center = false) {
      offset = Object.assign({ x: 0, y: 0, z: 0 }, offset);
      const centerVector = (v1, v2) => {
        var dx = (v1.x() - v2.x()) / 2 + offset.x;
        var dy = (v1.y() - v2.y()) / 2 + offset.y;
        var dz = (v1.z() - v2.z()) / 2 + offset.z;
        return new Ammo.btVector3(dx, dy, dz);
      };
      const transformB = new Ammo.btTransform();
      transformB.setIdentity();
      if (!center) {
        transformB.setOrigin(new Ammo.btVector3(offset.x, offset.y, offset.z));
        const transformA = bodyA.getCenterOfMassTransform().inverse().op_mul(bodyB.getWorldTransform()).op_mul(transformB);
        return { transformA, transformB };
      } else {
        const center2 = centerVector(bodyA.getWorldTransform().getOrigin(), bodyB.getWorldTransform().getOrigin());
        const transformB2 = new Ammo.btTransform();
        transformB2.setIdentity();
        transformB2.setOrigin(center2);
        const transformA = bodyA.getCenterOfMassTransform().inverse().op_mul(bodyB.getWorldTransform());
        transformA.op_mul(transformB2);
        return { transformA, transformB: transformB2 };
      }
    }
    lock(bodyA, bodyB, disableCollisionsBetweenLinkedBodies = true) {
      const zero = { x: 0, y: 0, z: 0 };
      return this.dof(bodyA, bodyB, { angularLowerLimit: zero, angularUpperLimit: zero }, disableCollisionsBetweenLinkedBodies);
    }
    fixed(bodyA, bodyB, disableCollisionsBetweenLinkedBodies = true) {
      const transform = this.getTransform(bodyA.ammo, bodyB.ammo);
      transform.transformA.setRotation(bodyA.ammo.getWorldTransform().getRotation());
      transform.transformB.setRotation(bodyB.ammo.getWorldTransform().getRotation());
      const constraint = new Ammo.btFixedConstraint(bodyA.ammo, bodyB.ammo, transform.transformA, transform.transformB);
      this.physicsWorld.addConstraint(constraint, disableCollisionsBetweenLinkedBodies);
      return constraint;
    }
    pointToPoint(bodyA, bodyB, config = {}, disableCollisionsBetweenLinkedBodies = true) {
      const { pivotA, pivotB } = config;
      const pivotV3 = new Ammo.btVector3((pivotA === null || pivotA === void 0 ? void 0 : pivotA.x) || 0, (pivotA === null || pivotA === void 0 ? void 0 : pivotA.y) || 0, (pivotA === null || pivotA === void 0 ? void 0 : pivotA.z) || 0);
      const targetPivotV3 = new Ammo.btVector3((pivotB === null || pivotB === void 0 ? void 0 : pivotB.x) || 0, (pivotB === null || pivotB === void 0 ? void 0 : pivotB.y) || 0, (pivotB === null || pivotB === void 0 ? void 0 : pivotB.z) || 0);
      const constraint = new Ammo.btPoint2PointConstraint(bodyA.ammo, bodyB.ammo, pivotV3, targetPivotV3);
      this.physicsWorld.addConstraint(constraint, disableCollisionsBetweenLinkedBodies);
      return constraint;
    }
    hinge(bodyA, bodyB, config = {}, disableCollisionsBetweenLinkedBodies = true) {
      const { pivotA, pivotB, axisA, axisB } = config;
      const pivotV3 = new Ammo.btVector3((pivotA === null || pivotA === void 0 ? void 0 : pivotA.x) || 0, (pivotA === null || pivotA === void 0 ? void 0 : pivotA.y) || 0, (pivotA === null || pivotA === void 0 ? void 0 : pivotA.z) || 0);
      const targetPivotV3 = new Ammo.btVector3((pivotB === null || pivotB === void 0 ? void 0 : pivotB.x) || 0, (pivotB === null || pivotB === void 0 ? void 0 : pivotB.y) || 0, (pivotB === null || pivotB === void 0 ? void 0 : pivotB.z) || 0);
      const axisV3 = new Ammo.btVector3((axisA === null || axisA === void 0 ? void 0 : axisA.x) || 0, (axisA === null || axisA === void 0 ? void 0 : axisA.y) || 0, (axisA === null || axisA === void 0 ? void 0 : axisA.z) || 0);
      const targetAxisV3 = new Ammo.btVector3((axisB === null || axisB === void 0 ? void 0 : axisB.x) || 0, (axisB === null || axisB === void 0 ? void 0 : axisB.y) || 0, (axisB === null || axisB === void 0 ? void 0 : axisB.z) || 0);
      const constraint = new Ammo.btHingeConstraint(bodyA.ammo, bodyB.ammo, pivotV3, targetPivotV3, axisV3, targetAxisV3, true);
      this.physicsWorld.addConstraint(constraint, disableCollisionsBetweenLinkedBodies);
      return constraint;
    }
    slider(bodyA, bodyB, config = {}, disableCollisionsBetweenLinkedBodies = true) {
      const transform = this.getTransform(bodyA.ammo, bodyB.ammo);
      const { frameA = {}, frameB = {}, linearLowerLimit: lll = 0, linearUpperLimit: lul = 0, angularLowerLimit: all = 0, angularUpperLimit: aul = 0 } = config;
      const rotationA = transform.transformA.getRotation();
      rotationA.setEulerZYX(frameA.x || 0, frameA.y || 0, frameA.z || 0);
      transform.transformA.setRotation(rotationA);
      const rotationB = transform.transformB.getRotation();
      rotationB.setEulerZYX(frameB.x || 0, frameB.y || 0, frameB.z || 0);
      transform.transformB.setRotation(rotationB);
      const constraint = new Ammo.btSliderConstraint(bodyA.ammo, bodyB.ammo, transform.transformA, transform.transformB, true);
      constraint.setLowerLinLimit(lll);
      constraint.setUpperLinLimit(lul);
      constraint.setLowerAngLimit(all);
      constraint.setUpperAngLimit(aul);
      this.physicsWorld.addConstraint(constraint, disableCollisionsBetweenLinkedBodies);
      return constraint;
    }
    spring(bodyA, bodyB, config = {}, disableCollisionsBetweenLinkedBodies = true) {
      const { stiffness = 50, damping = 0.01, angularLock = false, linearLowerLimit: lll = {}, linearUpperLimit: lul = {}, angularLowerLimit: all = {}, angularUpperLimit: aul = {}, offset = {}, center = false, enableSpring = true } = config;
      const off = Object.assign({ x: 0, y: 0, z: 0 }, offset);
      const transform = this.getTransform(bodyA.ammo, bodyB.ammo, off, center);
      const constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA.ammo, bodyB.ammo, transform.transformA, transform.transformB, true);
      this.tmpBtVector3.setValue(lll.x || 0, lll.y || 0, lll.z || 0);
      constraint.setLinearLowerLimit(this.tmpBtVector3);
      this.tmpBtVector3.setValue(lul.x || 0, lul.y || 0, lul.z || 0);
      constraint.setLinearUpperLimit(this.tmpBtVector3);
      if (angularLock) {
        this.tmpBtVector3.setValue(0, 0, 0);
        constraint.setAngularLowerLimit(this.tmpBtVector3);
        constraint.setAngularUpperLimit(this.tmpBtVector3);
      } else {
        console.log(all, aul);
        constraint.setAngularLowerLimit(this.toAmmoV3(all, -Math.PI));
        constraint.setAngularUpperLimit(this.toAmmoV3(aul, Math.PI));
      }
      for (let i = 0; i < 3; i++) {
        constraint.enableSpring(i, enableSpring);
        constraint.setStiffness(i, stiffness);
        constraint.setDamping(i, damping);
      }
      this.physicsWorld.addConstraint(constraint, disableCollisionsBetweenLinkedBodies);
      return constraint;
    }
    coneTwist(bodyA, bodyB, config, disableCollisionsBetweenLinkedBodies = true) {
      const { frameA, frameB } = config;
      const rbAFrame = new Ammo.btTransform();
      rbAFrame.setIdentity();
      rbAFrame.getOrigin().setValue((frameA === null || frameA === void 0 ? void 0 : frameA.x) || 0, (frameA === null || frameA === void 0 ? void 0 : frameA.y) || 0, (frameA === null || frameA === void 0 ? void 0 : frameA.z) || 0);
      const rbBFrame = new Ammo.btTransform();
      rbBFrame.setIdentity();
      rbBFrame.getOrigin().setValue((frameB === null || frameB === void 0 ? void 0 : frameB.x) || 0, (frameB === null || frameB === void 0 ? void 0 : frameB.y) || 0, (frameB === null || frameB === void 0 ? void 0 : frameB.z) || 0);
      const t = this.getTransform(bodyA.ammo, bodyB.ammo);
      const constraint = new Ammo.btConeTwistConstraint(bodyB.ammo, bodyA.ammo, rbAFrame, rbBFrame);
      constraint.setAngularOnly(true);
      this.physicsWorld.addConstraint(constraint, disableCollisionsBetweenLinkedBodies);
      return constraint;
    }
    dof(bodyA, bodyB, config = {}, disableCollisionsBetweenLinkedBodies = true) {
      const { offset, center = false } = config;
      const off = Object.assign({ x: 0, y: 0, z: 0 }, offset);
      const transform = this.getTransform(bodyA.ammo, bodyB.ammo, off, center);
      const constraint = new Ammo.btGeneric6DofConstraint(bodyA.ammo, bodyB.ammo, transform.transformA, transform.transformB, true);
      const { linearLowerLimit, linearUpperLimit, angularLowerLimit, angularUpperLimit } = config;
      const lll = this.toAmmoV3(linearLowerLimit);
      const lul = this.toAmmoV3(linearUpperLimit);
      const all = this.toAmmoV3(angularLowerLimit, -Math.PI);
      const aul = this.toAmmoV3(angularUpperLimit, Math.PI);
      constraint.setLinearLowerLimit(lll);
      constraint.setLinearUpperLimit(lul);
      constraint.setAngularLowerLimit(all);
      constraint.setAngularUpperLimit(aul);
      Ammo.destroy(lll);
      Ammo.destroy(lul);
      Ammo.destroy(all);
      Ammo.destroy(aul);
      this.physicsWorld.addConstraint(constraint, disableCollisionsBetweenLinkedBodies);
      return constraint;
    }
  };

  // node_modules/@enable3d/ammo-physics/dist/physics.js
  var import_events3 = __toModule(require_cjs());

  // node_modules/@enable3d/ammo-physics/dist/three-to-ammo.js
  var TYPE = {
    BOX: "box",
    CYLINDER: "cylinder",
    SPHERE: "sphere",
    CAPSULE: "capsule",
    CONE: "cone",
    HULL: "hull",
    HACD: "hacd",
    VHACD: "vhacd",
    MESH: "mesh",
    HEIGHTFIELD: "heightfield"
  };
  var FIT = {
    ALL: "all",
    MANUAL: "manual"
  };
  var createHullShape = function() {
    const vertex = new Vector3();
    const center = new Vector3();
    const matrix = new Matrix4();
    return function(vertices, matrices, matrixWorld, options = {}) {
      options.type = TYPE.HULL;
      _setOptions(options);
      if (options.fit === FIT.MANUAL) {
        console.warn("cannot use fit: manual with type: hull");
        return null;
      }
      const bounds = _computeBounds(vertices, matrices);
      const btVertex = new Ammo.btVector3();
      const originalHull = new Ammo.btConvexHullShape();
      originalHull.setMargin(options.margin);
      center.addVectors(bounds.max, bounds.min).multiplyScalar(0.5);
      let vertexCount = 0;
      for (let i = 0; i < vertices.length; i++) {
        vertexCount += vertices[i].length / 3;
      }
      const maxVertices = options.hullMaxVertices || 1e5;
      if (vertexCount > maxVertices) {
        console.warn(`too many vertices for hull shape; sampling ~${maxVertices} from ~${vertexCount} vertices`);
      }
      const p = Math.min(1, maxVertices / vertexCount);
      for (let i = 0; i < vertices.length; i++) {
        const components = vertices[i];
        matrix.fromArray(matrices[i]);
        for (let j = 0; j < components.length; j += 3) {
          const isLastVertex = i === vertices.length - 1 && j === components.length - 3;
          if (Math.random() <= p || isLastVertex) {
            vertex.set(components[j], components[j + 1], components[j + 2]).applyMatrix4(matrix).sub(center);
            btVertex.setValue(vertex.x, vertex.y, vertex.z);
            originalHull.addPoint(btVertex, isLastVertex);
          }
        }
      }
      let collisionShape = originalHull;
      if (originalHull.getNumVertices() >= 100) {
        const shapeHull = new Ammo.btShapeHull(originalHull);
        shapeHull.buildHull(options.margin);
        Ammo.destroy(originalHull);
        collisionShape = new Ammo.btConvexHullShape(Ammo.getPointer(shapeHull.getVertexPointer()), shapeHull.numVertices());
        Ammo.destroy(shapeHull);
      }
      Ammo.destroy(btVertex);
      _finishCollisionShape(collisionShape, options, _computeScale(matrixWorld, options));
      return collisionShape;
    };
  }();
  var createHACDShapes = function() {
    const vector = new Vector3();
    const center = new Vector3();
    const matrix = new Matrix4();
    return function(vertices, matrices, indexes, matrixWorld, options = {}) {
      options.type = TYPE.HACD;
      _setOptions(options);
      if (options.fit === FIT.MANUAL) {
        console.warn("cannot use fit: manual with type: hacd");
        return [];
      }
      if (!Ammo.hasOwnProperty("HACD")) {
        console.warn("HACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version.");
        return [];
      }
      const bounds = _computeBounds(vertices, matrices);
      const scale = _computeScale(matrixWorld, options);
      let vertexCount = 0;
      let triCount = 0;
      center.addVectors(bounds.max, bounds.min).multiplyScalar(0.5);
      for (let i = 0; i < vertices.length; i++) {
        vertexCount += vertices[i].length / 3;
        if (indexes && indexes[i]) {
          triCount += indexes[i].length / 3;
        } else {
          triCount += vertices[i].length / 9;
        }
      }
      const hacd = new Ammo.HACD();
      if (options.hasOwnProperty("compacityWeight"))
        hacd.SetCompacityWeight(options.compacityWeight);
      if (options.hasOwnProperty("volumeWeight"))
        hacd.SetVolumeWeight(options.volumeWeight);
      if (options.hasOwnProperty("nClusters"))
        hacd.SetNClusters(options.nClusters);
      if (options.hasOwnProperty("nVerticesPerCH"))
        hacd.SetNVerticesPerCH(options.nVerticesPerCH);
      if (options.hasOwnProperty("concavity"))
        hacd.SetConcavity(options.concavity);
      const points = Ammo._malloc(vertexCount * 3 * 8);
      const triangles = Ammo._malloc(triCount * 3 * 4);
      hacd.SetPoints(points);
      hacd.SetTriangles(triangles);
      hacd.SetNPoints(vertexCount);
      hacd.SetNTriangles(triCount);
      let pptr = points / 8, tptr = triangles / 4;
      for (let i = 0; i < vertices.length; i++) {
        const components = vertices[i];
        matrix.fromArray(matrices[i]);
        for (let j = 0; j < components.length; j += 3) {
          vector.set(components[j + 0], components[j + 1], components[j + 2]).applyMatrix4(matrix).sub(center);
          Ammo.HEAPF64[pptr + 0] = vector.x;
          Ammo.HEAPF64[pptr + 1] = vector.y;
          Ammo.HEAPF64[pptr + 2] = vector.z;
          pptr += 3;
        }
        if (indexes[i]) {
          const indices = indexes[i];
          for (let j = 0; j < indices.length; j++) {
            Ammo.HEAP32[tptr] = indices[j];
            tptr++;
          }
        } else {
          for (let j = 0; j < components.length / 3; j++) {
            Ammo.HEAP32[tptr] = j;
            tptr++;
          }
        }
      }
      hacd.Compute();
      Ammo._free(points);
      Ammo._free(triangles);
      const nClusters = hacd.GetNClusters();
      const shapes = [];
      for (let i = 0; i < nClusters; i++) {
        const hull = new Ammo.btConvexHullShape();
        hull.setMargin(options.margin);
        const nPoints = hacd.GetNPointsCH(i);
        const nTriangles = hacd.GetNTrianglesCH(i);
        const hullPoints = Ammo._malloc(nPoints * 3 * 8);
        const hullTriangles = Ammo._malloc(nTriangles * 3 * 4);
        hacd.GetCH(i, hullPoints, hullTriangles);
        const pptr2 = hullPoints / 8;
        for (let pi = 0; pi < nPoints; pi++) {
          const btVertex = new Ammo.btVector3();
          const px2 = Ammo.HEAPF64[pptr2 + pi * 3 + 0];
          const py2 = Ammo.HEAPF64[pptr2 + pi * 3 + 1];
          const pz2 = Ammo.HEAPF64[pptr2 + pi * 3 + 2];
          btVertex.setValue(px2, py2, pz2);
          hull.addPoint(btVertex, pi === nPoints - 1);
          Ammo.destroy(btVertex);
        }
        _finishCollisionShape(hull, options, scale);
        shapes.push(hull);
      }
      return shapes;
    };
  }();
  var createVHACDShapes = function() {
    const vector = new Vector3();
    const center = new Vector3();
    const matrix = new Matrix4();
    return function(vertices, matrices, indexes, matrixWorld, options = {}) {
      options.type = TYPE.VHACD;
      _setOptions(options);
      if (options.fit === FIT.MANUAL) {
        console.warn("cannot use fit: manual with type: vhacd");
        return [];
      }
      if (!Ammo.hasOwnProperty("VHACD")) {
        console.warn("VHACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version.");
        return [];
      }
      const bounds = _computeBounds(vertices, matrices);
      const scale = _computeScale(matrixWorld, options);
      let vertexCount = 0;
      let triCount = 0;
      center.addVectors(bounds.max, bounds.min).multiplyScalar(0.5);
      for (let i = 0; i < vertices.length; i++) {
        vertexCount += vertices[i].length / 3;
        if (indexes && indexes[i]) {
          triCount += indexes[i].length / 3;
        } else {
          triCount += vertices[i].length / 9;
        }
      }
      const vhacd = new Ammo.VHACD();
      const params = new Ammo.Parameters();
      if (options.hasOwnProperty("resolution"))
        params.set_m_resolution(options.resolution);
      if (options.hasOwnProperty("depth"))
        params.set_m_depth(options.depth);
      if (options.hasOwnProperty("concavity"))
        params.set_m_concavity(options.concavity);
      if (options.hasOwnProperty("planeDownsampling"))
        params.set_m_planeDownsampling(options.planeDownsampling);
      if (options.hasOwnProperty("convexhullDownsampling"))
        params.set_m_convexhullDownsampling(options.convexhullDownsampling);
      if (options.hasOwnProperty("alpha"))
        params.set_m_alpha(options.alpha);
      if (options.hasOwnProperty("beta"))
        params.set_m_beta(options.beta);
      if (options.hasOwnProperty("gamma"))
        params.set_m_gamma(options.gamma);
      if (options.hasOwnProperty("pca"))
        params.set_m_pca(options.pca);
      if (options.hasOwnProperty("mode"))
        params.set_m_mode(options.mode);
      if (options.hasOwnProperty("maxNumVerticesPerCH"))
        params.set_m_maxNumVerticesPerCH(options.maxNumVerticesPerCH);
      if (options.hasOwnProperty("minVolumePerCH"))
        params.set_m_minVolumePerCH(options.minVolumePerCH);
      if (options.hasOwnProperty("convexhullApproximation"))
        params.set_m_convexhullApproximation(options.convexhullApproximation);
      if (options.hasOwnProperty("oclAcceleration"))
        params.set_m_oclAcceleration(options.oclAcceleration);
      const points = Ammo._malloc(vertexCount * 3 * 8 + 3);
      const triangles = Ammo._malloc(triCount * 3 * 4);
      let pptr = points / 8, tptr = triangles / 4;
      for (let i = 0; i < vertices.length; i++) {
        const components = vertices[i];
        matrix.fromArray(matrices[i]);
        for (let j = 0; j < components.length; j += 3) {
          vector.set(components[j + 0], components[j + 1], components[j + 2]).applyMatrix4(matrix).sub(center);
          Ammo.HEAPF64[pptr + 0] = vector.x;
          Ammo.HEAPF64[pptr + 1] = vector.y;
          Ammo.HEAPF64[pptr + 2] = vector.z;
          pptr += 3;
        }
        if (indexes[i]) {
          const indices = indexes[i];
          for (let j = 0; j < indices.length; j++) {
            Ammo.HEAP32[tptr] = indices[j];
            tptr++;
          }
        } else {
          for (let j = 0; j < components.length / 3; j++) {
            Ammo.HEAP32[tptr] = j;
            tptr++;
          }
        }
      }
      vhacd.Compute(points, 3, vertexCount, triangles, 3, triCount, params);
      Ammo._free(points);
      Ammo._free(triangles);
      const nHulls = vhacd.GetNConvexHulls();
      const shapes = [];
      const ch = new Ammo.ConvexHull();
      for (let i = 0; i < nHulls; i++) {
        vhacd.GetConvexHull(i, ch);
        const nPoints = ch.get_m_nPoints();
        const hullPoints = ch.get_m_points();
        const hull = new Ammo.btConvexHullShape();
        hull.setMargin(options.margin);
        for (let pi = 0; pi < nPoints; pi++) {
          const btVertex = new Ammo.btVector3();
          const px2 = ch.get_m_points(pi * 3 + 0);
          const py2 = ch.get_m_points(pi * 3 + 1);
          const pz2 = ch.get_m_points(pi * 3 + 2);
          btVertex.setValue(px2, py2, pz2);
          hull.addPoint(btVertex, pi === nPoints - 1);
          Ammo.destroy(btVertex);
        }
        _finishCollisionShape(hull, options, scale);
        shapes.push(hull);
      }
      Ammo.destroy(ch);
      Ammo.destroy(vhacd);
      return shapes;
    };
  }();
  var createTriMeshShape = function() {
    const va = new Vector3();
    const vb = new Vector3();
    const vc = new Vector3();
    const matrix = new Matrix4();
    return function(vertices, matrices, indexes, matrixWorld, options = {}) {
      options.type = TYPE.MESH;
      _setOptions(options);
      if (options.fit === FIT.MANUAL) {
        console.warn("cannot use fit: manual with type: mesh");
        return null;
      }
      const scale = _computeScale(matrixWorld, options);
      const bta = new Ammo.btVector3();
      const btb = new Ammo.btVector3();
      const btc = new Ammo.btVector3();
      const triMesh = new Ammo.btTriangleMesh(true, false);
      for (let i = 0; i < vertices.length; i++) {
        const components = vertices[i];
        const index = indexes[i] ? indexes[i] : null;
        matrix.fromArray(matrices[i]);
        if (index) {
          for (let j = 0; j < index.length; j += 3) {
            const ai = index[j] * 3;
            const bi = index[j + 1] * 3;
            const ci = index[j + 2] * 3;
            va.set(components[ai], components[ai + 1], components[ai + 2]).applyMatrix4(matrix);
            vb.set(components[bi], components[bi + 1], components[bi + 2]).applyMatrix4(matrix);
            vc.set(components[ci], components[ci + 1], components[ci + 2]).applyMatrix4(matrix);
            bta.setValue(va.x, va.y, va.z);
            btb.setValue(vb.x, vb.y, vb.z);
            btc.setValue(vc.x, vc.y, vc.z);
            triMesh.addTriangle(bta, btb, btc, false);
          }
        } else {
          for (let j = 0; j < components.length; j += 9) {
            va.set(components[j + 0], components[j + 1], components[j + 2]).applyMatrix4(matrix);
            vb.set(components[j + 3], components[j + 4], components[j + 5]).applyMatrix4(matrix);
            vc.set(components[j + 6], components[j + 7], components[j + 8]).applyMatrix4(matrix);
            bta.setValue(va.x, va.y, va.z);
            btb.setValue(vb.x, vb.y, vb.z);
            btc.setValue(vc.x, vc.y, vc.z);
            triMesh.addTriangle(bta, btb, btc, false);
          }
        }
      }
      const localScale = new Ammo.btVector3(scale.x, scale.y, scale.z);
      triMesh.setScaling(localScale);
      Ammo.destroy(localScale);
      let collisionShape;
      if (options.concave)
        collisionShape = new Ammo.btBvhTriangleMeshShape(triMesh, true, true);
      else
        collisionShape = new Ammo.btConvexTriangleMeshShape(triMesh, true);
      collisionShape.resources = [triMesh];
      Ammo.destroy(bta);
      Ammo.destroy(btb);
      Ammo.destroy(btc);
      _finishCollisionShape(collisionShape, options);
      return collisionShape;
    };
  }();
  function _setOptions(options) {
    options.type = options.type || TYPE.HULL;
    options.margin = options.hasOwnProperty("margin") ? options.margin : 0.01;
    return;
    options.fit = options.hasOwnProperty("fit") ? options.fit : FIT.ALL;
    options.type = options.type || TYPE.HULL;
    options.minHalfExtent = options.hasOwnProperty("minHalfExtent") ? options.minHalfExtent : 0;
    options.maxHalfExtent = options.hasOwnProperty("maxHalfExtent") ? options.maxHalfExtent : Number.POSITIVE_INFINITY;
    options.cylinderAxis = options.cylinderAxis || "y";
    options.margin = options.hasOwnProperty("margin") ? options.margin : 0.01;
    options.includeInvisible = options.hasOwnProperty("includeInvisible") ? options.includeInvisible : false;
    if (!options.offset) {
      options.offset = new Vector3();
    }
    if (!options.orientation) {
      options.orientation = new Quaternion();
    }
  }
  var _finishCollisionShape = function(collisionShape, options, scale) {
    return;
    collisionShape.type = options.type;
    collisionShape.setMargin(options.margin);
    collisionShape.destroy = () => {
      for (let res of collisionShape.resources || []) {
        Ammo.destroy(res);
      }
      if (collisionShape.heightfieldData) {
        Ammo._free(collisionShape.heightfieldData);
      }
      Ammo.destroy(collisionShape);
    };
    const localTransform = new Ammo.btTransform();
    const rotation = new Ammo.btQuaternion();
    localTransform.setIdentity();
    localTransform.getOrigin().setValue(options.offset.x, options.offset.y, options.offset.z);
    rotation.setValue(options.orientation.x, options.orientation.y, options.orientation.z, options.orientation.w);
    localTransform.setRotation(rotation);
    Ammo.destroy(rotation);
    if (scale) {
      const localScale = new Ammo.btVector3(scale.x, scale.y, scale.z);
      collisionShape.setLocalScaling(localScale);
      Ammo.destroy(localScale);
    }
    collisionShape.localTransform = localTransform;
  };
  var iterateGeometries = function() {
    const inverse = new Matrix4();
    return function(root, options, cb) {
      if (parseInt(REVISION) >= 123)
        inverse.copy(root.matrixWorld).invert();
      else
        inverse.getInverse(root.matrixWorld);
      const scale = new Vector3();
      scale.setFromMatrixScale(root.matrixWorld);
      root.traverse((mesh) => {
        const transform = new Matrix4();
        if (mesh.isMesh && (options.includeInvisible || mesh.el && mesh.el.object3D.visible || mesh.visible)) {
          if (mesh === root) {
            transform.identity();
          } else {
            mesh.updateWorldMatrix(true);
            transform.multiplyMatrices(inverse, mesh.matrixWorld);
          }
          cb(mesh.geometry.isBufferGeometry ? mesh.geometry.attributes.position.array : mesh.geometry.vertices, transform.elements, mesh.geometry.index ? mesh.geometry.index.array : null);
        }
      });
    };
  }();
  var _computeScale = function() {
    const matrix = new Matrix4();
    return function(matrixWorld, options = {}) {
      const scale = new Vector3(1, 1, 1);
      if (options.fit === FIT.ALL) {
        matrix.fromArray(matrixWorld);
        scale.setFromMatrixScale(matrix);
      }
      return scale;
    };
  }();
  var _computeRadius = function() {
    const center = new Vector3();
    return function(vertices, matrices, bounds) {
      let maxRadiusSq = 0;
      let { x: cx, y: cy, z: cz } = bounds.getCenter(center);
      _iterateVertices(vertices, matrices, (v) => {
        const dx = cx - v.x;
        const dy = cy - v.y;
        const dz = cz - v.z;
        maxRadiusSq = Math.max(maxRadiusSq, dx * dx + dy * dy + dz * dz);
      });
      return Math.sqrt(maxRadiusSq);
    };
  }();
  var _computeBounds = function(vertices, matrices) {
    const bounds = new Box3();
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    bounds.min.set(0, 0, 0);
    bounds.max.set(0, 0, 0);
    _iterateVertices(vertices, matrices, (v) => {
      if (v.x < minX)
        minX = v.x;
      if (v.y < minY)
        minY = v.y;
      if (v.z < minZ)
        minZ = v.z;
      if (v.x > maxX)
        maxX = v.x;
      if (v.y > maxY)
        maxY = v.y;
      if (v.z > maxZ)
        maxZ = v.z;
    });
    bounds.min.set(minX, minY, minZ);
    bounds.max.set(maxX, maxY, maxZ);
    return bounds;
  };
  var _iterateVertices = function() {
    const vertex = new Vector3();
    const matrix = new Matrix4();
    return function(vertices, matrices, cb) {
      for (let i = 0; i < vertices.length; i++) {
        matrix.fromArray(matrices[i]);
        for (let j = 0; j < vertices[i].length; j += 3) {
          vertex.set(vertices[i][j], vertices[i][j + 1], vertices[i][j + 2]).applyMatrix4(matrix);
          cb(vertex);
        }
      }
    };
  }();

  // node_modules/@enable3d/ammo-physics/dist/torusShape.js
  var createTorusShape = (config, quat) => {
    const { radius = 1, tube = 0.4, tubularSegments = 8 } = config;
    const SIMD_PI = Math.PI;
    const subdivisions = tubularSegments;
    const gap = Math.sqrt(2 * tube * tube - 2 * tube * tube * Math.cos(2 * SIMD_PI / subdivisions));
    const btHalfExtents = new Ammo.btVector3(tube, SIMD_PI / subdivisions + 0.5 * gap, tube);
    const cylinderShape = new Ammo.btCylinderShape(btHalfExtents);
    cylinderShape.setMargin(0.05);
    const compoundShape = new Ammo.btCompoundShape();
    const forward = new Ammo.btVector3(0, 0, 1);
    const side = new Ammo.btVector3(0, radius, 0);
    const rotation = new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w);
    for (let x = 0; x < subdivisions; x++) {
      const angle = x * 2 * SIMD_PI / subdivisions;
      const position = side.rotate(forward, angle);
      const transform = new Ammo.btTransform();
      rotation.setRotation(forward, angle + Math.PI / 2);
      transform.setIdentity();
      transform.setOrigin(position);
      transform.setRotation(rotation);
      compoundShape.addChildShape(transform, cylinderShape);
    }
    return compoundShape;
  };

  // node_modules/@enable3d/ammo-physics/dist/collisionEvents.js
  var import_events2 = __toModule(require_cjs());
  var CollisionEvents = class extends import_events2.Events {
    addCollider(object1, object2, eventCallback) {
      if (!object1.body || !object2.body)
        return;
      object1.body.checkCollisions = true;
      object2.body.checkCollisions = true;
      this.on("collision", (data) => {
        var _a, _b;
        const { bodies, event } = data;
        if (((_a = bodies[0]) === null || _a === void 0 ? void 0 : _a.name) && ((_b = bodies[1]) === null || _b === void 0 ? void 0 : _b.name) && (object1 === null || object1 === void 0 ? void 0 : object1.name) && (object2 === null || object2 === void 0 ? void 0 : object2.name)) {
          if (bodies[0].name === object1.name && bodies[1].name === object2.name)
            eventCallback(event);
          else if (bodies[1].name === object1.name && bodies[0].name === object2.name)
            eventCallback(event);
        }
      });
    }
  };

  // node_modules/@enable3d/ammo-physics/dist/debugDrawer.js
  var AmmoDebugConstants = {
    NoDebug: 0,
    DrawWireframe: 1,
    DrawAabb: 2,
    DrawFeaturesText: 4,
    DrawContactPoints: 8,
    NoDeactivation: 16,
    NoHelpText: 32,
    DrawText: 64,
    ProfileTimings: 128,
    EnableSatComparison: 256,
    DisableBulletLCP: 512,
    EnableCCD: 1024,
    DrawConstraints: 1 << 11,
    DrawConstraintLimits: 1 << 12,
    FastWireframe: 1 << 13,
    DrawNormals: 1 << 14,
    DrawOnTop: 1 << 15,
    MAX_DEBUG_DRAW_MODE: 4294967295
  };
  var DebugDrawer = class {
    constructor(scene, world, options = {}) {
      this.scene = scene;
      this.world = world;
      this.options = options;
      this.debugDrawMode = options.debugDrawMode || AmmoDebugConstants.DrawWireframe;
      const drawOnTop = this.debugDrawMode & AmmoDebugConstants.DrawOnTop || false;
      const maxBufferSize = options.maxBufferSize || 1e6;
      this.geometry = new BufferGeometry();
      const vertices = new Float32Array(maxBufferSize * 3);
      const colors = new Float32Array(maxBufferSize * 3);
      this.geometry.setAttribute("position", new BufferAttribute(vertices, 3).setUsage(StaticDrawUsage));
      this.geometry.setAttribute("color", new BufferAttribute(colors, 3).setUsage(StaticDrawUsage));
      this.index = 0;
      const material = new LineBasicMaterial({
        vertexColors: true,
        depthTest: !drawOnTop
      });
      this.mesh = new LineSegments(this.geometry, material);
      if (drawOnTop)
        this.mesh.renderOrder = 999;
      this.mesh.frustumCulled = false;
      this.enabled = false;
      this.debugDrawer = new Ammo.DebugDrawer();
      this.debugDrawer.drawLine = this.drawLine.bind(this);
      this.debugDrawer.drawContactPoint = this.drawContactPoint.bind(this);
      this.debugDrawer.reportErrorWarning = this.reportErrorWarning.bind(this);
      this.debugDrawer.draw3dText = this.draw3dText.bind(this);
      this.debugDrawer.setDebugMode = this.setDebugMode.bind(this);
      this.debugDrawer.getDebugMode = this.getDebugMode.bind(this);
      this.world.setDebugDrawer(this.debugDrawer);
    }
    enable() {
      this.enabled = true;
      this.scene.add(this.mesh);
    }
    disable() {
      this.enabled = false;
      this.scene.remove(this.mesh);
    }
    update() {
      if (!this.enabled) {
        return;
      }
      if (this.index != 0) {
        this.geometry.attributes.position.needsUpdate = true;
        this.geometry.attributes.color.needsUpdate = true;
      }
      this.index = 0;
      this.world.debugDrawWorld();
      this.geometry.setDrawRange(0, this.index);
    }
    drawLine(from, to, color) {
      const heap = Ammo.HEAPF32;
      const r = heap[(color + 0) / 4];
      const g = heap[(color + 4) / 4];
      const b2 = heap[(color + 8) / 4];
      const fromX = heap[(from + 0) / 4];
      const fromY = heap[(from + 4) / 4];
      const fromZ = heap[(from + 8) / 4];
      this.geometry.attributes.position.setXYZ(this.index, fromX, fromY, fromZ);
      this.geometry.attributes.color.setXYZ(this.index++, r, g, b2);
      const toX = heap[(to + 0) / 4];
      const toY = heap[(to + 4) / 4];
      const toZ = heap[(to + 8) / 4];
      this.geometry.attributes.position.setXYZ(this.index, toX, toY, toZ);
      this.geometry.attributes.color.setXYZ(this.index++, r, g, b2);
    }
    drawContactPoint(pointOnB, normalOnB, distance, _lifeTime, color) {
      const heap = Ammo.HEAPF32;
      const r = heap[(color + 0) / 4];
      const g = heap[(color + 4) / 4];
      const b2 = heap[(color + 8) / 4];
      const x = heap[(pointOnB + 0) / 4];
      const y = heap[(pointOnB + 4) / 4];
      const z = heap[(pointOnB + 8) / 4];
      this.geometry.attributes.position.setXYZ(this.index, x, y, z);
      this.geometry.attributes.color.setXYZ(this.index++, r, g, b2);
      const dx = heap[(normalOnB + 0) / 4] * distance;
      const dy = heap[(normalOnB + 4) / 4] * distance;
      const dz = heap[(normalOnB + 8) / 4] * distance;
      this.geometry.attributes.position.setXYZ(this.index, x + dx, y + dy, z + dz);
      this.geometry.attributes.color.setXYZ(this.index++, r, g, b2);
    }
    reportErrorWarning(warningString) {
      if (Ammo.hasOwnProperty("Pointer_stringify")) {
        console.warn(Ammo.Pointer_stringify(warningString));
      } else if (!this.warnedOnce) {
        this.warnedOnce = true;
        console.warn("Cannot print warningString, please rebuild Ammo.js using 'debug' flag");
      }
    }
    draw3dText(_location, _textString) {
      console.warn("TODO: draw3dText");
    }
    setDebugMode(debugMode) {
      this.debugDrawMode = debugMode;
    }
    getDebugMode() {
      return this.debugDrawMode;
    }
  };
  var debugDrawer_default = DebugDrawer;

  // node_modules/three/examples/jsm/math/ConvexHull.js
  var ConvexHull = function() {
    var Visible = 0;
    var Deleted = 1;
    var v1 = new Vector3();
    function ConvexHull2() {
      this.tolerance = -1;
      this.faces = [];
      this.newFaces = [];
      this.assigned = new VertexList();
      this.unassigned = new VertexList();
      this.vertices = [];
    }
    Object.assign(ConvexHull2.prototype, {
      setFromPoints: function(points) {
        if (Array.isArray(points) !== true) {
          console.error("THREE.ConvexHull: Points parameter is not an array.");
        }
        if (points.length < 4) {
          console.error("THREE.ConvexHull: The algorithm needs at least four points.");
        }
        this.makeEmpty();
        for (var i = 0, l = points.length; i < l; i++) {
          this.vertices.push(new VertexNode(points[i]));
        }
        this.compute();
        return this;
      },
      setFromObject: function(object) {
        var points = [];
        object.updateMatrixWorld(true);
        object.traverse(function(node) {
          var i, l, point;
          var geometry = node.geometry;
          if (geometry !== void 0) {
            if (geometry.isGeometry) {
              console.error("THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.");
              return;
            } else if (geometry.isBufferGeometry) {
              var attribute = geometry.attributes.position;
              if (attribute !== void 0) {
                for (i = 0, l = attribute.count; i < l; i++) {
                  point = new Vector3();
                  point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);
                  points.push(point);
                }
              }
            }
          }
        });
        return this.setFromPoints(points);
      },
      containsPoint: function(point) {
        var faces = this.faces;
        for (var i = 0, l = faces.length; i < l; i++) {
          var face = faces[i];
          if (face.distanceToPoint(point) > this.tolerance)
            return false;
        }
        return true;
      },
      intersectRay: function(ray, target) {
        var faces = this.faces;
        var tNear = -Infinity;
        var tFar = Infinity;
        for (var i = 0, l = faces.length; i < l; i++) {
          var face = faces[i];
          var vN = face.distanceToPoint(ray.origin);
          var vD = face.normal.dot(ray.direction);
          if (vN > 0 && vD >= 0)
            return null;
          var t = vD !== 0 ? -vN / vD : 0;
          if (t <= 0)
            continue;
          if (vD > 0) {
            tFar = Math.min(t, tFar);
          } else {
            tNear = Math.max(t, tNear);
          }
          if (tNear > tFar) {
            return null;
          }
        }
        if (tNear !== -Infinity) {
          ray.at(tNear, target);
        } else {
          ray.at(tFar, target);
        }
        return target;
      },
      intersectsRay: function(ray) {
        return this.intersectRay(ray, v1) !== null;
      },
      makeEmpty: function() {
        this.faces = [];
        this.vertices = [];
        return this;
      },
      addVertexToFace: function(vertex, face) {
        vertex.face = face;
        if (face.outside === null) {
          this.assigned.append(vertex);
        } else {
          this.assigned.insertBefore(face.outside, vertex);
        }
        face.outside = vertex;
        return this;
      },
      removeVertexFromFace: function(vertex, face) {
        if (vertex === face.outside) {
          if (vertex.next !== null && vertex.next.face === face) {
            face.outside = vertex.next;
          } else {
            face.outside = null;
          }
        }
        this.assigned.remove(vertex);
        return this;
      },
      removeAllVerticesFromFace: function(face) {
        if (face.outside !== null) {
          var start = face.outside;
          var end = face.outside;
          while (end.next !== null && end.next.face === face) {
            end = end.next;
          }
          this.assigned.removeSubList(start, end);
          start.prev = end.next = null;
          face.outside = null;
          return start;
        }
      },
      deleteFaceVertices: function(face, absorbingFace) {
        var faceVertices = this.removeAllVerticesFromFace(face);
        if (faceVertices !== void 0) {
          if (absorbingFace === void 0) {
            this.unassigned.appendChain(faceVertices);
          } else {
            var vertex = faceVertices;
            do {
              var nextVertex = vertex.next;
              var distance = absorbingFace.distanceToPoint(vertex.point);
              if (distance > this.tolerance) {
                this.addVertexToFace(vertex, absorbingFace);
              } else {
                this.unassigned.append(vertex);
              }
              vertex = nextVertex;
            } while (vertex !== null);
          }
        }
        return this;
      },
      resolveUnassignedPoints: function(newFaces) {
        if (this.unassigned.isEmpty() === false) {
          var vertex = this.unassigned.first();
          do {
            var nextVertex = vertex.next;
            var maxDistance = this.tolerance;
            var maxFace = null;
            for (var i = 0; i < newFaces.length; i++) {
              var face = newFaces[i];
              if (face.mark === Visible) {
                var distance = face.distanceToPoint(vertex.point);
                if (distance > maxDistance) {
                  maxDistance = distance;
                  maxFace = face;
                }
                if (maxDistance > 1e3 * this.tolerance)
                  break;
              }
            }
            if (maxFace !== null) {
              this.addVertexToFace(vertex, maxFace);
            }
            vertex = nextVertex;
          } while (vertex !== null);
        }
        return this;
      },
      computeExtremes: function() {
        var min = new Vector3();
        var max = new Vector3();
        var minVertices = [];
        var maxVertices = [];
        var i, l, j;
        for (i = 0; i < 3; i++) {
          minVertices[i] = maxVertices[i] = this.vertices[0];
        }
        min.copy(this.vertices[0].point);
        max.copy(this.vertices[0].point);
        for (i = 0, l = this.vertices.length; i < l; i++) {
          var vertex = this.vertices[i];
          var point = vertex.point;
          for (j = 0; j < 3; j++) {
            if (point.getComponent(j) < min.getComponent(j)) {
              min.setComponent(j, point.getComponent(j));
              minVertices[j] = vertex;
            }
          }
          for (j = 0; j < 3; j++) {
            if (point.getComponent(j) > max.getComponent(j)) {
              max.setComponent(j, point.getComponent(j));
              maxVertices[j] = vertex;
            }
          }
        }
        this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));
        return { min: minVertices, max: maxVertices };
      },
      computeInitialHull: function() {
        var line3, plane, closestPoint;
        return function computeInitialHull() {
          if (line3 === void 0) {
            line3 = new Line3();
            plane = new Plane();
            closestPoint = new Vector3();
          }
          var vertex, vertices = this.vertices;
          var extremes = this.computeExtremes();
          var min = extremes.min;
          var max = extremes.max;
          var v0, v12, v2, v3;
          var i, l, j;
          var distance, maxDistance = 0;
          var index = 0;
          for (i = 0; i < 3; i++) {
            distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);
            if (distance > maxDistance) {
              maxDistance = distance;
              index = i;
            }
          }
          v0 = min[index];
          v12 = max[index];
          maxDistance = 0;
          line3.set(v0.point, v12.point);
          for (i = 0, l = this.vertices.length; i < l; i++) {
            vertex = vertices[i];
            if (vertex !== v0 && vertex !== v12) {
              line3.closestPointToPoint(vertex.point, true, closestPoint);
              distance = closestPoint.distanceToSquared(vertex.point);
              if (distance > maxDistance) {
                maxDistance = distance;
                v2 = vertex;
              }
            }
          }
          maxDistance = -1;
          plane.setFromCoplanarPoints(v0.point, v12.point, v2.point);
          for (i = 0, l = this.vertices.length; i < l; i++) {
            vertex = vertices[i];
            if (vertex !== v0 && vertex !== v12 && vertex !== v2) {
              distance = Math.abs(plane.distanceToPoint(vertex.point));
              if (distance > maxDistance) {
                maxDistance = distance;
                v3 = vertex;
              }
            }
          }
          var faces = [];
          if (plane.distanceToPoint(v3.point) < 0) {
            faces.push(Face.create(v0, v12, v2), Face.create(v3, v12, v0), Face.create(v3, v2, v12), Face.create(v3, v0, v2));
            for (i = 0; i < 3; i++) {
              j = (i + 1) % 3;
              faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j));
              faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));
            }
          } else {
            faces.push(Face.create(v0, v2, v12), Face.create(v3, v0, v12), Face.create(v3, v12, v2), Face.create(v3, v2, v0));
            for (i = 0; i < 3; i++) {
              j = (i + 1) % 3;
              faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3));
              faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));
            }
          }
          for (i = 0; i < 4; i++) {
            this.faces.push(faces[i]);
          }
          for (i = 0, l = vertices.length; i < l; i++) {
            vertex = vertices[i];
            if (vertex !== v0 && vertex !== v12 && vertex !== v2 && vertex !== v3) {
              maxDistance = this.tolerance;
              var maxFace = null;
              for (j = 0; j < 4; j++) {
                distance = this.faces[j].distanceToPoint(vertex.point);
                if (distance > maxDistance) {
                  maxDistance = distance;
                  maxFace = this.faces[j];
                }
              }
              if (maxFace !== null) {
                this.addVertexToFace(vertex, maxFace);
              }
            }
          }
          return this;
        };
      }(),
      reindexFaces: function() {
        var activeFaces = [];
        for (var i = 0; i < this.faces.length; i++) {
          var face = this.faces[i];
          if (face.mark === Visible) {
            activeFaces.push(face);
          }
        }
        this.faces = activeFaces;
        return this;
      },
      nextVertexToAdd: function() {
        if (this.assigned.isEmpty() === false) {
          var eyeVertex, maxDistance = 0;
          var eyeFace = this.assigned.first().face;
          var vertex = eyeFace.outside;
          do {
            var distance = eyeFace.distanceToPoint(vertex.point);
            if (distance > maxDistance) {
              maxDistance = distance;
              eyeVertex = vertex;
            }
            vertex = vertex.next;
          } while (vertex !== null && vertex.face === eyeFace);
          return eyeVertex;
        }
      },
      computeHorizon: function(eyePoint, crossEdge, face, horizon) {
        this.deleteFaceVertices(face);
        face.mark = Deleted;
        var edge;
        if (crossEdge === null) {
          edge = crossEdge = face.getEdge(0);
        } else {
          edge = crossEdge.next;
        }
        do {
          var twinEdge = edge.twin;
          var oppositeFace = twinEdge.face;
          if (oppositeFace.mark === Visible) {
            if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {
              this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);
            } else {
              horizon.push(edge);
            }
          }
          edge = edge.next;
        } while (edge !== crossEdge);
        return this;
      },
      addAdjoiningFace: function(eyeVertex, horizonEdge) {
        var face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());
        this.faces.push(face);
        face.getEdge(-1).setTwin(horizonEdge.twin);
        return face.getEdge(0);
      },
      addNewFaces: function(eyeVertex, horizon) {
        this.newFaces = [];
        var firstSideEdge = null;
        var previousSideEdge = null;
        for (var i = 0; i < horizon.length; i++) {
          var horizonEdge = horizon[i];
          var sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);
          if (firstSideEdge === null) {
            firstSideEdge = sideEdge;
          } else {
            sideEdge.next.setTwin(previousSideEdge);
          }
          this.newFaces.push(sideEdge.face);
          previousSideEdge = sideEdge;
        }
        firstSideEdge.next.setTwin(previousSideEdge);
        return this;
      },
      addVertexToHull: function(eyeVertex) {
        var horizon = [];
        this.unassigned.clear();
        this.removeVertexFromFace(eyeVertex, eyeVertex.face);
        this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);
        this.addNewFaces(eyeVertex, horizon);
        this.resolveUnassignedPoints(this.newFaces);
        return this;
      },
      cleanup: function() {
        this.assigned.clear();
        this.unassigned.clear();
        this.newFaces = [];
        return this;
      },
      compute: function() {
        var vertex;
        this.computeInitialHull();
        while ((vertex = this.nextVertexToAdd()) !== void 0) {
          this.addVertexToHull(vertex);
        }
        this.reindexFaces();
        this.cleanup();
        return this;
      }
    });
    function Face() {
      this.normal = new Vector3();
      this.midpoint = new Vector3();
      this.area = 0;
      this.constant = 0;
      this.outside = null;
      this.mark = Visible;
      this.edge = null;
    }
    Object.assign(Face, {
      create: function(a, b2, c) {
        var face = new Face();
        var e0 = new HalfEdge(a, face);
        var e1 = new HalfEdge(b2, face);
        var e2 = new HalfEdge(c, face);
        e0.next = e2.prev = e1;
        e1.next = e0.prev = e2;
        e2.next = e1.prev = e0;
        face.edge = e0;
        return face.compute();
      }
    });
    Object.assign(Face.prototype, {
      getEdge: function(i) {
        var edge = this.edge;
        while (i > 0) {
          edge = edge.next;
          i--;
        }
        while (i < 0) {
          edge = edge.prev;
          i++;
        }
        return edge;
      },
      compute: function() {
        var triangle;
        return function compute() {
          if (triangle === void 0)
            triangle = new Triangle();
          var a = this.edge.tail();
          var b2 = this.edge.head();
          var c = this.edge.next.head();
          triangle.set(a.point, b2.point, c.point);
          triangle.getNormal(this.normal);
          triangle.getMidpoint(this.midpoint);
          this.area = triangle.getArea();
          this.constant = this.normal.dot(this.midpoint);
          return this;
        };
      }(),
      distanceToPoint: function(point) {
        return this.normal.dot(point) - this.constant;
      }
    });
    function HalfEdge(vertex, face) {
      this.vertex = vertex;
      this.prev = null;
      this.next = null;
      this.twin = null;
      this.face = face;
    }
    Object.assign(HalfEdge.prototype, {
      head: function() {
        return this.vertex;
      },
      tail: function() {
        return this.prev ? this.prev.vertex : null;
      },
      length: function() {
        var head = this.head();
        var tail = this.tail();
        if (tail !== null) {
          return tail.point.distanceTo(head.point);
        }
        return -1;
      },
      lengthSquared: function() {
        var head = this.head();
        var tail = this.tail();
        if (tail !== null) {
          return tail.point.distanceToSquared(head.point);
        }
        return -1;
      },
      setTwin: function(edge) {
        this.twin = edge;
        edge.twin = this;
        return this;
      }
    });
    function VertexNode(point) {
      this.point = point;
      this.prev = null;
      this.next = null;
      this.face = null;
    }
    function VertexList() {
      this.head = null;
      this.tail = null;
    }
    Object.assign(VertexList.prototype, {
      first: function() {
        return this.head;
      },
      last: function() {
        return this.tail;
      },
      clear: function() {
        this.head = this.tail = null;
        return this;
      },
      insertBefore: function(target, vertex) {
        vertex.prev = target.prev;
        vertex.next = target;
        if (vertex.prev === null) {
          this.head = vertex;
        } else {
          vertex.prev.next = vertex;
        }
        target.prev = vertex;
        return this;
      },
      insertAfter: function(target, vertex) {
        vertex.prev = target;
        vertex.next = target.next;
        if (vertex.next === null) {
          this.tail = vertex;
        } else {
          vertex.next.prev = vertex;
        }
        target.next = vertex;
        return this;
      },
      append: function(vertex) {
        if (this.head === null) {
          this.head = vertex;
        } else {
          this.tail.next = vertex;
        }
        vertex.prev = this.tail;
        vertex.next = null;
        this.tail = vertex;
        return this;
      },
      appendChain: function(vertex) {
        if (this.head === null) {
          this.head = vertex;
        } else {
          this.tail.next = vertex;
        }
        vertex.prev = this.tail;
        while (vertex.next !== null) {
          vertex = vertex.next;
        }
        this.tail = vertex;
        return this;
      },
      remove: function(vertex) {
        if (vertex.prev === null) {
          this.head = vertex.next;
        } else {
          vertex.prev.next = vertex.next;
        }
        if (vertex.next === null) {
          this.tail = vertex.prev;
        } else {
          vertex.next.prev = vertex.prev;
        }
        return this;
      },
      removeSubList: function(a, b2) {
        if (a.prev === null) {
          this.head = b2.next;
        } else {
          a.prev.next = b2.next;
        }
        if (b2.next === null) {
          this.tail = a.prev;
        } else {
          b2.next.prev = a.prev;
        }
        return this;
      },
      isEmpty: function() {
        return this.head === null;
      }
    });
    return ConvexHull2;
  }();

  // node_modules/three/examples/jsm/geometries/ConvexGeometry.js
  var ConvexGeometry = function(points) {
    BufferGeometry.call(this);
    var vertices = [];
    var normals = [];
    if (ConvexHull === void 0) {
      console.error("THREE.ConvexBufferGeometry: ConvexBufferGeometry relies on ConvexHull");
    }
    var convexHull = new ConvexHull().setFromPoints(points);
    var faces = convexHull.faces;
    for (var i = 0; i < faces.length; i++) {
      var face = faces[i];
      var edge = face.edge;
      do {
        var point = edge.head().point;
        vertices.push(point.x, point.y, point.z);
        normals.push(face.normal.x, face.normal.y, face.normal.z);
        edge = edge.next;
      } while (edge !== face.edge);
    }
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
  };
  ConvexGeometry.prototype = Object.create(BufferGeometry.prototype);
  ConvexGeometry.prototype.constructor = ConvexGeometry;

  // node_modules/@enable3d/ammo-physics/dist/convexObjectBreaker.js
  var newConvexGeometry = (points) => {
    const _newConvexGeometry = window.THREE && window.THREE.ConvexGeometry ? window.THREE.ConvexGeometry : ConvexGeometry;
    return new _newConvexGeometry(points);
  };
  var ConvexObjectBreaker = function(minSizeForBreak, smallDelta) {
    this.minSizeForBreak = minSizeForBreak || 1.4;
    this.smallDelta = smallDelta || 1e-4;
    this.tempLine1 = new Line3();
    this.tempPlane1 = new Plane();
    this.tempPlane2 = new Plane();
    this.tempPlane_Cut = new Plane();
    this.tempCM1 = new Vector3();
    this.tempCM2 = new Vector3();
    this.tempVector3 = new Vector3();
    this.tempVector3_2 = new Vector3();
    this.tempVector3_3 = new Vector3();
    this.tempVector3_P0 = new Vector3();
    this.tempVector3_P1 = new Vector3();
    this.tempVector3_P2 = new Vector3();
    this.tempVector3_N0 = new Vector3();
    this.tempVector3_N1 = new Vector3();
    this.tempVector3_AB = new Vector3();
    this.tempVector3_CB = new Vector3();
    this.tempResultObjects = { object1: null, object2: null };
    this.segments = [];
    var n = 30 * 30;
    for (var i = 0; i < n; i++)
      this.segments[i] = false;
  };
  ConvexObjectBreaker.prototype = {
    constructor: ConvexObjectBreaker,
    prepareBreakableObject: function(object, mass, velocity, angularVelocity, breakable) {
      if (!object.geometry.isBufferGeometry) {
        console.error("THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry.");
      }
      object.userData.ammoPhysicsData = {};
      var ammoPhysicsData = object.userData.ammoPhysicsData;
      ammoPhysicsData.mass = mass;
      ammoPhysicsData.velocity = velocity.clone();
      ammoPhysicsData.angularVelocity = angularVelocity.clone();
      ammoPhysicsData.breakable = breakable;
    },
    subdivideByImpact: function(object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) {
      var debris = [];
      var tempPlane1 = this.tempPlane1;
      var tempPlane2 = this.tempPlane2;
      this.tempVector3.addVectors(pointOfImpact, normal);
      tempPlane1.setFromCoplanarPoints(pointOfImpact, object.position, this.tempVector3);
      var maxTotalIterations = maxRandomIterations + maxRadialIterations;
      var scope = this;
      function subdivideRadial(subObject, startAngle, endAngle, numIterations) {
        if (Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations) {
          debris.push(subObject);
          return;
        }
        var angle = Math.PI;
        if (numIterations === 0) {
          tempPlane2.normal.copy(tempPlane1.normal);
          tempPlane2.constant = tempPlane1.constant;
        } else {
          if (numIterations <= maxRadialIterations) {
            angle = (endAngle - startAngle) * (0.2 + 0.6 * Math.random()) + startAngle;
            scope.tempVector3_2.copy(object.position).sub(pointOfImpact).applyAxisAngle(normal, angle).add(pointOfImpact);
            tempPlane2.setFromCoplanarPoints(pointOfImpact, scope.tempVector3, scope.tempVector3_2);
          } else {
            angle = (0.5 * (numIterations & 1) + 0.2 * (2 - Math.random())) * Math.PI;
            scope.tempVector3_2.copy(pointOfImpact).sub(subObject.position).applyAxisAngle(normal, angle).add(subObject.position);
            scope.tempVector3_3.copy(normal).add(subObject.position);
            tempPlane2.setFromCoplanarPoints(subObject.position, scope.tempVector3_3, scope.tempVector3_2);
          }
        }
        scope.cutByPlane(subObject, tempPlane2, scope.tempResultObjects);
        var obj1 = scope.tempResultObjects.object1;
        var obj2 = scope.tempResultObjects.object2;
        if (obj1) {
          subdivideRadial(obj1, startAngle, angle, numIterations + 1);
        }
        if (obj2) {
          subdivideRadial(obj2, angle, endAngle, numIterations + 1);
        }
      }
      subdivideRadial(object, 0, 2 * Math.PI, 0);
      return debris;
    },
    cutByPlane: function(object, plane, output) {
      var geometry = object.geometry;
      var coords = geometry.attributes.position.array;
      var normals = geometry.attributes.normal.array;
      var numPoints = coords.length / 3;
      var numFaces = numPoints / 3;
      var indices = geometry.getIndex();
      if (indices) {
        indices = indices.array;
        numFaces = indices.length / 3;
      }
      function getVertexIndex(faceIdx, vert) {
        var idx = faceIdx * 3 + vert;
        return indices ? indices[idx] : idx;
      }
      var points1 = [];
      var points2 = [];
      var delta = this.smallDelta;
      var numPointPairs = numPoints * numPoints;
      for (var i = 0; i < numPointPairs; i++)
        this.segments[i] = false;
      var p0 = this.tempVector3_P0;
      var p1 = this.tempVector3_P1;
      var n0 = this.tempVector3_N0;
      var n1 = this.tempVector3_N1;
      for (var i = 0; i < numFaces - 1; i++) {
        var a1 = getVertexIndex(i, 0);
        var b1 = getVertexIndex(i, 1);
        var c1 = getVertexIndex(i, 2);
        n0.set(normals[a1], normals[a1] + 1, normals[a1] + 2);
        for (var j = i + 1; j < numFaces; j++) {
          var a2 = getVertexIndex(j, 0);
          var b2 = getVertexIndex(j, 1);
          var c2 = getVertexIndex(j, 2);
          n1.set(normals[a2], normals[a2] + 1, normals[a2] + 2);
          var coplanar = 1 - n0.dot(n1) < delta;
          if (coplanar) {
            if (a1 === a2 || a1 === b2 || a1 === c2) {
              if (b1 === a2 || b1 === b2 || b1 === c2) {
                this.segments[a1 * numPoints + b1] = true;
                this.segments[b1 * numPoints + a1] = true;
              } else {
                this.segments[c1 * numPoints + a1] = true;
                this.segments[a1 * numPoints + c1] = true;
              }
            } else if (b1 === a2 || b1 === b2 || b1 === c2) {
              this.segments[c1 * numPoints + b1] = true;
              this.segments[b1 * numPoints + c1] = true;
            }
          }
        }
      }
      var localPlane = this.tempPlane_Cut;
      object.updateMatrix();
      ConvexObjectBreaker.transformPlaneToLocalSpace(plane, object.matrix, localPlane);
      for (var i = 0; i < numFaces; i++) {
        var va = getVertexIndex(i, 0);
        var vb = getVertexIndex(i, 1);
        var vc = getVertexIndex(i, 2);
        for (var segment = 0; segment < 3; segment++) {
          var i0 = segment === 0 ? va : segment === 1 ? vb : vc;
          var i1 = segment === 0 ? vb : segment === 1 ? vc : va;
          var segmentState = this.segments[i0 * numPoints + i1];
          if (segmentState)
            continue;
          this.segments[i0 * numPoints + i1] = true;
          this.segments[i1 * numPoints + i0] = true;
          p0.set(coords[3 * i0], coords[3 * i0 + 1], coords[3 * i0 + 2]);
          p1.set(coords[3 * i1], coords[3 * i1 + 1], coords[3 * i1 + 2]);
          var mark0 = 0;
          var d = localPlane.distanceToPoint(p0);
          if (d > delta) {
            mark0 = 2;
            points2.push(p0.clone());
          } else if (d < -delta) {
            mark0 = 1;
            points1.push(p0.clone());
          } else {
            mark0 = 3;
            points1.push(p0.clone());
            points2.push(p0.clone());
          }
          var mark1 = 0;
          var d = localPlane.distanceToPoint(p1);
          if (d > delta) {
            mark1 = 2;
            points2.push(p1.clone());
          } else if (d < -delta) {
            mark1 = 1;
            points1.push(p1.clone());
          } else {
            mark1 = 3;
            points1.push(p1.clone());
            points2.push(p1.clone());
          }
          if (mark0 === 1 && mark1 === 2 || mark0 === 2 && mark1 === 1) {
            this.tempLine1.start.copy(p0);
            this.tempLine1.end.copy(p1);
            var intersection = new Vector3();
            intersection = localPlane.intersectLine(this.tempLine1, intersection);
            if (intersection === void 0) {
              console.error("Internal error: segment does not intersect plane.");
              output.segmentedObject1 = null;
              output.segmentedObject2 = null;
              return 0;
            }
            points1.push(intersection);
            points2.push(intersection.clone());
          }
        }
      }
      var newMass = object.userData.ammoPhysicsData.mass * 0.5;
      this.tempCM1.set(0, 0, 0);
      var radius1 = 0;
      var numPoints1 = points1.length;
      if (numPoints1 > 0) {
        for (var i = 0; i < numPoints1; i++)
          this.tempCM1.add(points1[i]);
        this.tempCM1.divideScalar(numPoints1);
        for (var i = 0; i < numPoints1; i++) {
          var p = points1[i];
          p.sub(this.tempCM1);
          radius1 = Math.max(radius1, p.x, p.y, p.z);
        }
        this.tempCM1.add(object.position);
      }
      this.tempCM2.set(0, 0, 0);
      var radius2 = 0;
      var numPoints2 = points2.length;
      if (numPoints2 > 0) {
        for (var i = 0; i < numPoints2; i++)
          this.tempCM2.add(points2[i]);
        this.tempCM2.divideScalar(numPoints2);
        for (var i = 0; i < numPoints2; i++) {
          var p = points2[i];
          p.sub(this.tempCM2);
          radius2 = Math.max(radius2, p.x, p.y, p.z);
        }
        this.tempCM2.add(object.position);
      }
      var object1 = null;
      var object2 = null;
      var numObjects = 0;
      if (numPoints1 > 4) {
        try {
          object1 = new Mesh(newConvexGeometry(points1), object.material);
          object1.position.copy(this.tempCM1);
          object1.quaternion.copy(object.quaternion);
          object1.userData = object.userData;
          this.prepareBreakableObject(object1, newMass, object.userData.ammoPhysicsData.velocity, object.userData.ammoPhysicsData.angularVelocity, 2 * radius1 > this.minSizeForBreak);
          numObjects++;
        } catch (error) {
          logger("Error in ConvexObjectBreaker.ts", true);
          logger(error, true);
        }
      }
      if (numPoints2 > 4) {
        try {
          object2 = new Mesh(newConvexGeometry(points2), object.material);
          object2.position.copy(this.tempCM2);
          object2.quaternion.copy(object.quaternion);
          object2.userData = object.userData;
          this.prepareBreakableObject(object2, newMass, object.userData.ammoPhysicsData.velocity, object.userData.ammoPhysicsData.angularVelocity, 2 * radius2 > this.minSizeForBreak);
          numObjects++;
        } catch (error) {
          logger("Error in ConvexObjectBreaker.ts", true);
          logger(error, true);
        }
      }
      output.object1 = object1;
      output.object2 = object2;
      return numObjects;
    }
  };
  ConvexObjectBreaker.transformFreeVector = function(v, m) {
    var x = v.x, y = v.y, z = v.z;
    var e = m.elements;
    v.x = e[0] * x + e[4] * y + e[8] * z;
    v.y = e[1] * x + e[5] * y + e[9] * z;
    v.z = e[2] * x + e[6] * y + e[10] * z;
    return v;
  };
  ConvexObjectBreaker.transformFreeVectorInverse = function(v, m) {
    var x = v.x, y = v.y, z = v.z;
    var e = m.elements;
    v.x = e[0] * x + e[1] * y + e[2] * z;
    v.y = e[4] * x + e[5] * y + e[6] * z;
    v.z = e[8] * x + e[9] * y + e[10] * z;
    return v;
  };
  ConvexObjectBreaker.transformTiedVectorInverse = function(v, m) {
    var x = v.x, y = v.y, z = v.z;
    var e = m.elements;
    v.x = e[0] * x + e[1] * y + e[2] * z - e[12];
    v.y = e[4] * x + e[5] * y + e[6] * z - e[13];
    v.z = e[8] * x + e[9] * y + e[10] * z - e[14];
    return v;
  };
  ConvexObjectBreaker.transformPlaneToLocalSpace = function() {
    var v1 = new Vector3();
    return function transformPlaneToLocalSpace(plane, m, resultPlane) {
      resultPlane.normal.copy(plane.normal);
      resultPlane.constant = plane.constant;
      var referencePoint = ConvexObjectBreaker.transformTiedVectorInverse(plane.coplanarPoint(v1), m);
      ConvexObjectBreaker.transformFreeVectorInverse(resultPlane.normal, m);
      resultPlane.constant = -referencePoint.dot(resultPlane.normal);
    };
  }();

  // node_modules/@enable3d/common/dist/wasmLoader.js
  var wasmSupported = (() => {
    try {
      if (typeof WebAssembly === "object" && typeof WebAssembly.instantiate === "function") {
        const module = new WebAssembly.Module(Uint8Array.of(0, 97, 115, 109, 1, 0, 0, 0));
        if (module instanceof WebAssembly.Module)
          return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;
      }
    } catch (e) {
      console.error(e.message);
    }
    return false;
  })();
  var loadScriptAsync = (url, doneCallback) => {
    var tag = document.createElement("script");
    tag.onload = () => {
      doneCallback();
    };
    tag.onerror = () => {
      throw new Error(`failed to load ${url}`);
    };
    tag.async = true;
    tag.src = url;
    document.head.appendChild(tag);
  };
  var loadAmmoModule = (path, doneCallback) => {
    if (wasmSupported)
      loadScriptAsync(`${path}/ammo.wasm.js`, () => doneCallback());
    else
      loadScriptAsync(`${path}/ammo.js`, () => doneCallback());
  };
  var wasmLoader_default = loadAmmoModule;

  // node_modules/@enable3d/common/dist/physicsLoader.js
  var PhysicsLoader = (path, callback) => {
    if (typeof window !== "undefined")
      window.__loadPhysics = true;
    wasmLoader_default(path, () => {
      Ammo().then(() => {
        callback();
      });
    });
  };

  // node_modules/@enable3d/common/dist/applyMixins.js
  var applyMixins = (derivedCtor, baseCtors) => {
    baseCtors.forEach((baseCtor) => {
      Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {
        Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));
      });
    });
  };
  var applyMixins_default = applyMixins;

  // node_modules/@enable3d/ammo-physics/dist/raycaster/closestRayResultCallback.js
  var ClosestRayResultCallback = class {
    constructor(physics) {
      this.physics = physics;
    }
    getHitPointWorld() {
      const h = this._btRayCallback.get_m_hitPointWorld();
      const point = { x: h.x(), y: h.y(), z: h.z() };
      return point;
    }
    getHitNormalWorld() {
      const h = this._btRayCallback.get_m_hitNormalWorld();
      const normal = { x: h.x(), y: h.y(), z: h.z() };
      return normal;
    }
    getCollisionObject() {
      const rb = Ammo.castObject(this._btRayCallback.get_m_collisionObject(), Ammo.btRigidBody);
      return rb.threeObject;
    }
  };

  // node_modules/@enable3d/ammo-physics/dist/raycaster/allHitsRayResultCallback.js
  var AllHitsRayResultCallback = class {
    constructor(physics) {
      this.physics = physics;
    }
    getHitPointsWorld() {
      const h = this._btRayCallback.get_m_hitPointWorld();
      const points = [];
      for (let i = h.size() - 1; i >= 0; i--) {
        const hh = h.at(i);
        points.push({ x: hh.x(), y: hh.y(), z: hh.z() });
      }
      return points;
    }
    getHitPointWorld() {
      logger("Use getHitPointsWorld() instead of getHitPointWorld() for the AllHitsRayCaster!");
      return this.getHitPointsWorld();
    }
    getHitNormalsWorld() {
      const h = this._btRayCallback.get_m_hitNormalWorld();
      const normals = [];
      for (let i = h.size() - 1; i >= 0; i--) {
        const hh = h.at(i);
        normals.push({ x: hh.x(), y: hh.y(), z: hh.z() });
      }
      return normals;
    }
    getCollisionObjects() {
      const threeObjects = [];
      const objects = this._btRayCallback.get_m_collisionObjects();
      for (let i = objects.size() - 1; i >= 0; i--) {
        const rb = Ammo.castObject(objects.at(i), Ammo.btRigidBody);
        threeObjects.push(rb.threeObject);
      }
      return threeObjects;
    }
  };

  // node_modules/@enable3d/ammo-physics/dist/raycaster/raycaster.js
  var Raycaster2 = class {
    constructor(physics) {
      this.physics = physics;
    }
    setRayFromWorld(x = 0, y = 0, z = 0) {
      this._btRayFrom.setValue(x, y, z);
    }
    setRayToWorld(x = 0, y = 0, z = 0) {
      this._btRayTo.setValue(x, y, z);
    }
    hasHit() {
      return this._btRayCallback.hasHit();
    }
    rayTest() {
      if (typeof this._btRayCallback !== "undefined")
        Ammo.destroy(this._btRayCallback);
      this._btRayCallback = this.type === "closest" ? new Ammo.ClosestRayResultCallback(this._btRayFrom, this._btRayTo) : new Ammo.AllHitsRayResultCallback(this._btRayFrom, this._btRayTo);
      this.physics.physicsWorld.rayTest(this._btRayFrom, this._btRayTo, this._btRayCallback);
    }
    destroy() {
      if (typeof this._btRayFrom !== "undefined")
        Ammo.destroy(this._btRayFrom);
      if (typeof this._btRayTo !== "undefined")
        Ammo.destroy(this._btRayTo);
      if (typeof this._btRayCallback !== "undefined")
        Ammo.destroy(this._btRayCallback);
    }
  };
  var ClosestRaycaster = class {
    constructor(physics) {
      this.physics = physics;
      this.type = "closest";
      this._btRayFrom = new Ammo.btVector3(0, 0, 0);
      this._btRayTo = new Ammo.btVector3(0, 0, 0);
    }
  };
  var AllHitsRaycaster = class {
    constructor(physics) {
      this.physics = physics;
      this.type = "allHits";
      this._btRayFrom = new Ammo.btVector3(0, 0, 0);
      this._btRayTo = new Ammo.btVector3(0, 0, 0);
    }
  };
  applyMixins_default(ClosestRaycaster, [Raycaster2, ClosestRayResultCallback]);
  applyMixins_default(AllHitsRaycaster, [Raycaster2, AllHitsRayResultCallback]);

  // node_modules/@enable3d/ammo-physics/dist/physics.js
  var AmmoPhysics = class extends import_events3.Events {
    constructor(scene, config = {}) {
      super();
      this.scene = scene;
      this.config = config;
      this.rigidBodies = [];
      this.earlierDetectedCollisions = [];
      this.complexShapes = ["plane", "hull", "hacd", "vhacd", "convexMesh", "concaveMesh"];
      this.gravity = config.gravity || { x: 0, y: -9.81, z: 0 };
      this.isHeadless = scene === "headless" ? true : false;
      this.tmpEuler = new Euler();
      this.tmpQuaternion = new Quaternion();
      this.tmpVector3 = new Vector3();
      this.tmpVector3a = new Vector3();
      this.tmpMatrix4 = new Matrix4();
      this.tmpMatrix4a = new Matrix4();
      this.tmpBtVector3 = new Ammo.btVector3();
      this.tmpBtQuaternion = new Ammo.btQuaternion(0, 0, 0, 1);
      this.emptyV3 = new Vector3();
      this.impactPoint = new Vector3();
      this.impactNormal = new Vector3();
      if (scene !== "headless") {
        this.defaultMaterial = new defaultMaterial_default();
      }
      this.start();
    }
    get tmpTrans() {
      console.warn("Use worldTransform instead of tmpTrans.");
      return this.worldTransform;
    }
    set tmpTrans(transform) {
      console.warn("Use worldTransform instead of tmpTrans.");
      this.worldTransform = transform;
    }
    destroy(body) {
      var _a;
      const b2 = Object.keys(body).includes("body") ? body.body : body;
      if (typeof (b2 === null || b2 === void 0 ? void 0 : b2.ammo) === "undefined")
        return;
      const name = b2.ammo.name;
      let obj = b2.ammo.threeObject;
      if (name && obj) {
        if ((_a = obj === null || obj === void 0 ? void 0 : obj.body) === null || _a === void 0 ? void 0 : _a.ammo) {
          !obj.body.isSoftBody ? this.physicsWorld.removeRigidBody(obj.body.ammo) : this.physicsWorld.removeSoftBody(obj.body.ammo);
          obj.body.destructor();
          obj.body = void 0;
          obj.hasBody = false;
          delete b2.ammo.threeObject;
          for (let i = 0; i < this.rigidBodies.length; i++) {
            if (this.rigidBodies[i].name === name) {
              this.rigidBodies.splice(i, 1);
              i--;
            }
          }
        }
      }
      if (this.scene === "headless" && obj)
        obj = null;
    }
    setup() {
      this.worldTransform = new Ammo.btTransform();
      if (typeof this.config.setupPhysicsWorld === "function")
        this.physicsWorld = this.config.setupPhysicsWorld();
      else
        this.physicsWorld = this.setupPhysicsWorld();
      if (this.scene !== "headless") {
        this.convexBreaker = new ConvexObjectBreaker();
        this.objectsToRemove = [];
        this.numObjectsToRemove = 0;
        for (let i = 0; i < 500; i++) {
          this.objectsToRemove[i] = null;
        }
      }
      this.collisionEvents = new CollisionEvents();
      this.factory = new Factories(this.scene);
      this.shapes = new shapes_default(this.factory, (object, config) => this.addExisting(object, config));
      this.constraints = new Constraints(this.worldTransform, this.physicsWorld);
      if (this.scene !== "headless")
        this.debugDrawer = new debugDrawer_default(this.scene, this.physicsWorld, {});
    }
    updateDebugger() {
      if (this.scene === "headless")
        return;
      if (this.debugDrawer && this.debugDrawer.enabled)
        this.debugDrawer.update();
    }
    setupPhysicsWorld() {
      const g = this.gravity;
      const { softBodies = false } = this.config;
      let physicsWorld;
      if (!softBodies) {
        const collisionConfiguration = new Ammo.btDefaultCollisionConfiguration(), dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration), broadphase = new Ammo.btDbvtBroadphase(), solver = new Ammo.btSequentialImpulseConstraintSolver();
        physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);
      }
      if (softBodies) {
        const collisionConfiguration = new Ammo.btSoftBodyRigidBodyCollisionConfiguration(), dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration), broadphase = new Ammo.btDbvtBroadphase(), solver = new Ammo.btSequentialImpulseConstraintSolver(), softBodySolver = new Ammo.btDefaultSoftBodySolver();
        physicsWorld = new Ammo.btSoftRigidDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration, softBodySolver);
      }
      physicsWorld.setGravity(new Ammo.btVector3(g.x, g.y, g.z));
      return physicsWorld;
    }
    createDebrisFromBreakableObject(object, parent) {
      if (this.scene === "headless")
        return;
      object.material = parent.material;
      object.shape = "hull";
      object.fragmentDepth = parent.fragmentDepth + 1;
      this.scene.add(object);
      this.addExisting(object);
      object.body.fractureImpulse = parent.body.fractureImpulse;
      object.body.breakable = false;
      setTimeout(() => {
        object.body.breakable = true;
      }, 2500);
    }
    removeDebris(object) {
      if (this.scene === "headless")
        return;
      this.scene.remove(object);
      this.destroy(object);
    }
    update(delta) {
      this.updatePhysics(delta);
      this.detectCollisions();
    }
    updatePhysics(delta) {
      const deltaTime = delta / 1e3;
      this.physicsWorld.stepSimulation(deltaTime, this.config.maxSubSteps || 4, this.config.fixedTimeStep || 1 / 60);
      for (let i = 0; i < this.rigidBodies.length; i++) {
        const objThree = this.rigidBodies[i];
        const objPhys = objThree.body.ammo;
        const ms = objPhys.getMotionState();
        if (ms) {
          ms.getWorldTransform(this.worldTransform);
          if (objThree.body.didUpdate) {
            if (objThree.body._emitUpdateEvents)
              objThree.body.eventEmitter.emit("update");
            objThree.body.didUpdate = false;
          }
          if (objThree.body.ammo.isKinematicObject() && objThree.body.needUpdate) {
            objThree.getWorldQuaternion(this.tmpQuaternion);
            objThree.getWorldPosition(this.tmpVector3);
            this.tmpBtVector3.setValue(this.tmpVector3.x, this.tmpVector3.y, this.tmpVector3.z);
            this.tmpBtQuaternion.setValue(this.tmpQuaternion.x, this.tmpQuaternion.y, this.tmpQuaternion.z, this.tmpQuaternion.w);
            this.worldTransform.setOrigin(this.tmpBtVector3);
            this.worldTransform.setRotation(this.tmpBtQuaternion);
            ms.setWorldTransform(this.worldTransform);
            objThree.body.needUpdate = false;
          } else if (objThree.body.skipUpdate) {
          } else if (!objThree.body.ammo.isStaticObject()) {
            const p = this.worldTransform.getOrigin();
            const q = this.worldTransform.getRotation();
            const o = objThree.body.offset;
            if (objThree.body.ignoreScale) {
              this.tmpVector3a.set(objThree.scale.x, objThree.scale.y, objThree.scale.z);
            } else {
              const scale = objThree.body.ammo.getCollisionShape().getLocalScaling();
              this.tmpVector3a.set(scale.x(), scale.y(), scale.z());
            }
            this.tmpVector3.set(p.x() + o.x, p.y() + o.y, p.z() + o.z);
            this.tmpQuaternion.set(q.x(), q.y(), q.z(), q.w());
            this.tmpMatrix4.compose(this.tmpVector3, this.tmpQuaternion, this.tmpVector3a);
            if (objThree.parent) {
              if (parseInt(REVISION) >= 123)
                this.tmpMatrix4a.copy(objThree.parent.matrixWorld).invert();
              else
                this.tmpMatrix4a.getInverse(objThree.parent.matrixWorld);
            } else {
              this.tmpMatrix4a.identity();
            }
            this.tmpMatrix4a.multiply(this.tmpMatrix4);
            this.tmpMatrix4a.decompose(objThree.position, objThree.quaternion, objThree.scale);
          }
        }
      }
    }
    detectCollisions() {
      var _a, _b;
      const detectedCollisions = [];
      this.impactPoint.set(0, 0, 0);
      this.impactNormal.set(0, 0, 0);
      const dispatcher = this.physicsWorld.getDispatcher();
      const numManifolds = dispatcher.getNumManifolds();
      for (let i = 0; i < numManifolds; i++) {
        const contactManifold = dispatcher.getManifoldByIndexInternal(i);
        const numContacts = contactManifold.getNumContacts();
        const rb0 = Ammo.castObject(contactManifold.getBody0(), Ammo.btRigidBody);
        const rb1 = Ammo.castObject(contactManifold.getBody1(), Ammo.btRigidBody);
        const threeObject0 = rb0.threeObject;
        const threeObject1 = rb1.threeObject;
        if (!threeObject0 || !threeObject1) {
          continue;
        }
        if (rb0.name === "" && rb1.name === "")
          continue;
        const checkCollisions0 = (_a = threeObject0.body) === null || _a === void 0 ? void 0 : _a.checkCollisions;
        const checkCollisions1 = (_b = threeObject1.body) === null || _b === void 0 ? void 0 : _b.checkCollisions;
        const breakable0 = threeObject0.body.breakable;
        const breakable1 = threeObject1.body.breakable;
        const fractureImpulse0 = threeObject0.body.fractureImpulse;
        const fractureImpulse1 = threeObject1.body.fractureImpulse;
        const checkCollisions = checkCollisions0 || checkCollisions1;
        const checkBreakable = breakable0 || breakable1;
        if (!checkCollisions && !checkBreakable)
          continue;
        let contact = false;
        let maxImpulse = 0;
        let event = "start";
        for (let j = 0; j < numContacts; j++) {
          const contactPoint = contactManifold.getContactPoint(j);
          const distance = contactPoint.getDistance();
          if (distance <= 0) {
            contact = true;
            const impulse = contactPoint.getAppliedImpulse();
            const impactPoint = contactPoint.get_m_positionWorldOnB();
            const impactNormal = contactPoint.get_m_normalWorldOnB();
            if (checkCollisions0 || checkCollisions1) {
              const names = [threeObject0.name, threeObject1.name].sort();
              const combinedName = `${names[0]}__${names[1]}`;
              if (this.earlierDetectedCollisions.find((el) => el.combinedName === combinedName))
                event = "collision";
              if (!detectedCollisions.find((el) => el.combinedName === combinedName)) {
                detectedCollisions.push({ combinedName, collision: true });
                this.collisionEvents.emit("collision", { bodies: [threeObject0, threeObject1], event });
              }
            }
            if (impulse >= maxImpulse) {
              maxImpulse = impulse;
              if (breakable0 || breakable1) {
                this.impactPoint.set(impactPoint.x(), impactPoint.y(), impactPoint.z());
                this.impactNormal.set(impactNormal.x(), impactNormal.y(), impactNormal.z());
              }
            }
            break;
          }
        }
        if (!contact)
          continue;
        if (!checkBreakable)
          continue;
        const MAX_FRAGMENT_DEPTH = 2;
        this.emptyV3.set(0, 0, 0);
        threeObject0.userData.ammoPhysicsData = {
          mass: 1,
          velocity: this.emptyV3,
          angularVelocity: this.emptyV3,
          breakable: breakable0,
          physicsBody: rb0
        };
        threeObject1.userData.ammoPhysicsData = {
          mass: 1,
          velocity: this.emptyV3,
          angularVelocity: this.emptyV3,
          breakable: breakable1,
          physicsBody: rb1
        };
        if (breakable0 && maxImpulse > fractureImpulse0 && threeObject0.fragmentDepth < MAX_FRAGMENT_DEPTH) {
          const debris = this.convexBreaker.subdivideByImpact(threeObject0, this.impactPoint, this.impactNormal, 1, 2);
          const numObjects = debris.length;
          for (let j = 0; j < numObjects; j++) {
            const vel = rb0.getLinearVelocity();
            const angVel = rb0.getAngularVelocity();
            const fragment = debris[j];
            fragment.userData.ammoPhysicsData.velocity.set(vel.x(), vel.y(), vel.z());
            fragment.userData.ammoPhysicsData.angularVelocity.set(angVel.x(), angVel.y(), angVel.z());
            this.createDebrisFromBreakableObject(fragment, threeObject0);
          }
          this.objectsToRemove[this.numObjectsToRemove++] = threeObject0;
        }
        if (breakable1 && maxImpulse > fractureImpulse1 && threeObject1.fragmentDepth < MAX_FRAGMENT_DEPTH) {
          const debris = this.convexBreaker.subdivideByImpact(threeObject1, this.impactPoint, this.impactNormal, 1, 2);
          const numObjects = debris.length;
          for (let j = 0; j < numObjects; j++) {
            const vel = rb1.getLinearVelocity();
            const angVel = rb1.getAngularVelocity();
            const fragment = debris[j];
            fragment.userData.ammoPhysicsData.velocity.set(vel.x(), vel.y(), vel.z());
            fragment.userData.ammoPhysicsData.angularVelocity.set(angVel.x(), angVel.y(), angVel.z());
            this.createDebrisFromBreakableObject(fragment, threeObject1);
          }
          this.objectsToRemove[this.numObjectsToRemove++] = threeObject1;
        }
      }
      for (let i = 0; i < this.numObjectsToRemove; i++) {
        this.removeDebris(this.objectsToRemove[i]);
      }
      this.numObjectsToRemove = 0;
      this.earlierDetectedCollisions.forEach((el) => {
        const { combinedName } = el;
        if (!detectedCollisions.find((el2) => el2.combinedName === combinedName)) {
          const split = combinedName.split("__");
          const obj0 = this.rigidBodies.find((obj) => obj.name === split[0]);
          const obj1 = this.rigidBodies.find((obj) => obj.name === split[1]);
          const event = "end";
          if (obj0 && obj1)
            this.collisionEvents.emit("collision", { bodies: [obj0, obj1], event });
        }
      });
      this.earlierDetectedCollisions = [...detectedCollisions];
    }
    setGravity(x = 0, y = -9.8, z = 0) {
      this.tmpBtVector3.setValue(x, y, z);
      this.physicsWorld.setGravity(this.tmpBtVector3);
    }
    get debug() {
      if (this.isHeadless)
        return null;
      return {
        enable: () => {
          this.debugDrawer.enable();
        },
        mode: (debugMode = 1) => {
          this.debugDrawer.setDebugMode(debugMode);
        },
        disable: () => {
          this.debugDrawer.disable();
        }
      };
    }
    start() {
      if (typeof Ammo === "undefined") {
        logger("Are you sure you included ammo.js?");
        return;
      }
      if (typeof Ammo === "function")
        Ammo().then(() => {
          this.setup();
        });
      else
        this.setup();
    }
    get add() {
      return {
        collider: (object1, object2, eventCallback) => this.collisionEvents.addCollider(object1, object2, eventCallback),
        constraints: this.constraints.addConstraints,
        existing: (object, config) => this.addExisting(object, config),
        plane: (planeConfig = {}, materialConfig = {}) => this.shapes.addPlane(planeConfig, materialConfig),
        sphere: (sphereConfig = {}, materialConfig = {}) => this.shapes.addSphere(sphereConfig, materialConfig),
        ground: (groundConfig = {}, materialConfig = {}) => this.shapes.addGround(groundConfig, materialConfig),
        box: (boxConfig = {}, materialConfig = {}) => this.shapes.addBox(boxConfig, materialConfig),
        cylinder: (cylinderConfig = {}, materialConfig = {}) => this.shapes.addCylinder(cylinderConfig, materialConfig),
        cone: (coneConfig = {}, materialConfig = {}) => this.shapes.addCone(coneConfig, materialConfig),
        torus: (torusConfig = {}, materialConfig = {}) => this.shapes.addTorus(torusConfig, materialConfig),
        extrude: (extrudeConfig, materialConfig = {}) => this.shapes.addExtrude(extrudeConfig, materialConfig),
        raycaster: (type = "closest") => {
          if (type === "closest")
            return new ClosestRaycaster(this);
          else
            return new AllHitsRaycaster(this);
        }
      };
    }
    prepareThreeObjectForCollisionShape(object, config = {}) {
      var _a, _b;
      const { autoCenter = false } = config;
      const defaultParams = {
        width: 1,
        height: 1,
        depth: 1,
        radius: 1,
        radiusTop: 1,
        radiusBottom: 1,
        tube: 0.4,
        tubularSegments: 6
      };
      let shape = "unknown";
      const type = ((_a = object.geometry) === null || _a === void 0 ? void 0 : _a.type) || "unknown";
      if (/box/i.test(type))
        shape = "box";
      else if (/cone/i.test(type))
        shape = "cone";
      else if (/cylinder/i.test(type))
        shape = "cylinder";
      else if (/extrude/i.test(type))
        shape = "extrude";
      else if (/plane/i.test(type))
        shape = "plane";
      else if (/sphere/i.test(type))
        shape = "sphere";
      else if (/torus/i.test(type))
        shape = "torus";
      let params = Object.assign(Object.assign({}, defaultParams), (_b = object === null || object === void 0 ? void 0 : object.geometry) === null || _b === void 0 ? void 0 : _b.parameters);
      if (config.shape) {
        params = Object.assign(Object.assign({}, defaultParams), config);
        shape = config.shape;
      } else if (object.shape) {
        shape = object.shape;
      }
      Object.keys(params).forEach((key) => {
        if (typeof params[key] === "undefined" && defaultParams[key]) {
          params[key] = defaultParams[key];
        }
      });
      if (autoCenter)
        object.geometry.center();
      if (shape === "cylinder")
        params.radius = config.radius || params.radiusTop;
      if (shape === "extrude")
        shape = "hacd";
      if (shape === "mesh" || shape === "convex")
        shape = "convexMesh";
      if (shape === "concave")
        shape = "concaveMesh";
      if (shape === "unknown") {
        logger(`Shape for ${object === null || object === void 0 ? void 0 : object.name} not recognized! Will fallback to box.`);
        shape = "box";
      }
      return { shape, params, object };
    }
    createCollisionShape(shape, params, object) {
      const quat = (object === null || object === void 0 ? void 0 : object.quaternion) ? object === null || object === void 0 ? void 0 : object.quaternion : new Quaternion(0, 0, 0, 1);
      const { axis = "y" } = params;
      const btHalfExtents = new Ammo.btVector3();
      const geometry = object === null || object === void 0 ? void 0 : object.geometry;
      if (object && (geometry === null || geometry === void 0 ? void 0 : geometry.isGeometry)) {
        object.geometry = new BufferGeometry().fromGeometry(geometry);
      }
      const extractData = (object2) => {
        const matrixWorld = new Matrix4().elements;
        const vertices = [];
        const matrices = [];
        const indexes = [];
        iterateGeometries(object2, {}, (vertexArray, matrixArray, indexArray) => {
          vertices.push(vertexArray);
          matrices.push(matrixArray);
          indexes.push(indexArray);
        });
        return { vertices, matrices, indexes, matrixWorld };
      };
      let d = {};
      if (this.complexShapes.indexOf(shape) !== -1)
        d = extractData(object);
      let collisionShape;
      switch (shape) {
        case "box":
          btHalfExtents.setValue(params.width / 2, params.height / 2, params.depth / 2);
          collisionShape = new Ammo.btBoxShape(btHalfExtents);
          break;
        case "sphere":
          collisionShape = new Ammo.btSphereShape(params.radius);
          break;
        case "cylinder":
          switch (axis) {
            case "y":
              btHalfExtents.setValue(params.radius, params.height / 2, params.radius);
              collisionShape = new Ammo.btCylinderShape(btHalfExtents);
              break;
            case "x":
              btHalfExtents.setValue(params.height / 2, params.radius, params.radius);
              collisionShape = new Ammo.btCylinderShapeX(btHalfExtents);
              break;
            case "z":
              btHalfExtents.setValue(params.radius, params.radius, params.height / 2);
              collisionShape = new Ammo.btCylinderShapeZ(btHalfExtents);
              break;
          }
          break;
        case "cone":
          switch (axis) {
            case "y":
              collisionShape = new Ammo.btConeShape(params.radius, params.height);
              break;
            case "x":
              collisionShape = new Ammo.btConeShapeX(params.radius, params.height);
              break;
            case "z":
              collisionShape = new Ammo.btConeShapeZ(params.radius, params.height);
              break;
          }
          break;
        case "capsule":
          switch (axis) {
            case "y":
              collisionShape = new Ammo.btCapsuleShape(params.radius, params.height);
              break;
            case "x":
              collisionShape = new Ammo.btCapsuleShapeX(params.radius, params.height);
              break;
            case "z":
              collisionShape = new Ammo.btCapsuleShapeZ(params.radius, params.height);
              break;
          }
          break;
        case "torus":
          collisionShape = createTorusShape(params, quat);
          break;
        case "plane":
          collisionShape = createTriMeshShape(d.vertices, d.matrices, d.indexes, d.matrixWorld, Object.assign(Object.assign({}, params), { concave: false }));
          break;
        case "hull":
          collisionShape = createHullShape(d.vertices, d.matrices, d.matrixWorld, params);
          break;
        case "hacd":
          collisionShape = createHACDShapes(d.vertices, d.matrices, d.indexes, d.matrixWorld, params);
          break;
        case "vhacd":
          collisionShape = createVHACDShapes(d.vertices, d.matrices, d.indexes, d.matrixWorld, params);
          break;
        case "convexMesh":
          collisionShape = createTriMeshShape(d.vertices, d.matrices, d.indexes, d.matrixWorld, Object.assign(Object.assign({}, params), { concave: false }));
          break;
        case "concaveMesh":
          collisionShape = createTriMeshShape(d.vertices, d.matrices, d.indexes, d.matrixWorld, Object.assign(Object.assign({}, params), { concave: true }));
          break;
      }
      Ammo.destroy(btHalfExtents);
      const { x, y, z } = params;
      if (x || y || z) {
        collisionShape.offset = { x: x || 0, y: y || 0, z: z || 0 };
      }
      if (Array.isArray(collisionShape))
        collisionShape = this.mergeCollisionShapesToCompoundShape(collisionShape);
      return collisionShape;
    }
    mergeCollisionShapesToCompoundShape(collisionShapes) {
      const compoundShape = new Ammo.btCompoundShape();
      collisionShapes.forEach((shape) => {
        const _tmp = shape._tmp;
        if (_tmp) {
          const { pos: pos2, quat, scale, margin } = _tmp;
          const transform = this.applyPosQuatScaleMargin(shape, pos2, quat, scale, margin);
          compoundShape.addChildShape(transform, shape);
        } else {
          const transform = new Ammo.btTransform();
          transform.setIdentity();
          compoundShape.addChildShape(transform, shape);
        }
      });
      return compoundShape;
    }
    addExisting(object, config = {}) {
      const { hasBody } = object;
      if (hasBody) {
        logger(`Object "${object.name}" already has a physical body!`);
        return;
      }
      const pos2 = new Vector3();
      const quat = new Quaternion();
      const scale = new Vector3();
      object.getWorldPosition(pos2);
      object.getWorldQuaternion(quat);
      object.getWorldScale(scale);
      const isStaticObject = (config.collisionFlags || 0).toString(2).slice(-1) === "1";
      const isKinematicObject = (config.collisionFlags || 0).toString(2).slice(-2, -1) === "1";
      const {
        shape = "unknown",
        compound = [],
        mass = isStaticObject || isKinematicObject ? 0 : 1,
        collisionFlags = 0,
        collisionGroup = 1,
        collisionMask = -1,
        offset = void 0,
        breakable = false,
        addChildren = true,
        margin = 0.01,
        ignoreScale = false,
        fractureImpulse = 1
      } = config;
      if (ignoreScale)
        scale.set(1, 1, 1);
      if (compound.length >= 1) {
        const collisionShapes2 = compound.map((s) => this.createCollisionShape(s.shape, s));
        const compoundShape = this.mergeCollisionShapesToCompoundShape(collisionShapes2);
        const localTransform2 = this.applyPosQuatScaleMargin(compoundShape, pos2, quat, scale, margin);
        const rigidBody2 = this.collisionShapeToRigidBody(compoundShape, localTransform2, mass, isKinematicObject);
        this.addRigidBodyToWorld(object, rigidBody2, collisionFlags, collisionGroup, collisionMask, offset);
        object.body.breakable = breakable;
        object.body.fractureImpulse = fractureImpulse;
        object.body.ignoreScale = ignoreScale;
        return;
      }
      const collisionShapes = [];
      if (shape !== "unknown" || object.isMesh) {
        const p = this.prepareThreeObjectForCollisionShape(object, config);
        const cs = this.createCollisionShape(p.shape, p.params, p.object);
        collisionShapes.push(cs);
      }
      if (shape === "unknown" && addChildren && object.children.length >= 1) {
        object.children.forEach((child) => {
          if (child.isMesh) {
            const p = this.prepareThreeObjectForCollisionShape(child);
            const cs = this.createCollisionShape(p.shape, p.params, p.object);
            cs._tmp = {
              pos: child.position.clone(),
              quat: child.quaternion.clone(),
              scale: child.scale.clone(),
              margin
            };
            collisionShapes.push(cs);
          }
        });
      }
      if (collisionShapes.length === 0) {
        const p = this.prepareThreeObjectForCollisionShape(object, config);
        const cs = this.createCollisionShape(p.shape, p.params, p.object);
        collisionShapes.push(cs);
      }
      const collisionShape = collisionShapes.length === 1 ? collisionShapes[0] : this.mergeCollisionShapesToCompoundShape(collisionShapes);
      const localTransform = this.applyPosQuatScaleMargin(collisionShape, pos2, quat, scale, margin);
      const rigidBody = this.collisionShapeToRigidBody(collisionShape, localTransform, mass, isKinematicObject);
      this.addRigidBodyToWorld(object, rigidBody, collisionFlags, collisionGroup, collisionMask, offset);
      object.body.breakable = breakable;
      object.body.fractureImpulse = fractureImpulse;
      object.body.ignoreScale = ignoreScale;
    }
    addRigidBodyToWorld(object, rigidBody, collisionFlags, collisionGroup, collisionMask, offset) {
      this.rigidBodies.push(object);
      this.physicsWorld.addRigidBody(rigidBody, collisionGroup, collisionMask);
      const ptr = Object.values(rigidBody)[0];
      rigidBody.name = object.name;
      object.body = new physicsBody_default(this, rigidBody);
      object.hasBody = true;
      object.ptr = ptr;
      rigidBody.threeObject = object;
      if (offset)
        object.body.offset = Object.assign({ x: 0, y: 0, z: 0 }, offset);
      object.body.setCollisionFlags(collisionFlags);
    }
    applyPosQuatScaleMargin(collisionShape, pos2 = new Vector3(), quat = new Quaternion(), scale = new Vector3(), margin = 0.01) {
      collisionShape.setMargin(margin);
      const rotation = new Ammo.btQuaternion(0, 0, 0, 1);
      rotation.setValue(quat.x, quat.y, quat.z, quat.w);
      const localTransform = new Ammo.btTransform();
      localTransform.setIdentity();
      localTransform.getOrigin().setValue(pos2.x, pos2.y, pos2.z);
      localTransform.setRotation(rotation);
      Ammo.destroy(rotation);
      const localScale = new Ammo.btVector3(scale.x, scale.y, scale.z);
      collisionShape.setLocalScaling(localScale);
      Ammo.destroy(localScale);
      return localTransform;
    }
    collisionShapeToRigidBody(collisionShape, localTransform, mass, disableDeactivation) {
      const motionState = new Ammo.btDefaultMotionState(localTransform);
      const localInertia = new Ammo.btVector3(0, 0, 0);
      if (mass > 0)
        collisionShape.calculateLocalInertia(mass, localInertia);
      const rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, collisionShape, localInertia);
      const rigidBody = new Ammo.btRigidBody(rbInfo);
      if (mass > 0 || disableDeactivation)
        rigidBody.setActivationState(4);
      return rigidBody;
    }
  };

  // node_modules/@enable3d/three-graphics/jsm/core.js
  var ThreeGraphics = class {
    constructor(threeGraphicsConfig = {}) {
      this.threeGraphicsConfig = threeGraphicsConfig;
      const { alpha = false, anisotropy = 1, camera = Cameras.Perspective({ z: 25, y: 5 }), antialias = false, usePhysics = true, renderer } = threeGraphicsConfig;
      this.textureAnisotropy = anisotropy;
      this.camera = camera;
      this.scene = new Scene();
      this.renderer = renderer || new WebGLRenderer({ antialias, alpha });
      this.renderer.shadowMap.enabled = true;
      this.renderer.shadowMap.type = PCFSoftShadowMap;
      this.cache = Cache;
      this.cache.enabled = true;
      if (usePhysics) {
        if (typeof Ammo !== "undefined")
          this.physics = new AmmoPhysics(this.scene, threeGraphicsConfig);
        else
          logger("Are you sure you included ammo.js?");
      }
    }
  };

  // node_modules/@enable3d/three-graphics/jsm/version.js
  var VERSION = "0.22.0";

  // node_modules/@enable3d/three-graphics/jsm/index.js
  var info = `Powered by enable3d v${VERSION}`;
  console.log(`%c %c %c %c %c ${info} %c https://enable3d.io/`, "background: #ff0000", "background: #ffff00", "background: #00ff00", "background: #00ffff", "color: #fff; background: #000000;", "background: none");

  // node_modules/enable3d/dist/project.js
  var Project = class extends ThreeGraphics {
    constructor(projectConfig) {
      var _a;
      super(projectConfig);
      this.projectConfig = projectConfig;
      this.scenes = new Map();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      if (this.projectConfig.parent)
        this.parent = document.getElementById(this.projectConfig.parent);
      else
        this.parent = document.body;
      if (!this.parent) {
        logger(`Parent "${this.projectConfig.parent}" not found! Will add it to the body.`);
        this.parent = document.body;
      }
      this.parent.appendChild(this.renderer.domElement);
      this.canvas = this.renderer.domElement;
      let firstSceneKey = "";
      this.projectConfig.scenes.forEach((scene, i) => {
        const s = new scene();
        if (i === 0)
          firstSceneKey = s.sceneKey;
        const plug = {
          sceneConfig: {
            textureAnisotropy: this.textureAnisotropy,
            autoStart: false
          },
          renderer: this.renderer,
          parent: this.parent,
          canvas: this.canvas,
          scene: this.scene,
          scenes: this.scenes,
          camera: this.camera,
          cache: this.cache,
          physics: this.physics
        };
        s.initializeScene(plug);
        if (i === 0) {
          s.setSize(this.parent.clientWidth, this.parent.clientHeight);
          s.setPixelRatio(Math.max(1, window.devicePixelRatio / 2));
        }
        this.scenes.set(s.sceneKey, s);
      });
      (_a = this.scenes.get(firstSceneKey)) === null || _a === void 0 ? void 0 : _a.start(firstSceneKey);
    }
  };

  // node_modules/@yandeu/tap/lib/index.js
  var import_events4 = __toModule(require_cjs());

  // node_modules/@yandeu/tap/lib/eventMatrix.js
  var eventMatrix = [
    {
      name: "pointer",
      enabled: true,
      test: "onpointerdown" in window,
      events: {
        down: "pointerdown",
        move: "pointermove",
        up: "pointerup"
      }
    },
    {
      name: "touch",
      enabled: true,
      test: "ontouchstart" in window && window.navigator.maxTouchPoints >= 1,
      events: {
        down: "touchstart",
        move: "touchmove",
        up: "touchend"
      }
    },
    {
      name: "mouse",
      enabled: true,
      test: "onmousedown" in window,
      events: {
        down: "mousedown",
        move: "mousemove",
        up: "mouseup"
      }
    }
  ];

  // node_modules/@enable3d/three-graphics/jsm/flat/_misc.js
  var fontHeightCache = new Map();
  var canvas = document.createElement("canvas");
  var raycaster = new Raycaster();
  var mouse = new Vector2();
  var pos = new Vector2();
  var size = new Vector2();

  // node_modules/@enable3d/three-graphics/jsm/flat/actionSprite.js
  var import_events5 = __toModule(require_cjs());

  // node_modules/@enable3d/three-graphics/jsm/flat/physics/physics.js
  var import_matter_js = __toModule(require_matter());

  // node_modules/@enable3d/common/dist/misc/joystick.js
  var import_events6 = __toModule(require_cjs());

  // node_modules/three/examples/jsm/postprocessing/ShaderPass.js
  var ShaderPass = function(shader, textureID) {
    Pass.call(this);
    this.textureID = textureID !== void 0 ? textureID : "tDiffuse";
    if (shader instanceof ShaderMaterial) {
      this.uniforms = shader.uniforms;
      this.material = shader;
    } else if (shader) {
      this.uniforms = UniformsUtils.clone(shader.uniforms);
      this.material = new ShaderMaterial({
        defines: Object.assign({}, shader.defines),
        uniforms: this.uniforms,
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader
      });
    }
    this.fsQuad = new Pass.FullScreenQuad(this.material);
  };
  ShaderPass.prototype = Object.assign(Object.create(Pass.prototype), {
    constructor: ShaderPass,
    render: function(renderer, writeBuffer, readBuffer) {
      if (this.uniforms[this.textureID]) {
        this.uniforms[this.textureID].value = readBuffer.texture;
      }
      this.fsQuad.material = this.material;
      if (this.renderToScreen) {
        renderer.setRenderTarget(null);
        this.fsQuad.render(renderer);
      } else {
        renderer.setRenderTarget(writeBuffer);
        if (this.clear)
          renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
        this.fsQuad.render(renderer);
      }
    }
  });

  // node_modules/three/examples/jsm/postprocessing/MaskPass.js
  var MaskPass = function(scene, camera) {
    Pass.call(this);
    this.scene = scene;
    this.camera = camera;
    this.clear = true;
    this.needsSwap = false;
    this.inverse = false;
  };
  MaskPass.prototype = Object.assign(Object.create(Pass.prototype), {
    constructor: MaskPass,
    render: function(renderer, writeBuffer, readBuffer) {
      var context = renderer.getContext();
      var state = renderer.state;
      state.buffers.color.setMask(false);
      state.buffers.depth.setMask(false);
      state.buffers.color.setLocked(true);
      state.buffers.depth.setLocked(true);
      var writeValue, clearValue;
      if (this.inverse) {
        writeValue = 0;
        clearValue = 1;
      } else {
        writeValue = 1;
        clearValue = 0;
      }
      state.buffers.stencil.setTest(true);
      state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
      state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 4294967295);
      state.buffers.stencil.setClear(clearValue);
      state.buffers.stencil.setLocked(true);
      renderer.setRenderTarget(readBuffer);
      if (this.clear)
        renderer.clear();
      renderer.render(this.scene, this.camera);
      renderer.setRenderTarget(writeBuffer);
      if (this.clear)
        renderer.clear();
      renderer.render(this.scene, this.camera);
      state.buffers.color.setLocked(false);
      state.buffers.depth.setLocked(false);
      state.buffers.stencil.setLocked(false);
      state.buffers.stencil.setFunc(context.EQUAL, 1, 4294967295);
      state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
      state.buffers.stencil.setLocked(true);
    }
  });
  var ClearMaskPass = function() {
    Pass.call(this);
    this.needsSwap = false;
  };
  ClearMaskPass.prototype = Object.create(Pass.prototype);
  Object.assign(ClearMaskPass.prototype, {
    render: function(renderer) {
      renderer.state.buffers.stencil.setLocked(false);
      renderer.state.buffers.stencil.setTest(false);
    }
  });

  // node_modules/three/examples/jsm/postprocessing/EffectComposer.js
  var EffectComposer = function(renderer, renderTarget) {
    this.renderer = renderer;
    if (renderTarget === void 0) {
      var parameters = {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        format: RGBAFormat
      };
      var size2 = renderer.getSize(new Vector2());
      this._pixelRatio = renderer.getPixelRatio();
      this._width = size2.width;
      this._height = size2.height;
      renderTarget = new WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, parameters);
      renderTarget.texture.name = "EffectComposer.rt1";
    } else {
      this._pixelRatio = 1;
      this._width = renderTarget.width;
      this._height = renderTarget.height;
    }
    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();
    this.renderTarget2.texture.name = "EffectComposer.rt2";
    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;
    this.renderToScreen = true;
    this.passes = [];
    if (CopyShader === void 0) {
      console.error("THREE.EffectComposer relies on CopyShader");
    }
    if (ShaderPass === void 0) {
      console.error("THREE.EffectComposer relies on ShaderPass");
    }
    this.copyPass = new ShaderPass(CopyShader);
    this.clock = new Clock();
  };
  Object.assign(EffectComposer.prototype, {
    swapBuffers: function() {
      var tmp2 = this.readBuffer;
      this.readBuffer = this.writeBuffer;
      this.writeBuffer = tmp2;
    },
    addPass: function(pass) {
      this.passes.push(pass);
      pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    },
    insertPass: function(pass, index) {
      this.passes.splice(index, 0, pass);
      pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    },
    removePass: function(pass) {
      const index = this.passes.indexOf(pass);
      if (index !== -1) {
        this.passes.splice(index, 1);
      }
    },
    isLastEnabledPass: function(passIndex) {
      for (var i = passIndex + 1; i < this.passes.length; i++) {
        if (this.passes[i].enabled) {
          return false;
        }
      }
      return true;
    },
    render: function(deltaTime) {
      if (deltaTime === void 0) {
        deltaTime = this.clock.getDelta();
      }
      var currentRenderTarget = this.renderer.getRenderTarget();
      var maskActive = false;
      var pass, i, il = this.passes.length;
      for (i = 0; i < il; i++) {
        pass = this.passes[i];
        if (pass.enabled === false)
          continue;
        pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i);
        pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);
        if (pass.needsSwap) {
          if (maskActive) {
            var context = this.renderer.getContext();
            var stencil = this.renderer.state.buffers.stencil;
            stencil.setFunc(context.NOTEQUAL, 1, 4294967295);
            this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);
            stencil.setFunc(context.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        if (MaskPass !== void 0) {
          if (pass instanceof MaskPass) {
            maskActive = true;
          } else if (pass instanceof ClearMaskPass) {
            maskActive = false;
          }
        }
      }
      this.renderer.setRenderTarget(currentRenderTarget);
    },
    reset: function(renderTarget) {
      if (renderTarget === void 0) {
        var size2 = this.renderer.getSize(new Vector2());
        this._pixelRatio = this.renderer.getPixelRatio();
        this._width = size2.width;
        this._height = size2.height;
        renderTarget = this.renderTarget1.clone();
        renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
      }
      this.renderTarget1.dispose();
      this.renderTarget2.dispose();
      this.renderTarget1 = renderTarget;
      this.renderTarget2 = renderTarget.clone();
      this.writeBuffer = this.renderTarget1;
      this.readBuffer = this.renderTarget2;
    },
    setSize: function(width, height) {
      this._width = width;
      this._height = height;
      var effectiveWidth = this._width * this._pixelRatio;
      var effectiveHeight = this._height * this._pixelRatio;
      this.renderTarget1.setSize(effectiveWidth, effectiveHeight);
      this.renderTarget2.setSize(effectiveWidth, effectiveHeight);
      for (var i = 0; i < this.passes.length; i++) {
        this.passes[i].setSize(effectiveWidth, effectiveHeight);
      }
    },
    setPixelRatio: function(pixelRatio) {
      this._pixelRatio = pixelRatio;
      this.setSize(this._width, this._height);
    }
  });
  var Pass2 = function() {
    this.enabled = true;
    this.needsSwap = true;
    this.clear = false;
    this.renderToScreen = false;
  };
  Object.assign(Pass2.prototype, {
    setSize: function() {
    },
    render: function() {
      console.error("THREE.Pass: .render() must be implemented in derived pass.");
    }
  });
  Pass2.FullScreenQuad = function() {
    var camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
    var geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
    geometry.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
    var FullScreenQuad = function(material) {
      this._mesh = new Mesh(geometry, material);
    };
    Object.defineProperty(FullScreenQuad.prototype, "material", {
      get: function() {
        return this._mesh.material;
      },
      set: function(value) {
        this._mesh.material = value;
      }
    });
    Object.assign(FullScreenQuad.prototype, {
      dispose: function() {
        this._mesh.geometry.dispose();
      },
      render: function(renderer) {
        renderer.render(this._mesh, camera);
      }
    });
    return FullScreenQuad;
  }();

  // node_modules/three/examples/jsm/postprocessing/RenderPass.js
  var RenderPass = function(scene, camera, overrideMaterial, clearColor, clearAlpha) {
    Pass.call(this);
    this.scene = scene;
    this.camera = camera;
    this.overrideMaterial = overrideMaterial;
    this.clearColor = clearColor;
    this.clearAlpha = clearAlpha !== void 0 ? clearAlpha : 0;
    this.clear = true;
    this.clearDepth = false;
    this.needsSwap = false;
    this._oldClearColor = new Color();
  };
  RenderPass.prototype = Object.assign(Object.create(Pass.prototype), {
    constructor: RenderPass,
    render: function(renderer, writeBuffer, readBuffer) {
      var oldAutoClear = renderer.autoClear;
      renderer.autoClear = false;
      var oldClearAlpha, oldOverrideMaterial;
      if (this.overrideMaterial !== void 0) {
        oldOverrideMaterial = this.scene.overrideMaterial;
        this.scene.overrideMaterial = this.overrideMaterial;
      }
      if (this.clearColor) {
        renderer.getClearColor(this._oldClearColor);
        oldClearAlpha = renderer.getClearAlpha();
        renderer.setClearColor(this.clearColor, this.clearAlpha);
      }
      if (this.clearDepth) {
        renderer.clearDepth();
      }
      renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
      if (this.clear)
        renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
      renderer.render(this.scene, this.camera);
      if (this.clearColor) {
        renderer.setClearColor(this._oldClearColor, oldClearAlpha);
      }
      if (this.overrideMaterial !== void 0) {
        this.scene.overrideMaterial = oldOverrideMaterial;
      }
      renderer.autoClear = oldAutoClear;
    }
  });

  // src/particle-base.ts
  var ParticleBase = class extends ExtendedObject3D {
    kind;
    friction;
    _frictionForce;
    _v;
    worldRange;
    constructor(kind = 0, friction = 0.1, color = 16777215, worldRange = 100) {
      super();
      this.kind = kind;
      this.friction = friction;
      this._frictionForce = new Vector3();
      this.worldRange = worldRange;
      this._v = new Vector3();
      const geometry = new SphereGeometry(0.5, 2, 2);
      const lineGeometry = new WireframeGeometry2(geometry);
      const lineMaterial = new LineMaterial({ color, linewidth: 1.5, dashed: false });
      lineMaterial.resolution.set(window.innerWidth, window.innerHeight);
      const wireframe = new Wireframe(lineGeometry, lineMaterial);
      wireframe.computeLineDistances();
      wireframe.scale.set(1, 1, 1);
      this.add(wireframe);
    }
    reaction(particle) {
      const direction = this._v.subVectors(particle.position, this.position);
      const dist = direction.length();
      let force;
      direction.normalize();
      switch (particle.kind) {
        case 0:
          force = (3 * dist - 30) / 2 ** (dist - 8);
          if (force < 0)
            force /= 3;
          direction.multiplyScalar(force);
          this.body.applyForce(direction.x, direction.y, direction.z);
          break;
        case 1:
          force = (10 * dist * Math.log(1.35) - 100 * Math.log(1.35) - 10) / 1.35 ** (dist - 5);
          direction.multiplyScalar(force);
          this.body.applyForce(direction.x, direction.y, direction.z);
          break;
        case 2:
          force = (3 * dist * Math.log(1.35) - 30 * Math.log(1.35) - 3) / 1.35 ** (dist - 10);
          if (force < 0)
            force /= 5;
          direction.multiplyScalar(force);
          this.body.applyForce(direction.x, direction.y, direction.z);
          break;
        default:
          break;
      }
    }
    update() {
      this._frictionForce.set(this.body.velocity.x, this.body.velocity.y, this.body.velocity.z);
      this._frictionForce.multiplyScalar(-1 * this.friction);
      this.body.applyForce(this._frictionForce.x, this._frictionForce.y, this._frictionForce.z);
      this._frictionForce.set(this.body.angularVelocity.x, this.body.angularVelocity.y, this.body.angularVelocity.z);
      this._frictionForce.multiplyScalar(-1 * this.friction);
      this.body.applyTorque(this._frictionForce.x, this._frictionForce.y, this._frictionForce.z);
    }
  };

  // src/particle.ts
  var Particle1 = class extends ParticleBase {
    constructor() {
      super(1, 0.1, 5374972);
    }
    reaction(particle) {
      const direction = this._v.subVectors(particle.position, this.position);
      const dist = direction.length() / 2;
      direction.normalize();
      let force;
      switch (particle.kind) {
        case 0:
          force = (10 * dist * Math.log(1.35) - 100 * Math.log(1.35) - 10) / 1.35 ** (dist - 5);
          direction.multiplyScalar(force);
          this.body.applyForce(direction.x, direction.y, direction.z);
          break;
        case 1:
          force = (3 * dist * Math.log(1.35) - 9 * Math.log(1.35) - 3) / 1.35 ** (dist - 3);
          if (force < 0)
            force /= 3;
          direction.multiplyScalar(force);
          this.body.applyForce(direction.x, direction.y, direction.z);
          break;
        case 2:
          break;
        default:
          break;
      }
    }
  };
  var Particle2 = class extends ParticleBase {
    constructor() {
      super(2, 0.1, 646818);
    }
    reaction(particle) {
      const direction = this._v.subVectors(particle.position, this.position);
      const dist = direction.length() / 2;
      direction.normalize();
      let force;
      switch (particle.kind) {
        case 0:
          force = (3 * dist * Math.log(1.35) - 30 * Math.log(1.35) - 3) / 1.35 ** (dist - 10);
          if (force < 0)
            force /= 5;
          direction.multiplyScalar(force);
          this.body.applyForce(direction.x, direction.y, direction.z);
          break;
        case 1:
          break;
        case 2:
          direction.multiplyScalar((4 / dist) ** 2);
          direction.multiplyScalar(-1);
          this.body.applyForce(direction.x, direction.y, direction.z);
          break;
        default:
          break;
      }
    }
  };
  var Particle3 = class extends ParticleBase {
    constructor() {
      super(3, 0.1, 14679043);
    }
    reaction(particle) {
      const direction = this._v.subVectors(particle.position, this.position);
      const dist = direction.length() / 2;
      direction.normalize();
      let force;
      switch (particle.kind) {
        case 0:
          force = 1 / dist ** 2;
          direction.multiplyScalar(-1 * force);
          this.body.applyForce(direction.x, direction.y, direction.z);
          break;
        case 1:
          force = 10 / dist;
          direction.multiplyScalar(force);
          this.body.applyForce(direction.x, direction.y, direction.z);
          break;
        case 2:
          break;
        case 3:
          force = (10 * dist * Math.log(1.35) - 100 * Math.log(1.35) - 10) / 3 ** (dist - 5);
          direction.multiplyScalar(force);
          this.body.applyForce(direction.x, direction.y, direction.z);
          break;
        default:
          break;
      }
    }
  };

  // src/particle-handler.ts
  var ParticleHandler = class {
    scene3d;
    particles;
    constructor(scene3d) {
      this.scene3d = scene3d;
      this.particles = [];
    }
    addParticle(particle) {
      this.scene3d.scene.add(particle);
      this.scene3d.physics.add.existing(particle);
      this.particles.push(particle);
    }
    updateForce() {
      for (let start of this.particles) {
        for (let end of this.particles) {
          if (start == end) {
            continue;
          }
          start.reaction(end);
        }
      }
    }
    updateFriction() {
      for (let particle of this.particles) {
        particle.update();
      }
    }
  };

  // src/main.ts
  var MainScene = class extends Scene3D {
    particleHandler;
    constructor() {
      super();
      this.particleHandler = new ParticleHandler(this);
    }
    async init() {
      this.renderer.setPixelRatio(window.devicePixelRatio);
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.renderer.toneMapping = ACESFilmicToneMapping;
      this.renderer.toneMappingExposure = 0.7;
      const renderPass = new RenderPass(this.scene, this.camera);
      const bloomPass = new UnrealBloomPass(new Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.1);
      const fxaaPass = new ShaderPass(FXAAShader);
      const filmPass = new FilmPass(0.5, 0.3, 1448, 0);
      this.composer = new EffectComposer(this.renderer);
      this.composer.addPass(renderPass);
      this.composer.addPass(fxaaPass);
      this.composer.addPass(bloomPass);
      this.physics.setGravity(0, 0, 0);
    }
    async create() {
      await this.warpSpeed("-ground", "-sky");
      const createBoundaryBoxes = (range) => {
        const boundaryBoxes = new ExtendedObject3D();
        const boundaryBoxGeometry = new WireframeGeometry2(new BoxGeometry(range, range, range));
        const boundaryBoxMaterial = new LineMaterial({ linewidth: 1, dashed: false });
        boundaryBoxMaterial.resolution.set(window.innerWidth, window.innerHeight);
        for (let i = 0; i < 27; i++) {
          let x = 0, y = 0, z = 0;
          switch (i % 3) {
            case 0:
              x = -range;
              break;
            case 1:
              x = 0;
              break;
            case 2:
              x = range;
              break;
          }
          switch (Math.floor(i / 3) % 3) {
            case 0:
              y = -range;
              break;
            case 1:
              y = 0;
              break;
            case 2:
              y = range;
              break;
          }
          switch (Math.floor(i / 9) % 3) {
            case 0:
              z = -range;
              break;
            case 1:
              z = 0;
              break;
            case 2:
              z = range;
              break;
          }
          console.log(i, x, y, z);
          if (x == 0 && y == 0 && z == 0)
            continue;
          const box = new Wireframe(boundaryBoxGeometry, boundaryBoxMaterial);
          box.computeLineDistances();
          box.position.set(x, y, z);
          boundaryBoxes.add(box);
        }
        return boundaryBoxes;
      };
      const boundary = createBoundaryBoxes(500);
      this.physics.add.existing(boundary, { collisionFlags: 1, mass: 1e4, shape: "hacd" });
      for (let i = 0; i < 100; i++) {
        const particle = new ParticleBase();
        particle.position.set((Math.random() - 1 / 2) * 100, (Math.random() - 1 / 2) * 100, (Math.random() - 1 / 2) * 100);
        this.particleHandler.addParticle(particle);
      }
      for (let i = 0; i < 100; i++) {
        const particle = new Particle1();
        particle.position.set((Math.random() - 1 / 2) * 100, (Math.random() - 1 / 2) * 100, (Math.random() - 1 / 2) * 100);
        this.particleHandler.addParticle(particle);
      }
      for (let i = 0; i < 100; i++) {
        const particle = new Particle2();
        particle.position.set((Math.random() - 1 / 2) * 100, (Math.random() - 1 / 2) * 100, (Math.random() - 1 / 2) * 100);
        this.particleHandler.addParticle(particle);
      }
      for (let i = 0; i < 100; i++) {
        const particle = new Particle3();
        particle.position.set((Math.random() - 1 / 2) * 100, (Math.random() - 1 / 2) * 100, (Math.random() - 1 / 2) * 100);
        this.particleHandler.addParticle(particle);
      }
      const resize = () => {
        const width = window.innerWidth;
        const height = window.innerHeight;
        this.renderer.setSize(width, height);
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
      };
      window.onresize = resize;
    }
    update() {
      this.particleHandler.updateForce();
      this.particleHandler.updateFriction();
    }
  };
  var sceneConfig = {
    antialias: true,
    scenes: [MainScene]
  };
  PhysicsLoader("./ammo", () => new Project(sceneConfig));
})();
/*!
 * matter-js 0.16.1 by @liabru 2021-01-31
 * http://brm.io/matter-js/
 * License MIT
 * 
 * The MIT License (MIT)
 * 
 * Copyright (c) Liam Brummitt and contributors.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
*/
/**
 * @author       Evan Wallace (http://madebyevan.com/))
 * @copyright    Copyright (c) 2011 Evan Wallace
 * @license      MIT license
 *
 * @author       manthrax (https://github.com/manthrax)
 *
 * @author       Jiro-Digital (https://github.com/Jiro-Digital)
 * @copyright    Copyright (c) 2020 Jiro Digital Ltd
 * @license      {@link https://github.com/Jiro-Digital/three-csg-ts/blob/master/LICENSE|MIT}
 *
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2021 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */
/**
 * @author       Kevin Lee (https://github.com/InfiniteLee)
 * @copyright    Copyright (c) 2019 Kevin Lee; Project Url: https://github.com/InfiniteLee/ammo-debug-drawer
 * @license      {@link https://github.com/InfiniteLee/ammo-debug-drawer/blob/master/LICENSE|MPL-2.0}
 */
/**
 * @author       Kevin Lee (https://github.com/InfiniteLee)
 * @copyright    Copyright (c) 2020 Kevin Lee; Project Url: https://github.com/InfiniteLee/three-to-ammo
 * @license      {@link https://github.com/InfiniteLee/three-to-ammo/blob/master/LICENSE|MPL-2.0}
 */
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2021 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */
/**
 * @description  This code has originally been copied from Sketchbook
 *
 * @author       swift502 <blaha.j502@gmail.com> (http://jblaha.art/)
 * @copyright    Copyright (c) 2018 swift502; Project Url: https://github.com/swift502/Sketchbook
 * @license      {@link https://github.com/swift502/Sketchbook/blob/master/LICENSE|GPL-3.0}
 *
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */
/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
/**
 * @package      npmjs.com/package/@yandeu/events (events.min.js)
 *
 * @author       Arnout Kazemier (https://github.com/3rd-Eden)
 * @copyright    Copyright (c) 2014 Arnout Kazemier
 * @license      {@link https://github.com/primus/eventemitter3/blob/master/LICENSE|MIT}
 *
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2021 Yannick Deubel; Project Url: https://github.com/yandeu/events
 * @license      {@link https://github.com/yandeu/events/blob/master/LICENSE|MIT}
 */
/**
 * @package      npmjs.com/package/@yandeu/tap (tap.min.js)
 *
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2021 Yannick Deubel; Project Url: https://github.com/yandeu/tap
 * @license      {@link https://github.com/yandeu/tap/blob/master/LICENSE|MIT}
 * @description  Inspired by tapjs (https://www.npmjs.com/package/tapjs)
 */
